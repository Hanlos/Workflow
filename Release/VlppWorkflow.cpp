/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "VlppWorkflow.h"

/***********************************************************************
ANALYZER\WFANALYZER.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
WfLexicalSymbol
***********************************************************************/

			WfLexicalSymbol::WfLexicalSymbol(WfLexicalScope* _ownerScope)
				:ownerScope(_ownerScope)
			{
			}

			WfLexicalSymbol::~WfLexicalSymbol()
			{
			}

			WString WfLexicalSymbol::GetFriendlyName()
			{
				return ownerScope->GetFriendlyName() + L"::" + name;
			}

/***********************************************************************
WfLexicalScope
***********************************************************************/

			WfLexicalScope::WfLexicalScope(WfLexicalScopeManager* _ownerManager)
				:ownerManager(_ownerManager)
			{
			}

			WfLexicalScope::WfLexicalScope(Ptr<WfLexicalScope> _parentScope)
				:ownerManager(0)
				, parentScope(_parentScope)
			{
			}

			WfLexicalScope::~WfLexicalScope()
			{
			}

			WfLexicalScopeManager* WfLexicalScope::FindManager()
			{
				WfLexicalScope* scope = this;
				while (scope)
				{
					if (scope->ownerManager)
					{
						return scope->ownerManager;
					}
					scope = scope->parentScope.Obj();
				}
				return 0;
			}

			Ptr<WfModule> WfLexicalScope::FindModule()
			{
				WfLexicalScope* scope = this;
				while (scope)
				{
					if (scope->ownerModule)
					{
						return scope->ownerModule;
					}
					scope = scope->parentScope.Obj();
				}
				return 0;
			}

			Ptr<WfDeclaration> WfLexicalScope::FindDeclaration()
			{
				WfLexicalScope* scope = this;
				while (scope)
				{
					if (scope->ownerDeclaration)
					{
						return scope->ownerDeclaration;
					}
					scope = scope->parentScope.Obj();
				}
				return 0;
			}

			WString WfLexicalScope::GetFriendlyName()
			{
				if (ownerModule)
				{
					return L"<" + ownerModule->name.value + L">";
				}
				else if (ownerDeclaration)
				{
					return parentScope->GetFriendlyName() + L"::" + ownerDeclaration->name.value;
				}
				else if (!parentScope)
				{
					return L"";
				}
				else
				{
					return parentScope->GetFriendlyName() + L"::<>";
				}
			}

/***********************************************************************
WfLexicalScopeName
***********************************************************************/

			WfLexicalScopeName::WfLexicalScopeName(bool _createdByTypeDescriptor)
				:parent(0)
				, createdByTypeDescriptor(_createdByTypeDescriptor)
				, typeDescriptor(0)
			{
			}

			WfLexicalScopeName::~WfLexicalScopeName()
			{
			}

			Ptr<WfLexicalScopeName> WfLexicalScopeName::AccessChild(const WString& name, bool createdByTypeDescriptor)
			{
				vint index = children.Keys().IndexOf(name);
				if (index == -1)
				{
					Ptr<WfLexicalScopeName> newName = new WfLexicalScopeName(createdByTypeDescriptor);
					newName->name = name;
					newName->parent = this;
					children.Add(name, newName);
					return newName;
				}
				else
				{
					return children.Values()[index];
				}
			}

			void WfLexicalScopeName::RemoveNonTypeDescriptorNames()
			{
				for (vint i = children.Count() - 1; i >= 0; i--)
				{
					if (!children.Values()[i]->createdByTypeDescriptor)
					{
						children.Remove(children.Keys()[i]);
					}
				}
				
				declarations.Clear();
				FOREACH(Ptr<WfLexicalScopeName>, name, children.Values())
				{
					name->RemoveNonTypeDescriptorNames();
				}
			}

			WString WfLexicalScopeName::GetFriendlyName()
			{
				if (parent)
				{
					WString parentName = parent->GetFriendlyName();
					if (parentName == L"")
					{
						return name;
					}
					else
					{
						return parentName + L"::" + name;
					}
				}
				else
				{
					return L"";
				}
			}

/***********************************************************************
ResolveExpressionResult
***********************************************************************/

			ResolveExpressionResult::ResolveExpressionResult()
				:propertyInfo(0)
				, methodInfo(0)
				, eventInfo(0)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(Ptr<WfLexicalScopeName> _scopeName)
				:scopeName(_scopeName)
				, propertyInfo(0)
				, methodInfo(0)
				, eventInfo(0)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(Ptr<reflection::description::ITypeInfo> _type, Ptr<reflection::description::ITypeInfo> _leftValueType)
				:type(_type)
				, leftValueType(_leftValueType)
				, propertyInfo(0)
				, methodInfo(0)
				, eventInfo(0)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(Ptr<WfLexicalSymbol> _symbol, Ptr<reflection::description::ITypeInfo> _type, Ptr<reflection::description::ITypeInfo> _leftValueType)
				:symbol(_symbol)
				, type(_type)
				, leftValueType(_leftValueType)
				, propertyInfo(0)
				, methodInfo(0)
				, eventInfo(0)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(reflection::description::IPropertyInfo* _propertyInfo, Ptr<reflection::description::ITypeInfo> _type, Ptr<reflection::description::ITypeInfo> _leftValueType)
				:propertyInfo(_propertyInfo)
				, methodInfo(0)
				, eventInfo(0)
				, type(_type)
				, leftValueType(_leftValueType)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(reflection::description::IMethodInfo* _methodInfo, Ptr<reflection::description::ITypeInfo> _type)
				:propertyInfo(0)
				, methodInfo(_methodInfo)
				, eventInfo(0)
				, type(_type)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(reflection::description::IEventInfo* _eventInfo)
				:propertyInfo(0)
				, methodInfo(0)
				, eventInfo(_eventInfo)
			{
			}

			WString ResolveExpressionResult::GetFriendlyName()const
			{
				WString typeName;
				if (type)
				{
					typeName= + L" of type \"" + type->GetTypeFriendlyName() + L"\"";
				}
				if (scopeName)
				{
					return scopeName->GetFriendlyName();
				}
				else if (symbol)
				{
					return symbol->GetFriendlyName() + typeName;
				}
				else if (propertyInfo)
				{
					return L"property \"" + propertyInfo->GetName() + L"\" in \"" + propertyInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"" + typeName;
				}
				else if (methodInfo)
				{
					if (methodInfo->GetName() == L"")
					{
						return L"constructor in " + methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"" + typeName;
					}
					else
					{
						return L"method \"" + methodInfo->GetName() + L"\" in \"" + methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"" + typeName;
					}
				}
				else if (eventInfo)
				{
					return L"event \"" + eventInfo->GetName() + L"\" in \"" + eventInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"";
				}
				else if (type)
				{
					return L"expression" + typeName;
				}
				else
				{
					return L"<unknown>";
				}
			}

/***********************************************************************
WfLexicalScopeManager
***********************************************************************/

			WfLexicalScopeManager::WfLexicalScopeManager(Ptr<parsing::tabling::ParsingTable> _parsingTable)
				:parsingTable(_parsingTable)
			{
			}

			WfLexicalScopeManager::~WfLexicalScopeManager()
			{
			}

			vint WfLexicalScopeManager::AddModule(const WString& moduleCode)
			{
				if (auto module = WfParseModule(moduleCode, parsingTable, errors, usedCodeIndex))
				{
					modules.Add(module);
					moduleCodes.Add(moduleCode);
				}
				return usedCodeIndex++;
			}

			vint WfLexicalScopeManager::AddModule(Ptr<WfModule> module)
			{
				module->codeRange.codeIndex = usedCodeIndex;
				modules.Add(module);
				moduleCodes.Add(L"");
				return usedCodeIndex++;
			}

			WfLexicalScopeManager::ModuleList& WfLexicalScopeManager::GetModules()
			{
				return modules;
			}

			WfLexicalScopeManager::ModuleCodeList& WfLexicalScopeManager::GetModuleCodes()
			{
				return moduleCodes;
			}

			void WfLexicalScopeManager::Clear(bool keepTypeDescriptorNames, bool deleteModules)
			{
				if (globalName)
				{
					if (keepTypeDescriptorNames)
					{
						globalName->RemoveNonTypeDescriptorNames();
					}
					else
					{
						globalName = 0;
					}
				}
				
				if (deleteModules)
				{
					modules.Clear();
					moduleCodes.Clear();
					usedCodeIndex = 0;
				}

				errors.Clear();
				namespaceNames.Clear();
				analyzedScopes.Clear();

				moduleScopes.Clear();
				declarationScopes.Clear();
				statementScopes.Clear();
				expressionScopes.Clear();
				expressionResolvings.Clear();
				functionLambdaCaptures.Clear();
				orderedLambdaCaptures.Clear();

				declarationTypes.Clear();
				declarationMemberInfos.Clear();
			}

			void WfLexicalScopeManager::Rebuild(bool keepTypeDescriptorNames)
			{
				Clear(keepTypeDescriptorNames, false);
				if (!globalName)
				{
					globalName = new WfLexicalScopeName(true);
					BuildGlobalNameFromTypeDescriptors(this);
				}

				vint errorCount = errors.Count();

#define EXIT_IF_ERRORS_EXIST\
				do\
				{\
					if (errors.Count() != errorCount) return;\
				}while (0)
				
				EXIT_IF_ERRORS_EXIST;
				FOREACH(Ptr<WfModule>, module, modules)
				{
					ValidateModuleStructure(this, module);
				}
				
				EXIT_IF_ERRORS_EXIST;
				BuildGlobalNameFromModules(this);
				FOREACH(Ptr<WfModule>, module, modules)
				{
					BuildScopeForModule(this, module);
				}
				ValidateScopeName(this, globalName);
				CheckScopes(this);
				
				EXIT_IF_ERRORS_EXIST;
				FOREACH(Ptr<WfModule>, module, modules)
				{
					CompleteScopeForModule(this, module);
				}
				
				EXIT_IF_ERRORS_EXIST;
				FOREACH(Ptr<WfModule>, module, modules)
				{
					ValidateModuleSemantic(this, module);
				}

#undef EXIT_IF_ERRORS_EXIST
			}
			
			void WfLexicalScopeManager::ResolveSymbol(WfLexicalScope* scope, const WString& symbolName, collections::List<Ptr<WfLexicalSymbol>>& symbols)
			{
				while (scope && !scope->ownerModule && !scope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
				{
					vint index = scope->symbols.Keys().IndexOf(symbolName);
					if (index != -1)
					{
						CopyFrom(symbols, scope->symbols.GetByIndex(index), true);
					}
					scope = scope->parentScope.Obj();
				}
			}

			class UsingPathToNameVisitor :public Object, public WfModuleUsingFragment::IVisitor
			{
			public:
				WString					name;
				WString					result;

				UsingPathToNameVisitor(const WString& _name)
					:name(_name)
				{
				}

				void Visit(WfModuleUsingNameFragment* node)
				{
					result = node->name.value;
				}

				void Visit(WfModuleUsingWildCardFragment* node)
				{
					result = name;
				}

				static WString Execute(Ptr<WfModuleUsingFragment> fragment, const WString& name)
				{
					UsingPathToNameVisitor visitor(name);
					fragment->Accept(&visitor);
					return visitor.result;
				}
			};

			void WfLexicalScopeManager::ResolveScopeName(WfLexicalScope* scope, const WString& symbolName, collections::List<Ptr<WfLexicalScopeName>>& names)
			{
				while (scope)
				{
					if (scope->ownerModule || scope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
					{
						break;
					}
					scope = scope->parentScope.Obj();
				}

				List<WString> namespacePath;
				Ptr<WfModule> module;
				while (scope)
				{
					if (auto ns = scope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
					{
						namespacePath.Add(ns->name.value);
					}
					if (!module)
					{
						module = scope->ownerModule;
					}
					scope = scope->parentScope.Obj();
				}

				Ptr<WfLexicalScopeName> scopeName = globalName;
				vint nsIndex = namespacePath.Count();
				while (scopeName)
				{
					vint index = scopeName->children.Keys().IndexOf(symbolName);
					if (index != -1)
					{
						names.Add(scopeName->children.Values()[index]);
					}

					if (--nsIndex < 0) break;
					index = scopeName->children.Keys().IndexOf(namespacePath[nsIndex]);
					if (index == -1) break;
					scopeName = scopeName->children.Values()[index];
				}

				FOREACH(Ptr<WfModuleUsingPath>, path, module->paths)
				{
					scopeName = globalName;
					FOREACH(Ptr<WfModuleUsingItem>, item, path->items)
					{
						WString name;
						FOREACH(Ptr<WfModuleUsingFragment>, fragment, item->fragments)
						{
							name += UsingPathToNameVisitor::Execute(fragment, symbolName);
						}
						vint index = scopeName->children.Keys().IndexOf(name);
						if (index == -1) goto USING_PATH_MATCHING_FAILED;
						scopeName = scopeName->children.Values()[index];
					}
					names.Add(scopeName);
				USING_PATH_MATCHING_FAILED:;
				}
			}

			Ptr<WfLexicalSymbol> WfLexicalScopeManager::GetDeclarationSymbol(WfLexicalScope* scope, WfDeclaration* node)
			{
				auto symbol = From(scope->parentScope->symbols[node->name.value])
					.Where([=](Ptr<WfLexicalSymbol> symbol)
					{
						return symbol->creatorDeclaration == node;
					})
					.First();
				return symbol;
			}

/***********************************************************************
WfCodegenFunctionContext
***********************************************************************/

			WfCodegenFunctionContext::WfCodegenFunctionContext()
			{
				scopeContextStack.Add(new WfCodegenScopeContext);
			}

			Ptr<WfCodegenScopeContext> WfCodegenFunctionContext::GetCurrentScopeContext()
			{
				return scopeContextStack[scopeContextStack.Count() - 1];
			}

			Ptr<WfCodegenScopeContext> WfCodegenFunctionContext::GetCurrentScopeContext(WfCodegenScopeType type)
			{
				for (vint i = scopeContextStack.Count() - 1; i >= 0; i--)
				{
					auto context = scopeContextStack[i];
					if (context->type == type)
					{
						return context;
					}
				}
				return 0;
			}

			Ptr<WfCodegenScopeContext> WfCodegenFunctionContext::PushScopeContext(WfCodegenScopeType type)
			{
				auto context = MakePtr<WfCodegenScopeContext>();
				context->type = type;
				scopeContextStack.Add(context);
				return context;
			}

			void WfCodegenFunctionContext::PopScopeContext()
			{
				scopeContextStack.RemoveAt(scopeContextStack.Count() - 1);
			}

/***********************************************************************
WfCodegenContext
***********************************************************************/

			WfCodegenContext::WfCodegenContext(Ptr<runtime::WfAssembly> _assembly, WfLexicalScopeManager* _manager)
				:assembly(_assembly)
				, manager(_manager)
			{
			}

			vint WfCodegenContext::AddInstruction(parsing::ParsingTreeCustomBase* node, const runtime::WfInstruction& ins)
			{
				auto index = assembly->instructions.Add(ins);
				if (node)
				{
					assembly->insBeforeCodegen->instructionCodeMapping.Add(nodePositionsBeforeCodegen[node]);
					assembly->insAfterCodegen->instructionCodeMapping.Add(nodePositionsAfterCodegen[node]);
				}
				else
				{
					parsing::ParsingTextRange range;
					assembly->insBeforeCodegen->instructionCodeMapping.Add(range);
					assembly->insAfterCodegen->instructionCodeMapping.Add(range);
				}
				return index;
			}

			void WfCodegenContext::AddExitInstruction(parsing::ParsingTreeCustomBase* node, const runtime::WfInstruction& ins)
			{
				auto context = functionContext->GetCurrentScopeContext();
				context->exitInstructions.Add(ins);
				context->instructionCodeMappingBeforeCodegen.Add(nodePositionsBeforeCodegen[node]);
				context->instructionCodeMappingAfterCodegen.Add(nodePositionsAfterCodegen[node]);
			}

			void WfCodegenContext::ApplyExitInstructions(Ptr<WfCodegenScopeContext> scopeContext)
			{
				if (scopeContext->exitInstructions.Count() > 0)
				{
					CopyFrom(assembly->instructions, scopeContext->exitInstructions, true);
					CopyFrom(assembly->insBeforeCodegen->instructionCodeMapping, scopeContext->instructionCodeMappingBeforeCodegen, true);
					CopyFrom(assembly->insAfterCodegen->instructionCodeMapping, scopeContext->instructionCodeMappingAfterCodegen, true);
				}
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_BUILDGLOBALNAME.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
BuildGlobalNameFromTypeDescriptors
***********************************************************************/

			void BuildGlobalNameFromTypeDescriptors(WfLexicalScopeManager* manager)
			{
				for (vint i = 0; i < GetGlobalTypeManager()->GetTypeDescriptorCount(); i++)
				{
					ITypeDescriptor* typeDescriptor = GetGlobalTypeManager()->GetTypeDescriptor(i);
					WString name = typeDescriptor->GetTypeName();
					const wchar_t* reading = name.Buffer();
					Ptr<WfLexicalScopeName> currentName = manager->globalName;

					while (true)
					{
						WString fragment;
						const wchar_t* delimiter = wcsstr(reading, L"::");
						if (delimiter)
						{
							fragment = WString(reading, vint(delimiter - reading));
							reading = delimiter + 2;
						}
						else
						{
							fragment = reading;
							reading = 0;
						}

						currentName = currentName->AccessChild(fragment, true);
						if (!reading)
						{
							currentName->typeDescriptor = typeDescriptor;
							break;
						}
					}
				}
			}

/***********************************************************************
BuildGlobalNameFromModules
***********************************************************************/

			class BuildClassMemberVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*			manager;
				Ptr<WfLexicalScopeName>			scopeName;
				Ptr<WfClassDeclaration>			classDecl;
				Ptr<WfCustomType>				td;
				Ptr<WfClassMember>				member;

				BuildClassMemberVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScopeName> _scopeName, Ptr<WfClassDeclaration> _classDecl, Ptr<WfCustomType> _td, Ptr<WfClassMember> _member)
					:manager(_manager)
					, scopeName(_scopeName)
					, classDecl(_classDecl)
					, td(_td)
					, member(_member)
				{
				}

				static void BuildClass(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> scopeName, Ptr<WfClassDeclaration> declaration)
				{
					WString typeName = scopeName->name;
					{
						WfLexicalScopeName* name = scopeName->parent;
						while (name && name != manager->globalName.Obj())
						{
							typeName = name->name + L"::" + typeName;
							name = name->parent;
						}
					}

					Ptr<WfCustomType> td;
					switch (declaration->kind)
					{
					case WfClassKind::Class:
						td = MakePtr<WfClass>(typeName);
						break;
					case WfClassKind::Interface:
						td = MakePtr<WfInterface>(typeName);
						break;
					}
					manager->declarationTypes.Add(declaration, td);

					if (!scopeName->typeDescriptor)
					{
						scopeName->typeDescriptor = td.Obj();
					}

					FOREACH(Ptr<WfClassMember>, member, declaration->members)
					{
						BuildClassMemberVisitor visitor(manager, scopeName, declaration, td, member);
						member->declaration->Accept(&visitor);
					}
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (member->kind == WfClassMemberKind::Static)
					{
						auto info = MakePtr<WfStaticMethod>();
						td->AddMember(node->name.value, info);
						manager->declarationMemberInfos.Add(node, info);
					}
					else
					{
						switch (classDecl->kind)
						{
						case WfClassKind::Class:
							throw 0;
						case WfClassKind::Interface:
							{
								auto info = MakePtr<WfInterfaceMethod>();
								td->AddMember(node->name.value, info);
								manager->declarationMemberInfos.Add(node, info);
							}
							break;
						}
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					throw 0;
				}

				void Visit(WfEventDeclaration* node)override
				{
					auto info = MakePtr<WfEvent>(td.Obj(), node->name.value);
					td->AddMember(info);
					manager->declarationMemberInfos.Add(node, info);
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					auto info = MakePtr<WfProperty>(td.Obj(), node->name.value);
					td->AddMember(info);
					manager->declarationMemberInfos.Add(node, info);
				}

				void Visit(WfClassDeclaration* node)override
				{
					auto newScopeName = scopeName->AccessChild(node->name.value, false);
					newScopeName->declarations.Add(node);
					BuildClass(manager, newScopeName, node);
				}
			};

			class BuildNameDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*			manager;
				Ptr<WfLexicalScopeName>			scopeName;

				BuildNameDeclarationVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScopeName> _scopeName)
					:manager(_manager)
					, scopeName(_scopeName)
				{
				}

				static void BuildName(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> name, Ptr<WfDeclaration> declaration)
				{
					auto scopeName = name->AccessChild(declaration->name.value, false);
					scopeName->declarations.Add(declaration);

					BuildNameDeclarationVisitor visitor(manager, scopeName);
					declaration->Accept(&visitor);
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					manager->namespaceNames.Add(node, scopeName);
					FOREACH(Ptr<WfDeclaration>, subDecl, node->declarations)
					{
						BuildName(manager, scopeName, subDecl);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
				}

				void Visit(WfVariableDeclaration* node)override
				{
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					BuildClassMemberVisitor::BuildClass(manager, scopeName, node);
				}
			};

			void BuildGlobalNameFromModules(WfLexicalScopeManager* manager)
			{
				FOREACH(Ptr<WfModule>, module, manager->GetModules())
				{
					FOREACH(Ptr<WfDeclaration>, declaration, module->declarations)
					{
						BuildNameDeclarationVisitor::BuildName(manager, manager->globalName, declaration);
					}
				}
			}

/***********************************************************************
ValidateScopeName
***********************************************************************/

			class ValidateScopeNameDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				enum Category
				{
					None,
					Type,
					Variable,
					Function,
					Event,
					Property,
					Namespace,
				};

				WfLexicalScopeManager*				manager;
				Ptr<WfLexicalScopeName>				name;
				Category							category;

				ValidateScopeNameDeclarationVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScopeName> _name)
					:manager(_manager)
					, name(_name)
					, category(name->typeDescriptor && name->createdByTypeDescriptor ? Type : None)
				{
				}

				void AddError(WfDeclaration* node)
				{
					WString categoryName;
					switch (category)
					{
					case Type:
						categoryName = L"type";
						break;
					case Variable:
						categoryName = L"variable";
						break;
					case Function:
						categoryName = L"function";
						break;
					case Event:
						categoryName = L"event";
						break;
					case Property:
						categoryName = L"property";
						break;
					case Namespace:
						categoryName = L"namespace";
						break;
					default:
						CHECK_FAIL(L"ValidateScopeNameDeclarationVisitor::AddError(WfDeclaration*)#Internal error.");
					}
					manager->errors.Add(WfErrors::DuplicatedDeclaration(node, categoryName));
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					if (category == None)
					{
						category = Namespace;
					}
					else if (category != Namespace)
					{
						AddError(node);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (category == None)
					{
						category = Function;
					}
					else if (category != Function)
					{
						AddError(node);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					if (category == None)
					{
						category = Variable;
					}
					else
					{
						AddError(node);
					}
				}

				void Visit(WfEventDeclaration* node)override
				{
					if (category == None)
					{
						category = Event;
					}
					else
					{
						AddError(node);
					}
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					if (category == None)
					{
						category = Property;
					}
					else
					{
						AddError(node);
					}
				}

				void Visit(WfClassDeclaration* node)override
				{
					if (category == None)
					{
						category = Type;
					}
					else
					{
						AddError(node);
					}
				}
			};

			void ValidateScopeName(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> name)
			{
				ValidateScopeNameDeclarationVisitor visitor(manager, name);
				FOREACH(Ptr<WfDeclaration>, declaration, name->declarations)
				{
					declaration->Accept(&visitor);
				}

				FOREACH(Ptr<WfLexicalScopeName>, child, name->children.Values())
				{
					ValidateScopeName(manager, child);
				}
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_BUILDSCOPE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
BuildScopeForDeclaration
***********************************************************************/

			class BuildScopeForDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ParsingTreeCustomBase*					source;
				Ptr<WfLexicalScope>						parentScope;

				Ptr<WfCustomType>						td;
				Ptr<WfClassDeclaration>					classDecl;
				Ptr<WfClassMember>						member;

				Ptr<WfLexicalScope>						resultScope;

				BuildScopeForDeclarationVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScope> _parentScope, ParsingTreeCustomBase* _source, Ptr<WfCustomType> _td, Ptr<WfClassDeclaration> _classDecl, Ptr<WfClassMember> _member)
					:manager(_manager)
					, source(_source)
					, parentScope(_parentScope)
					, td(_td)
					, classDecl(_classDecl)
					, member(_member)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(parentScope.Obj());
					symbol->name = node->name.value;
					symbol->creatorDeclaration = node;
					parentScope->symbols.Add(symbol->name, symbol);

					resultScope = new WfLexicalScope(parentScope);
					FOREACH(Ptr<WfDeclaration>, declaration, node->declarations)
					{
						BuildScopeForDeclaration(manager, resultScope, declaration);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					resultScope = new WfLexicalScope(parentScope);

					if (node->anonymity == WfFunctionAnonymity::Named)
					{
						Ptr<WfLexicalScope> functionNameScope = parentScope;
						if (source && dynamic_cast<WfFunctionExpression*>(source))
						{
							functionNameScope = resultScope;
						}

						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(functionNameScope.Obj());
						symbol->name = node->name.value;
						symbol->creatorDeclaration = node;
						{
							Ptr<WfFunctionType> type = new WfFunctionType;
							type->result = node->returnType;
							FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
							{
								type->arguments.Add(argument->type);
							}
							symbol->type = type;
						}
						functionNameScope->symbols.Add(symbol->name, symbol);
					}

					if (node->statement)
					{
						FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
						{
							Ptr<WfLexicalSymbol> argumentSymbol = new WfLexicalSymbol(resultScope.Obj());
							argumentSymbol->name = argument->name.value;
							argumentSymbol->type = argument->type;
							argumentSymbol->creatorArgument = argument;
							resultScope->symbols.Add(argumentSymbol->name, argumentSymbol);
						}

						BuildScopeForStatement(manager, resultScope, node->statement);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(parentScope.Obj());
					symbol->name = node->name.value;
					symbol->creatorDeclaration = node;
					symbol->type = node->type;
					parentScope->symbols.Add(symbol->name, symbol);

					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfEventDeclaration* node)override
				{
					Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(parentScope.Obj());
					symbol->name = node->name.value;
					symbol->creatorDeclaration = node;
					parentScope->symbols.Add(symbol->name, symbol);
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(parentScope.Obj());
					symbol->name = node->name.value;
					symbol->creatorDeclaration = node;
					symbol->type = node->type;
					parentScope->symbols.Add(symbol->name, symbol);
				}

				void Visit(WfClassDeclaration* node)override
				{
					Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(parentScope.Obj());
					symbol->name = node->name.value;
					symbol->creatorDeclaration = node;
					parentScope->symbols.Add(symbol->name, symbol);
					
					auto td = manager->declarationTypes[node].Cast<WfCustomType>();					
					resultScope = new WfLexicalScope(parentScope);
					FOREACH(Ptr<WfClassMember>, member, node->members)
					{
						BuildScopeForClassMember(manager, resultScope, td, node, member);
					}
				}

				static Ptr<WfLexicalScope> Execute(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, ParsingTreeCustomBase* source, Ptr<WfDeclaration> declaration, Ptr<WfCustomType> td = nullptr, Ptr<WfClassDeclaration> classDecl = nullptr, Ptr<WfClassMember> member = nullptr)
				{
					BuildScopeForDeclarationVisitor visitor(manager, parentScope, source, td, classDecl, member);
					declaration->Accept(&visitor);
					if (visitor.resultScope)
					{
						manager->declarationScopes.Add(declaration, visitor.resultScope);
						visitor.resultScope->ownerDeclaration = declaration;
						visitor.resultScope->ownerClassMember = member;
					}
					else
					{
						manager->declarationScopes.Add(declaration, parentScope);
					}
					return visitor.resultScope;
				}
			};

/***********************************************************************
BuildScopeForStatement
***********************************************************************/

			class BuildScopeForStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Ptr<WfLexicalScope>						parentScope;
				Ptr<WfLexicalScope>						resultScope;

				BuildScopeForStatementVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScope> _parentScope)
					:manager(_manager)
					, parentScope(_parentScope)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
				}

				void Visit(WfContinueStatement* node)override
				{
				}

				void Visit(WfReturnStatement* node)override
				{
					if (node->expression)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
					}
				}

				void Visit(WfIfStatement* node)override
				{
					resultScope = new WfLexicalScope(parentScope);
					if (node->type)
					{
						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
						symbol->name = node->name.value;
						symbol->type = node->type;
						symbol->creatorStatement = node;
						resultScope->symbols.Add(symbol->name, symbol);
					}

					BuildScopeForExpression(manager, resultScope, node->expression);
					BuildScopeForStatement(manager, resultScope, node->trueBranch);
					if (node->falseBranch)
					{
						BuildScopeForStatement(manager, resultScope, node->falseBranch);
					}
				}

				void Visit(WfSwitchStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						BuildScopeForExpression(manager, parentScope, switchCase->expression);
						BuildScopeForStatement(manager, parentScope, switchCase->statement);
					}
					if (node->defaultBranch)
					{
						BuildScopeForStatement(manager, parentScope, node->defaultBranch);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->condition);
					BuildScopeForStatement(manager, parentScope, node->statement);
				}

				void Visit(WfForEachStatement* node)override
				{
					resultScope = new WfLexicalScope(parentScope);

					Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
					symbol->name = node->name.value;
					symbol->creatorStatement = node;
					resultScope->symbols.Add(symbol->name, symbol);

					BuildScopeForExpression(manager, parentScope, node->collection);
					BuildScopeForStatement(manager, resultScope, node->statement);
				}

				void Visit(WfTryStatement* node)override
				{
					BuildScopeForStatement(manager, parentScope, node->protectedStatement);
					if (node->catchStatement)
					{
						resultScope = new WfLexicalScope(parentScope);

						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
						symbol->name = node->name.value;
						symbol->creatorStatement = node;
						{
							auto system = MakePtr<WfTopQualifiedType>();
							system->name.value = L"system";

							auto exception = MakePtr<WfChildType>();
							exception->parent = system;
							exception->name.value = L"Exception";

							auto sharedPtr = MakePtr<WfSharedPointerType>();
							sharedPtr->element = exception;

							symbol->type = sharedPtr;
						}
						resultScope->symbols.Add(symbol->name, symbol);

						BuildScopeForStatement(manager, resultScope, node->catchStatement);
					}
					if (node->finallyStatement)
					{
						BuildScopeForStatement(manager, parentScope, node->finallyStatement);
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					resultScope = new WfLexicalScope(parentScope);

					FOREACH(Ptr<WfStatement>, statement, node->statements)
					{
						BuildScopeForStatement(manager, resultScope, statement);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfVariableStatement* node)override
				{
					BuildScopeForDeclaration(manager, parentScope, node->variable, node);
				}

				static Ptr<WfLexicalScope> Execute(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfStatement> statement)
				{
					BuildScopeForStatementVisitor visitor(manager, parentScope);
					statement->Accept(&visitor);
					if (visitor.resultScope)
					{
						manager->statementScopes.Add(statement, visitor.resultScope);
						visitor.resultScope->ownerStatement = statement;
					}
					else
					{
						manager->statementScopes.Add(statement, parentScope);
					}
					return visitor.resultScope;
				}
			};

/***********************************************************************
BuildScopeForExpression
***********************************************************************/

			class BuildScopeForExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Ptr<WfLexicalScope>						parentScope;
				Ptr<WfLexicalScope>						resultScope;

				BuildScopeForExpressionVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScope> _parentScope)
					:manager(_manager)
					, parentScope(_parentScope)
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					SortedList<vint> names;
					SearchOrderedName(parentScope.Obj(), node->body, names);

					resultScope = new WfLexicalScope(parentScope);
					FOREACH(vint, name, names)
					{
						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
						symbol->name = L"$" + itow(name);
						symbol->creatorExpression = node;
						resultScope->symbols.Add(symbol->name, symbol);
					}

					BuildScopeForExpression(manager, resultScope, node->body);
				}

				void Visit(WfMemberExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->parent);
				}

				void Visit(WfChildExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->parent);
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
					if (node->expandedExpression)
					{
						BuildScopeForExpression(manager, parentScope, node->expandedExpression);
					}
				}

				void Visit(WfUnaryExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->operand);
				}

				void Visit(WfBinaryExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->first);
					BuildScopeForExpression(manager, parentScope, node->second);
				}

				void Visit(WfLetExpression* node)override
				{
					resultScope = new WfLexicalScope(parentScope);
					FOREACH(Ptr<WfLetVariable>, variable, node->variables)
					{
						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
						symbol->name = variable->name.value;
						symbol->creatorExpression = node;
						resultScope->symbols.Add(symbol->name, symbol);
						BuildScopeForExpression(manager, resultScope, variable->value);
					}

					BuildScopeForExpression(manager, resultScope, node->expression);
				}

				void Visit(WfIfExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->condition);
					BuildScopeForExpression(manager, parentScope, node->trueBranch);
					BuildScopeForExpression(manager, parentScope, node->falseBranch);
				}

				void Visit(WfRangeExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->begin);
					BuildScopeForExpression(manager, parentScope, node->end);
				}

				void Visit(WfSetTestingExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->element);
					BuildScopeForExpression(manager, parentScope, node->collection);
				}

				void Visit(WfConstructorExpression* node)override
				{
					FOREACH(Ptr<WfConstructorArgument>, argument, node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument->key);
						if (argument->value)
						{
							BuildScopeForExpression(manager, parentScope, argument->value);
						}
					}
				}

				void Visit(WfInferExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					if (node->expression)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
					}
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfAttachEventExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->event);
					BuildScopeForExpression(manager, parentScope, node->function);
				}

				void Visit(WfDetachEventExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->handler);
				}

				void Visit(WfBindExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfObserveExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->parent);
					if (node->observeType == WfObserveType::SimpleObserve)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
						FOREACH(Ptr<WfExpression>, event, node->events)
						{
							BuildScopeForExpression(manager, parentScope, event);
						}
					}
					else
					{
						resultScope = new WfLexicalScope(parentScope);
						{
							Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
							symbol->name = node->name.value;
							symbol->creatorExpression = node;
							resultScope->symbols.Add(symbol->name, symbol);
						}

						BuildScopeForExpression(manager, resultScope, node->expression);
						FOREACH(Ptr<WfExpression>, event, node->events)
						{
							BuildScopeForExpression(manager, resultScope, event);
						}
					}
				}

				void Visit(WfCallExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->function);
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument);
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					BuildScopeForDeclaration(manager, parentScope, node->function, node);
				}

				void Visit(WfNewTypeExpression* node)override
				{
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument);
					}

					resultScope = new WfLexicalScope(parentScope);
					FOREACH(Ptr<WfFunctionDeclaration>, function, node->functions)
					{
						BuildScopeForDeclaration(manager, resultScope, function);
					}
				}

				static Ptr<WfLexicalScope> Execute(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfExpression> expression)
				{
					BuildScopeForExpressionVisitor visitor(manager, parentScope);
					expression->Accept(&visitor);
					if (visitor.resultScope)
					{
						manager->expressionScopes.Add(expression, visitor.resultScope);
						visitor.resultScope->ownerExpression = expression;
					}
					else
					{
						manager->expressionScopes.Add(expression, parentScope);
					}
					return visitor.resultScope;
				}
			};

/***********************************************************************
BuildScope
***********************************************************************/

			void BuildScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				Ptr<WfLexicalScope> scope = new WfLexicalScope(manager);
				scope->ownerModule = module;
				manager->moduleScopes.Add(module, scope);

				FOREACH(Ptr<WfDeclaration>, declaration, module->declarations)
				{
					BuildScopeForDeclaration(manager, scope, declaration);
				}
			}

			void BuildScopeForClassMember(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<typeimpl::WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfClassMember> member, parsing::ParsingTreeCustomBase* source)
			{
				BuildScopeForDeclarationVisitor::Execute(manager, parentScope, source, member->declaration, td, classDecl, member);
			}

			void BuildScopeForDeclaration(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfDeclaration> declaration, parsing::ParsingTreeCustomBase* source)
			{
				BuildScopeForDeclarationVisitor::Execute(manager, parentScope, source, declaration);
			}

			void BuildScopeForStatement(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfStatement> statement)
			{
				BuildScopeForStatementVisitor::Execute(manager, parentScope, statement);
			}

			void BuildScopeForExpression(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfExpression> expression)
			{
				BuildScopeForExpressionVisitor::Execute(manager, parentScope, expression);
			}

/***********************************************************************
CheckScopes
***********************************************************************/

			bool CheckScopes(WfLexicalScopeManager* manager)
			{
				vint errorCount = manager->errors.Count();
				FOREACH(Ptr<WfLexicalScope>, scope,
					From(manager->moduleScopes.Values())
						.Concat(manager->declarationScopes.Values())
						.Concat(manager->statementScopes.Values())
						.Concat(manager->expressionScopes.Values()))
				{
					if (!manager->analyzedScopes.Contains(scope.Obj()))
					{
						manager->analyzedScopes.Add(scope);

						for (vint i = 0; i < scope->symbols.Count(); i++)
						{
							const auto& symbols = scope->symbols.GetByIndex(i);
							if (symbols.Count() > 1)
							{
								if (!scope->ownerModule && !scope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
								{
									if (symbols.Count() > 1)
									{
										FOREACH(Ptr<WfLexicalSymbol>, symbol, From(symbols))
										{
											if (symbol->creatorDeclaration)
											{
												if (!symbol->creatorDeclaration.Cast<WfFunctionDeclaration>())
												{
													manager->errors.Add(WfErrors::DuplicatedSymbol(symbol->creatorDeclaration.Obj(), symbol));
												}
											}
											else if (symbol->creatorArgument)
											{
												manager->errors.Add(WfErrors::DuplicatedSymbol(symbol->creatorArgument.Obj(), symbol));
											}
											else if (symbol->creatorStatement)
											{
												manager->errors.Add(WfErrors::DuplicatedSymbol(symbol->creatorStatement.Obj(), symbol));
											}
											else if (symbol->creatorExpression)
											{
												manager->errors.Add(WfErrors::DuplicatedSymbol(symbol->creatorExpression.Obj(), symbol));
											}
										}
									}
								}
							}
						}

						for (vint i = 0; i < scope->symbols.Count(); i++)
						{
							FOREACH(Ptr<WfLexicalSymbol>, symbol, scope->symbols.GetByIndex(i))
							{
								if (symbol->type)
								{
									symbol->typeInfo = CreateTypeInfoFromType(scope.Obj(), symbol->type);
								}
							}
						}
					}
				}
				return manager->errors.Count() == errorCount;
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_COMPLETESCOPE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
CompleteScopeForClassMember
***********************************************************************/

			class CompleteScopeForClassMemberVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Ptr<WfCustomType>						td;
				Ptr<WfClassDeclaration>					classDecl;
				Ptr<WfClassMember>						member;

				CompleteScopeForClassMemberVisitor(WfLexicalScopeManager* _manager, Ptr<WfCustomType> _td, Ptr<WfClassDeclaration> _classDecl, Ptr<WfClassMember> _member)
					:manager(_manager)
					, td(_td)
					, member(_member)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					auto scope = manager->declarationScopes[node];
					auto info = manager->declarationMemberInfos[node].Cast<WfMethodBase>();

					FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
					{
						if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), argument->type))
						{
							auto paramInfo = MakePtr<ParameterInfoImpl>(info.Obj(), argument->name.value, typeInfo);
							info->AddParameter(paramInfo);
						}
					}

					if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), node->returnType))
					{
						info->SetReturn(typeInfo);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					throw 0;
				}

				void Visit(WfEventDeclaration* node)override
				{
					auto scope = manager->declarationScopes[node];
					auto type = MakePtr<WfFunctionType>();
					{
						auto voidType = MakePtr<WfPredefinedType>();
						voidType->name = WfPredefinedTypeName::Void;
						type->result = voidType;
					}
					FOREACH(Ptr<WfType>, argument, node->arguments)
					{
						type->arguments.Add(argument);
					}

					if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), type))
					{
						auto info = manager->declarationMemberInfos[node].Cast<WfEvent>();
						info->SetHandlerType(typeInfo);
					}
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					auto scope = manager->declarationScopes[node];
					auto info = manager->declarationMemberInfos[node].Cast<WfProperty>();

					if (node->getter.value != L"")
					{
						info->SetGetter(dynamic_cast<MethodInfoImpl*>(td->GetMethodGroupByName(node->getter.value, false)->GetMethod(0)));
					}

					if (node->setter.value != L"")
					{
						info->SetSetter(dynamic_cast<MethodInfoImpl*>(td->GetMethodGroupByName(node->setter.value, false)->GetMethod(0)));
					}

					if (node->valueChangedEvent.value != L"")
					{
						info->SetValueChangedEvent(dynamic_cast<EventInfoImpl*>(td->GetEventByName(node->valueChangedEvent.value, false)));
					}
				}

				void Visit(WfClassDeclaration* node)override
				{
					CompleteScopeForDeclaration(manager, node);
				}

				static void Execute(WfLexicalScopeManager* manager, Ptr<WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfClassMember> member)
				{
					CompleteScopeForClassMemberVisitor visitor(manager, td, classDecl, member);
					member->declaration->Accept(&visitor);
				}
			};

/***********************************************************************
CompleteScopeForDeclaration
***********************************************************************/

			class CompleteScopeForDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Ptr<WfDeclaration>						declaration;

				CompleteScopeForDeclarationVisitor(WfLexicalScopeManager* _manager, Ptr<WfDeclaration> _declaration)
					:manager(_manager)
					, declaration(_declaration)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					FOREACH(Ptr<WfDeclaration>, decl, node->declarations)
					{
						CompleteScopeForDeclaration(manager, decl);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
				}

				void Visit(WfVariableDeclaration* node)override
				{
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					auto scope = manager->declarationScopes[node];
					auto td = manager->declarationTypes[node].Cast<WfCustomType>();
					FOREACH(Ptr<WfType>, baseType, node->baseTypes)
					{
						if (auto scopeName = GetScopeNameFromReferenceType(scope.Obj(), baseType))
						{
							if (scopeName->typeDescriptor)
							{
								td->AddBaseType(scopeName->typeDescriptor);
							}
						}
					}
					FOREACH(Ptr<WfClassMember>, member, node->members)
					{
						CompleteScopeForClassMember(manager, td, node, member);
					}
				}

				static void Execute(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration)
				{
					CompleteScopeForDeclarationVisitor visitor(manager, declaration);
					declaration->Accept(&visitor);
				}
			};

/***********************************************************************
CompleteScope
***********************************************************************/

			void CompleteScopeForClassMember(WfLexicalScopeManager* manager, Ptr<WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfClassMember> member)
			{
				CompleteScopeForClassMemberVisitor::Execute(manager, td, classDecl, member);
			}

			void CompleteScopeForDeclaration(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration)
			{
				CompleteScopeForDeclarationVisitor::Execute(manager, declaration);
			}

			void CompleteScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				FOREACH(Ptr<WfDeclaration>, declaration, module->declarations)
				{
					CompleteScopeForDeclaration(manager, declaration);
				}
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_ERRORS.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
WfErrors
***********************************************************************/

			Ptr<parsing::ParsingError> WfErrors::WrongFormatStringSyntax(WfExpression* node)
			{
				return new ParsingError(node, L"A0: Wrong format string syntax.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongSimpleObserveExpression(WfExpression* node)
			{
				return new ParsingError(node, L"A1: Simple observe expression should observe a property under the observed object.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongSimpleObserveEvent(WfExpression* node)
			{
				return new ParsingError(node, L"A2: Simple observe expression should react to an event under the observed object.");
			}

			Ptr<parsing::ParsingError> WfErrors::EmptyObserveEvent(WfExpression* node)
			{
				return new ParsingError(node, L"A2: Observe expression should react to at least one event.");
			}

			Ptr<parsing::ParsingError> WfErrors::ObserveNotInBind(WfExpression* node)
			{
				return new ParsingError(node, L"A3: Observe expression should appear in a bind expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::ObserveInObserveEvent(WfExpression* node)
			{
				return new ParsingError(node, L"A4: Observe expression should not appear in the event expression in another observe expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::BindInBind(WfExpression* node)
			{
				return new ParsingError(node, L"A4: Bind expression should not appear in another bind expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::AttachInBind(WfExpression* node)
			{
				return new ParsingError(node, L"A4: Attach expression should not appear in another bind expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::DetachInBind(WfExpression* node)
			{
				return new ParsingError(node, L"A4: Detach expression should not appear in another bind expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorMixMapAndList(WfExpression* node)
			{
				return new ParsingError(node, L"A5: Key-value pairs are not allowed in list constructor expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorMixClassAndInterface(WfExpression* node)
			{
				return new ParsingError(node, L"A6: Functions are not allowed in class constructor expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::ScopeNameIsNotExpression(WfExpression* node, Ptr<WfLexicalScopeName> scopeName)
			{
				return new ParsingError(node, L"A7: Symbol \"" + scopeName->GetFriendlyName() + L"\" cannot be used as an expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::EventIsNotExpression(WfExpression* node, reflection::description::IEventInfo* eventInfo)
			{
				return new ParsingError(node, L"A7: Event \"" + eventInfo->GetName() + L"\" of type \"" + eventInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\" cannot be used as an expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotScopeName(WfExpression* node)
			{
				return new ParsingError(node, L"A8: Expression does not reference to a declaration.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotEvent(WfExpression* node)
			{
				return new ParsingError(node, L"A8: Expression does not reference to an event.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionCannotResolveType(WfExpression* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"A9: Expression referencing to symbol \"" + symbol->name + L"\" failed to resolve its type.");
			}

			Ptr<parsing::ParsingError> WfErrors::NullCannotResolveType(WfExpression* node)
			{
				return new ParsingError(node, L"A9: Expression \"null\" failed to resolve its type.");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorCannotResolveType(WfExpression* node)
			{
				return new ParsingError(node, L"A9: Expression \"{}\" failed to resolve its type.");
			}

			Ptr<parsing::ParsingError> WfErrors::OrderedLambdaCannotResolveType(WfExpression* node)
			{
				return new ParsingError(node, L"A9: Ordered lambda expression failed to resolve its type.");
			}

			Ptr<parsing::ParsingError> WfErrors::NullCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A10: Expression \"null\" cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A10: Expression \"{}\" cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::OrderedLambdaCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A10: Ordered lambda expression cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A10: Expression of type \"" + fromType->GetTypeFriendlyName() + L"\" cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionCannotExplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A11: Expression of type \"" + fromType->GetTypeFriendlyName() + L"\" cannot explicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotWeakCastToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A12: Expression cannot weakly cast to \"" + toType->GetTypeFriendlyName() + L"\" because it cannot be \"null\".");
			}

			Ptr<parsing::ParsingError> WfErrors::IntegerLiteralOutOfRange(WfIntegerExpression* node)
			{
				return new ParsingError(node, L"A13: Integer literal \"" + node->value.value + L"\" out of range.");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotMergeTwoType(WfExpression* node, reflection::description::ITypeInfo* firstType, reflection::description::ITypeInfo* secondType)
			{
				return new ParsingError(node, L"A14: Failed to merge type \"" + firstType->GetTypeFriendlyName() + L"\" with type \"" + secondType->GetTypeFriendlyName() + L"\" together to calculate the result type.");
			}

			Ptr<parsing::ParsingError> WfErrors::RangeShouldBeInteger(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A15: Elements in a range expression should be integer, not \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::UnaryOperatorOnWrongType(WfUnaryExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A16: Unary operator cannot apply on expression of type \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::BinaryOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A16: Binary operator cannot apply on expression of type \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::IndexOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* containerType)
			{
				return new ParsingError(node, L"A17: Container of type \"" + containerType->GetTypeFriendlyName() + L"\" cannot be accessed using index.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotCollection(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A18: Expression of type \"" + type->GetTypeFriendlyName() + L"\" is not an enumerable type.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotFunction(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A19: Expression of type \"" + type->GetTypeFriendlyName() + L"\" is not an invokable function type.");
			}

			Ptr<parsing::ParsingError> WfErrors::FunctionArgumentCountMismatched(WfExpression* node, vint expectedCount, const ResolveExpressionResult& function)
			{
				return new ParsingError(node, L"A20: Function " + function.GetFriendlyName() + L"\" is not allowed to call with " + itow(expectedCount) + L" arguments.");
			}

			Ptr<parsing::ParsingError> WfErrors::FunctionArgumentTypeMismatched(WfExpression* node, const ResolveExpressionResult& function, vint index, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A21: The " + itow(index) + L"-th argument of function " + function.GetFriendlyName() + L" cannot implicitly convert from \"" + fromType->GetTypeFriendlyName() + L"\" to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotPickOverloadedFunctions(WfExpression* node, collections::List<ResolveExpressionResult>& results)
			{
				WString description;
				FOREACH_INDEXER(ResolveExpressionResult, result, index, results)
				{
					description += L"\r\n\t";
					description += result.GetFriendlyName();
				}
				return new ParsingError(node, L"A22: Cannot decide which function to call in multiple targets: " + description + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::ClassContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A23: Class \"" + type->GetTypeFriendlyName() + L"\" does not contain any constructor.");
			}

			Ptr<parsing::ParsingError> WfErrors::InterfaceContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				Ptr<ITypeInfo> proxy = TypeInfoRetriver<Ptr<IValueInterfaceProxy>>::CreateTypeInfo();
				return new ParsingError(node, L"A23: Interface \"" + type->GetTypeFriendlyName() + L"\" does not contain any constructor receiving an \"" + proxy->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorReturnTypeMismatched(WfExpression* node, const ResolveExpressionResult& function, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A24: The return type of " + function.GetFriendlyName() + L" cannot implicitly convert from \"" + fromType->GetTypeFriendlyName() + L"\" to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotLeftValue(WfExpression* node, const ResolveExpressionResult& result)
			{
				return new ParsingError(node, L"A25: Expression " + result.GetFriendlyName() + L" is not assignable.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongVoidType(WfType* node)
			{
				return new ParsingError(node, L"B0: Void is not a type for a value.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongInterfaceType(WfType* node)
			{
				return new ParsingError(node, L"B1: Interface is not a type for a value.");
			}

			Ptr<parsing::ParsingError> WfErrors::RawPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return new ParsingError(node, L"B2: A raw pointer" + (typeInfo ? L" \"" + typeInfo->GetTypeFriendlyName() + L"\"" : L"") + L" should point to a class or interface.");
			}

			Ptr<parsing::ParsingError> WfErrors::SharedPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return new ParsingError(node, L"B3: A shared pointer" + (typeInfo ? L" \"" + typeInfo->GetTypeFriendlyName() + L"\"" : L"") + L" should point to a class or interface.");
			}

			Ptr<parsing::ParsingError> WfErrors::NullableToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return new ParsingError(node, L"B4: A nullable value" + (typeInfo ? L" \"" + typeInfo->GetTypeFriendlyName() + L"\"" : L"") + L" should point to a struct.");
			}

			Ptr<parsing::ParsingError> WfErrors::ChildOfNonReferenceType(WfType* node)
			{
				return new ParsingError(node, L"B5: Only a reference type have child types.");
			}

			Ptr<parsing::ParsingError> WfErrors::TypeNotExists(WfType* node, Ptr<WfLexicalScopeName> scopeName)
			{
				return new ParsingError(node, L"B6: \"" + scopeName->GetFriendlyName() + L"\" is not a type.");
			}

			Ptr<parsing::ParsingError> WfErrors::TypeNotExists(WfType* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"B6: \"" + symbol->name + L"\" is not a type.");
			}

			Ptr<parsing::ParsingError> WfErrors::TypeNotForValue(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return new ParsingError(node, L"B7: Type \"" + typeInfo->GetTypeFriendlyName() + L"\" is not a type for a value.");
			}

			Ptr<parsing::ParsingError> WfErrors::BreakNotInLoop(WfStatement* node)
			{
				return new ParsingError(node, L"C0: Break statement should appear in a loop.");
			}

			Ptr<parsing::ParsingError> WfErrors::ContinueNotInLoop(WfStatement* node)
			{
				return new ParsingError(node, L"C1: Continue statement should appear in a loop.");
			}

			Ptr<parsing::ParsingError> WfErrors::RethrowNotInCatch(WfStatement* node)
			{
				return new ParsingError(node, L"C2: Re-raise exception statement should appear in catch.");
			}

			Ptr<parsing::ParsingError> WfErrors::TryMissCatchAndFinally(WfStatement* node)
			{
				return new ParsingError(node, L"C3: Try statement should not appear without both catch and finally.");
			}

			Ptr<parsing::ParsingError> WfErrors::ReturnMissExpression(WfStatement* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"C4: Return statement requires an expression of type \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::DeleteNonRawPointer(WfStatement* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"C5: Delete statement cannot apply on an expression of type \"" + type->GetTypeFriendlyName() + L"\", which is expected to be a raw pointer.");
			}

			Ptr<parsing::ParsingError> WfErrors::FunctionShouldHaveName(WfDeclaration* node)
			{
				return new ParsingError(node, L"D0: Function should have a name.");
			}

			Ptr<parsing::ParsingError> WfErrors::FunctionShouldHaveImplementation(WfDeclaration* node)
			{
				return new ParsingError(node, L"D0: Function should be implemented.");
			}

			Ptr<parsing::ParsingError> WfErrors::InterfaceMethodShouldNotHaveImplementation(WfDeclaration* node)
			{
				return new ParsingError(node, L"D0: Interface method should not be implemented.");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedDeclaration(WfDeclaration* node, const WString& firstDeclarationCategory)
			{
				return new ParsingError(node, L"D1: Duplicated declaration \"" + node->name.value + L"\", it has already beed defined as a " + firstDeclarationCategory + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedSymbol(WfDeclaration* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedSymbol(WfFunctionArgument* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedSymbol(WfStatement* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedSymbol(WfExpression* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::InterfaceMethodNotImplemented(WfNewTypeExpression* node, reflection::description::IMethodInfo* method)
			{
				ResolveExpressionResult result(method, CreateTypeInfoFromMethodInfo(method));
				return new ParsingError(node, L"D3: Interface method not implemented: " + result.GetFriendlyName() + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::InterfaceMethodNotFound(WfFunctionDeclaration* node, reflection::description::ITypeInfo* interfaceType, reflection::description::ITypeInfo* methodType)
			{
				return new ParsingError(node, L"D4: Interface \"" + interfaceType->GetTypeFriendlyName() + L"\" does not contain method \"" + node->name.value + L"\" which is in type \"" + methodType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotPickOverloadedInterfaceMethods(WfExpression* node, collections::List<ResolveExpressionResult>& results)
			{
				WString description;
				FOREACH_INDEXER(ResolveExpressionResult, result, index, results)
				{
					description += L"\r\n\t";
					description += result.GetFriendlyName();
				}
				return new ParsingError(node, L"D5: Cannot decide which function to implement in multiple targets: " + description + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotPickOverloadedImplementMethods(WfFunctionDeclaration* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"D6: There are some other methods named \"" + node->name.value + L"\" whose types are also \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::WrontDeclaration(WfEventDeclaration* node)
			{
				return new ParsingError(node, L"D7: Event \"" + node->name.value + L"\" cannot be used outside of classes.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrontDeclaration(WfPropertyDeclaration* node)
			{
				return new ParsingError(node, L"D7: Property \"" + node->name.value + L"\" cannot be used outside of classes.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongUsingPathWildCard(WfModuleUsingPath* node)
			{
				return new ParsingError(node, L"E0: Wild card \"*\" should only appear in the last item of the using path and should appear once.");
			}

			Ptr<parsing::ParsingError> WfErrors::TopQualifiedSymbolNotExists(parsing::ParsingTreeCustomBase* node, const WString& name)
			{
				return new ParsingError(node, L"F0: Top qualified symbol \"" + name + L"\" does not exist.");
			}

			Ptr<parsing::ParsingError> WfErrors::ChildSymbolNotExists(parsing::ParsingTreeCustomBase* node, Ptr<WfLexicalScopeName> scopeName, const WString& name)
			{
				return new ParsingError(node, L"F1: Symbol \"" + name + L"\" does not exist in \"" + scopeName->GetFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::MemberNotExists(parsing::ParsingTreeCustomBase* node, reflection::description::ITypeDescriptor* typeDescriptor, const WString& name)
			{
				return new ParsingError(node, L"F1: Member \"" + name + L"\" does not exist in \"" + typeDescriptor->GetTypeName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ReferenceNotExists(parsing::ParsingTreeCustomBase* node, const WString& name)
			{
				return new ParsingError(node, L"F2: Symbol \"" + name + L"\" does not exist in the current scope.");
			}

			Ptr<parsing::ParsingError> WfErrors::TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<ResolveExpressionResult>& results, const WString& name)
			{
				WString description;
				FOREACH_INDEXER(ResolveExpressionResult, result, index, results)
				{
					description += L"\r\n\t";
					description += result.GetFriendlyName();
				}
				return new ParsingError(node, L"F3: Symbol \"" + name + L"\" references to too many targets: " + description + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<Ptr<WfLexicalSymbol>>& symbols, const WString& name)
			{
				List<ResolveExpressionResult> results;
				CopyFrom(
					results,
					From(symbols)
					.Select([](Ptr<WfLexicalSymbol> symbol)
					{
						return ResolveExpressionResult(symbol, 0);
					}));
				return TooManyTargets(node, results, name);
			}

			Ptr<parsing::ParsingError> WfErrors::TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<Ptr<WfLexicalScopeName>>& names, const WString& name)
			{
				List<ResolveExpressionResult> results;
				CopyFrom(
					results,
					From(names)
					.Select([](Ptr<WfLexicalScopeName> name)
					{
						return ResolveExpressionResult(name);
					}));
				return TooManyTargets(node, results, name);
			}

			Ptr<parsing::ParsingError> WfErrors::ClassFeatureNotSupported(WfClassDeclaration* node, const WString& name)
			{
				return new ParsingError(node, L"G0: Class feature not supported yet: " + name + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::ClassFeatureNotSupported(WfClassMember* node, const WString& name)
			{
				return new ParsingError(node, L"G0: Class field \"" + node->declaration->name.value + L"\" not supported yet: " + name + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::NonFunctionClassMemberCannotBeStatic(WfClassMember* node)
			{
				return new ParsingError(node, L"G1: Class member \"" + node->declaration->name.value + L"\" cannot be static because it is not a function.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongClassMember(WfNamespaceDeclaration* node)
			{
				return new ParsingError(node, L"G2: Namespace \"" + node->name.value + L"\" cannot be a class member.");
			}

			Ptr<parsing::ParsingError> WfErrors::PropertyGetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return new ParsingError(node, L"G3: Cannot find the getter \"" + node->getter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\". A property getter should be a non-static method in the same type.");
			}

			Ptr<parsing::ParsingError> WfErrors::PropertySetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return new ParsingError(node, L"G3: Cannot find the setter \"" + node->setter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\". A property setter should be a non-static method in the same type.");
			}

			Ptr<parsing::ParsingError> WfErrors::PropertyEventNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return new ParsingError(node, L"G3: Cannot find the event \"" + node->valueChangedEvent.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\". A property setter should be an event in the same type.");
			}

			Ptr<parsing::ParsingError> WfErrors::TooManyPropertyGetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return new ParsingError(node, L"G4: Too many symbols found for the getter \"" + node->getter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::TooManyPropertySetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return new ParsingError(node, L"G4: Too many symbols found for the setter \"" + node->setter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::TooManyPropertyEvent(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return new ParsingError(node, L"G4: Too many symbols found for the event \"" + node->valueChangedEvent.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::PropertyGetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return new ParsingError(node, L"G5: Cannot match the getter \"" + node->getter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\". A property getter should have no argument, and its return type should be identical to the property type.");
			}

			Ptr<parsing::ParsingError> WfErrors::PropertySetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return new ParsingError(node, L"G5: Cannot match the setter \"" + node->getter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\". A property setter should have no return value and have only one argument, and the argument type should be identical to the property type.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongBaseType(WfClassDeclaration* node, WfType* type)
			{
				return new ParsingError(node, L"G6: A base type of the type \"" + node->name.value + L"\" should be another custom type, it cannot be any predefined type, pointer type, shared pointer type, nullable type, collection type, or function type");
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_GENERATEASSEMBLY.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace regex;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;
			using namespace runtime;
			using namespace typeimpl;

			typedef WfInstruction Ins;

#define INSTRUCTION(X) context.AddInstruction(node, X)

/***********************************************************************
GenerateTypeCastInstructions
***********************************************************************/

			void GenerateTypeCastInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, bool strongCast, WfExpression* node)
			{
				if (expectedType->GetTypeDescriptor() != GetTypeDescriptor<Value>())
				{
					if (strongCast)
					{
						switch (expectedType->GetDecorator())
						{
						case ITypeInfo::RawPtr:
							INSTRUCTION(Ins::ConvertToType(Value::RawPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::SharedPtr:
							INSTRUCTION(Ins::ConvertToType(Value::SharedPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::Nullable:
						case ITypeInfo::TypeDescriptor:
						case ITypeInfo::Generic:
							INSTRUCTION(Ins::ConvertToType(Value::Text, expectedType->GetTypeDescriptor()));
							break;
						}
					}
					else
					{
						switch (expectedType->GetDecorator())
						{
						case ITypeInfo::RawPtr:
							INSTRUCTION(Ins::TryConvertToType(Value::RawPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::SharedPtr:
							INSTRUCTION(Ins::TryConvertToType(Value::SharedPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::Nullable:
						case ITypeInfo::TypeDescriptor:
						case ITypeInfo::Generic:
							INSTRUCTION(Ins::TryConvertToType(Value::Text, expectedType->GetTypeDescriptor()));
							break;
						}
					}
				}
			}

/***********************************************************************
GetInstructionTypeArgument
***********************************************************************/

			void GenerateTypeTestingInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, WfExpression* node)
			{
				if (expectedType->GetTypeDescriptor() != GetTypeDescriptor<Value>())
				{
					switch (expectedType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						INSTRUCTION(Ins::TestType(Value::RawPtr, expectedType->GetTypeDescriptor()));
						break;
					case ITypeInfo::SharedPtr:
						INSTRUCTION(Ins::TestType(Value::SharedPtr, expectedType->GetTypeDescriptor()));
						break;
					case ITypeInfo::Nullable:
					case ITypeInfo::TypeDescriptor:
					case ITypeInfo::Generic:
						INSTRUCTION(Ins::TestType(Value::Text, expectedType->GetTypeDescriptor()));
						break;
					}
				}
				else
				{
					INSTRUCTION(Ins::Pop());
					INSTRUCTION(Ins::LoadValue(BoxValue(true)));
				}
			}

/***********************************************************************
GenerateTypeCastInstructions
***********************************************************************/

			runtime::WfInsType GetInstructionTypeArgument(Ptr<reflection::description::ITypeInfo> expectedType)
			{
				auto td = expectedType->GetTypeDescriptor();
				if (td == GetTypeDescriptor<bool>()) return WfInsType::Bool;
				if (td == GetTypeDescriptor<vint8_t>()) return WfInsType::I1;
				if (td == GetTypeDescriptor<vint16_t>()) return WfInsType::I2;
				if (td == GetTypeDescriptor<vint32_t>()) return WfInsType::I4;
				if (td == GetTypeDescriptor<vint64_t>()) return WfInsType::I8;
				if (td == GetTypeDescriptor<vuint8_t>()) return WfInsType::U1;
				if (td == GetTypeDescriptor<vuint16_t>()) return WfInsType::U2;
				if (td == GetTypeDescriptor<vuint32_t>()) return WfInsType::U4;
				if (td == GetTypeDescriptor<vuint64_t>()) return WfInsType::U8;
				if (td == GetTypeDescriptor<float>()) return WfInsType::F4;
				if (td == GetTypeDescriptor<double>()) return WfInsType::F8;
				if (td == GetTypeDescriptor<WString>()) return WfInsType::String;
				return WfInsType::Unknown;
			}

/***********************************************************************
GenerateAssembly
***********************************************************************/

			Ptr<runtime::WfAssembly> GenerateAssembly(WfLexicalScopeManager* manager)
			{
				auto assembly = MakePtr<WfAssembly>();
				assembly->insBeforeCodegen = new WfInstructionDebugInfo;
				assembly->insAfterCodegen = new WfInstructionDebugInfo;
				
				WfCodegenContext context(assembly, manager);
				FOREACH_INDEXER(Ptr<WfModule>, module, index, manager->GetModules())
				{
					auto codeBeforeCodegen = manager->GetModuleCodes()[index];

					auto recorderBefore = new ParsingGeneratedLocationRecorder(context.nodePositionsBeforeCodegen);
					auto recorderAfter = new ParsingGeneratedLocationRecorder(context.nodePositionsAfterCodegen);
					auto recorderOriginal = new ParsingOriginalLocationRecorder(recorderBefore);
					auto recorderMultiple = new ParsingMultiplePrintNodeRecorder;
					recorderMultiple->AddRecorder(recorderOriginal);
					recorderMultiple->AddRecorder(recorderAfter);

					stream::MemoryStream memoryStream;
					{
						stream::StreamWriter streamWriter(memoryStream);
						ParsingWriter parsingWriter(streamWriter, recorderMultiple, index);
						WfPrint(module, L"", parsingWriter);
					}

					memoryStream.SeekFromBegin(0);
					auto codeAfterCodegen = stream::StreamReader(memoryStream).ReadToEnd();

					assembly->insBeforeCodegen->moduleCodes.Add(codeBeforeCodegen);
					assembly->insAfterCodegen->moduleCodes.Add(codeAfterCodegen);
				}

				if (manager->declarationTypes.Count() > 0)
				{
					assembly->typeImpl = new WfTypeImpl;
					FOREACH(Ptr<ITypeDescriptor>, td, manager->declarationTypes.Values())
					{
						if (auto tdClass = td.Cast<WfClass>())
						{
							assembly->typeImpl->classes.Add(tdClass);
						}
						else if (auto tdInterface = td.Cast<WfInterface>())
						{
							assembly->typeImpl->interfaces.Add(tdInterface);
						}
					}
				}

				FOREACH(Ptr<WfModule>, module, manager->GetModules())
				{
					FOREACH(Ptr<WfDeclaration>, decl, module->declarations)
					{
						GenerateGlobalDeclarationMetadata(context, decl);
					}
				}

				{
					auto meta = MakePtr<WfAssemblyFunction>();
					meta->name = L"<initialize>";
					vint functionIndex = assembly->functions.Add(meta);
					assembly->functionByName.Add(meta->name, functionIndex);

					auto functionContext = MakePtr<WfCodegenFunctionContext>();
					functionContext->function = meta;
					context.functionContext = functionContext;
					
					meta->firstInstruction = assembly->instructions.Count();
					FOREACH(Ptr<WfModule>, module, manager->GetModules())
					{
						FOREACH(Ptr<WfDeclaration>, decl, module->declarations)
						{
							GenerateInitializeInstructions(context, decl);
						}
					}

					// define node for INSTRUCTION
					parsing::ParsingTreeCustomBase* node = nullptr;
					INSTRUCTION(Ins::LoadValue(Value()));
					INSTRUCTION(Ins::Return());

					meta->lastInstruction = assembly->instructions.Count() - 1;

					context.functionContext = 0;
					GenerateClosureInstructions(context, functionContext);
				}

				FOREACH(Ptr<WfModule>, module, manager->GetModules())
				{
					FOREACH(Ptr<WfDeclaration>, decl, module->declarations)
					{
						GenerateDeclarationInstructions(context, decl);
					}
				}

				assembly->Initialize();
				return assembly;
			}

#undef INSTRUCTION

/***********************************************************************
Compile
***********************************************************************/

			Ptr<runtime::WfAssembly> Compile(Ptr<parsing::tabling::ParsingTable> table, WfLexicalScopeManager* manager, collections::List<WString>& moduleCodes, collections::List<Ptr<parsing::ParsingError>>& errors)
			{
				manager->Clear(true, true);
				FOREACH(WString, code, moduleCodes)
				{
					manager->AddModule(code);
				}

				if (manager->errors.Count() > 0)
				{
					CopyFrom(errors, manager->errors);
					return 0;
				}

				manager->Rebuild(true);
				if (manager->errors.Count() > 0)
				{
					CopyFrom(errors, manager->errors);
					return 0;
				}

				return GenerateAssembly(manager);
			}

			Ptr<runtime::WfAssembly> Compile(Ptr<parsing::tabling::ParsingTable> table, collections::List<WString>& moduleCodes, collections::List<Ptr<parsing::ParsingError>>& errors)
			{
				WfLexicalScopeManager manager(table);
				return Compile(table, &manager, moduleCodes, errors);
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_GENERATEBIND.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
WfObservingDependency
***********************************************************************/

			WfObservingDependency::WfObservingDependency(WfObservingDependency& dependency)
				:dependencies(dependency.dependencies)
			{
				CopyFrom(inputObserves, dependency.inputObserves);
			}

			WfObservingDependency::WfObservingDependency(DependencyGroup& _dependencies)
				:dependencies(_dependencies)
			{
			}

			WfObservingDependency::WfObservingDependency(DependencyGroup& _dependencies, ObserveList& _inputObserves)
				:dependencies(_dependencies)
			{
				CopyFrom(inputObserves, _inputObserves);
			}

			void WfObservingDependency::AddInternal(WfExpression* observe, WfExpression* dependedObserve)
			{
				auto index = dependencies.Keys().IndexOf(dependedObserve);
				if (index == -1)
				{
					dependencies.Add(dependedObserve, observe);
				}
				else if (!dependencies.GetByIndex(index).Contains(observe))
				{
					dependencies.Add(dependedObserve, observe);
				}
			}

			void WfObservingDependency::Prepare(WfExpression* observe)
			{
				AddInternal(0, observe);

				if (!outputObserves.Contains(observe))
				{
					outputObserves.Add(observe);
				}
			}

			void WfObservingDependency::Add(WfExpression* observe)
			{
				Add(observe, *this);
			}

			void WfObservingDependency::Add(WfExpression* observe, WfObservingDependency& dependency)
			{
				Prepare(observe);
				FOREACH(WfExpression*, dependedObserve, dependency.inputObserves)
				{
					AddInternal(observe, dependedObserve);
				}
			}

			void WfObservingDependency::TurnToInput()
			{
				if (outputObserves.Count() > 0)
				{
					CopyFrom(inputObserves, outputObserves);
					outputObserves.Clear();
				}
			}

			void WfObservingDependency::Cleanup()
			{
				SortedList<WfExpression*> all;
				CopyFrom(all, From(dependencies.Keys()).Distinct());

				vint count = dependencies.Keys().Count();
				for (vint i = 0; i < count; i++)
				{
					const auto& values = dependencies.GetByIndex(i);
					if (values.Contains(0) && values.Count()>1)
					{
						dependencies.Remove(dependencies.Keys()[i], 0);
					}

					FOREACH(WfExpression*, value, values)
					{
						all.Remove(value);
					}
				}

				FOREACH(WfExpression*, observe, all)
				{
					dependencies.Add(0, observe);
				}
			}

/***********************************************************************
GetObservingDependency
***********************************************************************/

			class GetObservingDependencyVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				WfObservingDependency&				dependency;

				GetObservingDependencyVisitor(WfLexicalScopeManager* _manager, WfObservingDependency& _dependency)
					:manager(_manager)
					, dependency(_dependency)
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
				}

				void Visit(WfMemberExpression* node)override
				{
					WfObservingDependency parent(dependency);
					GetObservingDependency(manager, node->parent, parent);
					parent.TurnToInput();

					if (dependency.inputObserves.Count() == 0)
					{
						auto memberResult = manager->expressionResolvings[node];
						if (memberResult.propertyInfo)
						{
							auto td = memberResult.propertyInfo->GetOwnerTypeDescriptor();
							auto ev = memberResult.propertyInfo->GetValueChangedEvent();
							if (!ev)
							{
								ev = td->GetEventByName(memberResult.propertyInfo->GetName() + L"Changed", true);
							}
							if (ev)
							{
								dependency.Add(node, parent);
							}
						}
					}
				}

				void Visit(WfChildExpression* node)override
				{
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
					GetObservingDependency(manager, node->expandedExpression, dependency);
				}

				void Visit(WfUnaryExpression* node)override
				{
					GetObservingDependency(manager, node->operand, dependency);
				}

				void Visit(WfBinaryExpression* node)override
				{
					GetObservingDependency(manager, node->first, dependency);
					GetObservingDependency(manager, node->second, dependency);
				}

				void Visit(WfLetExpression* node)override
				{
					FOREACH(Ptr<WfLetVariable>, var, node->variables)
					{
						GetObservingDependency(manager, var->value, dependency);
					}
					GetObservingDependency(manager, node->expression, dependency);
				}

				void Visit(WfIfExpression* node)override
				{
					GetObservingDependency(manager, node->condition, dependency);
					GetObservingDependency(manager, node->trueBranch, dependency);
					GetObservingDependency(manager, node->falseBranch, dependency);
				}

				void Visit(WfRangeExpression* node)override
				{
					GetObservingDependency(manager, node->begin, dependency);
					GetObservingDependency(manager, node->end, dependency);
				}

				void Visit(WfSetTestingExpression* node)override
				{
					GetObservingDependency(manager, node->element, dependency);
					GetObservingDependency(manager, node->collection, dependency);
				}

				void Visit(WfConstructorExpression* node)override
				{
					FOREACH(Ptr<WfConstructorArgument>, argument, node->arguments)
					{
						GetObservingDependency(manager, argument->key, dependency);
						if (argument->value)
						{
							GetObservingDependency(manager, argument->value, dependency);
						}
					}
				}

				void Visit(WfInferExpression* node)override
				{
					GetObservingDependency(manager, node->expression, dependency);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					GetObservingDependency(manager, node->expression, dependency);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					GetObservingDependency(manager, node->expression, dependency);
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					GetObservingDependency(manager, node->expression, dependency);
				}

				void Visit(WfAttachEventExpression* node)override
				{
				}

				void Visit(WfDetachEventExpression* node)override
				{
				}

				void Visit(WfBindExpression* node)override
				{
				}

				void Visit(WfObserveExpression* node)override
				{
					WfObservingDependency parent(dependency);
					GetObservingDependency(manager, node->parent, parent);
					parent.TurnToInput();

					dependency.Add(node, parent);
					dependency.TurnToInput();
					GetObservingDependency(manager, node->expression, dependency);
				}

				void Visit(WfCallExpression* node)override
				{
					GetObservingDependency(manager, node->function, dependency);
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						GetObservingDependency(manager, argument, dependency);
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
				}

				void Visit(WfNewTypeExpression* node)override
				{
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						GetObservingDependency(manager, argument, dependency);
					}
				}
			};

			void GetObservingDependency(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, WfObservingDependency& dependency)
			{
				GetObservingDependencyVisitor visitor(manager, dependency);
				expression->Accept(&visitor);
			}

/***********************************************************************
CreateBindVariableReference
***********************************************************************/

			Ptr<WfExpression> CreateBindVariableReference(const WString& name)
			{
				auto ref = MakePtr<WfReferenceExpression>();
				ref->name.value = name;

				auto zero = MakePtr<WfIntegerExpression>();
				zero->value.value = L"0";

				auto index = MakePtr<WfBinaryExpression>();
				index->op = WfBinaryOperator::Index;
				index->first = ref;
				index->second = zero;

				return index;
			}

/***********************************************************************
ExpandObserveExpression
***********************************************************************/

			class ExpandObserveExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				Dictionary<WfExpression*, WString>&		cacheNames;
				Dictionary<WString, WString>&			referenceReplacement;
				Ptr<WfExpression>						result;

				ExpandObserveExpressionVisitor(Dictionary<WfExpression*, WString>& _cacheNames, collections::Dictionary<WString, WString>& _referenceReplacement)
					:cacheNames(_cacheNames)
					, referenceReplacement(_referenceReplacement)
				{
				}

				Ptr<WfExpression> Expand(Ptr<WfExpression> expr)
				{
					return ExpandObserveExpression(expr.Obj(), cacheNames, referenceReplacement);
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					auto expr = MakePtr<WfTopQualifiedExpression>();
					expr->name.value = node->name.value;
					result = expr;
				}

				void Visit(WfReferenceExpression* node)override
				{
					vint index = referenceReplacement.Keys().IndexOf(node->name.value);
					if (index == -1)
					{
						auto expr = MakePtr<WfReferenceExpression>();
						expr->name.value = node->name.value;
						result = expr;
					}
					else
					{
						result = CreateBindVariableReference(referenceReplacement.Values()[index]);
					}
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					auto expr = MakePtr<WfOrderedNameExpression>();
					expr->name.value = node->name.value;
					result = expr;
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					auto expr = MakePtr<WfOrderedLambdaExpression>();
					expr->body = CopyExpression(node->body);
					result = expr;
				}

				void Visit(WfMemberExpression* node)override
				{
					auto expr = MakePtr<WfMemberExpression>();
					expr->parent = Expand(node->parent);
					expr->name.value = node->name.value;
					result = expr;
				}

				void Visit(WfChildExpression* node)override
				{
					auto expr = MakePtr<WfChildExpression>();
					expr->parent = Expand(node->parent);
					expr->name.value = node->name.value;
					result = expr;
				}

				void Visit(WfLiteralExpression* node)override
				{
					auto expr = MakePtr<WfLiteralExpression>();
					expr->value = node->value;
					result = expr;
				}

				void Visit(WfFloatingExpression* node)override
				{
					auto expr = MakePtr<WfFloatingExpression>();
					expr->value.value = node->value.value;
					result = expr;
				}

				void Visit(WfIntegerExpression* node)override
				{
					auto expr = MakePtr<WfIntegerExpression>();
					expr->value.value = node->value.value;
					result = expr;
				}

				void Visit(WfStringExpression* node)override
				{
					auto expr = MakePtr<WfStringExpression>();
					expr->value.value = node->value.value;
					result = expr;
				}

				void Visit(WfFormatExpression* node)override
				{
					auto expr = MakePtr<WfFormatExpression>();
					expr->value.value = node->value.value;
					expr->expandedExpression = Expand(node->expandedExpression);
					result = expr;
				}

				void Visit(WfUnaryExpression* node)override
				{
					auto expr = MakePtr<WfUnaryExpression>();
					expr->op = node->op;
					expr->operand = Expand(node->operand);
					result = expr;
				}

				void Visit(WfBinaryExpression* node)override
				{
					auto expr = MakePtr<WfBinaryExpression>();
					expr->op = node->op;
					expr->first = Expand(node->first);
					expr->second = Expand(node->second);
					result = expr;
				}

				void Visit(WfLetExpression* node)override
				{
					Dictionary<WString, WString> overrided;
					auto expr = MakePtr<WfLetExpression>();

					FOREACH(Ptr<WfLetVariable>, var, node->variables)
					{
						auto key = var->name.value;
						vint index = referenceReplacement.Keys().IndexOf(key);
						if (index != -1)
						{
							auto value = referenceReplacement.Values()[index];
							referenceReplacement.Remove(key);
							overrided.Add(key, value);
						}

						auto newVar = MakePtr<WfLetVariable>();
						newVar->name.value = key;
						newVar->value = Expand(var->value);
						expr->variables.Add(newVar);
					}
					expr->expression = Expand(node->expression);

					CopyFrom(referenceReplacement, overrided, true);
					result = expr;
				}

				void Visit(WfIfExpression* node)override
				{
					auto expr = MakePtr<WfIfExpression>();
					expr->condition = Expand(node->condition);
					expr->trueBranch = Expand(node->trueBranch);
					expr->falseBranch = Expand(node->falseBranch);
					result = expr;
				}

				void Visit(WfRangeExpression* node)override
				{
					auto expr = MakePtr<WfRangeExpression>();
					expr->begin = Expand(node->begin);
					expr->end = Expand(node->end);
					expr->beginBoundary = node->beginBoundary;
					expr->endBoundary = node->endBoundary;
					result = expr;
				}

				void Visit(WfSetTestingExpression* node)override
				{
					auto expr = MakePtr<WfSetTestingExpression>();
					expr->element = Expand(node->element);
					expr->collection = Expand(node->collection);
					result = expr;
				}

				void Visit(WfConstructorExpression* node)override
				{
					auto expr = MakePtr<WfConstructorExpression>();
					FOREACH(Ptr<WfConstructorArgument>, arg, node->arguments)
					{
						auto newArg = MakePtr<WfConstructorArgument>();
						newArg->key = Expand(arg->key);
						newArg->value = Expand(arg->value);
						expr->arguments.Add(newArg);
					}
					result = expr;
				}

				void Visit(WfInferExpression* node)override
				{
					auto expr = MakePtr<WfInferExpression>();
					expr->expression = Expand(node->expression);
					expr->type = CopyType(node->type);
					result = expr;
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					auto expr = MakePtr<WfTypeCastingExpression>();
					expr->expression = Expand(node->expression);
					expr->type = CopyType(node->type);
					expr->strategy = node->strategy;
					result = expr;
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					auto expr = MakePtr<WfTypeTestingExpression>();
					expr->expression = Expand(node->expression);
					expr->type = CopyType(node->type);
					expr->test = node->test;
					result = expr;
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					auto expr = MakePtr<WfTypeOfTypeExpression>();
					expr->type = CopyType(node->type);
					result = expr;
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					auto expr = MakePtr<WfTypeOfExpressionExpression>();
					expr->expression = Expand(node->expression);
					result = expr;
				}

				void Visit(WfAttachEventExpression* node)override
				{
					auto expr = MakePtr<WfAttachEventExpression>();
					expr->event = Expand(node->event);
					expr->function = Expand(node->function);
					result = expr;
				}

				void Visit(WfDetachEventExpression* node)override
				{
					auto expr = MakePtr<WfDetachEventExpression>();
					expr->handler = Expand(node->handler);
					result = expr;
				}

				void Visit(WfBindExpression* node)override
				{
					auto expr = MakePtr<WfBindExpression>();
					expr->expression = CopyExpression(node->expression);
					expr->expandedExpression = CopyExpression(node->expandedExpression);
					result = expr;
				}

				void Visit(WfObserveExpression* node)override
				{
					if (cacheNames.Count() == 0)
					{
						auto expr = MakePtr<WfObserveExpression>();
						expr->parent = CopyExpression(node->parent);
						expr->name.value = node->name.value;
						expr->observeType = node->observeType;
						expr->expression = node->expression;
						FOREACH(Ptr<WfExpression>, ev, node->events)
						{
							expr->events.Add(CopyExpression(ev));
						}
						result = expr;
					}
					else if (node->observeType == WfObserveType::SimpleObserve)
					{
						auto expr = MakePtr<WfMemberExpression>();
						expr->parent = Expand(node->parent);
						expr->name.value = node->expression.Cast<WfReferenceExpression>()->name.value;
						result = expr;
					}
					else
					{
						auto var = MakePtr<WfLetVariable>();
						var->name.value = node->name.value;
						var->value = Expand(node->parent);

						auto expr = MakePtr<WfLetExpression>();
						expr->variables.Add(var);
						expr->expression = Expand(node->expression);
						result = expr;
					}
				}

				void Visit(WfCallExpression* node)override
				{
					auto expr = MakePtr<WfCallExpression>();
					expr->function = Expand(node->function);
					FOREACH(Ptr<WfExpression>, arg, node->arguments)
					{
						expr->arguments.Add(Expand(arg));
					}
					result = expr;
				}

				Ptr<WfFunctionDeclaration> CopyFunction(Ptr<WfFunctionDeclaration> decl)
				{
					auto func = MakePtr<WfFunctionDeclaration>();
					func->name.value = decl->name.value;
					func->anonymity = decl->anonymity;
					func->returnType = CopyType(decl->returnType);
					FOREACH(Ptr<WfFunctionArgument>, arg, decl->arguments)
					{
						auto newArg = MakePtr<WfFunctionArgument>();
						newArg->type = CopyType(arg->type);
						newArg->name.value = arg->name.value;
						func->arguments.Add(newArg);
					}
					func->statement = CopyStatement(decl->statement);
					return func;
				}

				void Visit(WfFunctionExpression* node)override
				{
					auto expr = MakePtr<WfFunctionExpression>();
					expr->function = CopyFunction(node->function);
					result = expr;
				}

				void Visit(WfNewTypeExpression* node)override
				{
					auto expr = MakePtr<WfNewTypeExpression>();
					expr->type = CopyType(node->type);
					FOREACH(Ptr<WfExpression>, arg, node->arguments)
					{
						expr->arguments.Add(Expand(arg));
					}
					FOREACH(Ptr<WfFunctionDeclaration>, decl, node->functions)
					{
						expr->functions.Add(CopyFunction(decl));
					}
					result = expr;
				}
			};

			Ptr<WfExpression> ExpandObserveExpression(WfExpression* expression, collections::Dictionary<WfExpression*, WString>& cacheNames, collections::Dictionary<WString, WString>& referenceReplacement, bool useCache)
			{
				if (expression)
				{
					if (useCache)
					{
						vint index = cacheNames.Keys().IndexOf(expression);
						if (index != -1)
						{
							return CreateBindVariableReference(cacheNames.Values()[index]);
						}
					}

					ExpandObserveExpressionVisitor visitor(cacheNames, referenceReplacement);
					expression->Accept(&visitor);
					return visitor.result;
				}
				else
				{
					return 0;
				}
			}

			Ptr<WfExpression> CopyExpression(Ptr<WfExpression> expression)
			{
				Dictionary<WfExpression*, WString> cacheNames;
				Dictionary<WString, WString> referenceReplacement;
				return ExpandObserveExpression(expression.Obj(), cacheNames, referenceReplacement);
			}

/***********************************************************************
CopyStatement
***********************************************************************/

			class CopyStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				Ptr<WfStatement>						result;

				void Visit(WfBreakStatement* node)override
				{
					auto stat = MakePtr<WfBreakStatement>();
					result = stat;
				}

				void Visit(WfContinueStatement* node)override
				{
					auto stat = MakePtr<WfContinueStatement>();
					result = stat;
				}

				void Visit(WfReturnStatement* node)override
				{
					auto stat = MakePtr<WfReturnStatement>();
					stat->expression = CopyExpression(node->expression);
					result = stat;
				}

				void Visit(WfDeleteStatement* node)override
				{
					auto stat = MakePtr<WfDeleteStatement>();
					stat->expression = CopyExpression(node->expression);
					result = stat;
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					auto stat = MakePtr<WfRaiseExceptionStatement>();
					stat->expression = CopyExpression(node->expression);
					result = stat;
				}

				void Visit(WfIfStatement* node)override
				{
					auto stat = MakePtr<WfIfStatement>();
					stat->name.value = node->name.value;
					stat->type = CopyType(node->type);
					stat->expression = CopyExpression(node->expression);
					stat->trueBranch = CopyStatement(node->trueBranch);
					stat->falseBranch = CopyStatement(node->falseBranch);
					result = stat;
				}

				void Visit(WfSwitchStatement* node)override
				{
					auto stat = MakePtr<WfSwitchStatement>();
					stat->expression = CopyExpression(node->expression);
					stat->defaultBranch = CopyStatement(node->defaultBranch);
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						auto newCase = MakePtr<WfSwitchCase>();
						newCase->expression = CopyExpression(switchCase->expression);
						newCase->statement = CopyStatement(switchCase->statement);
						stat->caseBranches.Add(newCase);
					}
					result = stat;
				}

				void Visit(WfWhileStatement* node)override
				{
					auto stat = MakePtr<WfWhileStatement>();
					stat->condition = CopyExpression(node->condition);
					stat->statement = CopyStatement(node->statement);
					result = stat;
				}

				void Visit(WfForEachStatement* node)override
				{
					auto stat = MakePtr<WfForEachStatement>();
					stat->name.value = node->name.value;
					stat->direction = node->direction;
					stat->collection = CopyExpression(node->collection);
					stat->statement = CopyStatement(node->statement);
					result = stat;
				}

				void Visit(WfTryStatement* node)override
				{
					auto stat = MakePtr<WfTryStatement>();
					stat->name.value = node->name.value;
					stat->protectedStatement = CopyStatement(node->protectedStatement);
					stat->catchStatement = CopyStatement(node->catchStatement);
					stat->finallyStatement = CopyStatement(node->finallyStatement);
					result = stat;
				}

				void Visit(WfBlockStatement* node)override
				{
					auto stat = MakePtr<WfBlockStatement>();
					result = stat;
				}

				void Visit(WfExpressionStatement* node)override
				{
					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = CopyExpression(node->expression);
					result = stat;
				}

				void Visit(WfVariableStatement* node)override
				{
					auto var = MakePtr<WfVariableDeclaration>();
					var->name.value = node->variable->name.value;
					var->type = CopyType(node->variable->type);
					var->expression = CopyExpression(node->variable->expression);

					auto stat = MakePtr<WfVariableStatement>();
					stat->variable = var;
					result = stat;
				}

			};

			Ptr<WfStatement> CopyStatement(Ptr<WfStatement> statement)
			{
				CopyStatementVisitor visitor;
				statement->Accept(&visitor);
				return visitor.result;
			}

/***********************************************************************
DecodeObserveExpression
***********************************************************************/

			void DecodeObserveExpression(WfLexicalScopeManager* manager, WfExpression* observe, List<IEventInfo*>& events, WfExpression*& parent)
			{
				if (auto observeExpr = dynamic_cast<WfObserveExpression*>(observe))
				{
					parent = observeExpr->parent.Obj();
					FOREACH(Ptr<WfExpression>, eventExpr, observeExpr->events)
					{
						auto result = manager->expressionResolvings[eventExpr.Obj()];
						events.Add(result.eventInfo);
					}
				}
				else if (auto memberExpr = dynamic_cast<WfMemberExpression*>(observe))
				{
					parent = memberExpr->parent.Obj();
					auto result = manager->expressionResolvings[memberExpr];
					auto td = result.propertyInfo->GetOwnerTypeDescriptor();
					auto ev = result.propertyInfo->GetValueChangedEvent();
					if (!ev)
					{
						ev = td->GetEventByName(result.propertyInfo->GetName() + L"Changed", true);
					}
					events.Add(ev);
				}
			}

/***********************************************************************
CreateBindDefaultValue
***********************************************************************/

			Ptr<WfExpression> CreateBindDefaultValue(ITypeInfo* elementType)
			{
				if (elementType->GetTypeDescriptor()->GetValueSerializer())
				{
					auto stringExpr = MakePtr<WfStringExpression>();
					stringExpr->value.value = elementType->GetTypeDescriptor()->GetValueSerializer()->GetDefaultText();

					auto castExpr = MakePtr<WfTypeCastingExpression>();
					castExpr->strategy = WfTypeCastingStrategy::Strong;
					castExpr->expression = stringExpr;
					castExpr->type = GetTypeFromTypeInfo(elementType);

					return castExpr;
				}
				else
				{
					auto nullExpr = MakePtr<WfLiteralExpression>();
					nullExpr->value = WfLiteralValue::Null;

					auto inferExpr = MakePtr<WfInferExpression>();
					inferExpr->expression = nullExpr;
					inferExpr->type = GetTypeFromTypeInfo(elementType);

					return inferExpr;
				}
			}

/***********************************************************************
CreateBindWritableVariable
***********************************************************************/

			Ptr<WfVariableStatement> CreateBindWritableVariable(const WString& name, ITypeInfo* elementType)
			{
				auto ctorArg = MakePtr<WfConstructorArgument>();
				ctorArg->key = CreateBindDefaultValue(elementType);
				
				auto ctorExpr = MakePtr<WfConstructorExpression>();
				ctorExpr->arguments.Add(ctorArg);

				auto variable = MakePtr<WfVariableDeclaration>();
				variable->name.value = name;
				variable->expression = ctorExpr;
					
				auto variableStat = MakePtr<WfVariableStatement>();
				variableStat->variable = variable;
				return variableStat;
			}

/***********************************************************************
IValueListener::GetSubscription
***********************************************************************/

			Ptr<WfFunctionDeclaration> CreateListenerGetSubscriptionFunction()
			{
				auto func = MakePtr<WfFunctionDeclaration>();
				func->name.value = L"GetSubscription";
				func->anonymity = WfFunctionAnonymity::Named;
				{
					auto typeInfo = TypeInfoRetriver<IValueSubscription*>::CreateTypeInfo();
					func->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
				}

				auto block = MakePtr<WfBlockStatement>();
				func->statement = block;
				{
					auto returnStat = MakePtr<WfReturnStatement>();
					returnStat->expression =  CreateBindVariableReference(L"<subscription>");
					block->statements.Add(returnStat);
				}
				return func;
			}

/***********************************************************************
IValueListener::GetStopped
***********************************************************************/

			Ptr<WfFunctionDeclaration> CreateListenerGetStoppedFunction()
			{
				auto func = MakePtr<WfFunctionDeclaration>();
				func->name.value = L"GetStopped";
				func->anonymity = WfFunctionAnonymity::Named;
				{
					auto typeInfo = TypeInfoRetriver<bool>::CreateTypeInfo();
					func->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
				}

				auto block = MakePtr<WfBlockStatement>();
				func->statement = block;
				{
					auto listenersRef = MakePtr<WfReferenceExpression>();
					listenersRef->name.value = L"<bind-listeners>";

					auto keysExpr = MakePtr<WfMemberExpression>();
					keysExpr->parent = listenersRef;
					keysExpr->name.value = L"Keys";

					auto containsExpr = MakePtr<WfMemberExpression>();
					containsExpr->parent = keysExpr;
					containsExpr->name.value = L"Contains";

					auto callExpr = MakePtr<WfCallExpression>();
					callExpr->function = containsExpr;
					callExpr->arguments.Add(CreateBindVariableReference(L"<listener>"));

					auto notExpr = MakePtr<WfUnaryExpression>();
					notExpr->op = WfUnaryOperator::Not;
					notExpr->operand = callExpr;

					auto returnStat = MakePtr<WfReturnStatement>();
					returnStat->expression = notExpr;
					block->statements.Add(returnStat);
				}
				return func;
			}

/***********************************************************************
IValueListener::StopListening
***********************************************************************/

			Ptr<WfFunctionDeclaration> CreateListenerStopListeningFunction()
			{
				auto func = MakePtr<WfFunctionDeclaration>();
				func->name.value = L"StopListening";
				func->anonymity = WfFunctionAnonymity::Named;
				{
					auto typeInfo = TypeInfoRetriver<bool>::CreateTypeInfo();
					func->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
				}

				auto block = MakePtr<WfBlockStatement>();
				func->statement = block;
				{
					auto ifStat = MakePtr<WfIfStatement>();
					block->statements.Add(ifStat);
					{
						auto listenersRef = MakePtr<WfReferenceExpression>();
						listenersRef->name.value = L"<bind-listeners>";

						auto keysExpr = MakePtr<WfMemberExpression>();
						keysExpr->parent = listenersRef;
						keysExpr->name.value = L"Keys";

						auto containsExpr = MakePtr<WfMemberExpression>();
						containsExpr->parent = keysExpr;
						containsExpr->name.value = L"Contains";

						auto callExpr = MakePtr<WfCallExpression>();
						callExpr->function = containsExpr;
						callExpr->arguments.Add(CreateBindVariableReference(L"<listener>"));
						ifStat->expression = callExpr;
					}

					auto ifBlock = MakePtr<WfBlockStatement>();
					ifStat->trueBranch = ifBlock;
					{
						auto listenersRef = MakePtr<WfReferenceExpression>();
						listenersRef->name.value = L"<bind-listeners>";

						auto removeExpr = MakePtr<WfMemberExpression>();
						removeExpr->parent = listenersRef;
						removeExpr->name.value = L"Remove";

						auto callExpr = MakePtr<WfCallExpression>();
						callExpr->function = removeExpr;
						callExpr->arguments.Add(CreateBindVariableReference(L"<listener>"));

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = callExpr;
						ifBlock->statements.Add(stat);
					}
					{
						auto literal = MakePtr<WfLiteralExpression>();
						literal->value = WfLiteralValue::True;

						auto returnStat = MakePtr<WfReturnStatement>();
						returnStat->expression = literal;
						ifBlock->statements.Add(returnStat);
					}
				}
				{
					auto literal = MakePtr<WfLiteralExpression>();
					literal->value = WfLiteralValue::False;

					auto returnStat = MakePtr<WfReturnStatement>();
					returnStat->expression = literal;
					block->statements.Add(returnStat);
				}
				return func;
			}

/***********************************************************************
IValueSubscription::Subscribe
***********************************************************************/

			Ptr<WfFunctionDeclaration> CreateBindSubscribeFunction()
			{
				auto func = MakePtr<WfFunctionDeclaration>();
				func->name.value = L"Subscribe";
				func->anonymity = WfFunctionAnonymity::Named;
				{
					auto typeInfo = TypeInfoRetriver<Ptr<IValueListener>>::CreateTypeInfo();
					func->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
				}
				{
					auto typeInfo = TypeInfoRetriver<Func<void(Value)>>::CreateTypeInfo();
					auto argument = MakePtr<WfFunctionArgument>();
					argument->name.value = L"<bind-callback>";
					argument->type = GetTypeFromTypeInfo(typeInfo.Obj());
					func->arguments.Add(argument);
				}

				auto block = MakePtr<WfBlockStatement>();
				func->statement = block;
				block->statements.Add(CreateBindWritableVariable(L"<listener>", TypeInfoRetriver<IValueListener*>::CreateTypeInfo().Obj()));
				{
					auto newListener = MakePtr<WfNewTypeExpression>();
					{
						auto typeInfo = TypeInfoRetriver<Ptr<IValueListener>>::CreateTypeInfo();
						newListener->type = GetTypeFromTypeInfo(typeInfo.Obj());
					}
					newListener->functions.Add(CreateListenerGetSubscriptionFunction());
					newListener->functions.Add(CreateListenerGetStoppedFunction());
					newListener->functions.Add(CreateListenerStopListeningFunction());

					auto variable = MakePtr<WfVariableDeclaration>();
					variable->name.value = L"<listener-shared>";
					variable->expression = newListener;
					
					auto variableStat = MakePtr<WfVariableStatement>();
					variableStat->variable = variable;
					block->statements.Add(variableStat);
				}
				{
					auto listenerRef = MakePtr<WfReferenceExpression>();
					listenerRef->name.value = L"<listener-shared>";

					auto castExpr = MakePtr<WfTypeCastingExpression>();
					castExpr->strategy = WfTypeCastingStrategy::Strong;
					castExpr->expression = listenerRef;
					castExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<IValueListener*>::CreateTypeInfo().Obj());

					auto assign = MakePtr<WfBinaryExpression>();
					assign->op = WfBinaryOperator::Assign;
					assign->first = CreateBindVariableReference(L"<listener>");
					assign->second = castExpr;

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = assign;
					block->statements.Add(stat);
				}
				{
					auto callbackRef = MakePtr<WfReferenceExpression>();
					callbackRef->name.value = L"<bind-callback>";

					auto mapRef = MakePtr<WfReferenceExpression>();
					mapRef->name.value = L"<bind-listeners>";

					auto func = MakePtr<WfMemberExpression>();
					func->parent = mapRef;
					func->name.value = L"Set";

					auto call = MakePtr<WfCallExpression>();
					call->function = func;
					call->arguments.Add(CreateBindVariableReference(L"<listener>"));
					call->arguments.Add(callbackRef);

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = call;
					block->statements.Add(stat);
				}
				{
					auto listenerRef = MakePtr<WfReferenceExpression>();
					listenerRef->name.value = L"<listener-shared>";

					auto returnStat = MakePtr<WfReturnStatement>();
					returnStat->expression = listenerRef;
					block->statements.Add(returnStat);
				}
				return func;
			}

/***********************************************************************
ExpandObserveEvent
***********************************************************************/

			Ptr<WfExpression> ExpandObserveEvent(WfLexicalScopeManager* manager, const WString& cacheName, WfExpression* observe, vint eventIndex)
			{
				if (auto observeExpr = dynamic_cast<WfObserveExpression*>(observe))
				{
					if (observeExpr->observeType == WfObserveType::SimpleObserve)
					{
						auto expr = MakePtr<WfMemberExpression>();
						expr->parent = CreateBindVariableReference(cacheName);
						expr->name.value = observeExpr->events[eventIndex].Cast<WfReferenceExpression>()->name.value;
						return expr;
					}
					else
					{
						Dictionary<WfExpression*, WString> cacheNames;
						Dictionary<WString, WString> referenceReplacement;
						referenceReplacement.Add(observeExpr->name.value, cacheName);
						return ExpandObserveExpression(observeExpr->events[eventIndex].Obj(), cacheNames, referenceReplacement);
					}
				}
				else
				{
					auto memberExpr = dynamic_cast<WfMemberExpression*>(observe);
					auto result = manager->expressionResolvings[memberExpr];
					auto td = result.propertyInfo->GetOwnerTypeDescriptor();
					auto ev = result.propertyInfo->GetValueChangedEvent();
					if (!ev)
					{
						ev = td->GetEventByName(result.propertyInfo->GetName() + L"Changed", true);
					}
					auto eventName = ev->GetName();

					auto expr = MakePtr<WfMemberExpression>();
					expr->parent = CreateBindVariableReference(cacheName);
					expr->name.value = eventName;

					return expr;
				}
			}

/***********************************************************************
CreateBindAttachStatement
***********************************************************************/

			void CreateBindAttachStatement(Ptr<WfBlockStatement> block, WfLexicalScopeManager* manager, WfExpression* observe, const WString& cachedName, Group<WfExpression*, WString>& callbackNames, Group<WfExpression*, WString>& handlerNames)
			{
				vint index = callbackNames.Keys().IndexOf(observe);
				FOREACH_INDEXER(WString, callbackName, eventIndex, callbackNames.GetByIndex(index))
				{
					auto attach = MakePtr<WfAttachEventExpression>();
					attach->event = ExpandObserveEvent(manager, cachedName, observe, eventIndex);
					attach->function = CreateBindVariableReference(callbackName);

					auto assign = MakePtr<WfBinaryExpression>();
					assign->op = WfBinaryOperator::Assign;
					assign->first = CreateBindVariableReference(handlerNames.GetByIndex(index)[eventIndex]);
					assign->second = attach;

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = assign;
					block->statements.Add(stat);
				}
			}

/***********************************************************************
CreateBindDetachStatement
***********************************************************************/

			void CreateBindDetachStatement(Ptr<WfBlockStatement> block, WfExpression* observe, Group<WfExpression*, WString>& handlerNames)
			{
				vint index = handlerNames.Keys().IndexOf(observe);
				FOREACH(WString, name, handlerNames.GetByIndex(index))
				{
					auto detach = MakePtr<WfDetachEventExpression>();
					detach->handler = CreateBindVariableReference(name);

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = detach;
					block->statements.Add(stat);
				}
			}

/***********************************************************************
CreateBindCacheAssignStatement
***********************************************************************/

			void CreateBindCacheAssignStatement(Ptr<WfBlockStatement> block, WfExpression* parent, Dictionary<WfExpression*, WString>& cacheNames)
			{
				auto name = cacheNames[parent];

				auto assign = MakePtr<WfBinaryExpression>();
				assign->op = WfBinaryOperator::Assign;
				assign->first = CreateBindVariableReference(name);
				Dictionary<WString, WString> referenceReplacement;
				assign->second = ExpandObserveExpression(parent, cacheNames, referenceReplacement, false);

				auto stat = MakePtr<WfExpressionStatement>();
				stat->expression = assign;
				block->statements.Add(stat);
			}

/***********************************************************************
IValueSubscription::Update
***********************************************************************/

			Ptr<WfFunctionDeclaration> CreateBindUpdateFunction(const Dictionary<WString, Ptr<ITypeInfo>>& variableTypes, Group<WfExpression*, WString>& handlerNames)
			{
				auto func = MakePtr<WfFunctionDeclaration>();
				func->name.value = L"Update";
				func->anonymity = WfFunctionAnonymity::Named;
				{
					auto typeInfo = TypeInfoRetriver<bool>::CreateTypeInfo();
					func->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
				}

				auto block = MakePtr<WfBlockStatement>();
				func->statement = block;
				{
					auto ifStat = MakePtr<WfIfStatement>();
					block->statements.Add(ifStat);
					{
						auto notExpr = MakePtr<WfUnaryExpression>();
						notExpr->op = WfUnaryOperator::Not;
						notExpr->operand = CreateBindVariableReference(L"<bind-closed>");
						ifStat->expression = notExpr;
					}

					auto ifBlock = MakePtr<WfBlockStatement>();
					ifStat->trueBranch = ifBlock;
					{
						auto ref = MakePtr<WfReferenceExpression>();
						ref->name.value = L"<bind-activator>";

						auto call = MakePtr<WfCallExpression>();
						call->function = ref;

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = call;
						ifBlock->statements.Add(stat);
					}
					{
						auto literal = MakePtr<WfLiteralExpression>();
						literal->value = WfLiteralValue::True;

						auto returnStat = MakePtr<WfReturnStatement>();
						returnStat->expression = literal;
						ifBlock->statements.Add(returnStat);
					}
				}
				{
					auto literal = MakePtr<WfLiteralExpression>();
					literal->value = WfLiteralValue::False;

					auto returnStat = MakePtr<WfReturnStatement>();
					returnStat->expression = literal;
					block->statements.Add(returnStat);
				}

				return func;
			}

/***********************************************************************
IValueSubscription::Close
***********************************************************************/

			Ptr<WfFunctionDeclaration> CreateBindCloseFunction(const Dictionary<WString, Ptr<ITypeInfo>>& variableTypes, Group<WfExpression*, WString>& handlerNames)
			{
				auto func = MakePtr<WfFunctionDeclaration>();
				func->name.value = L"Close";
				func->anonymity = WfFunctionAnonymity::Named;
				{
					auto typeInfo = TypeInfoRetriver<bool>::CreateTypeInfo();
					func->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
				}

				auto block = MakePtr<WfBlockStatement>();
				func->statement = block;
				{
					auto ifStat = MakePtr<WfIfStatement>();
					block->statements.Add(ifStat);
					{
						auto notExpr = MakePtr<WfUnaryExpression>();
						notExpr->op = WfUnaryOperator::Not;
						notExpr->operand = CreateBindVariableReference(L"<bind-closed>");
						ifStat->expression = notExpr;
					}

					auto ifBlock = MakePtr<WfBlockStatement>();
					ifStat->trueBranch = ifBlock;
					{
						auto literal = MakePtr<WfLiteralExpression>();
						literal->value = WfLiteralValue::True;

						auto assign = MakePtr<WfBinaryExpression>();
						assign->op = WfBinaryOperator::Assign;
						assign->first = CreateBindVariableReference(L"<bind-closed>");
						assign->second = literal;

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = assign;
						ifBlock->statements.Add(stat);
					}
					FOREACH_INDEXER(WfExpression*, observe, index, handlerNames.Keys())
					{
						CreateBindDetachStatement(ifBlock, observe, handlerNames);
					}
					FOREACH_INDEXER(WString, name, index, variableTypes.Keys())
					{
						auto assign = MakePtr<WfBinaryExpression>();
						assign->op = WfBinaryOperator::Assign;
						assign->first = CreateBindVariableReference(name);
						assign->second = CreateBindDefaultValue(variableTypes.Values()[index].Obj());

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = assign;
						ifBlock->statements.Add(stat);
					}
					{
						auto ref = MakePtr<WfReferenceExpression>();
						ref->name.value = L"<bind-listeners>";

						auto func = MakePtr<WfMemberExpression>();
						func->parent = ref;
						func->name.value = L"Clear";

						auto call = MakePtr<WfCallExpression>();
						call->function = func;

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = call;
						ifBlock->statements.Add(stat);
					}
					{
						auto literal = MakePtr<WfLiteralExpression>();
						literal->value = WfLiteralValue::True;

						auto returnStat = MakePtr<WfReturnStatement>();
						returnStat->expression = literal;
						ifBlock->statements.Add(returnStat);
					}
				}
				{
					auto literal = MakePtr<WfLiteralExpression>();
					literal->value = WfLiteralValue::False;

					auto returnStat = MakePtr<WfReturnStatement>();
					returnStat->expression = literal;
					block->statements.Add(returnStat);
				}

				return func;
			}

/***********************************************************************
ExpandBindExpression
***********************************************************************/

			void ExpandBindExpression(WfLexicalScopeManager* manager, WfBindExpression* node)
			{
				Group<WfExpression*, WfExpression*> group;
				WfObservingDependency dependency(group);
				GetObservingDependency(manager, node->expression, dependency);
				dependency.Cleanup();

				auto lambdaBlock = MakePtr<WfBlockStatement>();
				{
					auto lambda = MakePtr<WfFunctionDeclaration>();
					lambda->anonymity = WfFunctionAnonymity::Anonymous;
					auto typeInfo = TypeInfoRetriver<Ptr<IValueSubscription>>::CreateTypeInfo();
					lambda->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
					lambda->statement = lambdaBlock;

					auto callLambda = MakePtr<WfCallExpression>();
					node->expandedExpression = callLambda;

					auto lambdaExpr = MakePtr<WfFunctionExpression>();
					lambdaExpr->function = lambda;
					callLambda->function = lambdaExpr;
				}

				Dictionary<WfExpression*, WfExpression*> observeParents;
				Dictionary<WfExpression*, WString> cacheNames;
				Group<WfExpression*, WString> handlerNames, callbackNames;
				Dictionary<WString, Ptr<ITypeInfo>> variableTypes;

				FOREACH_INDEXER(WfExpression*, observe, observeIndex, dependency.dependencies.Keys())
				{
					if (!observe) continue;
					List<IEventInfo*> events;
					WfExpression* parent = 0;
					DecodeObserveExpression(manager, observe, events, parent);

					WString cacheName = L"<bind-cache>" + itow(observeIndex);
					cacheNames.Add(parent, cacheName);
					observeParents.Add(observe, parent);
					{
						auto elementType = manager->expressionResolvings[parent].type;
						variableTypes.Add(cacheName, elementType);
						lambdaBlock->statements.Add(CreateBindWritableVariable(cacheName, elementType.Obj()));
					}

					FOREACH_INDEXER(IEventInfo*, ev, eventIndex, events)
					{
						WString handlerName = L"<bind-handler>" + itow(observeIndex) + L"_" + itow(eventIndex);
						{
							handlerNames.Add(observe, handlerName);
							auto elementType = TypeInfoRetriver<Ptr<IEventHandler>>::CreateTypeInfo();
							variableTypes.Add(handlerName, elementType);
							lambdaBlock->statements.Add(CreateBindWritableVariable(handlerName, elementType.Obj()));
						}
						
						WString callbackName = L"<bind-callback>" + itow(observeIndex) + L"_" + itow(eventIndex);
						{
							callbackNames.Add(observe, callbackName);
							auto elementType = CopyTypeInfo(ev->GetHandlerType());
							variableTypes.Add(callbackName, elementType);
							lambdaBlock->statements.Add(CreateBindWritableVariable(callbackName, elementType.Obj()));
						}
					}
				}

				lambdaBlock->statements.Add(CreateBindWritableVariable(L"<bind-closed>", TypeInfoRetriver<bool>::CreateTypeInfo().Obj()));
				{
					auto typeInfo = TypeInfoRetriver<Dictionary<IValueListener*, Func<void(Value)>>>::CreateTypeInfo();
					auto variable = MakePtr<WfVariableDeclaration>();
					variable->name.value = L"<bind-listeners>";
					variable->type = GetTypeFromTypeInfo(typeInfo.Obj());
					variable->expression = MakePtr<WfConstructorExpression>();

					auto variableStat = MakePtr<WfVariableStatement>();
					variableStat->variable = variable;
					lambdaBlock->statements.Add(variableStat);
				}
				lambdaBlock->statements.Add(CreateBindWritableVariable(L"<subscription>", TypeInfoRetriver<IValueSubscription*>::CreateTypeInfo().Obj()));

				{
					Group<WfExpression*, WfExpression*> dependencies;
					FOREACH_INDEXER(WfExpression*, key, index, dependency.dependencies.Keys())
					{
						FOREACH(WfExpression*, value, dependency.dependencies.GetByIndex(index))
						{
							if (value)
							{
								dependencies.Add(value, key);
							}
						}
					}
					
					List<WfExpression*> sorted, all;
					CopyFrom(all, dependency.dependencies.Keys());
					all.Remove(0);
					sorted.Add(0);
					for (vint i = 0; i < sorted.Count(); i++)
					{
						auto observe = sorted[i];
						for (vint j = dependencies.Count() - 1; j >= 0; j--)
						{
							auto key = dependencies.Keys()[j];
							if (From(dependencies.GetByIndex(j))
								.All([&all](WfExpression* value){return !all.Contains(value); })
								)
							{
								all.Remove(key);
								dependencies.Remove(key);
								sorted.Add(key);
							}
						}
					}
					sorted.Remove(0);

					FOREACH(WfExpression*, observe, sorted)
					{
						auto parent = observeParents[observe];
						CreateBindCacheAssignStatement(lambdaBlock, parent, cacheNames);
					}
				}
				{
					auto func = MakePtr<WfFunctionDeclaration>();
					func->anonymity = WfFunctionAnonymity::Anonymous;
					func->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());
					
					auto block = MakePtr<WfBlockStatement>();
					func->statement = block;
					{
						auto var = MakePtr<WfVariableDeclaration>();
						var->name.value = L"<bind-activator-result>";
						Dictionary<WString, WString> referenceReplacement;
						var->expression = ExpandObserveExpression(node->expression.Obj(), cacheNames, referenceReplacement);

						auto varStat = MakePtr<WfVariableStatement>();
						varStat->variable = var;
						block->statements.Add(varStat);
					}
					{
						auto ref = MakePtr<WfReferenceExpression>();
						ref->name.value = L"<bind-listeners>";

						auto values = MakePtr<WfMemberExpression>();
						values->parent = ref;
						values->name.value = L"Values";

						auto forStat = MakePtr<WfForEachStatement>();
						block->statements.Add(forStat);
						forStat->name.value = L"<bind-callback>";
						forStat->collection = values;
						forStat->direction = WfForEachDirection::Normal;

						auto forBlock = MakePtr<WfBlockStatement>();
						forStat->statement = forBlock;

						auto refResult = MakePtr<WfReferenceExpression>();
						refResult->name.value = L"<bind-activator-result>";

						auto refFunction = MakePtr<WfReferenceExpression>();
						refFunction->name.value = L"<bind-callback>";

						auto cast = MakePtr<WfTypeCastingExpression>();
						cast->expression = refFunction;
						cast->type = GetTypeFromTypeInfo(TypeInfoRetriver<Func<void(Value)>>::CreateTypeInfo().Obj());
						cast->strategy = WfTypeCastingStrategy::Strong;

						auto call = MakePtr<WfCallExpression>();
						call->function = cast;
						call->arguments.Add(refResult);

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = call;
						forBlock->statements.Add(stat);
					}
					
					auto funcExpr = MakePtr<WfFunctionExpression>();
					funcExpr->function = func;

					auto var = MakePtr<WfVariableDeclaration>();
					var->name.value = L"<bind-activator>";
					var->expression = funcExpr;

					auto varStat = MakePtr<WfVariableStatement>();
					varStat->variable = var;
					lambdaBlock->statements.Add(varStat);
				}
				FOREACH_INDEXER(WfExpression*, observe, index, callbackNames.Keys())
				{
					FOREACH_INDEXER(WString, callbackName, eventIndex, callbackNames.GetByIndex(index))
					{
						auto func = MakePtr<WfFunctionDeclaration>();
						func->anonymity = WfFunctionAnonymity::Anonymous;
						{
							auto genericType = variableTypes[callbackName]->GetElementType();
							func->returnType = GetTypeFromTypeInfo(genericType->GetGenericArgument(0));
							vint count = genericType->GetGenericArgumentCount();
							for (vint i = 1; i < count; i++)
							{
								auto arg = MakePtr<WfFunctionArgument>();
								arg->name.value = L"<bind-callback-argument>" + itow(i - 1);
								arg->type = GetTypeFromTypeInfo(genericType->GetGenericArgument(i));
								func->arguments.Add(arg);
							}
						}
						auto block = MakePtr<WfBlockStatement>();
						func->statement = block;
						{
							List<WfExpression*> affected;
							affected.Add(observe);
							for (vint i = 0; i < affected.Count(); i++)
							{
								auto current = affected[i];
								vint dependencyIndex = dependency.dependencies.Keys().IndexOf(current);
								if (dependencyIndex != -1)
								{
									FOREACH(WfExpression*, affectedObserve, dependency.dependencies.GetByIndex(dependencyIndex))
									{
										if (affectedObserve && !affected.Contains(affectedObserve))
										{
											affected.Add(affectedObserve);
										}
									}
								}
							}
							affected.Remove(observe);

							FOREACH(WfExpression*, affectedObserve, From(affected).Reverse())
							{
								CreateBindDetachStatement(block, affectedObserve, handlerNames);
							}
							FOREACH(WfExpression*, affectedObserve, affected)
							{
								auto parent = observeParents[affectedObserve];
								CreateBindCacheAssignStatement(block, parent, cacheNames);
							}
							FOREACH(WfExpression*, affectedObserve, affected)
							{
								WString cachedName = cacheNames[observeParents[affectedObserve]];
								CreateBindAttachStatement(block, manager, affectedObserve, cachedName, callbackNames, handlerNames);
							}
						}
						{
							auto ref = MakePtr<WfReferenceExpression>();
							ref->name.value = L"<bind-activator>";

							auto call = MakePtr<WfCallExpression>();
							call->function = ref;

							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = call;
							block->statements.Add(stat);
						}

						auto funcExpr = MakePtr<WfFunctionExpression>();
						funcExpr->function = func;

						auto assign = MakePtr<WfBinaryExpression>();
						assign->op = WfBinaryOperator::Assign;
						assign->first = CreateBindVariableReference(callbackName);
						assign->second = funcExpr;

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = assign;
						lambdaBlock->statements.Add(stat);
					}
				}
				FOREACH_INDEXER(WfExpression*, observe, index, callbackNames.Keys())
				{
					WString cachedName = cacheNames[observeParents[observe]];
					CreateBindAttachStatement(lambdaBlock, manager, observe, cachedName, callbackNames, handlerNames);
				}
						
				auto newSubscription = MakePtr<WfNewTypeExpression>();
				{
					auto typeInfo = TypeInfoRetriver<Ptr<IValueSubscription>>::CreateTypeInfo();
					newSubscription->type = GetTypeFromTypeInfo(typeInfo.Obj());
				}
				newSubscription->functions.Add(CreateBindSubscribeFunction());
				newSubscription->functions.Add(CreateBindUpdateFunction(variableTypes, handlerNames));
				newSubscription->functions.Add(CreateBindCloseFunction(variableTypes, handlerNames));

				{
					auto variable = MakePtr<WfVariableDeclaration>();
					variable->name.value = L"<subscription-shared>";
					variable->expression = newSubscription;
					
					auto variableStat = MakePtr<WfVariableStatement>();
					variableStat->variable = variable;
					lambdaBlock->statements.Add(variableStat);
				}
				{
					auto subscriptionRef = MakePtr<WfReferenceExpression>();
					subscriptionRef->name.value = L"<subscription-shared>";

					auto castExpr = MakePtr<WfTypeCastingExpression>();
					castExpr->strategy = WfTypeCastingStrategy::Strong;
					castExpr->expression = subscriptionRef;
					castExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<IValueSubscription*>::CreateTypeInfo().Obj());

					auto assign = MakePtr<WfBinaryExpression>();
					assign->op = WfBinaryOperator::Assign;
					assign->first = CreateBindVariableReference(L"<subscription>");
					assign->second = castExpr;

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = assign;
					lambdaBlock->statements.Add(stat);
				}
				{
					auto subscriptionRef = MakePtr<WfReferenceExpression>();
					subscriptionRef->name.value = L"<subscription-shared>";

					auto returnStat = MakePtr<WfReturnStatement>();
					returnStat->expression = subscriptionRef;
					lambdaBlock->statements.Add(returnStat);
				}
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_GENERATEDECLARATION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;
			using namespace runtime;
			using namespace typeimpl;

			typedef WfInstruction Ins;

#define INSTRUCTION(X) context.AddInstruction(node, X)

/***********************************************************************
GenerateInstructions(Initialize)
***********************************************************************/

			class GenerateInitializeInstructionsVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateInitializeInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					FOREACH(Ptr<WfDeclaration>, decl, node->declarations)
					{
						GenerateInitializeInstructions(context, decl);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto scope = context.manager->declarationScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					vint variableIndex = context.globalVariables[symbol.Obj()];
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::StoreGlobalVar(variableIndex));
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
				}
			};

			void GenerateInitializeInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration)
			{
				GenerateInitializeInstructionsVisitor visitor(context);
				declaration->Accept(&visitor);
			}

/***********************************************************************
GenerateInstructions(Declaration)
***********************************************************************/

			Ptr<WfCodegenFunctionContext> GenerateFunctionInstructions_Prolog(WfCodegenContext& context, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<ITypeInfo> returnType, Ptr<WfLexicalSymbol> recursiveLambdaSymbol, const List<Ptr<WfLexicalSymbol>>& argumentSymbols, const List<Ptr<WfLexicalSymbol>>& capturedSymbols, ParsingTreeCustomBase* node)
			{
				auto functionContext = MakePtr<WfCodegenFunctionContext>();
				functionContext->function = meta;
				context.functionContext = functionContext;
				{
					FOREACH_INDEXER(Ptr<WfLexicalSymbol>, argumentSymbol, index, argumentSymbols)
					{
						functionContext->arguments.Add(argumentSymbol.Obj(), index);
					}
					FOREACH_INDEXER(Ptr<WfLexicalSymbol>, capturedSymbol, index, capturedSymbols)
					{
						functionContext->capturedVariables.Add(capturedSymbol.Obj(), index);
					}
				}
				if (recursiveLambdaSymbol)
				{
					vint variableIndex = meta->argumentNames.Count() + meta->localVariableNames.Add(L"<recursive-lambda>" + recursiveLambdaSymbol->name);
					functionContext->localVariables.Add(recursiveLambdaSymbol.Obj(), variableIndex);
				}
					
				meta->firstInstruction = context.assembly->instructions.Count();
				if (recursiveLambdaSymbol)
				{
					for (vint i = 0; i < functionContext->capturedVariables.Count(); i++)
					{
						INSTRUCTION(Ins::LoadCapturedVar(i));
					}
					INSTRUCTION(Ins::LoadClosure(context.assembly->functions.IndexOf(meta.Obj()), functionContext->capturedVariables.Count()));
					INSTRUCTION(Ins::StoreLocalVar(functionContext->localVariables[recursiveLambdaSymbol.Obj()]));
				}
				return functionContext;
			}

			void GenerateFunctionInstructions_Epilog(WfCodegenContext& context, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<ITypeInfo> returnType, Ptr<WfLexicalSymbol> recursiveLambdaSymbol, const List<Ptr<WfLexicalSymbol>>& argumentSymbols, const List<Ptr<WfLexicalSymbol>>& capturedSymbols, Ptr<WfCodegenFunctionContext> functionContext, ParsingTreeCustomBase* node)
			{
				if (returnType->GetDecorator() == ITypeInfo::TypeDescriptor && returnType->GetTypeDescriptor()->GetValueSerializer())
				{
					auto serializer = returnType->GetTypeDescriptor()->GetValueSerializer();
					auto defaultText = serializer->GetDefaultText();
					Value result;
					serializer->Parse(defaultText, result);
					INSTRUCTION(Ins::LoadValue(result));
				}
				else
				{
					INSTRUCTION(Ins::LoadValue(Value()));
				}
				INSTRUCTION(Ins::Return());
				meta->lastInstruction = context.assembly->instructions.Count() - 1;
				context.functionContext = 0;

				GenerateClosureInstructions(context, functionContext);
			}

			void GenerateFunctionInstructions(WfCodegenContext& context, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<ITypeInfo> returnType, Ptr<WfLexicalSymbol> recursiveLambdaSymbol, const List<Ptr<WfLexicalSymbol>>& argumentSymbols, const List<Ptr<WfLexicalSymbol>>& capturedSymbols, Ptr<WfStatement> statementBody, ParsingTreeCustomBase* node)
			{
				auto functionContext = GenerateFunctionInstructions_Prolog(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, node);
				GenerateStatementInstructions(context, statementBody);
				GenerateFunctionInstructions_Epilog(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, functionContext, node);
			}

			void GenerateFunctionInstructions(WfCodegenContext& context, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<ITypeInfo> returnType, Ptr<WfLexicalSymbol> recursiveLambdaSymbol, const List<Ptr<WfLexicalSymbol>>& argumentSymbols, const List<Ptr<WfLexicalSymbol>>& capturedSymbols, Ptr<WfExpression> expressionBody, ParsingTreeCustomBase* node)
			{
				auto functionContext = GenerateFunctionInstructions_Prolog(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, node);
				GenerateExpressionInstructions(context, expressionBody);
				INSTRUCTION(Ins::Return());
				GenerateFunctionInstructions_Epilog(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, functionContext, node);
			}

			void GenerateFunctionDeclarationInstructions(WfCodegenContext& context, WfFunctionDeclaration* node, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<WfLexicalSymbol> recursiveLambdaSymbol)
			{
				List<Ptr<WfLexicalSymbol>> argumentSymbols, capturedSymbols;
				{
					FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
					{
						auto symbol = scope->symbols[argument->name.value][0];
						argumentSymbols.Add(symbol);
					}

					vint index = context.manager->functionLambdaCaptures.Keys().IndexOf(node);
					if (index != -1)
					{
						FOREACH(Ptr<WfLexicalSymbol>, symbol, context.manager->functionLambdaCaptures.GetByIndex(index))
						{
							capturedSymbols.Add(symbol);
						}
					}
				}

				auto returnType = CreateTypeInfoFromType(scope, node->returnType);
				GenerateFunctionInstructions(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, node->statement, node);
			}

			class GenerateClassMemberInstructionsVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;
				Ptr<WfClassDeclaration>					classDecl;
				Ptr<WfClassMember>						member;

				GenerateClassMemberInstructionsVisitor(WfCodegenContext& _context, Ptr<WfClassDeclaration> _classDecl, Ptr<WfClassMember> _member)
					:context(_context)
					, classDecl(_classDecl)
					, member(_member)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (member->kind == WfClassMemberKind::Static)
					{
						GenerateDeclarationInstructions(context, node);
					}
					else if (classDecl->kind == WfClassKind::Class)
					{
						throw 0;
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					throw 0;
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					GenerateDeclarationInstructions(context, node);
				}
			};

			class GenerateDeclarationInstructionsVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateDeclarationInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					FOREACH(Ptr<WfDeclaration>, decl, node->declarations)
					{
						GenerateDeclarationInstructions(context, decl);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					auto scope = context.manager->declarationScopes[node].Obj();
					auto symbol = context.manager->GetDeclarationSymbol(scope, node);
					auto meta = context.assembly->functions[context.globalFunctions[symbol.Obj()]];
					GenerateFunctionDeclarationInstructions(context, node, scope, meta, 0);
				}

				void Visit(WfVariableDeclaration* node)override
				{
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					FOREACH(Ptr<WfClassMember>, member, node->members)
					{
						GenerateClassMemberInstructionsVisitor visitor(context, node, member);
						member->declaration->Accept(&visitor);
					}
				}
			};

			void GenerateDeclarationInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration)
			{
				GenerateDeclarationInstructionsVisitor visitor(context);
				declaration->Accept(&visitor);
			}

/***********************************************************************
GenerateInstructions(Closure)
***********************************************************************/

			void GenerateClosureInstructions_StaticMethod(WfCodegenContext& context, vint functionIndex, WfExpression* node)
			{
				auto result = context.manager->expressionResolvings[node];
				auto methodInfo = result.methodInfo;
				auto meta = context.assembly->functions[functionIndex];

				for (vint j = 0; j < methodInfo->GetParameterCount(); j++)
				{
					meta->argumentNames.Add(methodInfo->GetParameter(j)->GetName());
				}

				meta->firstInstruction = context.assembly->instructions.Count();
				for (vint j = 0; j < methodInfo->GetParameterCount(); j++)
				{
					INSTRUCTION(Ins::LoadLocalVar(j));
				}
				INSTRUCTION(Ins::LoadValue(Value()));
				INSTRUCTION(Ins::InvokeMethod(methodInfo, methodInfo->GetParameterCount()));
				INSTRUCTION(Ins::Return());
				meta->lastInstruction = context.assembly->instructions.Count() - 1;
			}

			void GenerateClosureInstructions_Method(WfCodegenContext& context, vint functionIndex, WfMemberExpression* node)
			{
				auto result = context.manager->expressionResolvings[node];
				auto methodInfo = result.methodInfo;
				auto meta = context.assembly->functions[functionIndex];

				for (vint j = 0; j < methodInfo->GetParameterCount(); j++)
				{
					meta->argumentNames.Add(methodInfo->GetParameter(j)->GetName());
				}
				meta->capturedVariableNames.Add(L"<this>");

				meta->firstInstruction = context.assembly->instructions.Count();
				for (vint j = 0; j < methodInfo->GetParameterCount(); j++)
				{
					INSTRUCTION(Ins::LoadLocalVar(j));
				}
				INSTRUCTION(Ins::LoadCapturedVar(0));
				INSTRUCTION(Ins::InvokeMethod(methodInfo, methodInfo->GetParameterCount()));
				INSTRUCTION(Ins::Return());
				meta->lastInstruction = context.assembly->instructions.Count() - 1;
			}

			void GenerateClosureInstructions_Function(WfCodegenContext& context, vint functionIndex, WfFunctionDeclaration* node, bool createInterface)
			{
				auto scope = context.manager->declarationScopes[node].Obj();
				auto meta = context.assembly->functions[functionIndex];
				GenerateFunctionDeclarationMetadata(context, node, meta);
				Ptr<WfLexicalSymbol> recursiveLambdaSymbol;
				if (!createInterface && node->name.value != L"")
				{
					recursiveLambdaSymbol = scope->symbols[node->name.value][0];
				}
				GenerateFunctionDeclarationInstructions(context, node, scope, meta, recursiveLambdaSymbol);
			}

			void GenerateClosureInstructions_Ordered(WfCodegenContext& context, vint functionIndex, WfOrderedLambdaExpression* node)
			{
				auto scope = context.manager->expressionScopes[node].Obj();
				List<Ptr<WfLexicalSymbol>> argumentSymbols, capturedSymbols;
				CopyFrom(
					argumentSymbols,
					Range<vint>(0, scope->symbols.Count())
						.Select([scope](vint index)->Ptr<WfLexicalSymbol>{return scope->symbols.GetByIndex(index)[0];})
						.OrderBy([](Ptr<WfLexicalSymbol> a, Ptr<WfLexicalSymbol> b)
						{
							vint aId = wtoi(a->name.Sub(1, a->name.Length() - 1));
							vint bId = wtoi(b->name.Sub(1, a->name.Length() - 1));
							return aId - bId;
						})
					);

				auto meta = context.assembly->functions[functionIndex];
				FOREACH(Ptr<WfLexicalSymbol>, symbol, argumentSymbols)
				{
					meta->argumentNames.Add(symbol->name);
				}
				{
					vint index = context.manager->orderedLambdaCaptures.Keys().IndexOf(node);
					if (index != -1)
					{
						FOREACH(Ptr<WfLexicalSymbol>, symbol, context.manager->orderedLambdaCaptures.GetByIndex(index))
						{
							meta->capturedVariableNames.Add(L"<captured>" + symbol->name);
							capturedSymbols.Add(symbol);
						}
					}
				}

				auto result = context.manager->expressionResolvings[node];
				auto returnType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
				GenerateFunctionInstructions(context, scope, meta, returnType, 0, argumentSymbols, capturedSymbols, node->body, node);
			}

			void GenerateClosureInstructions(WfCodegenContext& context, Ptr<WfCodegenFunctionContext> functionContext)
			{
				for (vint i = 0; i < functionContext->closuresToCodegen.Count(); i++)
				{
					vint functionIndex = functionContext->closuresToCodegen.Keys()[i];
					auto closure = functionContext->closuresToCodegen.Values()[i];
					
					if (closure.staticMethodReferenceExpression)
					{
						GenerateClosureInstructions_StaticMethod(context, functionIndex, closure.staticMethodReferenceExpression);
					}
					else if (closure.methodReferenceExpression)
					{
						GenerateClosureInstructions_Method(context, functionIndex, closure.methodReferenceExpression);
					}
					else if (closure.functionExpression)
					{
						GenerateClosureInstructions_Function(context, functionIndex, closure.functionExpression->function.Obj(), false);
					}
					else if (closure.orderedLambdaExpression)
					{
						GenerateClosureInstructions_Ordered(context, functionIndex, closure.orderedLambdaExpression);
					}
					else if (closure.functionDeclaration)
					{
						GenerateClosureInstructions_Function(context, functionIndex, closure.functionDeclaration, true);
					}
				}
			}

#undef INSTRUCTION
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_GENERATEEXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace regex;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;
			using namespace runtime;

			typedef WfInstruction Ins;

#define INSTRUCTION(X) context.AddInstruction(node, X)

/***********************************************************************
GenerateInstructions(Expression)
***********************************************************************/

			class GenerateExpressionInstructionsVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateExpressionInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void GenerateLoadSymbolInstructions(WfLexicalSymbol* symbol, parsing::ParsingTreeCustomBase* node)
				{
					vint index = -1;
					if ((index = context.globalFunctions.Keys().IndexOf(symbol)) != -1)
					{
						vint functionIndex = context.globalFunctions.Values()[index];
						INSTRUCTION(Ins::LoadClosure(functionIndex, 0));
					}
					else if ((index = context.globalVariables.Keys().IndexOf(symbol)) != -1)
					{
						vint variableIndex = context.globalVariables.Values()[index];
						INSTRUCTION(Ins::LoadGlobalVar(variableIndex));
					}
					else if ((index = context.functionContext->capturedVariables.Keys().IndexOf(symbol)) != -1)
					{
						vint variableIndex = context.functionContext->capturedVariables.Values()[index];
						INSTRUCTION(Ins::LoadCapturedVar(variableIndex));
					}
					else if ((index = context.functionContext->localVariables.Keys().IndexOf(symbol)) != -1)
					{
						vint variableIndex = context.functionContext->localVariables.Values()[index];
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
					}
					else if ((index = context.functionContext->arguments.Keys().IndexOf(symbol)) != -1)
					{
						vint variableIndex = context.functionContext->arguments.Values()[index];
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
					}
				}

				void VisitReferenceExpression(WfExpression* node)
				{
					auto result = context.manager->expressionResolvings[node];
					if (result.symbol)
					{
						GenerateLoadSymbolInstructions(result.symbol.Obj(), node);
					}
					else
					{
						if (result.methodInfo && result.methodInfo->IsStatic())
						{
							auto meta = MakePtr<WfAssemblyFunction>();
							meta->name = result.methodInfo->GetName() + L"<" + result.methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L">";
							vint functionIndex = context.assembly->functions.Add(meta);
							context.assembly->functionByName.Add(meta->name, functionIndex);
						
							WfCodegenLambdaContext lc;
							lc.staticMethodReferenceExpression = node;
							context.functionContext->closuresToCodegen.Add(functionIndex, lc);

							INSTRUCTION(Ins::LoadClosure(functionIndex, 0));
						}
					}
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					VisitReferenceExpression(node);
				}

				void Visit(WfReferenceExpression* node)override
				{
					VisitReferenceExpression(node);
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					VisitReferenceExpression(node);
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					auto meta = MakePtr<WfAssemblyFunction>();
					vint functionIndex = context.assembly->functions.Add(meta);
					meta->name = L"<lambda:(" + itow(functionIndex) + L")> in " + context.functionContext->function->name;
					context.assembly->functionByName.Add(meta->name, functionIndex);

					WfCodegenLambdaContext lc;
					lc.orderedLambdaExpression = node;
					context.functionContext->closuresToCodegen.Add(functionIndex, lc);

					vint index = context.manager->orderedLambdaCaptures.Keys().IndexOf(node);
					if (index != -1)
					{
						const auto& symbols = context.manager->orderedLambdaCaptures.GetByIndex(index);
						FOREACH(Ptr<WfLexicalSymbol>, symbol, symbols)
						{
							GenerateLoadSymbolInstructions(symbol.Obj(), node);
						}
						INSTRUCTION(Ins::LoadClosure(functionIndex, symbols.Count()));
					}
					else
					{
						INSTRUCTION(Ins::LoadClosure(functionIndex, 0));
					}
				}

				void Visit(WfMemberExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					if (result.propertyInfo)
					{
						GenerateExpressionInstructions(context, node->parent);
						if (result.propertyInfo->GetGetter())
						{
							INSTRUCTION(Ins::InvokeMethod(result.propertyInfo->GetGetter(), 0));
						}
						else
						{
							INSTRUCTION(Ins::GetProperty(result.propertyInfo));
						}
					}
					else
					{
						auto meta = MakePtr<WfAssemblyFunction>();
						meta->name = result.methodInfo->GetName() + L"<" + result.methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L">";
						vint functionIndex = context.assembly->functions.Add(meta);
						context.assembly->functionByName.Add(meta->name, functionIndex);
						
						WfCodegenLambdaContext lc;
						lc.methodReferenceExpression = node;
						context.functionContext->closuresToCodegen.Add(functionIndex, lc);

						GenerateExpressionInstructions(context, node->parent);
						INSTRUCTION(Ins::LoadClosure(functionIndex, 1));
					}
				}

				void Visit(WfChildExpression* node)override
				{
					VisitReferenceExpression(node);
				}

				void Visit(WfLiteralExpression* node)override
				{
					switch (node->value)
					{
					case WfLiteralValue::Null:
						INSTRUCTION(Ins::LoadValue(Value()));
						break;
					case WfLiteralValue::True:
						INSTRUCTION(Ins::LoadValue(BoxValue(true)));
						break;
					case WfLiteralValue::False:
						INSTRUCTION(Ins::LoadValue(BoxValue(false)));
						break;
					}
				}

				void Visit(WfFloatingExpression* node)override
				{
					INSTRUCTION(Ins::LoadValue(BoxValue(wtof(node->value.value))));
				}

				void Visit(WfIntegerExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					auto td = result.type->GetTypeDescriptor();
					if (td == description::GetTypeDescriptor<vint32_t>())
					{
						INSTRUCTION(Ins::LoadValue(BoxValue((vint32_t)wtoi(node->value.value))));
					}
					else if (td == description::GetTypeDescriptor<vint64_t>())
					{
						INSTRUCTION(Ins::LoadValue(BoxValue((vint64_t)wtoi64(node->value.value))));
					}
					else if (td == description::GetTypeDescriptor<vuint64_t>())
					{
						INSTRUCTION(Ins::LoadValue(BoxValue((vuint64_t)wtou64(node->value.value))));
					}
				}

				void Visit(WfStringExpression* node)override
				{
					INSTRUCTION(Ins::LoadValue(BoxValue(node->value.value)));
				}

				void Visit(WfFormatExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expandedExpression);
				}

				void Visit(WfUnaryExpression* node)override
				{
					auto type = GenerateExpressionInstructions(context, node->operand);
					switch (node->op)
					{
					case WfUnaryOperator::Not:
						INSTRUCTION(Ins::OpNot(GetInstructionTypeArgument(type)));
						break;
					case WfUnaryOperator::Positive:
						INSTRUCTION(Ins::OpPositive(GetInstructionTypeArgument(type)));
						break;
					case WfUnaryOperator::Negative:
						INSTRUCTION(Ins::OpNegative(GetInstructionTypeArgument(type)));
						break;
					}
				}

				void Visit(WfBinaryExpression* node)override
				{
					if (node->op == WfBinaryOperator::Assign)
					{
						if (auto binary = node->first.Cast<WfBinaryExpression>())
						{
							auto result = context.manager->expressionResolvings[binary->first.Obj()];
							auto containerType = result.expectedType ? result.expectedType : result.type;
							auto methodInfo = containerType->GetTypeDescriptor()->GetMethodGroupByName(L"Set", true)->GetMethod(0);
							GenerateExpressionInstructions(context, binary->second);
							INSTRUCTION(Ins::Duplicate(0));
							GenerateExpressionInstructions(context, node->second);
							GenerateExpressionInstructions(context, binary->first);
							INSTRUCTION(Ins::InvokeMethod(methodInfo, 2));
							INSTRUCTION(Ins::Pop());
						}
						else if (auto member = node->first.Cast<WfMemberExpression>())
						{
							auto result = context.manager->expressionResolvings[member.Obj()];
							if (auto methodInfo = result.propertyInfo->GetSetter())
							{
								GenerateExpressionInstructions(context, node->second);
								INSTRUCTION(Ins::Duplicate(0));
								GenerateExpressionInstructions(context, member->parent);
								INSTRUCTION(Ins::InvokeMethod(methodInfo, 1));
								INSTRUCTION(Ins::Pop());
							}
							else
							{
								GenerateExpressionInstructions(context, node->second);
								INSTRUCTION(Ins::Duplicate(0));
								GenerateExpressionInstructions(context, member->parent);
								INSTRUCTION(Ins::SetProperty(result.propertyInfo));
							}
						}
						else
						{
							GenerateExpressionInstructions(context, node->second);
							INSTRUCTION(Ins::Duplicate(0));
							auto result = context.manager->expressionResolvings[node->first.Obj()];
							vint index = -1;
							if ((index = context.globalVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
							{
								vint variableIndex = context.globalVariables.Values()[index];
								INSTRUCTION(Ins::StoreGlobalVar(variableIndex));
							}
							else if ((index = context.functionContext->localVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
							{
								vint variableIndex = context.functionContext->localVariables.Values()[index];
								INSTRUCTION(Ins::StoreLocalVar(variableIndex));
							}
						}
					}
					else if (node->op == WfBinaryOperator::Index)
					{
						auto result = context.manager->expressionResolvings[node->first.Obj()];
						auto containerType = result.expectedType ? result.expectedType : result.type;
						auto methodInfo = containerType->GetTypeDescriptor()->GetMethodGroupByName(L"Get", true)->GetMethod(0);
						GenerateExpressionInstructions(context, node->second);
						GenerateExpressionInstructions(context, node->first);
						INSTRUCTION(Ins::InvokeMethod(methodInfo, 1));
					}
					else if (node->op == WfBinaryOperator::Concat)
					{
						auto type = TypeInfoRetriver<WString>::CreateTypeInfo();
						GenerateExpressionInstructions(context, node->first, type);
						GenerateExpressionInstructions(context, node->second, type);
						INSTRUCTION(Ins::OpConcat());
					}
					else if (node->op == WfBinaryOperator::FailedThen)
					{
						auto result = context.manager->expressionResolvings[node];
						vint trapInstruction = INSTRUCTION(Ins::InstallTry(-1));
						GenerateExpressionInstructions(context, node->first, result.type);
						INSTRUCTION(Ins::UninstallTry(1));
						vint finishInstruction = INSTRUCTION(Ins::Jump(-1));

						context.assembly->instructions[trapInstruction].indexParameter = context.assembly->instructions.Count();
						GenerateExpressionInstructions(context, node->second, result.type);

						context.assembly->instructions[finishInstruction].indexParameter = context.assembly->instructions.Count();
					}
					else
					{
						Ptr<ITypeInfo> mergedType;
						switch (node->op)
						{
						case WfBinaryOperator::Exp:
						case WfBinaryOperator::Add:
						case WfBinaryOperator::Sub:
						case WfBinaryOperator::Mul:
						case WfBinaryOperator::Div:
						case WfBinaryOperator::Mod:
						case WfBinaryOperator::Shl:
						case WfBinaryOperator::Shr:
							{
								auto result = context.manager->expressionResolvings[node];
								mergedType = result.type;
							}
							break;
						default:
							{
								auto firstResult = context.manager->expressionResolvings[node->first.Obj()];
								auto secondResult = context.manager->expressionResolvings[node->second.Obj()];
								auto firstType = firstResult.expectedType ? firstResult.expectedType : firstResult.type;
								auto secondType = secondResult.expectedType ? secondResult.expectedType : secondResult.type;
								if (node->op == WfBinaryOperator::EQ || node->op == WfBinaryOperator::NE)
								{
									if (firstType->GetDecorator() == ITypeInfo::RawPtr || firstType->GetDecorator() == ITypeInfo::SharedPtr)
									{
										GenerateExpressionInstructions(context, node->first);
										GenerateExpressionInstructions(context, node->second);
										INSTRUCTION(Ins::CompareReference());
										if (node->op == WfBinaryOperator::NE)
										{
											INSTRUCTION(Ins::OpNot(WfInsType::Bool));
										}
										return;
									}
								}

								mergedType = GetMergedType(firstType, secondType);
								if (node->op == WfBinaryOperator::EQ || node->op == WfBinaryOperator::NE)
								{
									if (mergedType->GetTypeDescriptor() == description::GetTypeDescriptor<Value>())
									{
										GenerateExpressionInstructions(context, node->first);
										GenerateExpressionInstructions(context, node->second);
										INSTRUCTION(Ins::CompareValue());
										if (node->op == WfBinaryOperator::NE)
										{
											INSTRUCTION(Ins::OpNot(WfInsType::Bool));
										}
										return;
									}
									else if (mergedType->GetTypeDescriptor()->GetValueSerializer())
									{
										auto structType = mergedType->GetDecorator() == ITypeInfo::Nullable ? CopyTypeInfo(mergedType->GetElementType()) : mergedType;
										auto insType = GetInstructionTypeArgument(structType);
										if (insType == WfInsType::Unknown)
										{
											GenerateExpressionInstructions(context, node->first);
											GenerateExpressionInstructions(context, node->second);
											INSTRUCTION(Ins::CompareStruct());
											if (node->op == WfBinaryOperator::NE)
											{
												INSTRUCTION(Ins::OpNot(WfInsType::Bool));
											}
											return;
										}
									}
								}
							}
						}

						GenerateExpressionInstructions(context, node->first, mergedType);
						GenerateExpressionInstructions(context, node->second, mergedType);

						switch (node->op)
						{
						case WfBinaryOperator::Exp:
							INSTRUCTION(Ins::OpExp(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Add:
							INSTRUCTION(Ins::OpAdd(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Sub:
							INSTRUCTION(Ins::OpSub(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Mul:
							INSTRUCTION(Ins::OpMul(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Div:
							INSTRUCTION(Ins::OpDiv(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Mod:
							INSTRUCTION(Ins::OpMod(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Shl:
							INSTRUCTION(Ins::OpShl(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Shr:
							INSTRUCTION(Ins::OpShr(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::LT:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpLT());
							break;
						case WfBinaryOperator::GT:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpGT());
							break;
						case WfBinaryOperator::LE:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpLE());
							break;
						case WfBinaryOperator::GE:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpGE());
							break;
						case WfBinaryOperator::EQ:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpEQ());
							break;
						case WfBinaryOperator::NE:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpNE());
							break;
						case WfBinaryOperator::Xor:
							INSTRUCTION(Ins::OpXor(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::And:
							INSTRUCTION(Ins::OpAnd(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Or:
							INSTRUCTION(Ins::OpOr(GetInstructionTypeArgument(mergedType)));
							break;
						default:;
						}
					}
				}

				void Visit(WfLetExpression* node)override
				{
					auto scope = context.manager->expressionScopes[node].Obj();
					Array<vint> variableIndices(node->variables.Count());
					auto function = context.functionContext->function;
					FOREACH_INDEXER(Ptr<WfLetVariable>, var, index, node->variables)
					{
						auto symbol = scope->symbols[var->name.value][0];
						vint variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<let>" + var->name.value);
						context.functionContext->localVariables.Add(symbol.Obj(), variableIndex);
						variableIndices[index] = variableIndex;

						GenerateExpressionInstructions(context, var->value);
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
					}
					GenerateExpressionInstructions(context, node->expression);
					FOREACH_INDEXER(Ptr<WfLetVariable>, var, index, node->variables)
					{
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(variableIndices[index]));
					}
				}

				void Visit(WfIfExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					GenerateExpressionInstructions(context, node->condition);
					vint fillTrueIndex = INSTRUCTION(Ins::JumpIf(-1));
					GenerateExpressionInstructions(context, node->falseBranch, result.type);
					vint fillEndIndex = INSTRUCTION(Ins::Jump(-1));
					context.assembly->instructions[fillTrueIndex].indexParameter = context.assembly->instructions.Count();
					GenerateExpressionInstructions(context, node->trueBranch, result.type);
					context.assembly->instructions[fillEndIndex].indexParameter = context.assembly->instructions.Count();
				}

				void Visit(WfRangeExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					auto elementType = result.type->GetElementType()->GetGenericArgument(0);
					auto type = GetInstructionTypeArgument(elementType);
					
					GenerateExpressionInstructions(context, node->begin, elementType);
					if (node->beginBoundary == WfRangeBoundary::Exclusive)
					{
						INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
						INSTRUCTION(Ins::OpAdd(type));
					}
					
					GenerateExpressionInstructions(context, node->end, elementType);
					if (node->endBoundary == WfRangeBoundary::Exclusive)
					{
						INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
						INSTRUCTION(Ins::OpSub(type));
					}

					INSTRUCTION(Ins::CreateRange(type));
				}

				void Visit(WfSetTestingExpression* node)override
				{
					if (auto range = node->collection.Cast<WfRangeExpression>())
					{
						auto resultElement = context.manager->expressionResolvings[node->element.Obj()];
						auto resultBegin = context.manager->expressionResolvings[range->begin.Obj()];
						auto resultEnd = context.manager->expressionResolvings[range->end.Obj()];
						auto typeElement = resultElement.expectedType ? resultElement.expectedType : resultElement.type;
						auto typeBegin = resultBegin.expectedType ? resultBegin.expectedType : resultBegin.type;
						auto typeEnd = resultEnd.expectedType ? resultEnd.expectedType : resultEnd.type;
						auto typeLeft = GetMergedType(typeElement, typeBegin);
						auto typeRight = GetMergedType(typeElement, typeEnd);

						auto function = context.functionContext->function;
						vint index = function->argumentNames.Count() + function->localVariableNames.Add(L"<anonymous-range-test>");
						GenerateExpressionInstructions(context, node->element);
						INSTRUCTION(Ins::StoreLocalVar(index));
						
						INSTRUCTION(Ins::LoadLocalVar(index));
						if (!IsSameType(typeElement.Obj(), typeLeft.Obj()))
						{
							GenerateTypeCastInstructions(context, typeLeft, true, node);
						}
						GenerateExpressionInstructions(context, range->begin, typeLeft);
						INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(typeLeft)));
						if (range->beginBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::OpGT());
						}
						else
						{
							INSTRUCTION(Ins::OpGE());
						}

						INSTRUCTION(Ins::LoadLocalVar(index));
						if (!IsSameType(typeElement.Obj(), typeRight.Obj()))
						{
							GenerateTypeCastInstructions(context, typeRight, true, node);
						}
						GenerateExpressionInstructions(context, range->end, typeRight);
						INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(typeRight)));
						if (range->endBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::OpLT());
						}
						else
						{
							INSTRUCTION(Ins::OpLE());
						}

						INSTRUCTION(Ins::OpAnd(WfInsType::Bool));
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(index));
					}
					else
					{
						auto result = context.manager->expressionResolvings[node->collection.Obj()];
						auto type = result.expectedType ? result.expectedType : result.type;

						GenerateExpressionInstructions(context, node->element);
						GenerateExpressionInstructions(context, node->collection);

						auto tdList = description::GetTypeDescriptor<IValueReadonlyList>();
						if (result.type->GetTypeDescriptor()->CanConvertTo(tdList))
						{
							auto method = tdList->GetMethodGroupByName(L"Contains", true)->GetMethod(0);
							INSTRUCTION(Ins::InvokeMethod(method, 1));
						}
						else
						{
							INSTRUCTION(Ins::TestElementInSet());
						}
					}
				}

				void Visit(WfConstructorExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];

					if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerable>()
						|| result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>()
						|| result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
					{
						Ptr<ITypeInfo> keyType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
						FOREACH(Ptr<WfConstructorArgument>, argument, From(node->arguments).Reverse())
						{
							GenerateExpressionInstructions(context, argument->key, keyType);
						}
						INSTRUCTION(Ins::CreateArray(node->arguments.Count()));
					}
					else
					{
						Ptr<ITypeInfo> keyType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
						Ptr<ITypeInfo> valueType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(1));
						FOREACH(Ptr<WfConstructorArgument>, argument, From(node->arguments).Reverse())
						{
							GenerateExpressionInstructions(context, argument->key, keyType);
							GenerateExpressionInstructions(context, argument->value, valueType);
						}
						INSTRUCTION(Ins::CreateMap(node->arguments.Count() * 2));
					}
				}

				void Visit(WfInferExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					if (node->strategy == WfTypeCastingStrategy::Strong)
					{
						auto result = context.manager->expressionResolvings[node];
						GenerateExpressionInstructions(context, node->expression, result.type);
					}
					else
					{
						auto scope = context.manager->expressionScopes[node].Obj();
						auto type = CreateTypeInfoFromType(scope, node->type);
						GenerateExpressionInstructions(context, node->expression);
						GenerateTypeCastInstructions(context, type, false, node);
					}
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					switch (node->test)
					{
					case WfTypeTesting::IsNull:
						GenerateExpressionInstructions(context, node->expression);
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::CompareReference());
						break;
					case WfTypeTesting::IsNotNull:
						GenerateExpressionInstructions(context, node->expression);
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::CompareReference());
						INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						break;
					case WfTypeTesting::IsType:
						{
							auto scope = context.manager->expressionScopes[node].Obj();
							auto type = CreateTypeInfoFromType(scope, node->type);
							GenerateExpressionInstructions(context, node->expression);
							GenerateTypeTestingInstructions(context, type, node);
						}
						break;
					case WfTypeTesting::IsNotType:
						{
							auto scope = context.manager->expressionScopes[node].Obj();
							auto type = CreateTypeInfoFromType(scope, node->type);
							GenerateExpressionInstructions(context, node->expression);
							GenerateTypeTestingInstructions(context, type, node);
							INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						}
						break;
					}
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					auto scope = context.manager->expressionScopes[node].Obj();
					auto type = CreateTypeInfoFromType(scope, node->type);
					auto value = Value::From(type->GetTypeDescriptor());
					INSTRUCTION(Ins::LoadValue(value));
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::GetType());
				}

				void Visit(WfAttachEventExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node->event.Obj()];
					auto parent = node->event.Cast<WfMemberExpression>()->parent;
					GenerateExpressionInstructions(context, parent);
					GenerateExpressionInstructions(context, node->function);
					INSTRUCTION(Ins::AttachEvent(result.eventInfo));
				}

				void Visit(WfDetachEventExpression* node)override
				{
					GenerateExpressionInstructions(context, node->handler);
					INSTRUCTION(Ins::DetachEvent());
				}

				void Visit(WfBindExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expandedExpression);
				}

				void Visit(WfObserveExpression* node)override
				{
				}

				void Visit(WfCallExpression* node)override
				{
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						GenerateExpressionInstructions(context, argument);
					}

					auto result = context.manager->expressionResolvings[node->function.Obj()];
					if (result.methodInfo)
					{
						if (result.methodInfo->IsStatic())
						{
							INSTRUCTION(Ins::LoadValue(Value()));
						}
						else
						{
							auto member = node->function.Cast<WfMemberExpression>();
							GenerateExpressionInstructions(context, member->parent);
						}

						INSTRUCTION(Ins::InvokeMethod(result.methodInfo, node->arguments.Count()));
						return;
					}
					else if (result.symbol)
					{
						vint index = context.globalFunctions.Keys().IndexOf(result.symbol.Obj());
						if (index != -1)
						{
							vint functionIndex = context.globalFunctions.Values()[index];
							INSTRUCTION(Ins::Invoke(functionIndex, node->arguments.Count()));
							return;
						}
					}

					GenerateExpressionInstructions(context, node->function);
					INSTRUCTION(Ins::InvokeProxy(node->arguments.Count()));
				}

				void VisitFunction(WfFunctionDeclaration* node, WfCodegenLambdaContext lc, const Func<WString(vint)>& getName)
				{
					auto meta = MakePtr<WfAssemblyFunction>();
					vint functionIndex = context.assembly->functions.Add(meta);
					meta->name = getName(functionIndex);
					context.assembly->functionByName.Add(meta->name, functionIndex);

					context.functionContext->closuresToCodegen.Add(functionIndex, lc);

					vint index = context.manager->functionLambdaCaptures.Keys().IndexOf(node);
					if (index != -1)
					{
						const auto& symbols = context.manager->functionLambdaCaptures.GetByIndex(index);
						FOREACH(Ptr<WfLexicalSymbol>, symbol, symbols)
						{
							GenerateLoadSymbolInstructions(symbol.Obj(), node);
						}
						INSTRUCTION(Ins::LoadClosure(functionIndex, symbols.Count()));
					}
					else
					{
						INSTRUCTION(Ins::LoadClosure(functionIndex, 0));
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					WfCodegenLambdaContext lc;
					lc.functionExpression = node;
					VisitFunction(node->function.Obj(), lc, [=](vint index)
					{
						return L"<lambda:" + node->function->name.value + L"(" + itow(index) + L")> in " + context.functionContext->function->name;
					});
				}

				void Visit(WfNewTypeExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					if (node->functions.Count() == 0)
					{
						FOREACH(Ptr<WfExpression>, argument, node->arguments)
						{
							GenerateExpressionInstructions(context, argument);
						}
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::InvokeMethod(result.methodInfo, node->arguments.Count()));
					}
					else
					{
						FOREACH(Ptr<WfFunctionDeclaration>, decl, node->functions)
						{
							INSTRUCTION(Ins::LoadValue(BoxValue(decl->name.value)));
							WfCodegenLambdaContext lc;
							lc.functionDeclaration = decl.Obj();
							VisitFunction(decl.Obj(), lc, [=](vint index)
							{
								return L"<method:" + decl->name.value + L"<" + result.type->GetTypeDescriptor()->GetTypeName() + L">(" + itow(index) + L")> in " + context.functionContext->function->name;
							});
						}
						INSTRUCTION(Ins::CreateInterface(node->functions.Count() * 2));
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::InvokeMethod(result.methodInfo, 1));
					}
				}
			};

#undef INSTRUCTION

			Ptr<reflection::description::ITypeInfo> GenerateExpressionInstructions(WfCodegenContext& context, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				GenerateExpressionInstructionsVisitor visitor(context);
				expression->Accept(&visitor);

				auto result = context.manager->expressionResolvings[expression.Obj()];
				auto type = result.type;

				if (result.expectedType && !IsSameType(type.Obj(), result.expectedType.Obj()))
				{
					type = result.expectedType;
					GenerateTypeCastInstructions(context, type, true, expression.Obj());
				}

				if (expectedType && !IsSameType(type.Obj(), expectedType.Obj()))
				{
					type = expectedType;
					GenerateTypeCastInstructions(context, type, true, expression.Obj());
				}

				return type;
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_GENERATEMETADATA.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace runtime;
			using namespace typeimpl;

/***********************************************************************
GenerateGlobalDeclarationMetadata
***********************************************************************/

			void GenerateFunctionDeclarationMetadata(WfCodegenContext& context, WfFunctionDeclaration* node, Ptr<WfAssemblyFunction> meta)
			{
				FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
				{
					meta->argumentNames.Add(argument->name.value);
				}
				{
					vint index = context.manager->functionLambdaCaptures.Keys().IndexOf(node);
					if (index != -1)
					{
						FOREACH(Ptr<WfLexicalSymbol>, symbol, context.manager->functionLambdaCaptures.GetByIndex(index))
						{
							meta->capturedVariableNames.Add(L"<captured>" + symbol->name);
						}
					}
				}
			}

			class GenerateGlobalClassMemberMetadataVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;
				WString									namePrefix;
				Ptr<WfClassDeclaration>					classDecl;
				Ptr<WfClassMember>						member;

				GenerateGlobalClassMemberMetadataVisitor(WfCodegenContext& _context, const WString& _namePrefix, Ptr<WfClassDeclaration> _classDecl, Ptr<WfClassMember> _member)
					:context(_context)
					, namePrefix(_namePrefix)
					, classDecl(_classDecl)
					, member(_member)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (member->kind == WfClassMemberKind::Static)
					{
						GenerateGlobalDeclarationMetadata(context, node, namePrefix);
						auto scope = context.manager->declarationScopes[node].Obj();
						auto symbol = context.manager->GetDeclarationSymbol(scope, node);
						auto index = context.globalFunctions[symbol.Obj()];
						auto info = context.manager->declarationMemberInfos[node].Cast<WfStaticMethod>();
						info->functionIndex = index;
					}
					else if (classDecl->kind == WfClassKind::Class)
					{
						throw 0;
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					throw 0;
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					GenerateGlobalDeclarationMetadata(context, node, namePrefix);
				}
			};

			class GenerateGlobalDeclarationMetadataVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;
				WString									namePrefix;

				GenerateGlobalDeclarationMetadataVisitor(WfCodegenContext& _context, const WString& _namePrefix)
					:context(_context)
					, namePrefix(_namePrefix)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					FOREACH(Ptr<WfDeclaration>, decl, node->declarations)
					{
						GenerateGlobalDeclarationMetadata(context, decl, namePrefix + node->name.value + L"::");
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					auto meta = MakePtr<WfAssemblyFunction>();
					meta->name = namePrefix + node->name.value;
					GenerateFunctionDeclarationMetadata(context, node, meta);

					vint index = context.assembly->functions.Add(meta);
					context.assembly->functionByName.Add(meta->name, index);

					auto scope = context.manager->declarationScopes[node].Obj();
					auto symbol = context.manager->GetDeclarationSymbol(scope, node);
					context.globalFunctions.Add(symbol.Obj(), index);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					vint index = context.assembly->variableNames.Add(namePrefix + node->name.value);

					auto scope = context.manager->declarationScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					context.globalVariables.Add(symbol.Obj(), index);
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					FOREACH(Ptr<WfClassMember>, member, node->members)
					{
						GenerateGlobalClassMemberMetadataVisitor visitor(context, namePrefix + node->name.value + L"::", node, member);
						member->declaration->Accept(&visitor);
					}
				}
			};

			void GenerateGlobalDeclarationMetadata(WfCodegenContext& context, Ptr<WfDeclaration> declaration, const WString& namePrefix)
			{
				GenerateGlobalDeclarationMetadataVisitor visitor(context, namePrefix);
				declaration->Accept(&visitor);
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_GENERATESTATEMENT.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace regex;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;
			using namespace runtime;

			typedef WfInstruction Ins;

#define INSTRUCTION(X) context.AddInstruction(node, X)
#define EXIT_CODE(X) context.AddExitInstruction(node, X)

/***********************************************************************
GenerateInstructions(Statement)
***********************************************************************/

			class GenerateStatementInstructionsVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateStatementInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void ApplyExitCode(Ptr<WfCodegenScopeContext> scopeContext)
				{
					context.ApplyExitInstructions(scopeContext);
					if (scopeContext->exitStatement)
					{
						GenerateStatementInstructions(context, scopeContext->exitStatement);
					}
				}

				void ApplyCurrentScopeExitCode()
				{
					auto scopeContext = context.functionContext->GetCurrentScopeContext();
					ApplyExitCode(scopeContext);
				}

				void InlineScopeExitCode(WfCodegenScopeType untilScopeType, bool exclusive)
				{
					vint index = context.functionContext->scopeContextStack.Count() - 1;
					while (index >= 0)
					{
						auto scopeContext = context.functionContext->scopeContextStack[index];
						if (exclusive && scopeContext->type == untilScopeType) break;
						ApplyExitCode(scopeContext);
						if (!exclusive && scopeContext->type == untilScopeType) break;
						index--;
					}
				}

				void Visit(WfBreakStatement* node)override
				{
					InlineScopeExitCode(WfCodegenScopeType::Loop, false);
					context.functionContext->GetCurrentScopeContext(WfCodegenScopeType::Loop)->breakInstructions.Add(INSTRUCTION(Ins::Jump(-1)));
				}

				void Visit(WfContinueStatement* node)override
				{
					InlineScopeExitCode(WfCodegenScopeType::Loop, true);
					context.functionContext->GetCurrentScopeContext(WfCodegenScopeType::Loop)->continueInstructions.Add(INSTRUCTION(Ins::Jump(-1)));
				}

				void Visit(WfReturnStatement* node)override
				{
					InlineScopeExitCode(WfCodegenScopeType::Function, false);
					if (node->expression)
					{
						GenerateExpressionInstructions(context, node->expression);
					}
					else
					{
						INSTRUCTION(Ins::LoadValue(Value()));
					}
					INSTRUCTION(Ins::Return());
				}

				void Visit(WfDeleteStatement* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::DeleteRawPtr());
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						GenerateExpressionInstructions(context, node->expression);
					}
					else
					{
						auto scope = context.manager->statementScopes[node];
						while (scope)
						{
							if (auto tryCatch = scope->ownerStatement.Cast<WfTryStatement>())
							{
								if (tryCatch->name.value != L"")
								{
									auto symbol = scope->symbols[tryCatch->name.value][0].Obj();
									vint index = context.functionContext->localVariables[symbol];
									INSTRUCTION(Ins::LoadLocalVar(index));
									break;
								}
							}
							scope = scope->parentScope;
						}
					}
					InlineScopeExitCode(WfCodegenScopeType::TryCatch, true);
					INSTRUCTION(Ins::RaiseException());
				}

				void Visit(WfIfStatement* node)override
				{
					vint variableIndex = -1;

					GenerateExpressionInstructions(context, node->expression);
					if (node->name.value != L"")
					{
						auto scope = context.manager->statementScopes[node];
						auto symbol = scope->symbols[node->name.value][0];
						auto function = context.functionContext->function;
						variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<if>" + node->name.value);
						context.functionContext->localVariables.Add(symbol.Obj(), variableIndex);

						GenerateTypeCastInstructions(context, symbol->typeInfo, false, node->expression.Obj());
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::CompareReference());
					}
					else
					{
						INSTRUCTION(Ins::OpNot(WfInsType::Bool));
					}
					vint fillElseIndex = INSTRUCTION(Ins::JumpIf(-1));

					GenerateStatementInstructions(context, node->trueBranch);
					if (variableIndex != -1)
					{
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
					}
					vint fillEndIndex = INSTRUCTION(Ins::Jump(-1));
					context.assembly->instructions[fillElseIndex].indexParameter = context.assembly->instructions.Count();

					if (node->falseBranch)
					{
						GenerateStatementInstructions(context, node->falseBranch);
					}
					context.assembly->instructions[fillEndIndex].indexParameter = context.assembly->instructions.Count();
				}

				void Visit(WfSwitchStatement* node)override
				{
					auto function = context.functionContext->function;
					vint variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<switch>");
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::StoreLocalVar(variableIndex));
					auto switchContext = context.functionContext->PushScopeContext(WfCodegenScopeType::Switch);
					{
						EXIT_CODE(Ins::LoadValue(Value()));
						EXIT_CODE(Ins::StoreLocalVar(variableIndex));
					}

					List<vint> caseInstructions, caseLabelIndices, breakInstructions;
					auto expressionResult = context.manager->expressionResolvings[node->expression.Obj()];
					auto expressionType = expressionResult.expectedType ? expressionResult.expectedType : expressionResult.type;
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						auto caseResult = context.manager->expressionResolvings[switchCase->expression.Obj()];
						auto caseType = caseResult.expectedType ? caseResult.expectedType : caseResult.type;
						auto mergedType = GetMergedType(expressionType, caseType);

						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
						if (!IsSameType(expressionType.Obj(), mergedType.Obj()))
						{
							GenerateTypeCastInstructions(context, mergedType, true, switchCase->expression.Obj());
						}
						GenerateExpressionInstructions(context, switchCase->expression);
						if (!IsSameType(caseType.Obj(), mergedType.Obj()))
						{
							GenerateTypeCastInstructions(context, mergedType, true, switchCase->expression.Obj());
						}
						if (mergedType->GetDecorator() == ITypeInfo::RawPtr || mergedType->GetDecorator() == ITypeInfo::SharedPtr)
						{
							INSTRUCTION(Ins::CompareReference());
							INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						}
						else
						{
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpNE());
						}
						caseInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));

						GenerateStatementInstructions(context, switchCase->statement);
						breakInstructions.Add(INSTRUCTION(Ins::Jump(-1)));
						caseLabelIndices.Add(context.assembly->instructions.Count());
					}

					if (node->defaultBranch)
					{
						GenerateStatementInstructions(context, node->defaultBranch);
					}
					
					vint breakLabelIndex = context.assembly->instructions.Count();
					for (vint i = 0; i < caseInstructions.Count(); i++)
					{
						context.assembly->instructions[caseInstructions[i]].indexParameter = caseLabelIndices[i];
					}
					FOREACH(vint, index, breakInstructions)
					{
						context.assembly->instructions[index].indexParameter = breakLabelIndex;
					}
					ApplyCurrentScopeExitCode();
					context.functionContext->PopScopeContext();
				}

				void Visit(WfWhileStatement* node)override
				{
					vint continueLabelIndex = -1;
					vint breakLabelIndex = -1;
					vint loopLabelIndex = -1;
					auto loopContext = context.functionContext->PushScopeContext(WfCodegenScopeType::Loop);

					loopLabelIndex = context.assembly->instructions.Count();
					continueLabelIndex = context.assembly->instructions.Count();
					GenerateExpressionInstructions(context, node->condition);
					INSTRUCTION(Ins::OpNot(WfInsType::Bool));
					loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
					GenerateStatementInstructions(context, node->statement);
					INSTRUCTION(Ins::Jump(loopLabelIndex));
					breakLabelIndex = context.assembly->instructions.Count();

					FOREACH(vint, index, loopContext->continueInstructions)
					{
						context.assembly->instructions[index].indexParameter = continueLabelIndex;
					}
					FOREACH(vint, index, loopContext->breakInstructions)
					{
						context.assembly->instructions[index].indexParameter = breakLabelIndex;
					}
					context.functionContext->PopScopeContext();
				}

				void Visit(WfForEachStatement* node)override
				{
					vint continueLabelIndex = -1;
					vint breakLabelIndex = -1;
					vint loopLabelIndex = -1;
					auto loopContext = context.functionContext->PushScopeContext(WfCodegenScopeType::Loop);

					auto scope = context.manager->statementScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					auto function = context.functionContext->function;
					vint elementIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for>" + node->name.value);
					{
						EXIT_CODE(Ins::LoadValue(Value()));
						EXIT_CODE(Ins::StoreLocalVar(elementIndex));
					}
					context.functionContext->localVariables.Add(symbol.Obj(), elementIndex);

					if (auto range = node->collection.Cast<WfRangeExpression>())
					{
						auto typeArgument = GetInstructionTypeArgument(symbol->typeInfo);
						vint beginIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for-begin>" + node->name.value);
						vint endIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for-end>" + node->name.value);
						{
							EXIT_CODE(Ins::LoadValue(Value()));
							EXIT_CODE(Ins::StoreLocalVar(beginIndex));
							EXIT_CODE(Ins::LoadValue(Value()));
							EXIT_CODE(Ins::StoreLocalVar(endIndex));
						}
						GenerateExpressionInstructions(context, range->begin, symbol->typeInfo);
						if (range->beginBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
							INSTRUCTION(Ins::OpAdd(typeArgument));
						}
						INSTRUCTION(Ins::StoreLocalVar(beginIndex));
						GenerateExpressionInstructions(context, range->end, symbol->typeInfo);
						if (range->endBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
							INSTRUCTION(Ins::OpSub(typeArgument));
						}
						INSTRUCTION(Ins::StoreLocalVar(endIndex));

						if (node->direction == WfForEachDirection::Normal)
						{
							INSTRUCTION(Ins::LoadLocalVar(beginIndex));
							INSTRUCTION(Ins::StoreLocalVar(elementIndex));
							loopLabelIndex = INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadLocalVar(endIndex));
							INSTRUCTION(Ins::CompareLiteral(typeArgument));
							INSTRUCTION(Ins::OpGT());
							loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
						}
						else
						{
							INSTRUCTION(Ins::LoadLocalVar(endIndex));
							INSTRUCTION(Ins::StoreLocalVar(elementIndex));
							loopLabelIndex = INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadLocalVar(beginIndex));
							INSTRUCTION(Ins::CompareLiteral(typeArgument));
							INSTRUCTION(Ins::OpLT());
							loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
						}
						GenerateStatementInstructions(context, node->statement);
						continueLabelIndex = context.assembly->instructions.Count();
						if (node->direction == WfForEachDirection::Normal)
						{
							INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadLocalVar(endIndex));
							INSTRUCTION(Ins::CompareLiteral(typeArgument));
							INSTRUCTION(Ins::OpEQ());
							loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
							INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
							INSTRUCTION(Ins::OpAdd(typeArgument));
							INSTRUCTION(Ins::StoreLocalVar(elementIndex));
						}
						else
						{
							INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadLocalVar(beginIndex));
							INSTRUCTION(Ins::CompareLiteral(typeArgument));
							INSTRUCTION(Ins::OpEQ());
							loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
							INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
							INSTRUCTION(Ins::OpSub(typeArgument));
							INSTRUCTION(Ins::StoreLocalVar(elementIndex));
						}
						INSTRUCTION(Ins::Jump(loopLabelIndex));

						breakLabelIndex = context.assembly->instructions.Count();
					}
					else
					{
						vint enumerableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for-enumerable>" + node->name.value);
						vint enumeratorIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for-enumerator>" + node->name.value);
						{
							EXIT_CODE(Ins::LoadValue(Value()));
							EXIT_CODE(Ins::StoreLocalVar(enumerableIndex));
							EXIT_CODE(Ins::LoadValue(Value()));
							EXIT_CODE(Ins::StoreLocalVar(enumeratorIndex));
						}
						auto methodCreateEnumerator = description::GetTypeDescriptor<IValueEnumerable>()->GetMethodGroupByName(L"CreateEnumerator", true)->GetMethod(0);
						auto methodNext = description::GetTypeDescriptor<IValueEnumerator>()->GetMethodGroupByName(L"Next", true)->GetMethod(0);
						auto methodGetCurrent = description::GetTypeDescriptor<IValueEnumerator>()->GetMethodGroupByName(L"GetCurrent", true)->GetMethod(0);

						GenerateExpressionInstructions(context, node->collection);
						if (node->direction == WfForEachDirection::Reversed)
						{
							INSTRUCTION(Ins::ReverseEnumerable());
						}
						INSTRUCTION(Ins::StoreLocalVar(enumerableIndex));
						INSTRUCTION(Ins::LoadLocalVar(enumerableIndex));
						INSTRUCTION(Ins::InvokeMethod(methodCreateEnumerator, 0));
						INSTRUCTION(Ins::StoreLocalVar(enumeratorIndex));
						
						loopLabelIndex = INSTRUCTION(Ins::LoadLocalVar(elementIndex));
						INSTRUCTION(Ins::LoadLocalVar(enumeratorIndex));
						INSTRUCTION(Ins::InvokeMethod(methodNext, 0));
						INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
						INSTRUCTION(Ins::LoadLocalVar(enumeratorIndex));
						INSTRUCTION(Ins::InvokeMethod(methodGetCurrent, 0));
						INSTRUCTION(Ins::StoreLocalVar(elementIndex));
						GenerateStatementInstructions(context, node->statement);
						continueLabelIndex = context.assembly->instructions.Count();
						INSTRUCTION(Ins::Jump(loopLabelIndex));

						breakLabelIndex = context.assembly->instructions.Count();
					}
					ApplyCurrentScopeExitCode();

					FOREACH(vint, index, loopContext->continueInstructions)
					{
						context.assembly->instructions[index].indexParameter = continueLabelIndex;
					}
					FOREACH(vint, index, loopContext->breakInstructions)
					{
						context.assembly->instructions[index].indexParameter = breakLabelIndex;
					}
					context.functionContext->PopScopeContext();
				}

				void VisitTryCatch(WfTryStatement* node)
				{
					if (!node->catchStatement)
					{
						GenerateStatementInstructions(context, node->protectedStatement);
					}
					else
					{
						auto catchContext = context.functionContext->PushScopeContext(WfCodegenScopeType::TryCatch);
						EXIT_CODE(Ins::UninstallTry(0));

						vint trapInstruction = INSTRUCTION(Ins::InstallTry(-1));
						GenerateStatementInstructions(context, node->protectedStatement);
						INSTRUCTION(Ins::UninstallTry(0));
						vint finishInstruction = INSTRUCTION(Ins::Jump(-1));
						context.functionContext->PopScopeContext();
						
						context.assembly->instructions[trapInstruction].indexParameter = context.assembly->instructions.Count();
						auto scope = context.manager->statementScopes[node].Obj();
						auto symbol = scope->symbols[node->name.value][0].Obj();
						auto function = context.functionContext->function;
						vint variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<catch>" + node->name.value);
						context.functionContext->localVariables.Add(symbol, variableIndex);
						INSTRUCTION(Ins::LoadException());
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
						GenerateStatementInstructions(context, node->catchStatement);
						
						context.assembly->instructions[finishInstruction].indexParameter = context.assembly->instructions.Count();
					}
				}

				void VisitTryFinally(WfTryStatement* node)
				{
					if (!node->finallyStatement)
					{
						VisitTryCatch(node);
					}
					else
					{
						auto catchContext = context.functionContext->PushScopeContext(WfCodegenScopeType::TryCatch);
						EXIT_CODE(Ins::UninstallTry(0));
						catchContext->exitStatement = node->finallyStatement;
						
						auto function = context.functionContext->function;
						vint variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<try-finally-exception>");
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
						vint trapInstruction = INSTRUCTION(Ins::InstallTry(-1));
						VisitTryCatch(node);
						INSTRUCTION(Ins::UninstallTry(0));
						vint untrapInstruction = INSTRUCTION(Ins::Jump(-1));
						context.functionContext->PopScopeContext();

						context.assembly->instructions[trapInstruction].indexParameter = context.assembly->instructions.Count();
						INSTRUCTION(Ins::LoadException());
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));

						context.assembly->instructions[untrapInstruction].indexParameter = context.assembly->instructions.Count();
						GenerateStatementInstructions(context, node->finallyStatement);

						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::CompareReference());
						vint finishInstruction = INSTRUCTION(Ins::JumpIf(-1));
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
						INSTRUCTION(Ins::RaiseException());
						context.assembly->instructions[finishInstruction].indexParameter = context.assembly->instructions.Count();
					}
				}

				void Visit(WfTryStatement* node)override
				{
					VisitTryFinally(node);
				}

				void Visit(WfBlockStatement* node)override
				{
					FOREACH(Ptr<WfStatement>, statement, node->statements)
					{
						GenerateStatementInstructions(context, statement);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::Pop());
				}

				void Visit(WfVariableStatement* node)override
				{
					auto manager = context.manager;
					auto scope = manager->declarationScopes[node->variable.Obj()];
					auto symbol = scope->symbols[node->variable->name.value][0].Obj();
					auto function = context.functionContext->function;
					vint index = function->argumentNames.Count() + function->localVariableNames.Add(node->variable->name.value);
					context.functionContext->localVariables.Add(symbol, index);

					GenerateExpressionInstructions(context, node->variable->expression);
					INSTRUCTION(Ins::StoreLocalVar(index));
				}
			};

#undef EXIT_CODE
#undef INSTRUCTION

			void GenerateStatementInstructions(WfCodegenContext& context, Ptr<WfStatement> statement)
			{
				GenerateStatementInstructionsVisitor visitor(context);
				statement->Accept(&visitor);
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_MISC.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
IsExpressionDependOnExpectedType(Expression)
***********************************************************************/

			class IsExpressionDependOnExpectedTypeVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				bool								result;

				IsExpressionDependOnExpectedTypeVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
					, result(false)
				{
				}

				bool Execute(Ptr<WfExpression> expression)
				{
					result = false;
					expression->Accept(this);
					return result;
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();
					result = scope->symbols.Count() > 0;
				}

				void Visit(WfMemberExpression* node)override
				{
				}

				void Visit(WfChildExpression* node)override
				{
				}

				void Visit(WfLiteralExpression* node)override
				{
					if (node->value == WfLiteralValue::Null)
					{
						result = true;
					}
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
				}

				void Visit(WfUnaryExpression* node)override
				{
				}

				void Visit(WfBinaryExpression* node)override
				{
				}

				void Visit(WfLetExpression* node)override
				{
				}

				void Visit(WfIfExpression* node)override
				{
					result = Execute(node->trueBranch) && Execute(node->falseBranch);
				}

				void Visit(WfRangeExpression* node)override
				{
				}

				void Visit(WfSetTestingExpression* node)override
				{
				}

				void Visit(WfConstructorExpression* node)override
				{
					result = node->arguments.Count() == 0;
				}

				void Visit(WfInferExpression* node)override
				{
				}

				void Visit(WfTypeCastingExpression* node)override
				{
				}

				void Visit(WfTypeTestingExpression* node)override
				{
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
				}

				void Visit(WfAttachEventExpression* node)override
				{
				}

				void Visit(WfDetachEventExpression* node)override
				{
				}

				void Visit(WfBindExpression* node)override
				{
				}

				void Visit(WfObserveExpression* node)override
				{
				}

				void Visit(WfCallExpression* node)override
				{
				}

				void Visit(WfFunctionExpression* node)override
				{
				}

				void Visit(WfNewTypeExpression* node)override
				{
				}
			};

			bool IsExpressionDependOnExpectedType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				IsExpressionDependOnExpectedTypeVisitor visitor(manager);
				expression->Accept(&visitor);
				return visitor.result;
			}

/***********************************************************************
GetExpressionName(Expression)
***********************************************************************/

			class GetExpressionNameVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WString								result;

				void Visit(WfTopQualifiedExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfReferenceExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
				}

				void Visit(WfMemberExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfChildExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
				}

				void Visit(WfUnaryExpression* node)override
				{
				}

				void Visit(WfBinaryExpression* node)override
				{
				}

				void Visit(WfLetExpression* node)override
				{
				}

				void Visit(WfIfExpression* node)override
				{
				}

				void Visit(WfRangeExpression* node)override
				{
				}

				void Visit(WfSetTestingExpression* node)override
				{
				}

				void Visit(WfConstructorExpression* node)override
				{
				}

				void Visit(WfInferExpression* node)override
				{
				}

				void Visit(WfTypeCastingExpression* node)override
				{
				}

				void Visit(WfTypeTestingExpression* node)override
				{
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
				}

				void Visit(WfAttachEventExpression* node)override
				{
				}

				void Visit(WfDetachEventExpression* node)override
				{
				}

				void Visit(WfBindExpression* node)override
				{
				}

				void Visit(WfObserveExpression* node)override
				{
				}

				void Visit(WfCallExpression* node)override
				{
				}

				void Visit(WfFunctionExpression* node)override
				{
				}

				void Visit(WfNewTypeExpression* node)override
				{
				}
			};

			WString GetExpressionName(Ptr<WfExpression> expression)
			{
				GetExpressionNameVisitor visitor;
				expression->Accept(&visitor);
				return visitor.result;
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_SEARCHORDEREDNAME.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;

/***********************************************************************
SearchOrderedName(Declaration)
***********************************************************************/

			class SearchOrderedNameDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScope*							scope;
				SortedList<vint>&						names;

				SearchOrderedNameDeclarationVisitor(WfLexicalScope* _scope, SortedList<vint>& _names)
					:scope(_scope)
					, names(_names)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					FOREACH(Ptr<WfDeclaration>, declaration, node->declarations)
					{
						SearchOrderedName(scope, declaration, names);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					SearchOrderedName(scope, node->statement, names);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					SearchOrderedName(scope, node->expression, names);
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					FOREACH(Ptr<WfClassMember>, member, node->members)
					{
						SearchOrderedName(scope, member->declaration, names);
					}
				}

				static void Execute(WfLexicalScope* scope, Ptr<WfDeclaration> declaration, SortedList<vint>& names)
				{
					SearchOrderedNameDeclarationVisitor visitor(scope, names);
					declaration->Accept(&visitor);
				}
			};

/***********************************************************************
SearchOrderedName(Statement)
***********************************************************************/

			class SearchOrderedNameStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfLexicalScope*							scope;
				SortedList<vint>&						names;

				SearchOrderedNameStatementVisitor(WfLexicalScope* _scope, SortedList<vint>& _names)
					:scope(_scope)
					, names(_names)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
				}

				void Visit(WfContinueStatement* node)override
				{
				}

				void Visit(WfReturnStatement* node)override
				{
					if (node->expression)
					{
						SearchOrderedName(scope, node->expression, names);
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					SearchOrderedName(scope, node->expression, names);
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						SearchOrderedName(scope, node->expression, names);
					}
				}

				void Visit(WfIfStatement* node)override
				{
					SearchOrderedName(scope, node->expression, names);
					node->trueBranch->Accept(this);
					if (node->falseBranch)
					{
						node->falseBranch->Accept(this);
					}
				}

				void Visit(WfSwitchStatement* node)override
				{
					SearchOrderedName(scope, node->expression, names);
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						SearchOrderedName(scope, switchCase->expression, names);
						switchCase->statement->Accept(this);
					}
					if (node->defaultBranch)
					{
						node->defaultBranch->Accept(this);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					SearchOrderedName(scope, node->condition, names);
					node->statement->Accept(this);
				}

				void Visit(WfForEachStatement* node)override
				{
					SearchOrderedName(scope, node->collection, names);
					node->statement->Accept(this);
				}

				void Visit(WfTryStatement* node)override
				{
					node->protectedStatement->Accept(this);
					if (node->catchStatement)
					{
						node->catchStatement->Accept(this);
					}
					if (node->finallyStatement)
					{
						node->finallyStatement->Accept(this);
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					FOREACH(Ptr<WfStatement>, statement, node->statements)
					{
						statement->Accept(this);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					SearchOrderedName(scope, node->expression, names);
				}

				void Visit(WfVariableStatement* node)override
				{
					SearchOrderedName(scope, node->variable.Cast<WfDeclaration>(), names);
				}

				static void Execute(WfLexicalScope* scope, Ptr<WfStatement> statement, SortedList<vint>& names)
				{
					SearchOrderedNameStatementVisitor visitor(scope, names);
					statement->Accept(&visitor);
				}
			};

/***********************************************************************
SearchOrderedName(Expression)
***********************************************************************/

			class SearchOrderedNameExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScope*							scope;
				SortedList<vint>&						names;

				SearchOrderedNameExpressionVisitor(WfLexicalScope* _scope, SortedList<vint>& _names)
					:scope(_scope)
					, names(_names)
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					vint name = wtoi(node->name.value.Sub(1, node->name.value.Length() - 1));
					if (!names.Contains(name))
					{
						WfLexicalScope* currentScope = scope;
						while (currentScope)
						{
							if (currentScope->symbols.Keys().Contains(node->name.value))
							{
								return;
							}
							currentScope = currentScope->parentScope.Obj();
						}
						names.Add(name);
					}
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					// names in nested ordered lambda expression is not counted
				}

				void Visit(WfMemberExpression* node)override
				{
					node->parent->Accept(this);
				}

				void Visit(WfChildExpression* node)override
				{
					node->parent->Accept(this);
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
					if (node->expandedExpression)
					{
						node->expandedExpression->Accept(this);
					}
				}

				void Visit(WfUnaryExpression* node)override
				{
					node->operand->Accept(this);
				}

				void Visit(WfBinaryExpression* node)override
				{
					node->first->Accept(this);
					node->second->Accept(this);
				}

				void Visit(WfLetExpression* node)override
				{
					FOREACH(Ptr<WfLetVariable>, variable, node->variables)
					{
						variable->value->Accept(this);
					}
					
					node->expression->Accept(this);
				}

				void Visit(WfIfExpression* node)override
				{
					node->condition->Accept(this);
					node->trueBranch->Accept(this);
					node->falseBranch->Accept(this);
				}

				void Visit(WfRangeExpression* node)override
				{
					node->begin->Accept(this);
					node->end->Accept(this);
				}

				void Visit(WfSetTestingExpression* node)override
				{
					node->element->Accept(this);
					node->collection->Accept(this);
				}

				void Visit(WfConstructorExpression* node)override
				{
					FOREACH(Ptr<WfConstructorArgument>, argument, node->arguments)
					{
						argument->value->Accept(this);
					}
				}

				void Visit(WfInferExpression* node)override
				{
					node->expression->Accept(this);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					node->expression->Accept(this);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					if (node->expression)
					{
						node->expression->Accept(this);
					}
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					node->expression->Accept(this);
				}

				void Visit(WfAttachEventExpression* node)override
				{
					node->event->Accept(this);
					node->function->Accept(this);
				}

				void Visit(WfDetachEventExpression* node)override
				{
					node->handler->Accept(this);
				}

				void Visit(WfBindExpression* node)override
				{
					node->expression->Accept(this);
				}

				void Visit(WfObserveExpression* node)override
				{
					node->parent->Accept(this);
					node->expression->Accept(this);
					FOREACH(Ptr<WfExpression>, event, node->events)
					{
						event->Accept(this);
					}
				}

				void Visit(WfCallExpression* node)override
				{
					node->function->Accept(this);
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						argument->Accept(this);
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					SearchOrderedName(scope, node->function.Cast<WfDeclaration>(), names);
				}

				void Visit(WfNewTypeExpression* node)override
				{
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						argument->Accept(this);
					}

					FOREACH(Ptr<WfFunctionDeclaration>, function, node->functions)
					{
						SearchOrderedName(scope, function.Cast<WfDeclaration>(), names);
					}
				}

				static void Execute(WfLexicalScope* scope, Ptr<WfExpression> expression, SortedList<vint>& names)
				{
					SearchOrderedNameExpressionVisitor visitor(scope, names);
					expression->Accept(&visitor);
				}
			};

/***********************************************************************
SearchOrderedName
***********************************************************************/

			void SearchOrderedName(WfLexicalScope* scope, Ptr<WfDeclaration> declaration, collections::SortedList<vint>& names)
			{
				SearchOrderedNameDeclarationVisitor::Execute(scope, declaration, names);
			}

			void SearchOrderedName(WfLexicalScope* scope, Ptr<WfStatement> statement, collections::SortedList<vint>& names)
			{
				SearchOrderedNameStatementVisitor::Execute(scope, statement, names);
			}

			void SearchOrderedName(WfLexicalScope* scope, Ptr<WfExpression> expression, collections::SortedList<vint>& names)
			{
				SearchOrderedNameExpressionVisitor::Execute(scope, expression, names);
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_TYPEINFO.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
GetTypeFlag
***********************************************************************/

			TypeFlag GetTypeFlag(reflection::description::ITypeDescriptor* typeDescriptor)
			{
				if (typeDescriptor == GetTypeDescriptor<bool>())		return TypeFlag::Bool;
				if (typeDescriptor == GetTypeDescriptor<vint8_t>())		return TypeFlag::I1;
				if (typeDescriptor == GetTypeDescriptor<vint16_t>())	return TypeFlag::I2;
				if (typeDescriptor == GetTypeDescriptor<vint32_t>())	return TypeFlag::I4;
				if (typeDescriptor == GetTypeDescriptor<vint64_t>())	return TypeFlag::I8;
				if (typeDescriptor == GetTypeDescriptor<vuint8_t>())	return TypeFlag::U1;
				if (typeDescriptor == GetTypeDescriptor<vuint16_t>())	return TypeFlag::U2;
				if (typeDescriptor == GetTypeDescriptor<vuint32_t>())	return TypeFlag::U4;
				if (typeDescriptor == GetTypeDescriptor<vuint64_t>())	return TypeFlag::U8;
				if (typeDescriptor == GetTypeDescriptor<float>())		return TypeFlag::F4;
				if (typeDescriptor == GetTypeDescriptor<double>())		return TypeFlag::F8;
				if (typeDescriptor == GetTypeDescriptor<WString>())		return TypeFlag::String;
				return TypeFlag::Others;
			}

			TypeFlag GetTypeFlag(reflection::description::ITypeInfo* typeInfo)
			{
				ITypeDescriptor* td = typeInfo->GetTypeDescriptor();
				return GetTypeFlag(td);
			}

/***********************************************************************
CreateTypeInfoFromTypeFlag
***********************************************************************/

			Ptr<reflection::description::ITypeInfo> CreateTypeInfoFromTypeFlag(TypeFlag flag)
			{
				switch (flag)
				{
				case TypeFlag::Bool:	return TypeInfoRetriver<bool>::CreateTypeInfo();
				case TypeFlag::I1:		return TypeInfoRetriver<vint8_t>::CreateTypeInfo();
				case TypeFlag::I2:		return TypeInfoRetriver<vint16_t>::CreateTypeInfo();
				case TypeFlag::I4:		return TypeInfoRetriver<vint32_t>::CreateTypeInfo();
				case TypeFlag::I8:		return TypeInfoRetriver<vint64_t>::CreateTypeInfo();
				case TypeFlag::U1:		return TypeInfoRetriver<vuint8_t>::CreateTypeInfo();
				case TypeFlag::U2:		return TypeInfoRetriver<vuint16_t>::CreateTypeInfo();
				case TypeFlag::U4:		return TypeInfoRetriver<vuint32_t>::CreateTypeInfo();
				case TypeFlag::U8:		return TypeInfoRetriver<vuint64_t>::CreateTypeInfo();
				case TypeFlag::F4:		return TypeInfoRetriver<float>::CreateTypeInfo();
				case TypeFlag::F8:		return TypeInfoRetriver<double>::CreateTypeInfo();
				case TypeFlag::String:	return TypeInfoRetriver<WString>::CreateTypeInfo();
				default:;
				}
				return 0;
			}

/***********************************************************************
GetTypeFromTypeInfo
***********************************************************************/

			Ptr<WfType> GetTypeFromTypeInfo(reflection::description::ITypeInfo* typeInfo)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::RawPtr:
					{
						Ptr<WfType> element = GetTypeFromTypeInfo(typeInfo->GetElementType());
						if (element)
						{
							Ptr<WfRawPointerType> type = new WfRawPointerType;
							type->element = element;
							return type;
						}
						return 0;
					}
				case ITypeInfo::SharedPtr:
					{
						if (typeInfo->GetElementType()->GetDecorator() == ITypeInfo::Generic)
						{
							return GetTypeFromTypeInfo(typeInfo->GetElementType());
						}
						else
						{
							Ptr<WfType> element = GetTypeFromTypeInfo(typeInfo->GetElementType());
							if (element)
							{
								Ptr<WfSharedPointerType> type = new WfSharedPointerType;
								type->element = element;
								return type;
							}
							return 0;
						}
					}
				case ITypeInfo::Nullable:
					{
						Ptr<WfType> element = GetTypeFromTypeInfo(typeInfo->GetElementType());
						if (element)
						{
							Ptr<WfNullableType> type = new WfNullableType;
							type->element = element;
							return type;
						}
						return 0;
					}
				case ITypeInfo::TypeDescriptor:
					{
						List<WString> fragments;
						{
							WString name = typeInfo->GetTypeDescriptor()->GetTypeName();
							const wchar_t* reading = name.Buffer();
							while (reading)
							{
								const wchar_t* delimiter = wcsstr(reading, L"::");
								if (delimiter)
								{
									fragments.Add(WString(reading, vint(delimiter - reading)));
									reading = delimiter + 2;
								}
								else
								{
									fragments.Add(reading);
									break;
								}
							}
						}

						Ptr<WfType> parentType;
						FOREACH(WString, fragment, fragments)
						{
							if (!parentType)
							{
								Ptr<WfTopQualifiedType> type = new WfTopQualifiedType;
								type->name.value = fragment;
								parentType = type;
							}
							else
							{
								Ptr<WfChildType> type = new WfChildType;
								type->parent = parentType;
								type->name.value = fragment;
								parentType = type;
							}
						}
						return parentType;
					}
				case ITypeInfo::Generic:
					{
						if (typeInfo->GetElementType()->GetDecorator() == ITypeInfo::TypeDescriptor)
						{
							if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueEnumerable>())
							{
								if (typeInfo->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> elementType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									{
										Ptr<WfEnumerableType> type = new WfEnumerableType;
										type->element = elementType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueReadonlyList>())
							{
								if (typeInfo->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									{
										Ptr<WfMapType> type = new WfMapType;
										type->writability = WfMapWritability::Readonly;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueList>())
							{
								if (typeInfo->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									{
										Ptr<WfMapType> type = new WfMapType;
										type->writability = WfMapWritability::Writable;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueReadonlyDictionary>())
							{
								if (typeInfo->GetGenericArgumentCount() == 2)
								{
									if (Ptr<WfType> keyType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(1)))
									{
										Ptr<WfMapType> type = new WfMapType;
										type->writability = WfMapWritability::Readonly;
										type->key = keyType;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueDictionary>())
							{
								if (typeInfo->GetGenericArgumentCount() == 2)
								{
									if (Ptr<WfType> keyType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(1)))
									{
										Ptr<WfMapType> type = new WfMapType;
										type->writability = WfMapWritability::Writable;
										type->key = keyType;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueFunctionProxy>())
							{
								if (typeInfo->GetGenericArgumentCount() >= 1)
								{
									if (Ptr<WfType> returnType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									{
										Ptr<WfFunctionType> type = new WfFunctionType;
										type->result = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0));
										for (vint i = 1; i < typeInfo->GetGenericArgumentCount(); i++)
										{
											if (Ptr<WfType> argumentType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(i)))
											{
												type->arguments.Add(argumentType);
											}
											else
											{
												return 0;
											}
										}
										return type;
									}
								}
							}
						}
						return 0;
					}
				default:
					return 0;
				}
			}

/***********************************************************************
GetScopeNameFromReferenceType
***********************************************************************/

			class GetScopeNameFromReferenceTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScope*				scope;
				Ptr<WfLexicalScopeName>		result;

				GetScopeNameFromReferenceTypeVisitor(WfLexicalScope* _scope)
					:scope(_scope)
				{
				}

				Ptr<WfLexicalScopeName> Call(WfType* node)
				{
					node->Accept(this);
					Ptr<WfLexicalScopeName> scopeName = result;
					result = 0;
					return scopeName;
				}

				void Visit(WfPredefinedType* node)override
				{
					WString name;
					switch (node->name)
					{
					case WfPredefinedTypeName::Void:
						name = L"Void";
						break;
					case WfPredefinedTypeName::Object:
						name = L"Object";
						break;
					case WfPredefinedTypeName::Interface:
						name = L"Interface";
						break;
					case WfPredefinedTypeName::Int:
#if defined VCZH_64
						name = L"Int64";
#else
						name = L"Int32";
#endif
						break;
					case WfPredefinedTypeName::UInt:
#if defined VCZH_64
						name = L"UInt64";
#else
						name = L"UInt32";
#endif
						break;
					case WfPredefinedTypeName::Float:
						name = L"Single";
						break;
					case WfPredefinedTypeName::Double:
						name = L"Double";
						break;
					case WfPredefinedTypeName::String:
						name = L"String";
						break;
					case WfPredefinedTypeName::Char:
						name = L"Char";
						break;
					case WfPredefinedTypeName::Bool:
						name = L"Boolean";
						break;
					default:
						CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfPredefinedType*)#Internal error, ValidateTypeStructure function should check correctly.");
					}

					Ptr<WfTopQualifiedType> ns = new WfTopQualifiedType;
					ns->name.value = L"system";

					Ptr<WfChildType> type = new WfChildType;
					type->parent = ns;
					type->name.value = name;

					type->Accept(this);
				}

				void Visit(WfTopQualifiedType* node)override
				{
					auto manager = scope->FindManager();
					if (manager->globalName)
					{
						vint index = manager->globalName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							result = manager->globalName->children.Values()[index];
							return;
						}
					}
					manager->errors.Add(WfErrors::TopQualifiedSymbolNotExists(node, node->name.value));
				}

				void Visit(WfReferenceType* node)override
				{
					auto manager = scope->FindManager();

					List<Ptr<WfLexicalSymbol>> symbols;
					manager->ResolveSymbol(scope, node->name.value, symbols);
					if (symbols.Count() > 1)
					{
						manager->errors.Add(WfErrors::TooManyTargets(node, symbols, node->name.value));
						return;
					}
					else if (symbols.Count() == 1)
					{
						manager->errors.Add(WfErrors::TypeNotExists(node, symbols[0]));
						return;
					}

					List<Ptr<WfLexicalScopeName>> scopeNames;
					manager->ResolveScopeName(scope, node->name.value, scopeNames);
					if (scopeNames.Count() > 1)
					{
						manager->errors.Add(WfErrors::TooManyTargets(node, scopeNames, node->name.value));
					}
					else if (scopeNames.Count() == 1)
					{
						result = scopeNames[0];
					}
					else
					{
						manager->errors.Add(WfErrors::ReferenceNotExists(node, node->name.value));
					}
				}

				void Visit(WfRawPointerType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfRawPointerType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfSharedPointerType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfSharedPointerType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfNullableType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfNullableType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfEnumerableType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfEnumerableType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfMapType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfMapType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfFunctionType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfFunctionType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfChildType* node)override
				{
					if (Ptr<WfLexicalScopeName> scopeName = Call(node->parent.Obj()))
					{
						vint index = scopeName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							result = scopeName->children.Values()[index];
							return;
						}
						scope->FindManager()->errors.Add(WfErrors::ChildSymbolNotExists(node, scopeName, node->name.value));
					}
				}

				static Ptr<WfLexicalScopeName> Execute(WfLexicalScope* scope, WfType* type)
				{
					return GetScopeNameFromReferenceTypeVisitor(scope).Call(type);
				}
			};

			Ptr<WfLexicalScopeName> GetScopeNameFromReferenceType(WfLexicalScope* scope, Ptr<WfType> type)
			{
				return GetScopeNameFromReferenceTypeVisitor::Execute(scope, type.Obj());
			}

/***********************************************************************
CreateTypeInfoFromType
***********************************************************************/

			class CreateTypeInfoFromTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScope*				scope;
				Ptr<ITypeInfo>				result;

				CreateTypeInfoFromTypeVisitor(WfLexicalScope* _scope)
					:scope(_scope)
				{
				}

				Ptr<ITypeInfo> Call(WfType* node, bool checkTypeForValue)
				{
					node->Accept(this);
					Ptr<ITypeInfo> typeInfo = result;
					result = 0;
					if (typeInfo)
					{
						auto manager = scope->FindManager();
						switch (typeInfo->GetDecorator())
						{
						case ITypeInfo::RawPtr:
						case ITypeInfo::SharedPtr:
							{
								auto element = typeInfo->GetElementType();
								if (element->GetDecorator() == ITypeInfo::Generic)
								{
									element = element->GetElementType();
								}

								if (element->GetDecorator() == ITypeInfo::TypeDescriptor)
								{
									if (element->GetTypeDescriptor()->GetValueSerializer() == 0)
									{
										goto RAW_SHARED_POINTER_CORRECT;
									}
								}

								if (typeInfo->GetDecorator() == ITypeInfo::RawPtr)
								{
									manager->errors.Add(WfErrors::RawPointerToNonReferenceType(node, element));
								}
								else
								{
									manager->errors.Add(WfErrors::SharedPointerToNonReferenceType(node, element));
								}
							RAW_SHARED_POINTER_CORRECT:
								;
							}
							break;
						case ITypeInfo::Nullable:
							{
								auto element = typeInfo->GetElementType();
								if (element->GetDecorator() == ITypeInfo::Generic)
								{
									element = element->GetElementType();
								}

								if (element->GetDecorator() == ITypeInfo::TypeDescriptor)
								{
									if (element->GetTypeDescriptor()->GetValueSerializer() != 0)
									{
										goto NULLABLE_CORRECT;
									}
								}

								manager->errors.Add(WfErrors::NullableToNonReferenceType(node, element));
							NULLABLE_CORRECT:
								;
							}
							break;
						case ITypeInfo::TypeDescriptor:
							if (checkTypeForValue)
							{
								if (typeInfo->GetTypeDescriptor()->GetValueSerializer() == 0 && typeInfo->GetTypeDescriptor() != description::GetTypeDescriptor<Value>())
								{
									manager->errors.Add(WfErrors::TypeNotForValue(node, typeInfo.Obj()));
								}
							}
							break;
						case ITypeInfo::Generic:
							if (checkTypeForValue)
							{
								manager->errors.Add(WfErrors::TypeNotForValue(node, typeInfo.Obj()));
							}
							break;
						}
					}
					return typeInfo;
				}

				void VisitReferenceType(WfType* node)
				{
					if (auto scopeName = GetScopeNameFromReferenceTypeVisitor::Execute(scope, node))
					{
						if (scopeName->typeDescriptor)
						{
							Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
							typeInfo->SetTypeDescriptor(scopeName->typeDescriptor);
							result = typeInfo;
						}
						else
						{
							scope->FindManager()->errors.Add(WfErrors::TypeNotExists(node, scopeName));
						}
					}
				}

				void Visit(WfPredefinedType* node)override
				{
					ITypeDescriptor* typeDescriptor = 0;
					switch (node->name)
					{
					case WfPredefinedTypeName::Void:
						typeDescriptor = description::GetTypeDescriptor<VoidValue>();
						break;
					case WfPredefinedTypeName::Object:
						typeDescriptor = description::GetTypeDescriptor<Value>();
						break;
					case WfPredefinedTypeName::Interface:
						typeDescriptor = description::GetTypeDescriptor<IDescriptable>();
						break;
					case WfPredefinedTypeName::Int:
						typeDescriptor = description::GetTypeDescriptor<vint>();
						break;
					case WfPredefinedTypeName::UInt:
						typeDescriptor = description::GetTypeDescriptor<vuint>();
						break;
					case WfPredefinedTypeName::Float:
						typeDescriptor = description::GetTypeDescriptor<float>();
						break;
					case WfPredefinedTypeName::Double:
						typeDescriptor = description::GetTypeDescriptor<double>();
						break;
					case WfPredefinedTypeName::String:
						typeDescriptor = description::GetTypeDescriptor<WString>();
						break;
					case WfPredefinedTypeName::Char:
						typeDescriptor = description::GetTypeDescriptor<wchar_t>();
						break;
					case WfPredefinedTypeName::Bool:
						typeDescriptor = description::GetTypeDescriptor<bool>();
						break;
					default:
						CHECK_FAIL(L"CreateTypeInfoFromTypeVisitor::Visit(WfPredefinedType*)#Internal error, ValidateTypeStructure function should check correctly.");
					}
					if (typeDescriptor)
					{
						Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						typeInfo->SetTypeDescriptor(typeDescriptor);
						result = typeInfo;
					}
				}

				void Visit(WfTopQualifiedType* node)override
				{
					VisitReferenceType(node);
				}

				void Visit(WfReferenceType* node)override
				{
					VisitReferenceType(node);
				}

				void Visit(WfRawPointerType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), false))
					{
						Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::RawPtr);
						typeInfo->SetElementType(element);
						result = typeInfo;
					}
				}

				void Visit(WfSharedPointerType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), false))
					{
						Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::SharedPtr);
						typeInfo->SetElementType(element);
						result = typeInfo;
					}
				}

				void Visit(WfNullableType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), false))
					{
						Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::Nullable);
						typeInfo->SetElementType(element);
						result = typeInfo;
					}
				}

				void Visit(WfEnumerableType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), true))
					{
						Ptr<TypeInfoImpl> enumerableTypeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						enumerableTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueEnumerable>());

						Ptr<TypeInfoImpl> genericTypeInfo = new TypeInfoImpl(ITypeInfo::Generic);
						genericTypeInfo->SetElementType(enumerableTypeInfo);
						genericTypeInfo->AddGenericArgument(element);

						Ptr<TypeInfoImpl> shared = new TypeInfoImpl(ITypeInfo::SharedPtr);
						shared->SetElementType(genericTypeInfo);
						result = shared;
					}
				}

				void Visit(WfMapType* node)override
				{
					Ptr<ITypeInfo> key, value;
					if (!(value = Call(node->value.Obj(), true))) return;
					if (node->key)
					{
						if (!(key = Call(node->key.Obj(), true))) return;
					}
					
					Ptr<TypeInfoImpl> mapTypeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					if (node->writability == WfMapWritability::Writable)
					{
						if (node->key)
						{
							mapTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueDictionary>());
						}
						else
						{
							mapTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueList>());
						}
					}
					else
					{
						if (node->key)
						{
							mapTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueReadonlyDictionary>());
						}
						else
						{
							mapTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueReadonlyList>());
						}
					}

					Ptr<TypeInfoImpl> genericTypeInfo = new TypeInfoImpl(ITypeInfo::Generic);
					genericTypeInfo->SetElementType(mapTypeInfo);
					if (key) genericTypeInfo->AddGenericArgument(key);
					genericTypeInfo->AddGenericArgument(value);

					Ptr<TypeInfoImpl> shared = new TypeInfoImpl(ITypeInfo::SharedPtr);
					shared->SetElementType(genericTypeInfo);
					result = shared;
				}

				void Visit(WfFunctionType* node)override
				{
					if (Ptr<ITypeInfo> returnType = Call(node->result.Obj(), true))
					{
						Ptr<TypeInfoImpl> enumerableTypeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						enumerableTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueFunctionProxy>());

						Ptr<TypeInfoImpl> genericTypeInfo = new TypeInfoImpl(ITypeInfo::Generic);
						genericTypeInfo->SetElementType(enumerableTypeInfo);
						genericTypeInfo->AddGenericArgument(returnType);
						FOREACH(Ptr<WfType>, argument, node->arguments)
						{
							if (Ptr<ITypeInfo> argumentType = Call(argument.Obj(), true))
							{
								genericTypeInfo->AddGenericArgument(argumentType);
							}
							else
							{
								return;
							}
						}

						Ptr<TypeInfoImpl> shared = new TypeInfoImpl(ITypeInfo::SharedPtr);
						shared->SetElementType(genericTypeInfo);
						result = shared;
					}
				}

				void Visit(WfChildType* node)override
				{
					VisitReferenceType(node);
				}

				static Ptr<ITypeInfo> Execute(WfLexicalScope* scope, WfType* type)
				{
					return CreateTypeInfoFromTypeVisitor(scope).Call(type, true);
				}
			};

			Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromType(WfLexicalScope* scope, Ptr<WfType> type)
			{
				return CreateTypeInfoFromTypeVisitor::Execute(scope, type.Obj());
			}
			


/***********************************************************************
CopyType
***********************************************************************/

			class CopyTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				Ptr<WfType>				result;

				void Visit(WfPredefinedType* node)override
				{
					auto type = MakePtr<WfPredefinedType>();
					type->name = node->name;
					result = type;
				}

				void Visit(WfTopQualifiedType* node)override
				{
					auto type = MakePtr<WfTopQualifiedType>();
					type->name.value = node->name.value;
					result = type;
				}

				void Visit(WfReferenceType* node)override
				{
					auto type = MakePtr<WfReferenceType>();
					type->name.value = node->name.value;
					result = type;
				}

				void Visit(WfRawPointerType* node)override
				{
					auto type = MakePtr<WfRawPointerType>();
					type->element = CopyType(node->element);
					result = type;
				}

				void Visit(WfSharedPointerType* node)override
				{
					auto type = MakePtr<WfSharedPointerType>();
					type->element = CopyType(node->element);
					result = type;
				}

				void Visit(WfNullableType* node)override
				{
					auto type = MakePtr<WfNullableType>();
					type->element = CopyType(node->element);
					result = type;
				}

				void Visit(WfEnumerableType* node)override
				{
					auto type = MakePtr<WfEnumerableType>();
					type->element = CopyType(node->element);
					result = type;
				}

				void Visit(WfMapType* node)override
				{
					auto type = MakePtr<WfMapType>();
					type->key = CopyType(node->key);
					type->value = CopyType(node->value);
					type->writability = node->writability;
					result = type;
				}

				void Visit(WfFunctionType* node)override
				{
					auto type = MakePtr<WfFunctionType>();
					type->result = CopyType(node->result);
					CopyFrom(type->arguments, From(node->arguments).Select(CopyType));
					result = type;
				}

				void Visit(WfChildType* node)override
				{
					auto type = MakePtr<WfChildType>();
					type->parent = CopyType(node->parent);
					type->name.value = node->name.value;
					result = type;
				}
			};

			Ptr<WfType> CopyType(Ptr<WfType> type)
			{
				if (type)
				{
					CopyTypeVisitor visitor;
					type->Accept(&visitor);
					return visitor.result;
				}
				else
				{
					return 0;
				}
			}

/***********************************************************************
CreateTypeInfoFromType
***********************************************************************/
			
			Ptr<reflection::description::ITypeInfo>	CopyTypeInfo(reflection::description::ITypeInfo* typeInfo)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					{
						Ptr<TypeInfoImpl> impl = new TypeInfoImpl(typeInfo->GetDecorator());
						impl->SetElementType(CopyTypeInfo(typeInfo->GetElementType()));
						return impl;
					}
				case ITypeInfo::TypeDescriptor:
					{
						Ptr<TypeInfoImpl> impl = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						impl->SetTypeDescriptor(typeInfo->GetTypeDescriptor());
						return impl;
					}
				case ITypeInfo::Generic:
					{
						Ptr<TypeInfoImpl> impl = new TypeInfoImpl(ITypeInfo::Generic);
						impl->SetElementType(CopyTypeInfo(typeInfo->GetElementType()));
						vint count = typeInfo->GetGenericArgumentCount();
						for (vint i = 0; i < count; i++)
						{
							impl->AddGenericArgument(CopyTypeInfo(typeInfo->GetGenericArgument(i)));
						}
						return impl;
					}
				default:
					return 0;
				}
			}

/***********************************************************************
CanConvertToType
***********************************************************************/

			bool CanConvertToType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType, bool explicitly)
			{
				ITypeDescriptor* objectType = GetTypeDescriptor<Value>();
				bool fromObject = fromType->GetDecorator() == ITypeInfo::TypeDescriptor && fromType->GetTypeDescriptor() == objectType;
				bool toObject = toType->GetDecorator() == ITypeInfo::TypeDescriptor && toType->GetTypeDescriptor() == objectType;

				if (fromObject && toObject)
				{
					return true;
				}
				else if (fromObject)
				{
					return explicitly;
				}
				else if (toObject)
				{
					return true;
				}

				switch (fromType->GetDecorator())
				{
				case ITypeInfo::RawPtr:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						return CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::SharedPtr:
						return explicitly && CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::Nullable:
					case ITypeInfo::TypeDescriptor:
					case ITypeInfo::Generic:
						return false;
					}
					break;
				case ITypeInfo::SharedPtr:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						return explicitly && CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::SharedPtr:
						return CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::Nullable:
					case ITypeInfo::TypeDescriptor:
					case ITypeInfo::Generic:
						return false;
					}
					break;
				case ITypeInfo::Nullable:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
						return false;
					case ITypeInfo::Nullable:
						return CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::TypeDescriptor:
						return explicitly && CanConvertToType(fromType->GetElementType(), toType, explicitly);
					case ITypeInfo::Generic:
						return false;
					}
					break;
				case ITypeInfo::TypeDescriptor:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
						return false;
					case ITypeInfo::Nullable:
						return CanConvertToType(fromType, toType->GetElementType(), explicitly);
					case ITypeInfo::TypeDescriptor:
						{
							ITypeDescriptor* fromTd = fromType->GetTypeDescriptor();
							ITypeDescriptor* toTd = toType->GetTypeDescriptor();
							if ((fromTd->GetValueSerializer() != 0) != (toTd->GetValueSerializer() != 0))
							{
								return false;
							}

							if (fromTd->GetValueSerializer())
							{
								if (fromTd == toTd) return true;
								TypeFlag fromFlag = GetTypeFlag(fromTd);
								TypeFlag toFlag = GetTypeFlag(toTd);
								static vint conversionTable[(vint)TypeFlag::Count][(vint)TypeFlag::Count] = {
									/*Bool		*/{1, /**/ 0, 0, 0, 0, /**/ 0, 0, 0, 0, /**/ 0, 0, /**/ 1, 0},
									//-------------------------------------------------------------------------
									/*I1		*/{0, /**/ 1, 1, 1, 1, /**/ 2, 2, 2, 2, /**/ 1, 1, /**/ 1, 0},
									/*I2		*/{0, /**/ 2, 1, 1, 1, /**/ 2, 2, 2, 2, /**/ 1, 1, /**/ 1, 0},
									/*I4		*/{0, /**/ 2, 2, 1, 1, /**/ 2, 2, 2, 2, /**/ 2, 1, /**/ 1, 0},
									/*I8		*/{0, /**/ 2, 2, 2, 1, /**/ 2, 2, 2, 2, /**/ 2, 1, /**/ 1, 0},
									//-------------------------------------------------------------------------
									/*U1		*/{0, /**/ 2, 2, 2, 2, /**/ 1, 1, 1, 1, /**/ 1, 1, /**/ 1, 0},
									/*U2		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 1, 1, 1, /**/ 1, 1, /**/ 1, 0},
									/*U4		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 1, 1, /**/ 2, 1, /**/ 1, 0},
									/*U8		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 1, /**/ 2, 1, /**/ 1, 0},
									//-------------------------------------------------------------------------
									/*F4		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 2, /**/ 1, 1, /**/ 1, 0},
									/*F8		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 2, /**/ 2, 1, /**/ 1, 0},
									//-------------------------------------------------------------------------
									/*String	*/{2, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 2, /**/ 2, 2, /**/ 1, 2},
									/*Others	*/{0, /**/ 0, 0, 0, 0, /**/ 0, 0, 0, 0, /**/ 0, 0, /**/ 1, 0},
								};
								vint conversion = conversionTable[(vint)fromFlag][(vint)toFlag];
								return conversion == 1 || (explicitly && conversion == 2);
							}
							else
							{
								if (fromTd->CanConvertTo(toTd))
								{
									return true;
								}
								if (explicitly && toTd->CanConvertTo(fromTd))
								{
									return true;
								}
							}
						}
						break;
					case ITypeInfo::Generic:
						return explicitly && CanConvertToType(fromType, toType->GetElementType(), explicitly);
					}
					break;
				case ITypeInfo::Generic:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
					case ITypeInfo::Nullable:
						return false;
					case ITypeInfo::TypeDescriptor:
						return CanConvertToType(fromType->GetElementType(), toType, explicitly);
					case ITypeInfo::Generic:
						if (explicitly) return true;
						if (fromType->GetGenericArgumentCount() != toType->GetGenericArgumentCount())
						{
							return false;
						}
						if (!CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly)) return false;
						for (vint i = 0; i < fromType->GetGenericArgumentCount(); i++)
						{
							if (!IsSameType(fromType->GetGenericArgument(i), toType->GetGenericArgument(i)))
							{
								return false;
							}
						}
						return true;
					}
					break;
				}
				return false;
			}

/***********************************************************************
IsSameType
***********************************************************************/

			bool IsSameType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				if (fromType->GetDecorator() != toType->GetDecorator())
				{
					return false;
				}
				switch (fromType->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					return IsSameType(fromType->GetElementType(), toType->GetElementType());
				case ITypeInfo::TypeDescriptor:
					return fromType->GetTypeDescriptor() == toType->GetTypeDescriptor();
				case ITypeInfo::Generic:
					if (fromType->GetGenericArgumentCount() != toType->GetGenericArgumentCount())
					{
						return false;
					}
					if (!IsSameType(fromType->GetElementType(), toType->GetElementType())) return false;
					for (vint i = 0; i < fromType->GetGenericArgumentCount(); i++)
					{
						if (!IsSameType(fromType->GetGenericArgument(i), toType->GetGenericArgument(i)))
						{
							return false;
						}
					}
					return true;
				}
				return false;
			}

/***********************************************************************
GetMergedType
***********************************************************************/

			Ptr<reflection::description::ITypeInfo>	GetMergedType(Ptr<reflection::description::ITypeInfo> firstType, Ptr<reflection::description::ITypeInfo> secondType)
			{
				if (CanConvertToType(secondType.Obj(), firstType.Obj(), false))
				{
					return firstType;
				}
				else if (CanConvertToType(firstType.Obj(), secondType.Obj(), false))
				{
					return secondType;
				}
				else
				{
					return 0;
				}
			}

/***********************************************************************
IsNullAcceptableType
***********************************************************************/

			bool IsNullAcceptableType(reflection::description::ITypeInfo* type)
			{
				switch (type->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					return true;
				case ITypeInfo::TypeDescriptor:
					return type->GetTypeDescriptor() == description::GetTypeDescriptor<Value>();
				case ITypeInfo::Generic:
					return false;
				}
				return false;
			}

/***********************************************************************
CreateTypeInfoFromMethodInfo
***********************************************************************/

			Ptr<reflection::description::ITypeInfo> CreateTypeInfoFromMethodInfo(reflection::description::IMethodInfo* info)
			{
				Ptr<TypeInfoImpl> functionType = new TypeInfoImpl(ITypeInfo::SharedPtr);
				{
					Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
					functionType->SetElementType(genericType);
					{
						Ptr<TypeInfoImpl> elementType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						elementType->SetTypeDescriptor(description::GetTypeDescriptor<IValueFunctionProxy>());
						genericType->SetElementType(elementType);
					}

					genericType->AddGenericArgument(CopyTypeInfo(info->GetReturn()));
					vint parameterCount = info->GetParameterCount();
					for (vint j = 0; j < parameterCount; j++)
					{
						genericType->AddGenericArgument(CopyTypeInfo(info->GetParameter(j)->GetType()));
					}
				}
				return functionType;
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_VALIDATESEMANTIC.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
ValidateSemantic(ClassMember)
***********************************************************************/

			class ValidateSemanticClassMemberVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				Ptr<WfCustomType>					td;
				Ptr<WfClassDeclaration>				classDecl;
				Ptr<WfClassMember>					member;

				ValidateSemanticClassMemberVisitor(Ptr<WfCustomType> _td, Ptr<WfClassDeclaration> _classDecl, Ptr<WfClassMember> _member, WfLexicalScopeManager* _manager)
					:td(_td)
					, classDecl(_classDecl)
					, member(_member)
					, manager(_manager)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (node->statement)
					{
						ValidateDeclarationSemantic(manager, node);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					throw 0;
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					auto scope = manager->declarationScopes[node];
					if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), node->type))
					{
						if (node->getter.value != L"")
						{
							auto getter = td->GetMethodGroupByName(node->getter.value, false)->GetMethod(0);
							if (!IsSameType(typeInfo.Obj(), getter->GetReturn()) || getter->GetParameterCount() != 0)
							{
								manager->errors.Add(WfErrors::PropertyGetterTypeMismatched(node, classDecl.Obj()));
							}
						}

						if (node->setter.value != L"")
						{
							auto setter = td->GetMethodGroupByName(node->setter.value, false)->GetMethod(0);
							if (setter->GetReturn()->GetTypeDescriptor() != description::GetTypeDescriptor<void>() || setter->GetParameterCount() != 1 || !IsSameType(typeInfo.Obj(), setter->GetParameter(0)->GetType()))
							{
								manager->errors.Add(WfErrors::PropertyGetterTypeMismatched(node, classDecl.Obj()));
							}
						}
					}
				}

				void Visit(WfClassDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
				}

				static void Execute(Ptr<WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfClassMember> member, WfLexicalScopeManager* manager)
				{
					ValidateSemanticClassMemberVisitor visitor(td, classDecl, member, manager);
					member->declaration->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateSemantic(Declaration)
***********************************************************************/

			class ValidateSemanticDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;

				ValidateSemanticDeclarationVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					FOREACH(Ptr<WfDeclaration>, declaration, node->declarations)
					{
						declaration->Accept(this);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto scope = manager->declarationScopes[node];
					auto symbol = scope->symbols[node->name.value][0];
					symbol->typeInfo = GetExpressionType(manager, node->expression, symbol->typeInfo);
					if (symbol->typeInfo && !symbol->type)
					{
						symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
					}
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					auto scope = manager->declarationScopes[node];
					auto td = manager->declarationTypes[node].Cast<WfCustomType>();

					FOREACH(Ptr<WfClassMember>, member, node->members)
					{
						ValidateClassMemberSemantic(manager, td, node, member);
					}
				}

				static void Execute(Ptr<WfDeclaration> declaration, WfLexicalScopeManager* manager)
				{
					ValidateSemanticDeclarationVisitor visitor(manager);
					declaration->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateSemantic(Statement)
***********************************************************************/

			class ValidateSemanticStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;

				ValidateSemanticStatementVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
				}

				void Visit(WfContinueStatement* node)override
				{
				}

				void Visit(WfReturnStatement* node)override
				{
					auto scope = manager->statementScopes[node].Obj();
					auto decl = scope->FindDeclaration().Cast<WfFunctionDeclaration>();
					auto returnType = CreateTypeInfoFromType(scope, decl->returnType);
					if (node->expression)
					{
						GetExpressionType(manager, node->expression, returnType);
					}
					else if (returnType->GetDecorator() != ITypeInfo::TypeDescriptor || returnType->GetTypeDescriptor() != description::GetTypeDescriptor<void>())
					{
						manager->errors.Add(WfErrors::ReturnMissExpression(node, returnType.Obj()));
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, 0);
					if (type)
					{
						if (type->GetDecorator() != ITypeInfo::RawPtr)
						{
							manager->errors.Add(WfErrors::DeleteNonRawPointer(node, type.Obj()));
						}
					}
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						Ptr<ITypeInfo> stringType = TypeInfoRetriver<WString>::CreateTypeInfo();
						GetExpressionType(manager, node->expression, stringType);
					}
				}

				void Visit(WfIfStatement* node)override
				{
					if (node->type)
					{
						auto scope = manager->statementScopes[node].Obj();
						auto symbol = scope->symbols[node->name.value][0];
						if (!IsNullAcceptableType(symbol->typeInfo.Obj()))
						{
							manager->errors.Add(WfErrors::NullCannotImplicitlyConvertToType(node->expression.Obj(), symbol->typeInfo.Obj()));
						}
						GetExpressionType(manager, node->expression, 0);
					}
					else
					{
						Ptr<ITypeInfo> boolType = TypeInfoRetriver<bool>::CreateTypeInfo();
						GetExpressionType(manager, node->expression, boolType);
					}
					ValidateStatementSemantic(manager, node->trueBranch);
					if (node->falseBranch)
					{
						ValidateStatementSemantic(manager, node->falseBranch);
					}
				}

				void Visit(WfSwitchStatement* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, 0);
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						Ptr<ITypeInfo> caseType;
						if (IsExpressionDependOnExpectedType(manager, switchCase->expression))
						{
							caseType = GetExpressionType(manager, switchCase->expression, type);
						}
						else
						{
							caseType = GetExpressionType(manager, switchCase->expression, 0);
						}

						if (type && caseType)
						{
							if (!GetMergedType(type, caseType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(switchCase->expression.Obj(), type.Obj(), caseType.Obj()));
							}
						}
						ValidateStatementSemantic(manager, switchCase->statement);
					}
					if (node->defaultBranch)
					{
						ValidateStatementSemantic(manager, node->defaultBranch);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					Ptr<ITypeInfo> boolType = TypeInfoRetriver<bool>::CreateTypeInfo();
					GetExpressionType(manager, node->condition, boolType);
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfForEachStatement* node)override
				{
					Ptr<ITypeInfo> elementType = GetEnumerableExpressionItemType(manager, node->collection, 0);
					if (elementType)
					{
						auto scope = manager->statementScopes[node].Obj();
						auto symbol = scope->symbols[node->name.value][0];
						symbol->typeInfo = elementType;
						symbol->type = GetTypeFromTypeInfo(elementType.Obj());
					}
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfTryStatement* node)override
				{
					ValidateStatementSemantic(manager, node->protectedStatement);
					if (node->catchStatement)
					{
						ValidateStatementSemantic(manager, node->catchStatement);
					}
					if (node->finallyStatement)
					{
						ValidateStatementSemantic(manager, node->finallyStatement);
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					FOREACH(Ptr<WfStatement>, statement, node->statements)
					{
						statement->Accept(this);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					GetExpressionType(manager, node->expression, 0);
				}

				void Visit(WfVariableStatement* node)override
				{
					ValidateDeclarationSemantic(manager, node->variable);
				}

				static void Execute(Ptr<WfStatement> statement, WfLexicalScopeManager* manager)
				{
					ValidateSemanticStatementVisitor visitor(manager);
					statement->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateSemantic(Expression)
***********************************************************************/

			class ValidateSemanticExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				Ptr<ITypeInfo>						expectedType;
				List<ResolveExpressionResult>&		results;

				ValidateSemanticExpressionVisitor(WfLexicalScopeManager* _manager, Ptr<ITypeInfo> _expectedType, List<ResolveExpressionResult>& _results)
					:manager(_manager)
					, expectedType(_expectedType)
					, results(_results)
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					if (manager->globalName)
					{
						vint index = manager->globalName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							results.Add(ResolveExpressionResult(manager->globalName->children.Values()[index]));
							return;
						}
					}
					manager->errors.Add(WfErrors::TopQualifiedSymbolNotExists(node, node->name.value));
				}

				void VisitSymbol(WfLexicalScope* scope, Ptr<WfLexicalSymbol> symbol)
				{
					if (symbol->typeInfo)
					{
						bool captured = false;
						if (!symbol->ownerScope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
						{
							auto currentScope = scope;
							while (currentScope)
							{
								vint index = currentScope->symbols.Keys().IndexOf(symbol->name);
								if (index != -1 && currentScope->symbols.GetByIndex(index).Contains(symbol.Obj()))
								{
									break;
								}
								if (auto node = currentScope->ownerDeclaration.Cast<WfFunctionDeclaration>())
								{
									if (!currentScope->ownerClassMember)
									{
										captured = true;
										vint index = manager->functionLambdaCaptures.Keys().IndexOf(node.Obj());
										if (index == -1 || !manager->functionLambdaCaptures.GetByIndex(index).Contains(symbol.Obj()))
										{
											manager->functionLambdaCaptures.Add(node.Obj(), symbol);
										}
									}
								}
								if (auto node = currentScope->ownerExpression.Cast<WfOrderedLambdaExpression>())
								{
									captured = true;
									vint index = manager->orderedLambdaCaptures.Keys().IndexOf(node.Obj());
									if (index == -1 || !manager->orderedLambdaCaptures.GetByIndex(index).Contains(symbol.Obj()))
									{
										manager->orderedLambdaCaptures.Add(node.Obj(), symbol);
									}
								}
								currentScope = currentScope->parentScope.Obj();
							}
						}

						bool writable = false;
						if (symbol->creatorDeclaration.Cast<WfVariableDeclaration>())
						{
							writable = !captured;
						}

						if (writable)
						{
							results.Add(ResolveExpressionResult(symbol, symbol->typeInfo, symbol->typeInfo));
						}
						else
						{
							results.Add(ResolveExpressionResult(symbol, symbol->typeInfo));
						}
					}
				}

				void Visit(WfReferenceExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();

					List<Ptr<WfLexicalSymbol>> symbols;
					manager->ResolveSymbol(scope, node->name.value, symbols);
					if (symbols.Count() >= 1)
					{
						FOREACH(Ptr<WfLexicalSymbol>, symbol, symbols)
						{
							VisitSymbol(scope, symbol);
						}

						if (results.Count() == 0)
						{
							FOREACH(Ptr<WfLexicalSymbol>, symbol, symbols)
							{
								manager->errors.Add(WfErrors::ExpressionCannotResolveType(node, symbol));
							}
						}
						return;
					}

					List<Ptr<WfLexicalScopeName>> scopeNames;
					manager->ResolveScopeName(scope, node->name.value, scopeNames);
					if (scopeNames.Count() >= 1)
					{
						FOREACH(Ptr<WfLexicalScopeName>, scopeName, scopeNames)
						{
							results.Add(ResolveExpressionResult(scopeName));
						}
					}
					else
					{
						manager->errors.Add(WfErrors::ReferenceNotExists(node, node->name.value));
					}
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();

					List<Ptr<WfLexicalSymbol>> symbols;
					manager->ResolveSymbol(scope, node->name.value, symbols);
					FOREACH(Ptr<WfLexicalSymbol>, symbol, symbols)
					{
						VisitSymbol(scope, symbol);
					}
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();
					List<Ptr<WfLexicalSymbol>> parameterSymbols;
					CopyFrom(
						parameterSymbols,
						Range<vint>(0, scope->symbols.Count())
							.Select([scope](vint index)->Ptr<WfLexicalSymbol>{return scope->symbols.GetByIndex(index)[0];})
							.OrderBy([](Ptr<WfLexicalSymbol> a, Ptr<WfLexicalSymbol> b)
							{
								vint aId = wtoi(a->name.Sub(1, a->name.Length() - 1));
								vint bId = wtoi(b->name.Sub(1, a->name.Length() - 1));
								return aId - bId;
							})
						);
					Ptr<ITypeInfo> resultType = expectedType;

					if (!expectedType && parameterSymbols.Count() > 0)
					{
						manager->errors.Add(WfErrors::OrderedLambdaCannotResolveType(node));
						return;
					}
					else if (expectedType)
					{
						ITypeInfo* type = expectedType.Obj();
						if (type->GetDecorator() != ITypeInfo::SharedPtr)
						{
							goto ORDERED_FAILED;
						}
						type = type->GetElementType();
						if (type->GetDecorator() != ITypeInfo::Generic)
						{
							goto ORDERED_FAILED;
						}
						{
							ITypeInfo* functionType = type->GetElementType();
							if (functionType->GetDecorator() != ITypeInfo::TypeDescriptor)
							{
								goto ORDERED_FAILED;
							}
							if (functionType->GetTypeDescriptor() != description::GetTypeDescriptor<IValueFunctionProxy>())
							{
								goto ORDERED_FAILED;
							}
						}

						if (type->GetGenericArgumentCount() != parameterSymbols.Count() + 1)
						{
							goto ORDERED_FAILED;
						}

						Ptr<ITypeInfo> resultType = type->GetGenericArgument(0);
						FOREACH_INDEXER(Ptr<WfLexicalSymbol>, symbol, index, parameterSymbols)
						{
							symbol->typeInfo = type->GetGenericArgument(index + 1);
							symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
						}
						GetExpressionType(manager, node->body, resultType);
					}
					else
					{
						auto bodyType = GetExpressionType(manager, node->body, 0);
						if (bodyType)
						{
							Ptr<TypeInfoImpl> funcType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
							funcType->SetTypeDescriptor(description::GetTypeDescriptor<IValueFunctionProxy>());

							Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
							genericType->SetElementType(funcType);
							genericType->AddGenericArgument(bodyType);

							Ptr<TypeInfoImpl> pointerType = new TypeInfoImpl(ITypeInfo::SharedPtr);
							pointerType->SetElementType(genericType);
							resultType = pointerType;
						}
					}

					goto ORDERED_FINISHED;
				ORDERED_FAILED:
					manager->errors.Add(WfErrors::OrderedLambdaCannotImplicitlyConvertToType(node, expectedType.Obj()));
				ORDERED_FINISHED:
					if (resultType)
					{
						results.Add(ResolveExpressionResult(resultType));
					}
				}

				void Visit(WfMemberExpression* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->parent, 0);
					if (type)
					{
						ITypeDescriptor* typeDescriptor = type->GetTypeDescriptor();
						if (IPropertyInfo* info = typeDescriptor->GetPropertyByName(node->name.value, true))
						{
							Ptr<ITypeInfo> getterType = CopyTypeInfo(info->GetReturn());
							Ptr<ITypeInfo> setterType;
							if (IMethodInfo* setter = info->GetSetter())
							{
								setterType = getterType;
								if (setter->GetParameterCount() == 1 && !IsSameType(getterType.Obj(), setter->GetParameter(0)->GetType()))
								{
									setterType = CopyTypeInfo(setter->GetParameter(0)->GetType());
								}
							}
							else if (!typeDescriptor->GetValueSerializer() && info->IsWritable())
							{
								setterType = CopyTypeInfo(info->GetReturn());
							}
							ResolveExpressionResult result(info, getterType, setterType);
							results.Add(result);
						}
						if (IEventInfo* info = typeDescriptor->GetEventByName(node->name.value, true))
						{
							ResolveExpressionResult result(info);
							results.Add(result);
						}
						if (IMethodGroupInfo* groupInfo = typeDescriptor->GetMethodGroupByName(node->name.value, true))
						{
							vint count = groupInfo->GetMethodCount();
							for (vint i = 0; i < count; i++)
							{
								IMethodInfo* info = groupInfo->GetMethod(i);
								ResolveExpressionResult result(info, CreateTypeInfoFromMethodInfo(info));
								results.Add(result);
							}
						}

						if (results.Count() == 0)
						{
							manager->errors.Add(WfErrors::MemberNotExists(node, typeDescriptor, node->name.value));
						}
					}
				}

				void Visit(WfChildExpression* node)override
				{
					if (Ptr<WfLexicalScopeName> scopeName = GetExpressionScopeName(manager, node->parent))
					{
						vint index = scopeName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							results.Add(ResolveExpressionResult(scopeName->children.Values()[index]));
							return;
						}

						if (scopeName->typeDescriptor)
						{
							if (auto group = scopeName->typeDescriptor->GetMethodGroupByName(node->name.value, true))
							{
								bool found = false;
								for (vint i = 0; i < group->GetMethodCount(); i++)
								{
									auto info = group->GetMethod(i);
									if (info->IsStatic())
									{
										found = true;
										results.Add(ResolveExpressionResult(info, CreateTypeInfoFromMethodInfo(info)));
									}
								}

								if (found)
								{
									return;
								}
							}
						}
						manager->errors.Add(WfErrors::ChildSymbolNotExists(node, scopeName, node->name.value));
					}
				}

				void Visit(WfLiteralExpression* node)override
				{
					if (node->value == WfLiteralValue::Null)
					{
						if (!expectedType)
						{
							manager->errors.Add(WfErrors::NullCannotResolveType(node));
						}
						else if (!IsNullAcceptableType(expectedType.Obj()))
						{
							manager->errors.Add(WfErrors::NullCannotImplicitlyConvertToType(node, expectedType.Obj()));
						}

						results.Add(ResolveExpressionResult(expectedType));
					}
					else
					{
						results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
					}
				}

				void Visit(WfFloatingExpression* node)override
				{
					results.Add(ResolveExpressionResult(TypeInfoRetriver<double>::CreateTypeInfo()));
				}

				void Visit(WfIntegerExpression* node)override
				{
					ITypeDescriptor* typeDescriptor = 0;
#ifndef VCZH_64
					typeDescriptor = description::GetTypeDescriptor<vint32_t>();
					if (typeDescriptor->GetValueSerializer()->Validate(node->value.value))
					{
						goto TYPE_FINISHED;
					}

					typeDescriptor = description::GetTypeDescriptor<vuint32_t>();
					if (typeDescriptor->GetValueSerializer()->Validate(node->value.value))
					{
						goto TYPE_FINISHED;
					}
#endif
					typeDescriptor = description::GetTypeDescriptor<vint64_t>();
					if (typeDescriptor->GetValueSerializer()->Validate(node->value.value))
					{
						goto TYPE_FINISHED;
					}

					typeDescriptor = description::GetTypeDescriptor<vuint64_t>();
					if (typeDescriptor->GetValueSerializer()->Validate(node->value.value))
					{
						goto TYPE_FINISHED;
					}

					manager->errors.Add(WfErrors::IntegerLiteralOutOfRange(node));

				TYPE_FINISHED:
					Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					typeInfo->SetTypeDescriptor(typeDescriptor);
					results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)typeInfo));
				}

				void Visit(WfStringExpression* node)override
				{
					results.Add(ResolveExpressionResult(TypeInfoRetriver<WString>::CreateTypeInfo()));
				}

				void Visit(WfFormatExpression* node)override
				{
					Ptr<ITypeInfo> typeInfo = TypeInfoRetriver<WString>::CreateTypeInfo();
					results.Add(ResolveExpressionResult(typeInfo));
					GetExpressionType(manager, node->expandedExpression, typeInfo);
				}

				void Visit(WfUnaryExpression* node)override
				{
					Ptr<ITypeInfo> typeInfo = GetExpressionType(manager, node->operand, 0);
					if (typeInfo)
					{
						TypeFlag flag = GetTypeFlag(typeInfo.Obj());
						switch (node->op)
						{
						case WfUnaryOperator::Not:
							switch (flag)
							{
							case TypeFlag::F4:
							case TypeFlag::F8:
							case TypeFlag::String:
							case TypeFlag::Others:
								manager->errors.Add(WfErrors::UnaryOperatorOnWrongType(node, typeInfo.Obj()));
								break;
							default:;
							}
							break;
						case WfUnaryOperator::Positive:
							switch (flag)
							{
							case TypeFlag::Bool:
							case TypeFlag::String:
							case TypeFlag::Others:
								manager->errors.Add(WfErrors::UnaryOperatorOnWrongType(node, typeInfo.Obj()));
								break;
							default:;
							}
							break;
						case WfUnaryOperator::Negative:
							switch (flag)
							{
							case TypeFlag::Bool:
							case TypeFlag::U1:
							case TypeFlag::U2:
							case TypeFlag::U4:
							case TypeFlag::U8:
							case TypeFlag::String:
							case TypeFlag::Others:
								manager->errors.Add(WfErrors::UnaryOperatorOnWrongType(node, typeInfo.Obj()));
								break;
							default:;
							}
							break;
						}

						results.Add(ResolveExpressionResult(typeInfo));
					}
				}

				void Visit(WfBinaryExpression* node)override
				{

					if (node->op == WfBinaryOperator::Assign)
					{
						Ptr<ITypeInfo> variableType = GetLeftValueExpressionType(manager, node->first);
						GetExpressionType(manager, node->second, variableType);
						if (variableType)
						{
							results.Add(ResolveExpressionResult(variableType));
						}
					}
					else if (node->op == WfBinaryOperator::Index)
					{
						Ptr<ITypeInfo> containerType = GetExpressionType(manager, node->first, 0);
						if (containerType)
						{
							if (containerType->GetDecorator() == ITypeInfo::SharedPtr)
							{
								ITypeInfo* genericType = containerType->GetElementType();
								Ptr<ITypeInfo> indexType;
								Ptr<ITypeInfo> resultType;
								bool leftValue = false;

								if (genericType->GetDecorator() == ITypeInfo::Generic)
								{
									ITypeInfo* classType = genericType->GetElementType();
									if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>())
									{
										indexType = TypeInfoRetriver<vint>::CreateTypeInfo();
										resultType = CopyTypeInfo(genericType->GetGenericArgument(0));
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
									{
										indexType = TypeInfoRetriver<vint>::CreateTypeInfo();
										resultType = CopyTypeInfo(genericType->GetGenericArgument(0));
										leftValue = true;
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyDictionary>())
									{
										indexType = CopyTypeInfo(genericType->GetGenericArgument(0));
										resultType = CopyTypeInfo(genericType->GetGenericArgument(1));
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
									{
										indexType = CopyTypeInfo(genericType->GetGenericArgument(0));
										resultType = CopyTypeInfo(genericType->GetGenericArgument(1));
										leftValue = true;
									}
									else
									{
										manager->errors.Add(WfErrors::IndexOperatorOnWrongType(node, containerType.Obj()));
									}
								}
								else
								{
									if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>())
									{
										indexType = TypeInfoRetriver<vint>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
									{
										indexType = TypeInfoRetriver<vint>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
										leftValue = true;
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyDictionary>())
									{
										indexType = TypeInfoRetriver<Value>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
									{
										indexType = TypeInfoRetriver<Value>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
										leftValue = true;
									}
									else
									{
										manager->errors.Add(WfErrors::IndexOperatorOnWrongType(node, containerType.Obj()));
									}
								}

								GetExpressionType(manager, node->second, indexType);
								if (resultType)
								{
									if (leftValue)
									{
										results.Add(ResolveExpressionResult(resultType, resultType));
									}
									else
									{
										results.Add(ResolveExpressionResult(resultType));
									}
								}
							}
							else
							{
								manager->errors.Add(WfErrors::IndexOperatorOnWrongType(node, containerType.Obj()));
							}
						}
					}
					else if (node->op == WfBinaryOperator::Concat)
					{
						Ptr<ITypeInfo> stringType = TypeInfoRetriver<WString>::CreateTypeInfo();
						GetExpressionType(manager, node->first, stringType);
						GetExpressionType(manager, node->second, stringType);
						results.Add(ResolveExpressionResult(stringType));
					}
					else if (node->op == WfBinaryOperator::FailedThen)
					{
						Ptr<ITypeInfo> firstType = GetExpressionType(manager, node->first, 0);
						bool depend = IsExpressionDependOnExpectedType(manager, node->second);
						Ptr<ITypeInfo> secondType = GetExpressionType(manager, node->second, (depend ? firstType : nullptr));

						if (firstType && secondType)
						{
							auto mergedType = GetMergedType(firstType, secondType);
							results.Add(ResolveExpressionResult(mergedType ? mergedType : firstType));
						}
					}
					else
					{
						Ptr<ITypeInfo> firstType = GetExpressionType(manager, node->first, 0);
						Ptr<ITypeInfo> secondType = GetExpressionType(manager, node->second, 0);
						Ptr<ITypeInfo> elementType;
						if (firstType && secondType)
						{
							if (!(elementType = GetMergedType(firstType, secondType)))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
							}
						}

						if (elementType)
						{
							TypeFlag flag = GetTypeFlag(elementType.Obj());
							TypeFlag* selectedTable = 0;
							switch (node->op)
							{
							case WfBinaryOperator::Exp:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::F4,
										/*I2		*/TypeFlag::F4,
										/*I4		*/TypeFlag::F8,
										/*I8		*/TypeFlag::F8,
										/*U1		*/TypeFlag::F4,
										/*U2		*/TypeFlag::F4,
										/*U4		*/TypeFlag::F8,
										/*U8		*/TypeFlag::F8,
										/*F4		*/TypeFlag::F4,
										/*F8		*/TypeFlag::F8,
										/*String	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::Add:
							case WfBinaryOperator::Sub:
							case WfBinaryOperator::Mul:
							case WfBinaryOperator::Div:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::I,
										/*I2		*/TypeFlag::I,
										/*I4		*/TypeFlag::I,
										/*I8		*/TypeFlag::I8,
										/*U1		*/TypeFlag::U,
										/*U2		*/TypeFlag::U,
										/*U4		*/TypeFlag::U,
										/*U8		*/TypeFlag::U8,
										/*F4		*/TypeFlag::F4,
										/*F8		*/TypeFlag::F8,
										/*String	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::Mod:
							case WfBinaryOperator::Shl:
							case WfBinaryOperator::Shr:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::I,
										/*I2		*/TypeFlag::I,
										/*I4		*/TypeFlag::I,
										/*I8		*/TypeFlag::I8,
										/*U1		*/TypeFlag::U,
										/*U2		*/TypeFlag::U,
										/*U4		*/TypeFlag::U,
										/*U8		*/TypeFlag::U8,
										/*F4		*/TypeFlag::Unknown,
										/*F8		*/TypeFlag::Unknown,
										/*String	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::LT:
							case WfBinaryOperator::GT:
							case WfBinaryOperator::LE:
							case WfBinaryOperator::GE:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::Bool,
										/*I2		*/TypeFlag::Bool,
										/*I4		*/TypeFlag::Bool,
										/*I8		*/TypeFlag::Bool,
										/*U1		*/TypeFlag::Bool,
										/*U2		*/TypeFlag::Bool,
										/*U4		*/TypeFlag::Bool,
										/*U8		*/TypeFlag::Bool,
										/*F4		*/TypeFlag::Bool,
										/*F8		*/TypeFlag::Bool,
										/*String	*/TypeFlag::Bool,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::EQ:
							case WfBinaryOperator::NE:
								{
									results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
									return;
								}
								break;
							case WfBinaryOperator::Xor:
							case WfBinaryOperator::And:
							case WfBinaryOperator::Or:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Bool,
										/*I1		*/TypeFlag::I1,
										/*I2		*/TypeFlag::I2,
										/*I4		*/TypeFlag::I4,
										/*I8		*/TypeFlag::I8,
										/*U1		*/TypeFlag::U1,
										/*U2		*/TypeFlag::U2,
										/*U4		*/TypeFlag::U4,
										/*U8		*/TypeFlag::U8,
										/*F4		*/TypeFlag::Unknown,
										/*F8		*/TypeFlag::Unknown,
										/*String	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							default:;
							}

							TypeFlag resultFlag = selectedTable[(vint)flag];
							if (resultFlag == TypeFlag::Unknown)
							{
								manager->errors.Add(WfErrors::BinaryOperatorOnWrongType(node, elementType.Obj()));
							}
							else
							{
								results.Add(ResolveExpressionResult(CreateTypeInfoFromTypeFlag(resultFlag)));
							}
						}
					}
				}

				void Visit(WfLetExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();

					FOREACH(Ptr<WfLetVariable>, variable, node->variables)
					{
						auto symbol = scope->symbols[variable->name.value][0];
						symbol->typeInfo = GetExpressionType(manager, variable->value, 0);
						if (symbol->typeInfo)
						{
							symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
						}
					}
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, expectedType);
					if (type)
					{
						results.Add(ResolveExpressionResult(type));
					}
				}

				void Visit(WfIfExpression* node)override
				{
					Ptr<ITypeInfo> boolType = TypeInfoRetriver<bool>::CreateTypeInfo();
					GetExpressionType(manager, node->condition, boolType);

					Ptr<ITypeInfo> firstType, secondType;

					if (expectedType)
					{
						firstType = GetExpressionType(manager, node->trueBranch, expectedType);
						secondType = GetExpressionType(manager, node->falseBranch, expectedType);
					}
					else
					{
						bool resolveFirst = !IsExpressionDependOnExpectedType(manager, node->trueBranch);
						bool resolveSecond = !IsExpressionDependOnExpectedType(manager, node->falseBranch);

						if (resolveFirst == resolveSecond)
						{
							firstType = GetExpressionType(manager, node->trueBranch, 0);
							secondType = GetExpressionType(manager, node->falseBranch, 0);
						}
						else if (resolveFirst)
						{
							firstType = GetExpressionType(manager, node->trueBranch, 0);
							secondType = GetExpressionType(manager, node->falseBranch, firstType);
						}
						else if (resolveSecond)
						{
							secondType = GetExpressionType(manager, node->falseBranch, 0);
							firstType = GetExpressionType(manager, node->trueBranch, secondType);
						}
					}
					
					if (firstType && !secondType)
					{
						results.Add(ResolveExpressionResult(firstType));
					}
					else if (!firstType && secondType)
					{
						results.Add(ResolveExpressionResult(secondType));
					}
					else if (firstType && secondType)
					{
						if (auto mergedType = GetMergedType(firstType, secondType))
						{
							results.Add(ResolveExpressionResult(mergedType));
						}
						else
						{
							manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
						}
					}
				}

				void Visit(WfRangeExpression* node)override
				{
					Ptr<ITypeInfo> firstType = GetExpressionType(manager, node->begin, 0);
					Ptr<ITypeInfo> secondType = GetExpressionType(manager, node->end, 0);
					Ptr<ITypeInfo> elementType;

					if (firstType && !secondType)
					{
						elementType = firstType;
					}
					else if (!firstType && secondType)
					{
						elementType = secondType;
					}
					else if (firstType && secondType)
					{
						if (!(elementType = GetMergedType(firstType, secondType)))
						{
							manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
						}
					}

					if (elementType)
					{
						TypeFlag flag = GetTypeFlag(elementType.Obj());
						switch (flag)
						{
						case TypeFlag::I1:
						case TypeFlag::I2:
						case TypeFlag::I4:
						case TypeFlag::I8:
						case TypeFlag::U1:
						case TypeFlag::U2:
						case TypeFlag::U4:
						case TypeFlag::U8:
							break;
						default:
							manager->errors.Add(WfErrors::RangeShouldBeInteger(node, elementType.Obj()));
						}

						Ptr<TypeInfoImpl> enumerableType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						enumerableType->SetTypeDescriptor(description::GetTypeDescriptor<IValueEnumerable>());

						Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
						genericType->SetElementType(enumerableType);
						genericType->AddGenericArgument(elementType);

						Ptr<TypeInfoImpl> pointerType = new TypeInfoImpl(ITypeInfo::SharedPtr);
						pointerType->SetElementType(genericType);
						results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)pointerType));
					}
				}

				void Visit(WfSetTestingExpression* node)override
				{
					Ptr<ITypeInfo> elementType = GetExpressionType(manager, node->element, 0);

					if (auto range = node->collection.Cast<WfRangeExpression>())
					{
						Ptr<ITypeInfo> beginType = GetExpressionType(manager, range->begin, 0);
						Ptr<ITypeInfo> endType = GetExpressionType(manager, range->end, 0);

						if (elementType && beginType)
						{
							if (!GetMergedType(elementType, beginType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, elementType.Obj(), beginType.Obj()));
							}
						}
						if (elementType && endType)
						{
							if (!GetMergedType(elementType, endType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, elementType.Obj(), endType.Obj()));
							}
						}
					}
					else
					{
						Ptr<ITypeInfo> itemType = GetEnumerableExpressionItemType(manager, node->collection, 0);
						if (elementType && itemType)
						{
							if (!GetMergedType(elementType, itemType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, elementType.Obj(), itemType.Obj()));
							}
						}
					}

					results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
				}

				void Visit(WfConstructorExpression* node)override
				{
					if (node->arguments.Count() == 0)
					{
						if (expectedType)
						{
							ITypeDescriptor* td = expectedType->GetTypeDescriptor();
							if (!td->CanConvertTo(description::GetTypeDescriptor<IValueEnumerable>()) && !td->CanConvertTo(description::GetTypeDescriptor<IValueReadonlyDictionary>()))
							{
								manager->errors.Add(WfErrors::ConstructorCannotImplicitlyConvertToType(node, expectedType.Obj()));
							}
							results.Add(ResolveExpressionResult(expectedType));
						}
						else
						{
							manager->errors.Add(WfErrors::ConstructorCannotResolveType(node));
						}
					}
					else
					{
						bool map = node->arguments[0]->value;
						Ptr<ITypeInfo> keyType, valueType;
						FOREACH(Ptr<WfConstructorArgument>, argument, node->arguments)
						{
							{
								Ptr<ITypeInfo> newKeyType = GetExpressionType(manager, argument->key, 0);
								if (!keyType)
								{
									keyType = newKeyType;
								}
								else if (auto mergedType = GetMergedType(keyType, newKeyType))
								{
									keyType = mergedType;
								}
								else
								{
									manager->errors.Add(WfErrors::CannotMergeTwoType(node, keyType.Obj(), newKeyType.Obj()));
								}
							}
							if (map)
							{
								Ptr<ITypeInfo> newValueType = GetExpressionType(manager, argument->value, 0);
								if (!valueType)
								{
									valueType = newValueType;
								}
								else if (auto mergedType = GetMergedType(valueType, newValueType))
								{
									valueType = mergedType;
								}
								else
								{
									manager->errors.Add(WfErrors::CannotMergeTwoType(node, valueType.Obj(), newValueType.Obj()));
								}
							}
						}

						if (map)
						{
							if (keyType && valueType)
							{
								Ptr<TypeInfoImpl> pointerType = new TypeInfoImpl(ITypeInfo::SharedPtr);
								{
									Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
									pointerType->SetElementType(genericType);
									{
										Ptr<TypeInfoImpl> classType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
										classType->SetTypeDescriptor(description::GetTypeDescriptor<IValueDictionary>());
										genericType->SetElementType(classType);
									}
									genericType->AddGenericArgument(keyType);
									genericType->AddGenericArgument(valueType);
								}
								results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)pointerType));
							}
						}
						else
						{
							if (keyType)
							{
								Ptr<TypeInfoImpl> pointerType = new TypeInfoImpl(ITypeInfo::SharedPtr);
								{
									Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
									pointerType->SetElementType(genericType);
									{
										Ptr<TypeInfoImpl> classType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
										classType->SetTypeDescriptor(description::GetTypeDescriptor<IValueList>());
										genericType->SetElementType(classType);
									}
									genericType->AddGenericArgument(keyType);
								}
								results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)pointerType));
							}
						}
					}
				}

				void Visit(WfInferExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();
					Ptr<ITypeInfo> type = CreateTypeInfoFromType(scope, node->type);
					Ptr<ITypeInfo> expressionType = GetExpressionType(manager, node->expression, type);
					if (expressionType)
					{
						results.Add(ResolveExpressionResult(type));
					}
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();
					Ptr<ITypeInfo> type = CreateTypeInfoFromType(scope, node->type);
					Ptr<ITypeInfo> expressionType = GetExpressionType(manager, node->expression, 0);
					if (type)
					{
						if (expressionType)
						{
							if (!CanConvertToType(expressionType.Obj(), type.Obj(), true))
							{
								manager->errors.Add(WfErrors::ExpressionCannotExplicitlyConvertToType(node->expression.Obj(), expressionType.Obj(), type.Obj()));
							}
						}
						if (node->strategy == WfTypeCastingStrategy::Weak)
						{
							switch (type->GetDecorator())
							{
							case ITypeInfo::RawPtr:
							case ITypeInfo::SharedPtr:
							case ITypeInfo::Nullable:
								break;
							default:
								manager->errors.Add(WfErrors::CannotWeakCastToType(node->expression.Obj(), type.Obj()));
							}
						}
						results.Add(ResolveExpressionResult(type));
					}
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, 0);
					if (type)
					{
						switch (node->test)
						{
						case WfTypeTesting::IsNull:
						case WfTypeTesting::IsNotNull:
							if (!IsNullAcceptableType(type.Obj()))
							{
								manager->errors.Add(WfErrors::NullCannotImplicitlyConvertToType(node->expression.Obj(), type.Obj()));
							}
							break;
						default:;
						}
					}
					results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					results.Add(ResolveExpressionResult(TypeInfoRetriver<ITypeDescriptor*>::CreateTypeInfo()));
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					GetExpressionType(manager, node->expression, 0);
					results.Add(ResolveExpressionResult(TypeInfoRetriver<ITypeDescriptor*>::CreateTypeInfo()));
				}

				void Visit(WfAttachEventExpression* node)override
				{
					IEventInfo* eventInfo = GetExpressionEventInfo(manager, node->event);
					Ptr<ITypeInfo> functionType;
					if (eventInfo)
					{
						functionType = CopyTypeInfo(eventInfo->GetHandlerType());
					}
					GetExpressionType(manager, node->function, functionType);
					results.Add(ResolveExpressionResult(TypeInfoRetriver<Ptr<IEventHandler>>::CreateTypeInfo()));
				}

				void Visit(WfDetachEventExpression* node)override
				{
					Ptr<ITypeInfo> pointerType = TypeInfoRetriver<Ptr<IEventHandler>>::CreateTypeInfo();
					GetExpressionType(manager, node->handler, pointerType);
					results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
				}

				void Visit(WfBindExpression* node)override
				{
					vint errorCount = manager->errors.Count();
					GetExpressionType(manager, node->expression, 0);
					results.Add(ResolveExpressionResult(TypeInfoRetriver<Ptr<IValueSubscription>>::CreateTypeInfo()));

					if (manager->errors.Count() == errorCount)
					{
						ExpandBindExpression(manager, node);
						auto parentScope = manager->expressionScopes[node];
						BuildScopeForExpression(manager, parentScope, node->expandedExpression);
						if (CheckScopes(manager))
						{
							GetExpressionType(manager, node->expandedExpression, 0);
						}
					}
				}

				void Visit(WfObserveExpression* node)override
				{
					Ptr<ITypeInfo> parentType = GetExpressionType(manager, node->parent, 0);
					Ptr<ITypeInfo> observeeType;
					if (parentType)
					{
						if (node->observeType == WfObserveType::SimpleObserve)
						{
							ITypeDescriptor* td = parentType->GetTypeDescriptor();
							IPropertyInfo* propertyInfo = 0;
							{
								auto ref = node->expression.Cast<WfReferenceExpression>();
								propertyInfo = td->GetPropertyByName(ref->name.value, true);
								if (propertyInfo)
								{
									observeeType = CopyTypeInfo(propertyInfo->GetReturn());
								}
								else
								{
									manager->errors.Add(WfErrors::MemberNotExists(ref.Obj(), td, ref->name.value));
								}
							}

							if (node->events.Count() == 0)
							{
								if (propertyInfo)
								{
									IEventInfo* eventInfo = propertyInfo->GetValueChangedEvent();
									if (!eventInfo)
									{
										eventInfo = td->GetEventByName(propertyInfo->GetName() + L"Changed", true);
									}
									if (!eventInfo)
									{
										manager->errors.Add(WfErrors::MemberNotExists(node->expression.Obj(), td, propertyInfo->GetName() + L"Changed"));
									}
								}
							}
							else
							{
								FOREACH(Ptr<WfExpression>, eventExpr, node->events)
								{
									auto ref = eventExpr.Cast<WfReferenceExpression>();
									IEventInfo* info = td->GetEventByName(ref->name.value, true);
									if (!info)
									{
										manager->errors.Add(WfErrors::MemberNotExists(ref.Obj(), td, ref->name.value));
									}
								}
							}
						}
						else
						{
							auto scope = manager->expressionScopes[node].Obj();
							auto symbol = scope->symbols[node->name.value][0];
							symbol->typeInfo = parentType;
							symbol->type = GetTypeFromTypeInfo(parentType.Obj());

							observeeType = GetExpressionType(manager, node->expression, 0);
							FOREACH(Ptr<WfExpression>, eventExpr, node->events)
							{
								GetExpressionEventInfo(manager, eventExpr);
							}
						}
					}

					if (observeeType)
					{
						results.Add(ResolveExpressionResult(observeeType));
					}
				}

				Ptr<ITypeInfo> SelectFunction(WfExpression* node, Ptr<WfExpression> functionExpression, List<ResolveExpressionResult>& functions, List<Ptr<WfExpression>>& arguments)
				{
					List<bool> resolvables;
					List<Ptr<ITypeInfo>> types;
					FOREACH(Ptr<WfExpression>, argument, arguments)
					{
						if (IsExpressionDependOnExpectedType(manager, argument))
						{
							resolvables.Add(false);
							types.Add(0);
						}
						else
						{
							resolvables.Add(true);
							types.Add(GetExpressionType(manager, argument, 0));
						}
					}

					List<Ptr<parsing::ParsingError>> functionErrors, nonFunctionErrors;
					ITypeDescriptor* functionFd = description::GetTypeDescriptor<IValueFunctionProxy>();
					for (vint i = functions.Count() - 1; i >= 0; i--)
					{
						bool failed = false;
						auto result = functions[i];
						if (result.type->GetDecorator() == ITypeInfo::SharedPtr)
						{
							ITypeInfo* genericType = result.type->GetElementType();
							if (genericType->GetDecorator() != ITypeInfo::Generic) goto FUNCTION_TYPE_FAILED;
							ITypeInfo* functionType = genericType->GetElementType();
							if (functionType->GetDecorator() != ITypeInfo::TypeDescriptor || functionType->GetTypeDescriptor() != functionFd) goto FUNCTION_TYPE_FAILED;
								
							if (genericType->GetGenericArgumentCount() != types.Count() + 1)
							{
								functionErrors.Add(WfErrors::FunctionArgumentCountMismatched(node, arguments.Count(), result));
								failed = true;
							}
							else
							{
								for (vint j = 0; j < types.Count(); j++)
								{
									if (resolvables[j] && types[j])
									{
										ITypeInfo* argumentType = genericType->GetGenericArgument(j + 1);
										if (!CanConvertToType(types[j].Obj(), argumentType, false))
										{
											functionErrors.Add(WfErrors::FunctionArgumentTypeMismatched(node, result, i + 1, types[j].Obj(), argumentType));
											failed = true;
										}
									}
								}
							}
						}
						else
						{
							goto FUNCTION_TYPE_FAILED;
						}

						goto FUNCTION_TYPE_FINISHED;
					FUNCTION_TYPE_FAILED:
						nonFunctionErrors.Add(WfErrors::ExpressionIsNotFunction(functionExpression.Obj(), result.type.Obj()));
						failed = true;
					FUNCTION_TYPE_FINISHED:
						if (failed)
						{
							functions.RemoveAt(i);
						}
					}

					if (functions.Count() > 1)
					{
						manager->errors.Add(WfErrors::CannotPickOverloadedFunctions(node, functions));
					}

					if (functions.Count() == 1)
					{
						Ptr<ITypeInfo> functionType = functions[0].type;
						ITypeInfo* genericType = functionType->GetElementType();
						for (vint i = 0; i < types.Count(); i++)
						{
							if (!resolvables[i])
							{
								ITypeInfo* argumentType = genericType->GetGenericArgument(i + 1);
								GetExpressionType(manager, arguments[i], CopyTypeInfo(argumentType));
							}
						}

						return CopyTypeInfo(genericType->GetGenericArgument(0));
					}
					else
					{
						CopyFrom(manager->errors, (functionErrors.Count() > 0 ? functionErrors : nonFunctionErrors), true);
					}
					return 0;
				}

				void Visit(WfCallExpression* node)override
				{
					List<ResolveExpressionResult> functions;
					GetExpressionTypes(manager, node->function, 0, functions);

					Ptr<ITypeInfo> resultType = SelectFunction(node, node->function, functions, node->arguments);
					if (resultType)
					{
						manager->expressionResolvings.Add(node->function, functions[0]);
						results.Add(ResolveExpressionResult(resultType));
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					ValidateDeclarationSemantic(manager, node->function);
					auto scope = manager->declarationScopes[node->function.Obj()].Obj();

					Ptr<TypeInfoImpl> functionType = new TypeInfoImpl(ITypeInfo::SharedPtr);
					{
						Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
						functionType->SetElementType(genericType);
						{
							Ptr<TypeInfoImpl> elementType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
							elementType->SetTypeDescriptor(description::GetTypeDescriptor<IValueFunctionProxy>());
							genericType->SetElementType(elementType);
						}

						genericType->AddGenericArgument(CreateTypeInfoFromType(scope, node->function->returnType));
						FOREACH(Ptr<WfFunctionArgument>, argument, node->function->arguments)
						{
							genericType->AddGenericArgument(scope->symbols[argument->name.value][0]->typeInfo);
						}
					}
					results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)functionType));
				}

				Ptr<ITypeInfo> GetFunctionDeclarationType(WfLexicalScope* scope,Ptr<WfFunctionDeclaration> decl)
				{
					Ptr<WfLexicalSymbol> symbol = From(manager->declarationScopes[decl.Obj()]->parentScope->symbols[decl->name.value])
						.Where([decl](Ptr<WfLexicalSymbol> symbol)
						{
							return symbol->creatorDeclaration == decl;
						})
						.First();
					return symbol->typeInfo;
				}

				void Visit(WfNewTypeExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();
					Ptr<ITypeInfo> type = CreateTypeInfoFromType(scope, node->type);
					if (type)
					{
						ITypeDescriptor* td = type->GetTypeDescriptor();
						ITypeDescriptor* proxyTd = description::GetTypeDescriptor<IValueInterfaceProxy>();
						IMethodGroupInfo* ctors = td->GetConstructorGroup();
						Ptr<ITypeInfo> selectedType;
						ResolveExpressionResult selectedFunction;
						if (!ctors || ctors->GetMethodCount() == 0)
						{
							manager->errors.Add(WfErrors::ClassContainsNoConstructor(node, type.Obj()));
						}
						else
						{
							if (node->functions.Count() == 0)
							{
								List<ResolveExpressionResult> functions;
								for (vint i = 0; i < ctors->GetMethodCount(); i++)
								{
									IMethodInfo* info = ctors->GetMethod(i);
									functions.Add(ResolveExpressionResult(info, CreateTypeInfoFromMethodInfo(info)));
								}

								selectedType = SelectFunction(node, 0, functions, node->arguments);
								if (selectedType)
								{
									selectedFunction = functions[0];
								}
							}
							else
							{
								for (vint i = 0; i < ctors->GetMethodCount(); i++)
								{
									IMethodInfo* info = ctors->GetMethod(i);
									if (info->GetParameterCount() == 1)
									{
										ITypeInfo* parameterType = info->GetParameter(0)->GetType();
										if (parameterType->GetDecorator() == ITypeInfo::SharedPtr)
										{
											parameterType = parameterType->GetElementType();
											if (parameterType->GetDecorator() == ITypeInfo::TypeDescriptor && parameterType->GetTypeDescriptor() == proxyTd)
											{
												selectedType = CopyTypeInfo(info->GetReturn());
												selectedFunction = ResolveExpressionResult(info, CreateTypeInfoFromMethodInfo(info));
												break;
											}
										}
									}
								}
								if (!selectedType)
								{
									manager->errors.Add(WfErrors::InterfaceContainsNoConstructor(node, type.Obj()));
								}
								
								Group<WString, IMethodInfo*> interfaceMethods;
								Group<WString, Ptr<WfFunctionDeclaration>> implementMethods;

								FOREACH(Ptr<WfFunctionDeclaration>, function, node->functions)
								{
									ValidateDeclarationSemantic(manager, function);
									implementMethods.Add(function->name.value, function);
								}

								{
									List<ITypeDescriptor*> types;
									types.Add(td);
									vint begin = 0;

									while (begin < types.Count())
									{
										ITypeDescriptor* currentType = types[begin++];
										vint count = currentType->GetBaseTypeDescriptorCount();
										for (vint i = 0; i < count; i++)
										{
											types.Add(currentType->GetBaseTypeDescriptor(i));
										}

										count = currentType->GetMethodGroupCount();
										for (vint i = 0; i < count; i++)
										{
											IMethodGroupInfo* group = currentType->GetMethodGroup(i);
											vint methodCount = group->GetMethodCount();
											for (vint j = 0; j < methodCount; j++)
											{
												interfaceMethods.Add(group->GetName(), group->GetMethod(j));
											}
										}
									}
								}

								auto discardFirst = [=](const WString& key, const List<IMethodInfo*>& methods)
									{
										FOREACH(IMethodInfo*, method, methods)
										{
											manager->errors.Add(WfErrors::InterfaceMethodNotImplemented(node, method));
										}
									};
								auto discardSecond = [=](const WString& key, const List<Ptr<WfFunctionDeclaration>>& methods)
									{
										FOREACH(Ptr<WfFunctionDeclaration>, decl, methods)
										{
											Ptr<ITypeInfo> declType = GetFunctionDeclarationType(scope, decl);
											manager->errors.Add(WfErrors::InterfaceMethodNotFound(decl.Obj(), type.Obj(), declType.Obj()));
										}
									};

								GroupInnerJoin(
									interfaceMethods,
									implementMethods,
									discardFirst,
									discardSecond,
									[=](const WString& key, const List<IMethodInfo*>& interfaces, const List<Ptr<WfFunctionDeclaration>>& implements)
									{
										Group<WString, IMethodInfo*> typedInterfaceMethods;
										Group<WString, Ptr<WfFunctionDeclaration>> typedImplementMethods;

										FOREACH(IMethodInfo*, method, interfaces)
										{
											Ptr<ITypeInfo> methodType = CreateTypeInfoFromMethodInfo(method);
											typedInterfaceMethods.Add(methodType->GetTypeFriendlyName(), method);
										}

										FOREACH(Ptr<WfFunctionDeclaration>, decl, implements)
										{
											Ptr<ITypeInfo> methodType = GetFunctionDeclarationType(scope, decl);
											typedImplementMethods.Add(methodType->GetTypeFriendlyName(), decl);
										}

										GroupInnerJoin(
											typedInterfaceMethods,
											typedImplementMethods,
											discardFirst,
											discardSecond,
											[=](const WString& key, const List<IMethodInfo*>& interfaces, const List<Ptr<WfFunctionDeclaration>>& implements)
											{
												if (interfaces.Count() > 1)
												{
													List<ResolveExpressionResult> functions;
													FOREACH(IMethodInfo*, method, interfaces)
													{
														functions.Add(ResolveExpressionResult(method, CreateTypeInfoFromMethodInfo(method)));
														manager->errors.Add(WfErrors::CannotPickOverloadedInterfaceMethods(node, functions));
													}
												}
												if (implements.Count() > 1)
												{
													auto decl = implements[0];
													Ptr<ITypeInfo> methodType = GetFunctionDeclarationType(scope, decl);
													manager->errors.Add(WfErrors::CannotPickOverloadedImplementMethods(decl.Obj(), methodType.Obj()));
												}
											});
									});
							}
						}
						if (selectedType)
						{
							if (!CanConvertToType(selectedType.Obj(), type.Obj(), false))
							{
								manager->errors.Add(WfErrors::ConstructorReturnTypeMismatched(node, selectedFunction, selectedType.Obj(), type.Obj()));
							}
						}
						results.Add(ResolveExpressionResult(selectedFunction.methodInfo, type));
					}
				}

				static void Execute(Ptr<WfExpression> expression, WfLexicalScopeManager* manager, Ptr<ITypeInfo> expectedType, List<ResolveExpressionResult>& results)
				{
					ValidateSemanticExpressionVisitor visitor(manager, expectedType, results);
					expression->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateSemantic
***********************************************************************/

			void ValidateModuleSemantic(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				FOREACH(Ptr<WfDeclaration>, declaration, module->declarations)
				{
					ValidateDeclarationSemantic(manager, declaration);
				}
			}

			void ValidateClassMemberSemantic(WfLexicalScopeManager* manager, Ptr<typeimpl::WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfClassMember> member)
			{
				return ValidateSemanticClassMemberVisitor::Execute(td, classDecl, member, manager);
			}

			void ValidateDeclarationSemantic(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration)
			{
				return ValidateSemanticDeclarationVisitor::Execute(declaration, manager);
			}

			void ValidateStatementSemantic(WfLexicalScopeManager* manager, Ptr<WfStatement> statement)
			{
				return ValidateSemanticStatementVisitor::Execute(statement, manager);
			}

			void ValidateExpressionSemantic(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results)
			{
				ValidateSemanticExpressionVisitor::Execute(expression, manager, expectedType, results);
				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto result = results[i];
					if (result.scopeName && result.scopeName->declarations.Count() > 0)
					{
						List<ResolveExpressionResult> replaces;
						FOREACH(Ptr<WfDeclaration>, decl, result.scopeName->declarations)
						{
							vint index = manager->declarationScopes.Keys().IndexOf(decl);
							if (index == -1) continue;
							auto scope = manager->declarationScopes.Values()[index];
							bool isVariable = decl.Cast<WfVariableDeclaration>();
							if (!isVariable)
							{
								scope = scope->parentScope;
							}

							index = scope->symbols.Keys().IndexOf(decl->name.value);
							if (index == -1) continue;
							FOREACH(Ptr<WfLexicalSymbol>, symbol, scope->symbols.GetByIndex(index))
							{
								if (symbol->creatorDeclaration == decl && symbol->typeInfo)
								{
									if (isVariable)
									{
										replaces.Add(ResolveExpressionResult(symbol, symbol->typeInfo, symbol->typeInfo));
									}
									else
									{
										replaces.Add(ResolveExpressionResult(symbol, symbol->typeInfo));
									}
								}
							}
						}

						if (replaces.Count() > 0)
						{
							results.RemoveAt(i);
							FOREACH_INDEXER(ResolveExpressionResult, replaceResult, index, replaces)
							{
								results.Insert(i + index, replaceResult);
							}
						}
					}
				}
			}

/***********************************************************************
GetExpressionScopeName
***********************************************************************/

			Ptr<WfLexicalScopeName> GetExpressionScopeName(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				List<ResolveExpressionResult> results;
				ValidateExpressionSemantic(manager, expression, 0, results);
				if (results.Count() == 0) return 0;

				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto& result = results[i];
					if (!result.scopeName)
					{
						results.RemoveAt(i);
					}
				}
				if (results.Count() == 0)
				{
					manager->errors.Add(WfErrors::ExpressionIsNotScopeName(expression.Obj()));
					return 0;
				}
				else if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression.Obj(), results, GetExpressionName(expression)));
					return 0;
				}

				auto result = results[0];
				manager->expressionResolvings.Add(expression, result);
				return result.scopeName;
			}

/***********************************************************************
GetExpressionEventInfo
***********************************************************************/

			reflection::description::IEventInfo* GetExpressionEventInfo(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				List<ResolveExpressionResult> results;
				ValidateExpressionSemantic(manager, expression, 0, results);
				if (results.Count() == 0) return 0;

				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto& result = results[i];
					if (!result.eventInfo)
					{
						results.RemoveAt(i);
					}
				}
				if (results.Count() == 0)
				{
					manager->errors.Add(WfErrors::ExpressionIsNotEvent(expression.Obj()));
					return 0;
				}
				else if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression.Obj(), results, GetExpressionName(expression)));
					return 0;
				}

				auto result = results[0];
				manager->expressionResolvings.Add(expression, result);
				return result.eventInfo;
			}

/***********************************************************************
GetExpressionTypes/GetExpressionType/GetLeftValueExpressionType
***********************************************************************/

			void GetExpressionTypes(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results)
			{
				ValidateExpressionSemantic(manager, expression, expectedType, results);
				if (results.Count() == 0) return;

				Ptr<WfLexicalScopeName> scopeName;
				IEventInfo* eventInfo = 0;
				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto& result = results[i];
					if (result.scopeName && !scopeName)
					{
						scopeName = result.scopeName;
					}
					if (result.eventInfo && !eventInfo)
					{
						eventInfo = result.eventInfo;
					}
					if (!result.type)
					{
						results.RemoveAt(i);
					}
				}
				if (results.Count() == 0)
				{
					if (scopeName)
					{
						manager->errors.Add(WfErrors::ScopeNameIsNotExpression(expression.Obj(), scopeName));
					}
					if (eventInfo)
					{
						manager->errors.Add(WfErrors::EventIsNotExpression(expression.Obj(), eventInfo));
					}
				}

				if (expectedType)
				{
					List<Ptr<ITypeInfo>> failedTypes;
					for (vint i = results.Count() - 1; i >= 0; i--)
					{
						auto& result = results[i];
						if (!CanConvertToType(result.type.Obj(), expectedType.Obj(), false))
						{
							failedTypes.Add(result.type);
							results.RemoveAt(i);
						}
					}

					if (results.Count() == 0)
					{
						FOREACH(Ptr<ITypeInfo>, type, failedTypes)
						{
							manager->errors.Add(WfErrors::ExpressionCannotImplicitlyConvertToType(expression.Obj(), type.Obj(), expectedType.Obj()));
						}
					}
				}
			}

			Ptr<reflection::description::ITypeInfo> GetExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				List<ResolveExpressionResult> results;
				GetExpressionTypes(manager, expression, expectedType, results);

				if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression.Obj(), results, GetExpressionName(expression)));
					return expectedType;
				}
				else if (results.Count() == 1)
				{
					auto result = results[0];
					result.expectedType = expectedType;
					manager->expressionResolvings.Add(expression, result);
					return expectedType ? expectedType : result.type;
				}
				else
				{
					return expectedType;
				}
			}

			Ptr<reflection::description::ITypeInfo>	GetLeftValueExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				List<ResolveExpressionResult> results;
				GetExpressionTypes(manager, expression, 0, results);

				if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression.Obj(), results, GetExpressionName(expression)));
				}
				else if (results.Count() == 1)
				{
					if (results[0].leftValueType)
					{
						auto result = results[0];
						manager->expressionResolvings.Add(expression, result);
						return result.leftValueType;
					}
					else
					{
						manager->errors.Add(WfErrors::ExpressionIsNotLeftValue(expression.Obj(), results[0]));
					}
				}
				return 0;
			}

/***********************************************************************
GetEnumerableExpressionItemType
***********************************************************************/

			Ptr<reflection::description::ITypeInfo>	GetEnumerableExpressionItemType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				Ptr<ITypeInfo> collectionType = GetExpressionType(manager, expression, expectedType);
				if (collectionType)
				{
					if (collectionType->GetTypeDescriptor()->CanConvertTo(description::GetTypeDescriptor<IValueEnumerable>()))
					{
						if (collectionType->GetDecorator() == ITypeInfo::SharedPtr)
						{
							ITypeInfo* genericType = collectionType->GetElementType();
							if (genericType->GetDecorator() == ITypeInfo::Generic && genericType->GetGenericArgumentCount() == 1)
							{
								return CopyTypeInfo(genericType->GetGenericArgument(0));
							}
						}
						return TypeInfoRetriver<Value>::CreateTypeInfo();
					}

					manager->errors.Add(WfErrors::ExpressionIsNotCollection(expression.Obj(), collectionType.Obj()));
				}
				return 0;
			}
		}
	}
}

/***********************************************************************
ANALYZER\WFANALYZER_VALIDATESTRUCTURE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace parsing;

/***********************************************************************
ValidateStructureContext
***********************************************************************/

			ValidateStructureContext::ValidateStructureContext()
				:currentBindExpression(0)
				, currentObserveExpression(0)
				, currentLoopStatement(0)
				, currentCatchStatement(0)
			{
			}

/***********************************************************************
ValidateStructure(Type)
***********************************************************************/

			class ValidateReferenceTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				bool									result;

				ValidateReferenceTypeVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
					, result(true)
				{
				}
				
				void Visit(WfPredefinedType* node)override
				{
				}

				void Visit(WfTopQualifiedType* node)override
				{
				}

				void Visit(WfReferenceType* node)override
				{
				}

				void Visit(WfRawPointerType* node)override
				{
					result = false;
				}

				void Visit(WfSharedPointerType* node)override
				{
					result = false;
				}

				void Visit(WfNullableType* node)override
				{
					result = false;
				}

				void Visit(WfEnumerableType* node)override
				{
					result = false;
				}

				void Visit(WfMapType* node)override
				{
					result = false;
				}

				void Visit(WfFunctionType* node)override
				{
					result = false;
				}

				void Visit(WfChildType* node)override
				{
					node->parent->Accept(this);
				}

				static bool Execute(Ptr<WfType> type, WfLexicalScopeManager* manager)
				{
					ValidateReferenceTypeVisitor visitor(manager);
					type->Accept(&visitor);
					return visitor.result;
				}
			};

			class ValidateStructureTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;

				ValidateStructureTypeVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}
				
				void Visit(WfPredefinedType* node)override
				{
					switch (node->name)
					{
					case WfPredefinedTypeName::Void:
						manager->errors.Add(WfErrors::WrongVoidType(node));
						break;
					case WfPredefinedTypeName::Interface:
						manager->errors.Add(WfErrors::WrongInterfaceType(node));
						break;
					default:;
					}
				}

				void Visit(WfTopQualifiedType* node)override
				{
				}

				void Visit(WfReferenceType* node)override
				{
				}

				void Visit(WfRawPointerType* node)override
				{
					if (!ValidateReferenceTypeVisitor::Execute(node->element, manager))
					{
						manager->errors.Add(WfErrors::RawPointerToNonReferenceType(node));
					}
					else if (auto predefinedType = node->element.Cast<WfPredefinedType>())
					{
						if (predefinedType->name != WfPredefinedTypeName::Interface)
						{
							manager->errors.Add(WfErrors::RawPointerToNonReferenceType(node));
						}
					}
				}

				void Visit(WfSharedPointerType* node)override
				{
					if (!ValidateReferenceTypeVisitor::Execute(node->element, manager))
					{
						manager->errors.Add(WfErrors::SharedPointerToNonReferenceType(node));
					}
					else if (auto predefinedType = node->element.Cast<WfPredefinedType>())
					{
						if (predefinedType->name != WfPredefinedTypeName::Interface)
						{
							manager->errors.Add(WfErrors::SharedPointerToNonReferenceType(node));
						}
					}
				}

				void Visit(WfNullableType* node)override
				{
					if (!ValidateReferenceTypeVisitor::Execute(node->element, manager))
					{
						manager->errors.Add(WfErrors::NullableToNonReferenceType(node));
					}
					else if (auto predefinedType = node->element.Cast<WfPredefinedType>())
					{
						switch (predefinedType->name)
						{
						case WfPredefinedTypeName::Void:
						case WfPredefinedTypeName::Object:
						case WfPredefinedTypeName::Interface:
							manager->errors.Add(WfErrors::NullableToNonReferenceType(node));
							break;
						default:;
						}
					}
				}

				void Visit(WfEnumerableType* node)override
				{
					ValidateTypeStructure(manager, node->element);
				}

				void Visit(WfMapType* node)override
				{
					if (node->key)
					{
						ValidateTypeStructure(manager, node->key);
					}
					ValidateTypeStructure(manager, node->value);
				}

				void Visit(WfFunctionType* node)override
				{
					ValidateTypeStructure(manager, node->result, true);
					FOREACH(Ptr<WfType>, argument, node->arguments)
					{
						ValidateTypeStructure(manager, argument);
					}
				}

				void Visit(WfChildType* node)override
				{
					if (!ValidateReferenceTypeVisitor::Execute(node->parent, manager))
					{
						manager->errors.Add(WfErrors::ChildOfNonReferenceType(node));
					}
				}

				static void Execute(Ptr<WfType> type, WfLexicalScopeManager* manager)
				{
					ValidateStructureTypeVisitor visitor(manager);
					type->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateStructure(Declaration)
***********************************************************************/

			class ValidateStructureDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				WfClassDeclaration*						classDecl;
				ParsingTreeCustomBase*					source;

				ValidateStructureDeclarationVisitor(WfLexicalScopeManager* _manager, WfClassDeclaration* _classDecl, ParsingTreeCustomBase* _source)
					:manager(_manager)
					, classDecl(_classDecl)
					, source(_source)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					if (auto classMember = dynamic_cast<WfClassMember*>(source))
					{
						manager->errors.Add(WfErrors::WrongClassMember(node));
					}

					for (vint i = 0; i < node->declarations.Count(); i++)
					{
						ValidateDeclarationStructure(manager, node->declarations[i]);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (auto classMember = dynamic_cast<WfClassMember*>(source))
					{
						if (node->statement)
						{
							if (classDecl->kind == WfClassKind::Interface && classMember->kind != WfClassMemberKind::Static)
							{
								manager->errors.Add(WfErrors::InterfaceMethodShouldNotHaveImplementation(node));
							}
						}
						else
						{
							if (classDecl->kind == WfClassKind::Class || classMember->kind == WfClassMemberKind::Static)
							{
								manager->errors.Add(WfErrors::FunctionShouldHaveImplementation(node));
							}
						}

						if (classDecl->kind == WfClassKind::Class && classMember->kind != WfClassMemberKind::Static)
						{
							manager->errors.Add(WfErrors::ClassFeatureNotSupported(classMember, L"non-static class method"));
						}
					}
					else
					{
						if (!node->statement)
						{
							manager->errors.Add(WfErrors::FunctionShouldHaveImplementation(node));
						}
					}

					if (node->anonymity == WfFunctionAnonymity::Anonymous)
					{
						if (!source || !dynamic_cast<WfFunctionExpression*>(source))
						{
							manager->errors.Add(WfErrors::FunctionShouldHaveName(node));
						}
					}


					ValidateTypeStructure(manager, node->returnType, true);
					FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
					{
						ValidateTypeStructure(manager, argument->type);
					}

					if (node->statement)
					{
						ValidateStructureContext context;
						ValidateStatementStructure(manager, &context, node->statement);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					if (auto classMember = dynamic_cast<WfClassMember*>(source))
					{
						switch (classMember->kind)
						{
						case WfClassMemberKind::Static:
							manager->errors.Add(WfErrors::NonFunctionClassMemberCannotBeStatic(classMember));
							break;
						}
						manager->errors.Add(WfErrors::ClassFeatureNotSupported(classMember, L"variable class member"));
					}

					if (node->type)
					{
						ValidateTypeStructure(manager, node->type);
					}
					ValidateStructureContext context;
					ValidateExpressionStructure(manager, &context, node->expression);
				}

				void Visit(WfEventDeclaration* node)override
				{
					if (auto classMember = dynamic_cast<WfClassMember*>(source))
					{
						switch (classDecl->kind)
						{
						case WfClassKind::Class:
							{
								manager->errors.Add(WfErrors::ClassFeatureNotSupported(classMember, L"event"));
							}
							break;
						}

						FOREACH(Ptr<WfType>, argument, node->arguments)
						{
							ValidateTypeStructure(manager, argument);
						}
					}
					else
					{
						manager->errors.Add(WfErrors::WrontDeclaration(node));
					}
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					if (auto classMember = dynamic_cast<WfClassMember*>(source))
					{
						switch (classDecl->kind)
						{
						case WfClassKind::Class:
							{
								manager->errors.Add(WfErrors::ClassFeatureNotSupported(classMember, L"property"));
							}
							break;
						}

						ValidateTypeStructure(manager, node->type);

						Ptr<WfClassMember> getter, setter, valueChangedEvent;
						bool duplicateGetter = false;
						bool duplicateSetter = false;
						bool duplicateEvent = false;
						FOREACH(Ptr<WfClassMember>, member, classDecl->members)
						{
							if (!duplicateGetter && member->declaration->name.value == node->getter.value)
							{
								if (getter)
								{
									duplicateGetter = true;
									manager->errors.Add(WfErrors::TooManyPropertyGetter(node, classDecl));
								}
								else
								{
									getter = member;
								}
							}

							if (!duplicateSetter && node->setter.value != L"" && member->declaration->name.value == node->setter.value)
							{
								if (setter)
								{
									duplicateSetter = true;
									manager->errors.Add(WfErrors::TooManyPropertySetter(node, classDecl));
								}
								else
								{
									setter = member;
								}
							}

							if (!duplicateEvent && node->valueChangedEvent.value != L"" && member->declaration->name.value == node->valueChangedEvent.value)
							{
								if (valueChangedEvent)
								{
									duplicateEvent = true;
									manager->errors.Add(WfErrors::TooManyPropertyEvent(node, classDecl));
								}
								else
								{
									valueChangedEvent = member;
								}
							}
						}

						if (!getter || getter->kind == WfClassMemberKind::Static || !getter->declaration.Cast<WfFunctionDeclaration>())
						{
							manager->errors.Add(WfErrors::PropertyGetterNotFound(node, classDecl));
						}

						if (node->setter.value != L"" && (!setter || setter->kind == WfClassMemberKind::Static || !setter->declaration.Cast<WfFunctionDeclaration>()))
						{
							manager->errors.Add(WfErrors::PropertySetterNotFound(node, classDecl));
						}

						if (node->valueChangedEvent.value != L"" && (!valueChangedEvent || valueChangedEvent->kind == WfClassMemberKind::Static || !valueChangedEvent->declaration.Cast<WfEventDeclaration>()))
						{
							manager->errors.Add(WfErrors::PropertyEventNotFound(node, classDecl));
						}
					}
					else
					{
						manager->errors.Add(WfErrors::WrontDeclaration(node));
					}
				}

				void Visit(WfClassDeclaration* node)override
				{
					if (auto classMember = dynamic_cast<WfClassMember*>(source))
					{
						switch (classMember->kind)
						{
						case WfClassMemberKind::Static:
							manager->errors.Add(WfErrors::NonFunctionClassMemberCannotBeStatic(classMember));
							break;
						}
					}

					switch (node->kind)
					{
					case WfClassKind::Class:
						{
							if (node->baseTypes.Count() > 0)
							{
								manager->errors.Add(WfErrors::ClassFeatureNotSupported(node, L"base type"));
							}
						}
						break;
					}

					FOREACH(Ptr<WfType>, type, node->baseTypes)
					{
						ValidateTypeStructure(manager, type);

						WfType* currentType = type.Obj();
						while (currentType)
						{
							if (auto tqType = dynamic_cast<WfTopQualifiedType*>(currentType))
							{
								currentType = nullptr;
							}
							else if (auto refType = dynamic_cast<WfReferenceType*>(currentType))
							{
								currentType = nullptr;
							}
							else if (auto childType = dynamic_cast<WfChildType*>(currentType))
							{
								currentType = childType->parent.Obj();
							}
							else
							{
								manager->errors.Add(WfErrors::WrongBaseType(node, type.Obj()));
								break;
							}
						}
					}

					FOREACH(Ptr<WfClassMember>, member, node->members)
					{
						ValidateDeclarationStructure(manager, member->declaration, node, member.Obj());
					}
				}

				static void Execute(Ptr<WfDeclaration> declaration, WfLexicalScopeManager* manager, WfClassDeclaration* classDecl, ParsingTreeCustomBase* source)
				{
					ValidateStructureDeclarationVisitor visitor(manager, classDecl, source);
					declaration->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateStructure(Statement)
***********************************************************************/

			class ValidateStructureStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ValidateStructureContext*				context;
				Ptr<WfStatement>						result;

				ValidateStructureStatementVisitor(WfLexicalScopeManager* _manager, ValidateStructureContext* _context)
					:manager(_manager)
					, context(_context)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
					if (!context->currentLoopStatement)
					{
						manager->errors.Add(WfErrors::BreakNotInLoop(node));
					}
				}

				void Visit(WfContinueStatement* node)override
				{
					if (!context->currentLoopStatement)
					{
						manager->errors.Add(WfErrors::ContinueNotInLoop(node));
					}
				}

				void Visit(WfReturnStatement* node)override
				{
					if (node->expression)
					{
						ValidateExpressionStructure(manager, context, node->expression);
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						ValidateExpressionStructure(manager, context, node->expression);
					}
					else if (!context->currentCatchStatement)
					{
						manager->errors.Add(WfErrors::RethrowNotInCatch(node));
					}
				}

				void Visit(WfIfStatement* node)override
				{
					if (node->type)
					{
						ValidateTypeStructure(manager, node->type);
					}
					ValidateExpressionStructure(manager, context, node->expression);
					ValidateStatementStructure(manager, context, node->trueBranch);
					if (node->falseBranch)
					{
						ValidateStatementStructure(manager, context, node->falseBranch);
					}
				}

				void Visit(WfSwitchStatement* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						ValidateExpressionStructure(manager, context, switchCase->expression);
						ValidateStatementStructure(manager, context, switchCase->statement);
					}
					if (node->defaultBranch)
					{
						ValidateStatementStructure(manager, context, node->defaultBranch);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					auto oldLoop = context->currentLoopStatement;
					context->currentLoopStatement = node;
					ValidateExpressionStructure(manager, context, node->condition);
					ValidateStatementStructure(manager, context, node->statement);
					context->currentLoopStatement = oldLoop;
				}

				void Visit(WfForEachStatement* node)override
				{
					auto oldLoop = context->currentLoopStatement;
					context->currentLoopStatement = node;
					ValidateExpressionStructure(manager, context, node->collection);
					ValidateStatementStructure(manager, context, node->statement);
					context->currentLoopStatement = oldLoop;
				}

				void Visit(WfTryStatement* node)override
				{
					ValidateStatementStructure(manager, context, node->protectedStatement);
					if (node->catchStatement)
					{
						auto oldCatch = context->currentCatchStatement;
						context->currentCatchStatement = node->catchStatement.Obj();
						ValidateStatementStructure(manager, context, node->catchStatement);
						context->currentCatchStatement = oldCatch;
					}
					if (node->finallyStatement)
					{
						ValidateStatementStructure(manager, context, node->finallyStatement);
					}
					if (!node->catchStatement && !node->finallyStatement)
					{
						manager->errors.Add(WfErrors::TryMissCatchAndFinally(node));
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					for (vint i = 0; i < node->statements.Count(); i++)
					{
						ValidateStatementStructure(manager, context, node->statements[i]);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfVariableStatement* node)override
				{
					ValidateDeclarationStructure(manager, node->variable, nullptr, node);
				}

				static void Execute(Ptr<WfStatement>& statement, WfLexicalScopeManager* manager, ValidateStructureContext* context)
				{
					ValidateStructureStatementVisitor visitor(manager, context);
					statement->Accept(&visitor);
					if (visitor.result)
					{
						statement = visitor.result;
					}
				}
			};

/***********************************************************************
ValidateStructure(Expression)
***********************************************************************/

			class ValidateStructureExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ValidateStructureContext*				context;
				Ptr<WfExpression>						result;

				ValidateStructureExpressionVisitor(WfLexicalScopeManager* _manager, ValidateStructureContext* _context)
					:manager(_manager)
					, context(_context)
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					auto oldBind = context->currentBindExpression;
					context->currentBindExpression = 0;
					ValidateExpressionStructure(manager, context, node->body);
					context->currentBindExpression = oldBind;
				}

				void Visit(WfMemberExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->parent);
				}

				void Visit(WfChildExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->parent);
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
					if (!node->expandedExpression)
					{
						List<Ptr<WfExpression>> expressions;
						const wchar_t* reading = node->value.value.Buffer();

						while (*reading)
						{
							const wchar_t* begin = wcsstr(reading, L"$(");
							if (begin)
							{
								Ptr<WfStringExpression> expression = new WfStringExpression;
								expression->codeRange = node->codeRange;
								expression->value.value = WString(reading, vint(begin - reading));
								expressions.Add(expression);
							}
							else
							{
								break;
							}

							const wchar_t* end = begin + 2;
							vint counter = 1;
							while (wchar_t c = *end++)
							{
								switch (c)
								{
								case L'(':
									counter++;
									break;
								case L')':
									counter--;
									break;
								}
								if (counter == 0)
								{
									break;
								}
							}

							if (counter != 0)
							{
								auto error = WfErrors::WrongFormatStringSyntax(node);
								error->errorMessage += L" (Does not find matched close bracket.)";
								manager->errors.Add(error);
								return;
							}
							else
							{
								WString input(begin + 2, vint(end - begin - 3));
								List<Ptr<ParsingError>> errors;
								if (auto expression = WfParseExpression(input, manager->parsingTable, errors))
								{
									expressions.Add(expression);
								}
								FOREACH(Ptr<ParsingError>, originalError, errors)
								{
									auto error = WfErrors::WrongFormatStringSyntax(node);
									error->errorMessage += L" (" + originalError->errorMessage + L")";
									manager->errors.Add(error);
								}
								reading = end;
							}
						}
						if (*reading || expressions.Count() == 0)
						{
							Ptr<WfStringExpression> expression = new WfStringExpression;
							expression->codeRange = node->codeRange;
							expression->value.value = reading;
							expressions.Add(expression);
						}

						if (expressions.Count() > 0)
						{
							Ptr<WfExpression> current = expressions[0];
							FOREACH(Ptr<WfExpression>, expression, From(expressions).Skip(1))
							{
								Ptr<WfBinaryExpression> binary = new WfBinaryExpression;
								binary->codeRange = node->codeRange;
								binary->first = current;
								binary->second = expression;
								binary->op = WfBinaryOperator::Concat;
								current = binary;
							}

							node->expandedExpression = current;
						}
					}

					if (node->expandedExpression)
					{
						ValidateExpressionStructure(manager, context, node->expandedExpression);
					}
				}

				void Visit(WfUnaryExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->operand);
				}

				void Visit(WfBinaryExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->first);
					ValidateExpressionStructure(manager, context, node->second);
				}

				void Visit(WfLetExpression* node)override
				{
					FOREACH(Ptr<WfLetVariable>, variable, node->variables)
					{
						ValidateExpressionStructure(manager, context, variable->value);
					}
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfIfExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->condition);
					ValidateExpressionStructure(manager, context, node->trueBranch);
					ValidateExpressionStructure(manager, context, node->falseBranch);
				}

				void Visit(WfRangeExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->begin);
					ValidateExpressionStructure(manager, context, node->end);
				}

				void Visit(WfSetTestingExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->element);
					ValidateExpressionStructure(manager, context, node->collection);
				}

				void Visit(WfConstructorExpression* node)override
				{
					vint listElementCount = 0;
					vint mapElementCount = 0;
					FOREACH(Ptr<WfConstructorArgument>, argument, node->arguments)
					{
						ValidateExpressionStructure(manager, context, argument->key);
						if (argument->value)
						{
							ValidateExpressionStructure(manager, context, argument->value);
							mapElementCount++;
						}
						else
						{
							listElementCount++;
						}
					}

					if (listElementCount*mapElementCount != 0)
					{
						manager->errors.Add(WfErrors::ConstructorMixMapAndList(node));
					}
				}

				void Visit(WfInferExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					if (node->type)
					{
						ValidateTypeStructure(manager, node->type);
					}
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfAttachEventExpression* node)override
				{
					if (context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::AttachInBind(node));
					}
					ValidateExpressionStructure(manager, context, node->event);
					ValidateExpressionStructure(manager, context, node->function);
				}

				void Visit(WfDetachEventExpression* node)override
				{
					if (context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::DetachInBind(node));
					}
					ValidateExpressionStructure(manager, context, node->handler);
				}

				void Visit(WfBindExpression* node)override
				{
					if (context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::BindInBind(node));
					}

					auto bind = context->currentBindExpression;
					context->currentBindExpression = node;
					ValidateExpressionStructure(manager, context, node->expression);
					context->currentBindExpression = bind;
				}

				void Visit(WfObserveExpression* node)override
				{
					if (!context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::ObserveNotInBind(node));
					}
					if (context->currentObserveExpression)
					{
						manager->errors.Add(WfErrors::ObserveInObserveEvent(node));
					}

					if (node->observeType == WfObserveType::SimpleObserve)
					{
						if (!node->expression.Cast<WfReferenceExpression>())
						{
							manager->errors.Add(WfErrors::WrongSimpleObserveExpression(node->expression.Obj()));
						}
						FOREACH(Ptr<WfExpression>, event, node->events)
						{
							if (!event.Cast<WfReferenceExpression>())
							{
								manager->errors.Add(WfErrors::WrongSimpleObserveEvent(event.Obj()));
							}
						}
					}
					if (node->events.Count() == 0)
					{
						manager->errors.Add(WfErrors::EmptyObserveEvent(node));
					}

					ValidateExpressionStructure(manager, context, node->parent);
					ValidateExpressionStructure(manager, context, node->expression);
					context->currentObserveExpression = node;
					for (vint i = 0; i < node->events.Count(); i++)
					{
						ValidateExpressionStructure(manager, context, node->events[i]);
					}
					context->currentObserveExpression = 0;
				}

				void Visit(WfCallExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->function);
					for (vint i = 0; i < node->arguments.Count(); i++)
					{
						ValidateExpressionStructure(manager, context, node->arguments[i]);
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					ValidateDeclarationStructure(manager, node->function, nullptr, node);
				}

				void Visit(WfNewTypeExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					for (vint i = 0; i < node->arguments.Count(); i++)
					{
						ValidateExpressionStructure(manager, context, node->arguments[i]);
					}
					FOREACH(Ptr<WfFunctionDeclaration>, function, node->functions)
					{
						ValidateDeclarationStructure(manager, function);
					}

					if (node->arguments.Count()*node->functions.Count() != 0)
					{
						manager->errors.Add(WfErrors::ConstructorMixClassAndInterface(node));
					}
				}

				static void Execute(Ptr<WfExpression>& expression, WfLexicalScopeManager* manager, ValidateStructureContext* context)
				{
					ValidateStructureExpressionVisitor visitor(manager, context);
					expression->Accept(&visitor);
					if (visitor.result)
					{
						expression = visitor.result;
					}
				}
			};

/***********************************************************************
ValidateStructure
***********************************************************************/

			void ValidateTypeStructure(WfLexicalScopeManager* manager, Ptr<WfType> type, bool returnType)
			{
				if (returnType)
				{
					if (auto predefinedType = type.Cast<WfPredefinedType>())
					{
						if (predefinedType->name == WfPredefinedTypeName::Void)
						{
							return;
						}
					}
				}
				ValidateStructureTypeVisitor::Execute(type, manager);
			}

			void ValidateModuleStructure(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				FOREACH(Ptr<WfModuleUsingPath>, path, module->paths)
				{
					FOREACH_INDEXER(Ptr<WfModuleUsingItem>, item, index, path->items)
					{
						vint counter = 0;
						FOREACH(Ptr<WfModuleUsingFragment>, fragment, item->fragments)
						{
							if (fragment.Cast<WfModuleUsingWildCardFragment>())
							{
								if (index == path->items.Count() - 1)
								{
									counter++;
								}
								else
								{
									goto USING_PATH_INCORRECT;
								}
							}
						}

						if (index == path->items.Count() - 1 && counter != 1)
						{
							goto USING_PATH_INCORRECT;
						}
					}
					continue;
				USING_PATH_INCORRECT:
					manager->errors.Add(WfErrors::WrongUsingPathWildCard(path.Obj()));
				}
				for (vint i = 0; i < module->declarations.Count(); i++)
				{
					ValidateDeclarationStructure(manager, module->declarations[i]);
				}
			}

			void ValidateDeclarationStructure(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration, WfClassDeclaration* classDecl, parsing::ParsingTreeCustomBase* source)
			{
				ValidateStructureDeclarationVisitor::Execute(declaration, manager, classDecl, source);
			}

			void ValidateStatementStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfStatement>& statement)
			{
				ValidateStructureStatementVisitor::Execute(statement, manager, context);
			}

			void ValidateExpressionStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfExpression>& expression)
			{
				ValidateStructureExpressionVisitor::Execute(expression, manager, context);
			}
		}
	}
}

/***********************************************************************
EXPRESSION\WFEXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		using namespace stream;
		using namespace collections;
		using namespace parsing;

/***********************************************************************
Unescaping Functions
***********************************************************************/

		void UnescapeStringInternal(vl::parsing::ParsingToken& value, bool formatString)
		{
			MemoryStream memoryStream;
			{
				WString input = formatString ? value.value.Sub(2, value.value.Length() - 3) : value.value.Sub(1, value.value.Length() - 2);
				const wchar_t* reading = input.Buffer();
				StreamWriter writer(memoryStream);

				while (wchar_t c = *reading++)
				{
					if (c == L'\\')
					{
						switch (wchar_t e = *reading++)
						{
						case L'r':
							writer.WriteChar('\r');
							break;
						case L'n':
							writer.WriteChar('\n');
							break;
						case L't':
							writer.WriteChar('\t');
							break;
						default:
							writer.WriteChar(e);
						}
					}
					else
					{
						writer.WriteChar(c);
					}
				}
			}

			memoryStream.SeekFromBegin(0);
			{
				StreamReader reader(memoryStream);
				value.value = reader.ReadToEnd();
			}
		}

		void UnescapeFormatString(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			UnescapeStringInternal(value, true);
		}

		void UnescapeString(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			UnescapeStringInternal(value, false);
		}

		void EscapeString(const WString& text, ParsingWriter& writer)
		{
			writer.WriteChar(L'\"');
			const wchar_t* reading = text.Buffer();
			while (wchar_t c = *reading++)
			{
				switch (c)
				{
				case '\r':
					writer.WriteString(L"\\r");
					break;
				case '\n':
					writer.WriteString(L"\\n");
					break;
				case '\t':
					writer.WriteString(L"\\t");
					break;
				case '\"':
					writer.WriteString(L"\\\"");
					break;
				case '\\':
					writer.WriteString(L"\\\\");
					break;
				default:
					writer.WriteChar(c);
				}
			}
			writer.WriteChar(L'\"');
		}

/***********************************************************************
Print (Type)
***********************************************************************/

		class PrintTypeVisitor : public Object, public WfType::IVisitor
		{
		public:
			WString								indent;
			ParsingWriter&						writer;

			PrintTypeVisitor(const WString& _indent, ParsingWriter& _writer)
				:indent(_indent), writer(_writer)
			{
			}

			void Visit(WfPredefinedType* node)override
			{
				writer.BeforePrint(node);
				switch (node->name)
				{
				case WfPredefinedTypeName::Void:
					writer.WriteString(L"void");
					break;
				case WfPredefinedTypeName::Object:
					writer.WriteString(L"object");
					break;
				case WfPredefinedTypeName::Interface:
					writer.WriteString(L"interface");
					break;
				case WfPredefinedTypeName::Int:
					writer.WriteString(L"int");
					break;
				case WfPredefinedTypeName::UInt:
					writer.WriteString(L"uint");
					break;
				case WfPredefinedTypeName::Float:
					writer.WriteString(L"float");
					break;
				case WfPredefinedTypeName::Double:
					writer.WriteString(L"double");
					break;
				case WfPredefinedTypeName::String:
					writer.WriteString(L"string");
					break;
				case WfPredefinedTypeName::Char:
					writer.WriteString(L"char");
					break;
				case WfPredefinedTypeName::Bool:
					writer.WriteString(L"bool");
					break;
				}
				writer.AfterPrint(node);
			}

			void Visit(WfTopQualifiedType* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"::" + node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfReferenceType* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfRawPointerType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				writer.WriteString(L"*");
				writer.AfterPrint(node);
			}

			void Visit(WfSharedPointerType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				writer.WriteString(L"^");
				writer.AfterPrint(node);
			}

			void Visit(WfNullableType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				writer.WriteString(L"?");
				writer.AfterPrint(node);
			}

			void Visit(WfEnumerableType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				writer.WriteString(L"{}");
				writer.AfterPrint(node);
			}

			void Visit(WfMapType* node)override
			{
				writer.BeforePrint(node);
				if (node->writability == WfMapWritability::Readonly)
				{
					writer.WriteString(L"const ");
				}
				WfPrint(node->value, indent, writer);
				writer.WriteString(L"[");
				if (node->key)
				{
					WfPrint(node->key, indent, writer);
				}
				writer.WriteString(L"]");
				writer.AfterPrint(node);
			}

			void Visit(WfFunctionType* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"func ");
				writer.WriteString(L"(");
				FOREACH_INDEXER(Ptr<WfType>, type, index, node->arguments)
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					WfPrint(type, indent, writer);
				}
				writer.WriteString(L")");

				writer.WriteString(L" : ");
				WfPrint(node->result, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfChildType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->parent, indent, writer);
				writer.WriteString(L"::");
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}
		};

/***********************************************************************
Print (Expression)
***********************************************************************/

		class PrintExpressionVisitor : public Object, public WfExpression::IVisitor
		{
		public:
			WString								indent;
			ParsingWriter&						writer;

			PrintExpressionVisitor(const WString& _indent, ParsingWriter& _writer)
				:indent(_indent), writer(_writer)
			{
			}

			void Visit(WfTopQualifiedExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"::");
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfReferenceExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfOrderedNameExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfOrderedLambdaExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"[");
				WfPrint(node->body, indent, writer);
				writer.WriteString(L"]");
				writer.AfterPrint(node);
			}

			void Visit(WfMemberExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->parent, indent, writer);
				writer.WriteString(L".");
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfChildExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->parent, indent, writer);
				writer.WriteString(L"::");
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfLiteralExpression* node)override
			{
				writer.BeforePrint(node);
				switch (node->value)
				{
				case WfLiteralValue::Null:
					writer.WriteString(L"null");
					break;
				case WfLiteralValue::True:
					writer.WriteString(L"true");
					break;
				case WfLiteralValue::False:
					writer.WriteString(L"false");
					break;
				}
				writer.AfterPrint(node);
			}

			void Visit(WfFloatingExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->value.value);
				writer.AfterPrint(node);
			}

			void Visit(WfIntegerExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->value.value);
				writer.AfterPrint(node);
			}

			void Visit(WfStringExpression* node)override
			{
				writer.BeforePrint(node);
				EscapeString(node->value.value, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfFormatExpression* node)override
			{
				writer.BeforePrint(node);
				if (node->expandedExpression)
				{
					WfPrint(node->expandedExpression, indent, writer);
				}
				else
				{
					writer.WriteString(L"$");
					EscapeString(node->value.value, writer);
				}
				writer.AfterPrint(node);
			}

			void Visit(WfUnaryExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"(");
				switch (node->op)
				{
				case WfUnaryOperator::Positive:
					writer.WriteString(L"+");
					break;
				case WfUnaryOperator::Negative:
					writer.WriteString(L"-");
					break;
				case WfUnaryOperator::Not:
					writer.WriteString(L"!");
					break;
				}
				WfPrint(node->operand, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfBinaryExpression* node)override
			{
				writer.BeforePrint(node);
				if (node->op == WfBinaryOperator::Index)
				{
					WfPrint(node->first, indent, writer);
					writer.WriteString(L"[");
					WfPrint(node->second, indent, writer);
					writer.WriteString(L"]");
				}
				else
				{
					writer.WriteString(L"(");
					WfPrint(node->first, indent, writer);
					switch (node->op)
					{
					case WfBinaryOperator::Assign:
						writer.WriteString(L" = ");
						break;
					case WfBinaryOperator::Concat:
						writer.WriteString(L" & ");
						break;
					case WfBinaryOperator::FailedThen:
						writer.WriteString(L" ?? ");
						break;
					case WfBinaryOperator::Exp:
						writer.WriteString(L" ^ ");
						break;
					case WfBinaryOperator::Add:
						writer.WriteString(L" + ");
						break;
					case WfBinaryOperator::Sub:
						writer.WriteString(L" - ");
						break;
					case WfBinaryOperator::Mul:
						writer.WriteString(L" * ");
						break;
					case WfBinaryOperator::Div:
						writer.WriteString(L" / ");
						break;
					case WfBinaryOperator::Mod:
						writer.WriteString(L" % ");
						break;
					case WfBinaryOperator::Shl:
						writer.WriteString(L" shl ");
						break;
					case WfBinaryOperator::Shr:
						writer.WriteString(L" shr ");
						break;
					case WfBinaryOperator::LT:
						writer.WriteString(L" < ");
						break;
					case WfBinaryOperator::GT:
						writer.WriteString(L" > ");
						break;
					case WfBinaryOperator::LE:
						writer.WriteString(L" <= ");
						break;
					case WfBinaryOperator::GE:
						writer.WriteString(L" >= ");
						break;
					case WfBinaryOperator::EQ:
						writer.WriteString(L" == ");
						break;
					case WfBinaryOperator::NE:
						writer.WriteString(L" != ");
						break;
					case WfBinaryOperator::Xor:
						writer.WriteString(L" xor ");
						break;
					case WfBinaryOperator::And:
						writer.WriteString(L" and ");
						break;
					case WfBinaryOperator::Or:
						writer.WriteString(L" or ");
						break;
					default:;
					}
					WfPrint(node->second, indent, writer);
					writer.WriteString(L")");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfLetExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"let ");
				FOREACH_INDEXER(Ptr<WfLetVariable>, var, index, node->variables)
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					writer.WriteString(var->name.value);
					writer.WriteString(L" = ");
					WfPrint(var->value, indent, writer);
				}
				writer.WriteString(L" in (");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfIfExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->condition, indent, writer);
				writer.WriteString(L" ? ");
				WfPrint(node->trueBranch, indent, writer);
				writer.WriteString(L" : ");
				WfPrint(node->falseBranch, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfRangeExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"range ");
				writer.WriteString(node->beginBoundary == WfRangeBoundary::Exclusive ? L"(" : L"[");
				WfPrint(node->begin, indent, writer);
				writer.WriteString(L", ");
				WfPrint(node->end, indent, writer);
				writer.WriteString(node->endBoundary == WfRangeBoundary::Exclusive ? L")" : L"]");
				writer.AfterPrint(node);
			}

			void Visit(WfSetTestingExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				if (node->test == WfSetTesting::NotIn)
				{
					writer.WriteString(L" not");
				}
				writer.WriteString(L" in ");
				WfPrint(node->collection, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfConstructorExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"{");
				FOREACH_INDEXER(Ptr<WfConstructorArgument>, argument, index, node->arguments)
				{
					if (index > 0)
					{
						writer.WriteString(L" ");
					}
					WfPrint(argument->key, indent, writer);
					if (argument->value)
					{
						writer.WriteString(L" : ");
						WfPrint(argument->value, indent, writer);
					}
				}
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfInferExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L" of (");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfTypeCastingExpression* node)override
			{
				writer.BeforePrint(node);
				if (node->strategy == WfTypeCastingStrategy::Strong)
				{
					writer.WriteString(L"(cast (");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L") ");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L")");
				}
				else
				{
					writer.WriteString(L"(");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L" as (");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L"))");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfTypeTestingExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->expression, indent, writer);
				switch (node->test)
				{
				case WfTypeTesting::IsType:
					writer.WriteString(L" is (");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L")");
					break;
				case WfTypeTesting::IsNotType:
					writer.WriteString(L" is not (");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L")");
					break;
				case WfTypeTesting::IsNull:
					writer.WriteString(L" is null");
					break;
				case WfTypeTesting::IsNotNull:
					writer.WriteString(L" is not null");
					break;
				}
				writer.AfterPrint(node);
			}

			void Visit(WfTypeOfTypeExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"typeof(");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfTypeOfExpressionExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"type(");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfAttachEventExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"attach(");
				WfPrint(node->event, indent, writer);
				writer.WriteString(L", ");
				WfPrint(node->function, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfDetachEventExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"detach(");
				WfPrint(node->handler, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfBindExpression* node)override
			{
				writer.BeforePrint(node);
				if (node->expandedExpression)
				{
					WfPrint(node->expandedExpression, indent, writer);
				}
				else
				{
					writer.WriteString(L"bind(");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L")");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfObserveExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->parent, indent, writer);
				writer.WriteString(L".observe");
				if (node->observeType == WfObserveType::ExtendedObserve)
				{
					writer.WriteString(L" as ");
					writer.WriteString(node->name.value);
				}
				writer.WriteString(L"(");
				WfPrint(node->expression, indent, writer);
				if (node->events.Count() > 0)
				{
					writer.WriteString(L" on ");
					FOREACH_INDEXER(Ptr<WfExpression>, argument, index, node->events)
					{
						if (index > 0)
						{
							writer.WriteString(L", ");
						}
						WfPrint(argument, indent, writer);
					}
				}
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfCallExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->function, indent, writer);
				writer.WriteString(L"(");
				FOREACH_INDEXER(Ptr<WfExpression>, argument, index, node->arguments)
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					WfPrint(argument, indent, writer);
				}
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfFunctionExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(Ptr<WfDeclaration>(node->function), indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfNewTypeExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"new (");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L")");
				if (node->functions.Count() == 0)
				{
					writer.WriteString(L"(");
					FOREACH_INDEXER(Ptr<WfExpression>, argument, index, node->arguments)
					{
						if (index > 0)
						{
							writer.WriteString(L", ");
						}
						WfPrint(argument, indent, writer);
					}
					writer.WriteString(L")");
				}
				else
				{
					writer.WriteLine(L"");
					writer.WriteString(indent);
					writer.WriteLine(L"{");
					FOREACH_INDEXER(Ptr<WfFunctionDeclaration>, function, index, node->functions)
					{
						if (index > 0)
						{
							writer.WriteLine(L"");
						}
						writer.WriteString(indent + L"    ");
						WfPrint(Ptr<WfDeclaration>(function), indent + L"    ", writer);
						writer.WriteLine(L"");
					}
					writer.WriteString(indent);
					writer.WriteString(L"}");
				}
				writer.AfterPrint(node);
			}
		};

/***********************************************************************
Print (Statement)
***********************************************************************/

		class PrintStatementVisitor : public Object, public WfStatement::IVisitor
		{
		public:
			WString								indent;
			ParsingWriter&						writer;

			PrintStatementVisitor(const WString& _indent, ParsingWriter& _writer)
				:indent(_indent), writer(_writer)
			{
			}

			void Visit(WfBreakStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"break;");
				writer.AfterPrint(node);
			}

			void Visit(WfContinueStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"continue;");
				writer.AfterPrint(node);
			}

			void Visit(WfReturnStatement* node)override
			{
				writer.BeforePrint(node);
				if (node->expression)
				{
					writer.WriteString(L"return ");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L";");
				}
				else
				{
					writer.WriteString(L"return;");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfDeleteStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"delete ");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L";");
				writer.AfterPrint(node);
			}

			void Visit(WfRaiseExceptionStatement* node)override
			{
				writer.BeforePrint(node);
				if (node->expression)
				{
					writer.WriteString(L"raise ");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L";");
				}
				else
				{
					writer.WriteString(L"raise;");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfIfStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"if (");
				if (node->type)
				{
					writer.WriteString(L"var ");
					writer.WriteString(node->name.value);
					writer.WriteString(L" : ");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L" = ");
				}
				WfPrint(node->expression, indent, writer);
				writer.WriteLine(L")");

				writer.WriteString(indent);
				WfPrint(node->trueBranch, indent, writer);
				if (node->falseBranch)
				{
					writer.WriteLine(L"");
					writer.WriteString(indent);
					writer.WriteLine(L"else");
					writer.WriteString(indent);
					WfPrint(node->falseBranch, indent, writer);
				}
				writer.AfterPrint(node);
			}

			void Visit(WfSwitchStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"switch (");
				WfPrint(node->expression, indent, writer);
				writer.WriteLine(L")");

				writer.WriteString(indent);
				writer.WriteLine(L"{");

				FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
				{
					writer.WriteString(indent);
					writer.WriteString(L"case ");
					WfPrint(switchCase->expression, indent, writer);
					writer.WriteLine(L":");
					writer.WriteString(indent + L"    ");
					WfPrint(switchCase->statement, indent + L"    ", writer);
					writer.WriteLine(L"");
				}
				if (node->defaultBranch)
				{
					writer.WriteString(indent);
					writer.WriteLine(L"default:");
					writer.WriteString(indent + L"    ");
					WfPrint(node->defaultBranch, indent + L"    ", writer);
					writer.WriteLine(L"");
				}

				writer.WriteString(indent);
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfWhileStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"while (");
				WfPrint(node->condition, indent, writer);
				writer.WriteLine(L")");
				writer.WriteString(indent);
				WfPrint(node->statement, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfForEachStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"for (");
				writer.WriteString(node->name.value);
				writer.WriteString(L" in ");
				if (node->direction == WfForEachDirection::Reversed)
				{
					writer.WriteString(L"reversed ");
				}
				WfPrint(node->collection, indent, writer);
				writer.WriteLine(L")");
				writer.WriteString(indent);
				WfPrint(node->statement, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfTryStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteLine(L"try");
				writer.WriteString(indent);
				WfPrint(node->protectedStatement, indent, writer);

				if (node->catchStatement)
				{
					writer.WriteLine(L"");
					writer.WriteString(indent);
					writer.WriteString(L"catch (");
					writer.WriteString(node->name.value);
					writer.WriteLine(L")");
					writer.WriteString(indent);
					WfPrint(node->catchStatement, indent, writer);
				}

				if (node->finallyStatement)
				{
					writer.WriteLine(L"");
					writer.WriteString(indent);
					writer.WriteLine(L"finally");
					writer.WriteString(indent);
					WfPrint(node->finallyStatement, indent, writer);
				}
				writer.AfterPrint(node);
			}

			void Visit(WfBlockStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteLine(L"{");
				FOREACH(Ptr<WfStatement>, statement, node->statements)
				{
					writer.WriteString(indent + L"    ");
					WfPrint(statement, indent + L"    ", writer);
					writer.WriteLine(L"");
				}
				writer.WriteString(indent);
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfExpressionStatement* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L";");
				writer.AfterPrint(node);
			}

			void Visit(WfVariableStatement* node)override
			{
				writer.BeforePrint(node);
				WfPrint(Ptr<WfDeclaration>(node->variable), indent, writer);
				writer.AfterPrint(node);
			}
		};

/***********************************************************************
Print (Declaration)
***********************************************************************/

		class PrintDeclarationVisitor : public Object, public WfDeclaration::IVisitor
		{
		public:
			WString								indent;
			ParsingWriter&						writer;

			PrintDeclarationVisitor(const WString& _indent, ParsingWriter& _writer)
				:indent(_indent), writer(_writer)
			{
			}

			void Visit(WfNamespaceDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteLine(L"namespace " + node->name.value);
				writer.WriteString(indent);
				writer.WriteLine(L"{");
				FOREACH_INDEXER(Ptr<WfDeclaration>, decl, index, node->declarations)
				{
					if (index > 0)
					{
						writer.WriteLine(L"");
						writer.WriteLine(L"");
					}
					WfPrint(decl, indent + L"    ", writer);
				}
				writer.WriteString(indent);
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfFunctionDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"func ");
				if (node->anonymity == WfFunctionAnonymity::Named)
				{
					writer.WriteString(node->name.value);
				}

				writer.WriteString(L"(");
				FOREACH_INDEXER(Ptr<WfFunctionArgument>, argument, index, node->arguments)
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					writer.WriteString(argument->name.value);
					writer.WriteString(L" : ");
					WfPrint(argument->type, indent, writer);
				}
				writer.WriteString(L")");

				writer.WriteString(L" : ");
				WfPrint(node->returnType, indent, writer);
				if (node->statement)
				{
					writer.WriteLine(L"");

					writer.WriteString(indent);
					WfPrint(node->statement, indent, writer);
				}
				else
				{
					writer.WriteString(L";");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfVariableDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"var ");
				writer.WriteString(node->name.value);
				if (node->type)
				{
					writer.WriteString(L" : ");
					WfPrint(node->type, indent, writer);
				}
				writer.WriteString(L" = ");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L";");
				writer.AfterPrint(node);
			}

			void Visit(WfEventDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"event ");
				writer.WriteString(node->name.value);
				writer.WriteString(L"(");
				FOREACH_INDEXER(Ptr<WfType>, type, index, node->arguments)
				{
					if (index != 0)
					{
						writer.WriteString(L", ");
					}
					WfPrint(type, indent, writer);
				}
				writer.WriteString(L");");
				writer.AfterPrint(node);
			}

			void Visit(WfPropertyDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"prop ");
				writer.WriteString(node->name.value);
				writer.WriteString(L" : ");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L"{");
				writer.WriteString(node->getter.value);
				if (node->setter.value != L"")
				{
					writer.WriteString(L", ");
					writer.WriteString(node->setter.value);
				}
				if (node->valueChangedEvent.value != L"")
				{
					writer.WriteString(L" : ");
					writer.WriteString(node->valueChangedEvent.value);
				}
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfClassDeclaration* node)override
			{
				writer.BeforePrint(node);
				switch (node->kind)
				{
				case WfClassKind::Class:
					writer.WriteString(L"class ");
					break;
				case WfClassKind::Interface:
					writer.WriteString(L"interface ");
					break;
				}
				writer.WriteString(node->name.value);

				FOREACH_INDEXER(Ptr<WfType>, type, index, node->baseTypes)
				{
					if (index == 0)
					{
						writer.WriteString(L" : ");
					}
					else
					{
						writer.WriteString(L", ");
					}
					WfPrint(type, indent, writer);
				}

				writer.WriteLine(L"");
				writer.WriteLine(L"{");

				FOREACH_INDEXER(Ptr<WfClassMember>, member, index, node->members)
				{
					if (index != 0)
					{
						writer.WriteLine(L"");
					}

					writer.WriteString(indent + L"    ");
					switch (member->kind)
					{
					case WfClassMemberKind::Static:
						writer.WriteString(L"static ");
						break;
					}
					WfPrint(member->declaration, indent + L"    ", writer);
					writer.WriteLine(L"");
				}

				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}
		};

/***********************************************************************
Print (Module)
***********************************************************************/

		void WfPrint(Ptr<WfType> node, const WString& indent, parsing::ParsingWriter& writer)
		{
			PrintTypeVisitor visitor(indent, writer);
			node->Accept(&visitor);
		}

		void WfPrint(Ptr<WfExpression> node, const WString& indent, parsing::ParsingWriter& writer)
		{
			PrintExpressionVisitor visitor(indent, writer);
			node->Accept(&visitor);
		}

		void WfPrint(Ptr<WfStatement> node, const WString& indent, parsing::ParsingWriter& writer)
		{
			PrintStatementVisitor visitor(indent, writer);
			node->Accept(&visitor);
		}

		void WfPrint(Ptr<WfDeclaration> node, const WString& indent, parsing::ParsingWriter& writer)
		{
			PrintDeclarationVisitor visitor(indent, writer);
			node->Accept(&visitor);
		}

		void WfPrint(Ptr<WfModule> node, const WString& indent, parsing::ParsingWriter& writer)
		{
			writer.WriteString(indent);
			switch (node->moduleType)
			{
			case WfModuleType::Module:
				writer.WriteLine(L"module " + node->name.value + L";");
				break;
			case WfModuleType::Unit:
				writer.WriteLine(L"unit " + node->name.value + L";");
				break;
			}

			FOREACH(Ptr<WfModuleUsingPath>, path, node->paths)
			{
				writer.WriteString(indent);
				writer.WriteString(L"using ");
				FOREACH_INDEXER(Ptr<WfModuleUsingItem>, item, index, path->items)
				{
					if (index > 0)
					{
						writer.WriteString(L"::");
					}
					FOREACH(Ptr<WfModuleUsingFragment>, fragment, item->fragments)
					{
						if (auto name = fragment.Cast<WfModuleUsingNameFragment>())
						{
							writer.WriteString(name->name.value);
						}
						else
						{
							writer.WriteString(L"*");
						}
					}
				}
				writer.WriteLine(L";");
			}

			FOREACH(Ptr<WfDeclaration>, decl, node->declarations)
			{
				writer.WriteLine(L"");
				writer.WriteString(indent);
				WfPrint(decl, indent, writer);
				writer.WriteLine(L"");
			}
		}

/***********************************************************************
Print (Module)
***********************************************************************/

		void WfPrint(Ptr<WfType> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}

		void WfPrint(Ptr<WfExpression> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}

		void WfPrint(Ptr<WfStatement> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}

		void WfPrint(Ptr<WfDeclaration> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}

		void WfPrint(Ptr<WfModule> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}
	}
}

/***********************************************************************
EXPRESSION\WFEXPRESSIONPARSER.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"class Type"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum PredefinedTypeName"
L"\r\n" L"{"
L"\r\n" L"\tVoid,"
L"\r\n" L"\tObject,"
L"\r\n" L"\tInterface,"
L"\r\n" L"\tInt,"
L"\r\n" L"\tUInt,"
L"\r\n" L"\tFloat,"
L"\r\n" L"\tDouble,"
L"\r\n" L"\tString,"
L"\r\n" L"\tChar,"
L"\r\n" L"\tBool,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class PredefinedType : Type"
L"\r\n" L"{"
L"\r\n" L"\tPredefinedTypeName\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TopQualifiedType : Type"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ReferenceType : Type"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class RawPointerType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\telement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SharedPointerType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\telement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class NullableType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\telement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class EnumerableType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\telement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum MapWritability"
L"\r\n" L"{"
L"\r\n" L"\tReadonly,"
L"\r\n" L"\tWritable,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class MapType : Type"
L"\r\n" L"{"
L"\r\n" L"\tMapWritability\t\t\twritability;"
L"\r\n" L"\tType\t\t\t\t\tkey;"
L"\r\n" L"\tType\t\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FunctionType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\tresult;"
L"\r\n" L"\tType[]\t\t\t\t\targuments;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ChildType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\tparent;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Expression"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TopQualifiedExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ReferenceExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class OrderedNameExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class OrderedLambdaExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tbody;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class MemberExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tparent;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ChildExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tparent;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum LiteralValue"
L"\r\n" L"{"
L"\r\n" L"\tNull,"
L"\r\n" L"\tTrue,"
L"\r\n" L"\tFalse,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class LiteralExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tLiteralValue\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FloatingExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class IntegerExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class StringExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tvalue(UnescapeString);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FormatExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tvalue(UnescapeFormatString);"
L"\r\n" L"\tExpression\t\t\t\texpandedExpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum UnaryOperator"
L"\r\n" L"{"
L"\r\n" L"\tPositive,"
L"\r\n" L"\tNegative,"
L"\r\n" L"\tNot,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class UnaryExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tUnaryOperator\t\t\top;"
L"\r\n" L"\tExpression\t\t\t\toperand;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum BinaryOperator"
L"\r\n" L"{"
L"\r\n" L"\tAssign,"
L"\r\n" L"\tIndex,"
L"\r\n" L"\tConcat,"
L"\r\n" L"\tFailedThen,"
L"\r\n" L"\tExp,"
L"\r\n" L"\tAdd,"
L"\r\n" L"\tSub,"
L"\r\n" L"\tMul,"
L"\r\n" L"\tDiv,"
L"\r\n" L"\tMod,"
L"\r\n" L"\tShl,"
L"\r\n" L"\tShr,"
L"\r\n" L"\tLT,"
L"\r\n" L"\tGT,"
L"\r\n" L"\tLE,"
L"\r\n" L"\tGE,"
L"\r\n" L"\tEQ,"
L"\r\n" L"\tNE,"
L"\r\n" L"\tXor,"
L"\r\n" L"\tAnd,"
L"\r\n" L"\tOr,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class BinaryExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tBinaryOperator\t\t\top;"
L"\r\n" L"\tExpression\t\t\t\tfirst;"
L"\r\n" L"\tExpression\t\t\t\tsecond;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class LetVariable"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tExpression\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class LetExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tLetVariable[]\t\t\tvariables;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class IfExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tcondition;"
L"\r\n" L"\tExpression\t\t\t\ttrueBranch;"
L"\r\n" L"\tExpression\t\t\t\tfalseBranch;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum RangeBoundary"
L"\r\n" L"{"
L"\r\n" L"\tInclusive,"
L"\r\n" L"\tExclusive,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class RangeExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tbegin;"
L"\r\n" L"\tRangeBoundary\t\t\tbeginBoundary;"
L"\r\n" L"\tExpression\t\t\t\tend;"
L"\r\n" L"\tRangeBoundary\t\t\tendBoundary;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum SetTesting"
L"\r\n" L"{"
L"\r\n" L"\tIn,"
L"\r\n" L"\tNotIn,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SetTestingExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tSetTesting\t\t\t\ttest;"
L"\r\n" L"\tExpression\t\t\t\telement;"
L"\r\n" L"\tExpression\t\t\t\tcollection;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ConstructorArgument"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tkey;"
L"\r\n" L"\tExpression\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ConstructorExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tConstructorArgument[]\targuments;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class InferExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum TypeCastingStrategy"
L"\r\n" L"{"
L"\r\n" L"\tStrong,"
L"\r\n" L"\tWeak,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TypeCastingExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tTypeCastingStrategy\t\tstrategy;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum TypeTesting"
L"\r\n" L"{"
L"\r\n" L"\tIsType,"
L"\r\n" L"\tIsNotType,"
L"\r\n" L"\tIsNull,"
L"\r\n" L"\tIsNotNull,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TypeTestingExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tTypeTesting\t\t\t\ttest;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TypeOfTypeExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TypeOfExpressionExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class AttachEventExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tevent;"
L"\r\n" L"\tExpression\t\t\t\tfunction;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class DetachEventExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\thandler;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class BindExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tExpression\t\t\t\texpandedExpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ObserveType"
L"\r\n" L"{"
L"\r\n" L"\tSimpleObserve,"
L"\r\n" L"\tExtendedObserve,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ObserveExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tparent;"
L"\r\n" L"\tObserveType\t\t\t\tobserveType;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tExpression[]\t\t\tevents;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CallExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tfunction;"
L"\r\n" L"\tExpression[]\t\t\targuments;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Statement"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class BreakStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ContinueStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ReturnStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class DeleteStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class RaiseExceptionStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class IfStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tStatement\t\t\t\ttrueBranch;"
L"\r\n" L"\tStatement\t\t\t\tfalseBranch;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SwitchCase"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tStatement\t\t\t\tstatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SwitchStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tSwitchCase[]\t\t\tcaseBranches;"
L"\r\n" L"\tStatement\t\t\t\tdefaultBranch;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class WhileStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tcondition;"
L"\r\n" L"\tStatement\t\t\t\tstatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ForEachDirection"
L"\r\n" L"{"
L"\r\n" L"\tNormal,"
L"\r\n" L"\tReversed,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ForEachStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tForEachDirection\t\tdirection;"
L"\r\n" L"\tExpression\t\t\t\tcollection;"
L"\r\n" L"\tStatement\t\t\t\tstatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TryStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tStatement\t\t\t\tprotectedStatement;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tStatement\t\t\t\tcatchStatement;"
L"\r\n" L"\tStatement\t\t\t\tfinallyStatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class BlockStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tStatement[]\t\t\t\tstatements;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ExpressionStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Declaration"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class NamespaceDeclaration : Declaration"
L"\r\n" L"{"
L"\r\n" L"\tDeclaration[]\t\t\tdeclarations;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FunctionArgument"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum FunctionAnonymity"
L"\r\n" L"{"
L"\r\n" L"\tNamed,"
L"\r\n" L"\tAnonymous,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FunctionDeclaration : Declaration"
L"\r\n" L"{"
L"\r\n" L"\tFunctionAnonymity\t\tanonymity;"
L"\r\n" L"\tFunctionArgument[]\t\targuments;"
L"\r\n" L"\tType\t\t\t\t\treturnType;"
L"\r\n" L"\tStatement\t\t\t\tstatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FunctionExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tFunctionDeclaration\t\tfunction;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class VariableDeclaration : Declaration"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class VariableStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tVariableDeclaration\t\tvariable;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class NewTypeExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"\tExpression[]\t\t\targuments;"
L"\r\n" L"\tFunctionDeclaration[]\tfunctions;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ClassMemberKind"
L"\r\n" L"{"
L"\r\n" L"\tStatic,"
L"\r\n" L"\tNormal,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ClassKind"
L"\r\n" L"{"
L"\r\n" L"\tClass,"
L"\r\n" L"\tInterface,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ClassMember"
L"\r\n" L"{"
L"\r\n" L"\tClassMemberKind\t\t\tkind;"
L"\r\n" L"\tDeclaration\t\t\t\tdeclaration;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class EventDeclaration : Declaration"
L"\r\n" L"{"
L"\r\n" L"\tType[]\t\t\t\t\targuments;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class PropertyDeclaration : Declaration"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"\ttoken\t\t\t\t\tgetter;"
L"\r\n" L"\ttoken\t\t\t\t\tsetter;"
L"\r\n" L"\ttoken\t\t\t\t\tvalueChangedEvent;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ClassDeclaration : Declaration"
L"\r\n" L"{"
L"\r\n" L"\tClassKind\t\t\t\tkind;"
L"\r\n" L"\tType[]\t\t\t\t\tbaseTypes;"
L"\r\n" L"\tClassMember[]\t\t\tmembers;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingFragment"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingNameFragment : ModuleUsingFragment"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingWildCardFragment : ModuleUsingFragment"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingItem"
L"\r\n" L"{"
L"\r\n" L"\tModuleUsingFragment[]\tfragments;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingPath"
L"\r\n" L"{"
L"\r\n" L"\tModuleUsingItem[]\t\titems;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ModuleType"
L"\r\n" L"{"
L"\r\n" L"\tModule,"
L"\r\n" L"\tUnit,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Module"
L"\r\n" L"{"
L"\r\n" L"\tModuleType\t\t\t\tmoduleType;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tModuleUsingPath[]\t\tpaths;"
L"\r\n" L"\tDeclaration[]\t\t\tdeclarations;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"token EXP = \"/^\";"
L"\r\n" L"token ADD = \"/+\";"
L"\r\n" L"token SUB = \"-\";"
L"\r\n" L"token MUL = \"/*\";"
L"\r\n" L"token DIV = \"//\";"
L"\r\n" L"token MOD = \"%\";"
L"\r\n" L"token CONCAT = \"&\";"
L"\r\n" L"token LE = \"/</=\";"
L"\r\n" L"token GE = \"/>/=\";"
L"\r\n" L"token LT = \"/<\";"
L"\r\n" L"token GT = \"/>\";"
L"\r\n" L"token EQ = \"/=/=\";"
L"\r\n" L"token NE = \"/!/=\";"
L"\r\n" L"token ASSIGN = \"/=\";"
L"\r\n" L"token FAILED_THEN = \"/?/?\";"
L"\r\n" L"token QUESTION_MARK = \"/?\";"
L"\r\n" L"token SCOPE_DELIMITER = \"::\";"
L"\r\n" L"token COLON = \":\";"
L"\r\n" L"token SEMICOLON = \";\";"
L"\r\n" L"token COMMA = \",\";"
L"\r\n" L"token DOT = \".\";"
L"\r\n" L"token OPEN_ARRAY = \"/[\";"
L"\r\n" L"token CLOSE_ARRAY = \"/]\";"
L"\r\n" L"token OPEN_BRACE = \"/{\";"
L"\r\n" L"token CLOSE_BRACE = \"/}\";"
L"\r\n" L"token OPEN_BRACKET = \"/(\";"
L"\r\n" L"token CLOSE_BRACKET = \"/)\";"
L"\r\n" L""
L"\r\n" L"token TYPE_VOID = \"void\";"
L"\r\n" L"token TYPE_OBJECT = \"object\";"
L"\r\n" L"token TYPE_INTERFACE = \"interface\";"
L"\r\n" L"token TYPE_INT = \"int\";"
L"\r\n" L"token TYPE_UINT = \"uint\";"
L"\r\n" L"token TYPE_FLOAT = \"float\";"
L"\r\n" L"token TYPE_DOUBLE = \"double\";"
L"\r\n" L"token TYPE_STRING = \"string\";"
L"\r\n" L"token TYPE_CHAR = \"char\";"
L"\r\n" L"token TYPE_BOOL = \"bool\";"
L"\r\n" L""
L"\r\n" L"token KEYWORD_CONST = \"const\";"
L"\r\n" L"token KEYWORD_SHL = \"shl\";"
L"\r\n" L"token KEYWORD_SHR = \"shr\";"
L"\r\n" L"token KEYWORD_XOR = \"xor\";"
L"\r\n" L"token KEYWORD_AND = \"and\";"
L"\r\n" L"token KEYWORD_OR = \"or\";"
L"\r\n" L"token KEYWORD_NOT = \"not\";"
L"\r\n" L"token KEYWORD_NULL= \"null\";"
L"\r\n" L"token KEYWORD_TRUE= \"true\";"
L"\r\n" L"token KEYWORD_FALSE = \"false\";"
L"\r\n" L"token KEYWORD_LET = \"let\";"
L"\r\n" L"token KEYWORD_IN = \"in\";"
L"\r\n" L"token KEYWORD_RANGE = \"range\";"
L"\r\n" L"token KEYWORD_NEW = \"new\";"
L"\r\n" L"token KEYWORD_OF = \"of\";"
L"\r\n" L"token KEYWORD_AS = \"as\";"
L"\r\n" L"token KEYWORD_IS = \"is\";"
L"\r\n" L"token KEYWORD_CAST = \"cast\";"
L"\r\n" L"token KEYWORD_FUNC = \"func\";"
L"\r\n" L"token KEYWORD_TYPEOF = \"typeof\";"
L"\r\n" L"token KEYWORD_TYPE = \"type\";"
L"\r\n" L"token KEYWORD_BIND = \"bind\";"
L"\r\n" L"token KEYWORD_OBSERVE = \"observe\";"
L"\r\n" L"token KEYWORD_ON = \"on\";"
L"\r\n" L"token KEYWORD_ATTACH = \"attach\";"
L"\r\n" L"token KEYWORD_DETACH = \"detach\";"
L"\r\n" L"token KEYWORD_VAR = \"var\";"
L"\r\n" L"token KEYWORD_BREAK = \"break\";"
L"\r\n" L"token KEYWORD_CONTINUE = \"continue\";"
L"\r\n" L"token KEYWORD_RETURN = \"return\";"
L"\r\n" L"token KEYWORD_DELETE = \"delete\";"
L"\r\n" L"token KEYWORD_RAISE = \"raise\";"
L"\r\n" L"token KEYWORD_IF = \"if\";"
L"\r\n" L"token KEYWORD_ELSE = \"else\";"
L"\r\n" L"token KEYWORD_SWITCH = \"switch\";"
L"\r\n" L"token KEYWORD_CASE = \"case\";"
L"\r\n" L"token KEYWORD_DEFAULT = \"default\";"
L"\r\n" L"token KEYWORD_WHILE = \"while\";"
L"\r\n" L"token KEYWORD_FOR = \"for\";"
L"\r\n" L"token KEYWORD_REVERSED = \"reversed\";"
L"\r\n" L"token KEYWORD_TRY = \"try\";"
L"\r\n" L"token KEYWORD_CATCH = \"catch\";"
L"\r\n" L"token KEYWORD_FINALLY = \"finally\";"
L"\r\n" L"token KEYWORD_CLASS = \"class\";"
L"\r\n" L"token KEYWORD_PROP = \"prop\";"
L"\r\n" L"token KEYWORD_EVENT = \"event\";"
L"\r\n" L"token KEYWORD_STATIC = \"static\";"
L"\r\n" L"token KEYWORD_USING = \"using\";"
L"\r\n" L"token KEYWORD_NAMESPACE = \"namespace\";"
L"\r\n" L"token KEYWORD_MODULE = \"module\";"
L"\r\n" L"token KEYWORD_UNIT = \"unit\";"
L"\r\n" L""
L"\r\n" L"token NAME = \"[a-zA-Z_]/w*\";"
L"\r\n" L"token ORDERED_NAME = \"/$[0-9]*\";"
L"\r\n" L"token FLOAT = \"/d+./d+\";"
L"\r\n" L"token INTEGER = \"/d+\";"
L"\r\n" L"token STRING = \"\'([^\'\\\\]|\\\\\\.)*\'|\"\"([^\"\"\\\\]|\\\\\\.)*\"\"\";"
L"\r\n" L"token FORMATSTRING = \"/$(\'([^\'\\\\]|\\\\\\.)*\'|\"\"([^\"\"\\\\]|\\\\\\.)*\"\")\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"rule Type WorkflowType"
L"\r\n" L"\t= \"void\" as PredefinedType with {name=\"Void\"}"
L"\r\n" L"\t= \"object\" as PredefinedType with {name=\"Object\"}"
L"\r\n" L"\t= \"interface\" as PredefinedType with {name=\"Interface\"}"
L"\r\n" L"\t= \"int\" as PredefinedType with {name=\"Int\"}"
L"\r\n" L"\t= \"uint\" as PredefinedType with {name=\"UInt\"}"
L"\r\n" L"\t= \"float\" as PredefinedType with {name=\"Float\"}"
L"\r\n" L"\t= \"double\" as PredefinedType with {name=\"Double\"}"
L"\r\n" L"\t= \"string\" as PredefinedType with {name=\"String\"}"
L"\r\n" L"\t= \"char\" as PredefinedType with {name=\"Char\"}"
L"\r\n" L"\t= \"bool\" as PredefinedType with {name=\"Bool\"}"
L"\r\n" L"\t= NAME : name as ReferenceType"
L"\r\n" L"\t= \"func\" \"(\" [WorkflowType : arguments {\",\" WorkflowType : arguments}] \")\" \":\" WorkflowType : result as FunctionType"
L"\r\n" L"\t= WorkflowType : element \"*\" as RawPointerType"
L"\r\n" L"\t= WorkflowType : element \"^\" as SharedPointerType"
L"\r\n" L"\t= WorkflowType : element \"?\" as NullableType"
L"\r\n" L"\t= WorkflowType : element \"{\" \"}\" as EnumerableType"
L"\r\n" L"\t= WorkflowType : value \"[\" [WorkflowType : key] \"]\" as MapType with {writability=\"Writable\"}"
L"\r\n" L"\t= \"const\" WorkflowType : value \"[\" [WorkflowType : key] \"]\" as MapType with {writability=\"Readonly\"}"
L"\r\n" L"\t= WorkflowType : parent \"::\" NAME : name as ChildType"
L"\r\n" L"\t= \"::\" NAME : name as TopQualifiedType"
L"\r\n" L"\t= \"(\" !WorkflowType \")\""
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule LiteralExpression Literal"
L"\r\n" L"\t= \"null\" as LiteralExpression with {value = \"Null\"}"
L"\r\n" L"\t= \"true\" as LiteralExpression with {value = \"True\"}"
L"\r\n" L"\t= \"false\" as LiteralExpression with {value = \"False\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule IntegerExpression Integer"
L"\r\n" L"\t= INTEGER : value as IntegerExpression"
L"\r\n" L"\t;"
L"\r\n" L"rule FloatingExpression FloatingPoint"
L"\r\n" L"\t= FLOAT : value as FloatingExpression"
L"\r\n" L"\t;"
L"\r\n" L"rule StringExpression String"
L"\r\n" L"\t= STRING : value as StringExpression"
L"\r\n" L"\t;"
L"\r\n" L"rule FormatExpression FormatString"
L"\r\n" L"\t= FORMATSTRING : value as FormatExpression"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule ConstructorArgument CtorFragment"
L"\r\n" L"\t= WorkflowExpression : key [ \":\" WorkflowExpression : value] as ConstructorArgument"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule LetVariable LetVariableFragment"
L"\r\n" L"\t= NAME : name \"=\" WorkflowExpression : value as LetVariable"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Expression ExpPrimitive"
L"\r\n" L"\t= !Literal"
L"\r\n" L"\t= !Integer"
L"\r\n" L"\t= !FloatingPoint"
L"\r\n" L"\t= !String"
L"\r\n" L"\t= !FormatString"
L"\r\n" L"\t= NAME : name as ReferenceExpression"
L"\r\n" L"\t= ORDERED_NAME : name as OrderedNameExpression"
L"\r\n" L"\t= \"(\" !WorkflowExpression \")\""
L"\r\n" L"\t= \"[\" WorkflowExpression : body \"]\" as OrderedLambdaExpression"
L"\r\n" L"\t= Function : function as FunctionExpression"
L"\r\n" L"\t= \"let\" LetVariableFragment : variables {\",\" LetVariableFragment : variables} \"in\" \"(\" WorkflowExpression : expression \")\" as LetExpression"
L"\r\n" L"\t= \"range\""
L"\r\n" L"\t\t((\"(\" with {beginBoundary = \"Exclusive\"}) | (\"[\" with {beginBoundary = \"Inclusive\"}))"
L"\r\n" L"\t\tWorkflowExpression : begin \",\" WorkflowExpression : end"
L"\r\n" L"\t\t((\")\" with {endBoundary = \"Exclusive\"}) | (\"]\" with {endBoundary = \"Inclusive\"}))"
L"\r\n" L"\t\tas RangeExpression"
L"\r\n" L"\t= \"{\" {CtorFragment : arguments} \"}\" as ConstructorExpression"
L"\r\n" L"\t= \"new\" WorkflowType : type"
L"\r\n" L"\t\t("
L"\r\n" L"\t\t\t\"(\" [WorkflowExpression : arguments {\",\" WorkflowExpression : arguments}] \")\" "
L"\r\n" L"\t\t\t| \"{\" {Function : functions} \"}\""
L"\r\n" L"\t\t) as NewTypeExpression"
L"\r\n" L"\t= \"bind\" \"(\" WorkflowExpression : expression \")\" as BindExpression"
L"\r\n" L"\t= ExpPrimitive : parent \".\" \"observe\" \"(\" WorkflowExpression : expression [\"on\" WorkflowExpression : events {\",\" WorkflowExpression : events}]\")\" as ObserveExpression with {observeType = \"SimpleObserve\"}"
L"\r\n" L"\t= ExpPrimitive : parent \".\" \"observe\" \"as\" NAME : name \"(\" WorkflowExpression : expression [\"on\" WorkflowExpression : events {\",\" WorkflowExpression : events}]\")\" as ObserveExpression with {observeType = \"ExtendedObserve\"}"
L"\r\n" L"\t= ExpPrimitive : function \"(\" [WorkflowExpression : arguments {\",\" WorkflowExpression : arguments}] \")\" as CallExpression"
L"\r\n" L"\t= ExpPrimitive : parent \".\" NAME : name as MemberExpression"
L"\r\n" L"\t= ExpPrimitive : parent \"::\" NAME : name as ChildExpression"
L"\r\n" L"\t= ExpPrimitive : first \"[\" WorkflowExpression : second \"]\" as BinaryExpression with {op = \"Index\"}"
L"\r\n" L"\t= ExpPrimitive : element"
L"\r\n" L"\t\t((\"in\" with {test=\"In\"}) | (\"not\" \"in\" with {test=\"NotIn\"}))"
L"\r\n" L"\t\tWorkflowExpression : collection as SetTestingExpression"
L"\r\n" L"\t= ExpPrimitive : expression \"of\" WorkflowType : type as InferExpression"
L"\r\n" L"\t= ExpPrimitive : expression"
L"\r\n" L"\t\t("
L"\r\n" L"\t\t\t("
L"\r\n" L"\t\t\t\t("
L"\r\n" L"\t\t\t\t\t(\"is\" with {test=\"IsType\"})"
L"\r\n" L"\t\t\t\t\t| (\"is\" \"not\" with {test=\"IsNotType\"})"
L"\r\n" L"\t\t\t\t) WorkflowType : type as TypeTestingExpression"
L"\r\n" L"\t\t\t)"
L"\r\n" L"\t\t\t| (\"is\" \"null\" as TypeTestingExpression with {test=\"IsNull\"})"
L"\r\n" L"\t\t\t| (\"is\" \"not\" \"null\" as TypeTestingExpression with {test=\"IsNotNull\"})"
L"\r\n" L"\t\t)"
L"\r\n" L"\t= ExpPrimitive : expression \"as\" WorkflowType : type as TypeCastingExpression with {strategy = \"Weak\"}"
L"\r\n" L"\t= \"typeof\" \"(\" WorkflowType : type \")\" as TypeOfTypeExpression"
L"\r\n" L"\t= \"type\" \"(\" WorkflowExpression : expression \")\" as TypeOfExpressionExpression"
L"\r\n" L"\t= \"attach\" \"(\" WorkflowExpression : event \",\" WorkflowExpression : function \")\" as AttachEventExpression"
L"\r\n" L"\t= \"detach\" \"(\" WorkflowExpression : handler \")\" as DetachEventExpression"
L"\r\n" L"\t= \"::\" NAME : name as TopQualifiedExpression"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Expression Exp0"
L"\r\n" L"\t= !ExpPrimitive"
L"\r\n" L"\t= \"+\" Exp0 : operand as UnaryExpression with {op = \"Positive\"}"
L"\r\n" L"\t= \"-\" Exp0 : operand as UnaryExpression with {op = \"Negative\"}"
L"\r\n" L"\t= \"not\" Exp0 : operand as UnaryExpression with {op = \"Not\"}"
L"\r\n" L"\t= \"cast\" WorkflowType : type Exp0 : expression as TypeCastingExpression with {strategy = \"Strong\"}"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Expression Exp1"
L"\r\n" L"\t= !Exp0"
L"\r\n" L"\t= Exp1 : first \"^\" Exp0 : second as BinaryExpression with {op = \"Exp\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp2"
L"\r\n" L"\t= !Exp1"
L"\r\n" L"\t= Exp2 : first \"*\" Exp1 : second as BinaryExpression with {op = \"Mul\"}"
L"\r\n" L"\t= Exp2 : first \"/\" Exp1 : second as BinaryExpression with {op = \"Div\"}"
L"\r\n" L"\t= Exp2 : first \"%\" Exp1 : second as BinaryExpression with {op = \"Mod\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp3"
L"\r\n" L"\t= !Exp2"
L"\r\n" L"\t= Exp3 : first \"+\" Exp2 : second as BinaryExpression with {op = \"Add\"}"
L"\r\n" L"\t= Exp3 : first \"-\" Exp2 : second as BinaryExpression with {op = \"Sub\"}"
L"\r\n" L"\t= Exp3 : first \"&\" Exp2 : second as BinaryExpression with {op = \"Concat\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp4"
L"\r\n" L"\t= !Exp3"
L"\r\n" L"\t= Exp4 : first \"shl\" Exp3 : second as BinaryExpression with {op = \"Shl\"}"
L"\r\n" L"\t= Exp4 : first \"shr\" Exp3 : second as BinaryExpression with {op = \"Shr\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp5"
L"\r\n" L"\t= !Exp4"
L"\r\n" L"\t= Exp5 : first \"<\" Exp4 : second as BinaryExpression with {op = \"LT\"}"
L"\r\n" L"\t= Exp5 : first \">\" Exp4 : second as BinaryExpression with {op = \"GT\"}"
L"\r\n" L"\t= Exp5 : first \"<=\" Exp4 : second as BinaryExpression with {op = \"LE\"}"
L"\r\n" L"\t= Exp5 : first \">=\" Exp4 : second as BinaryExpression with {op = \"GE\"}"
L"\r\n" L"\t= Exp5 : first \"==\" Exp4 : second as BinaryExpression with {op = \"EQ\"}"
L"\r\n" L"\t= Exp5 : first \"!=\" Exp4 : second as BinaryExpression with {op = \"NE\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp6"
L"\r\n" L"\t= !Exp5"
L"\r\n" L"\t= Exp6 : first \"xor\" Exp5 : second as BinaryExpression with {op = \"Xor\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp7"
L"\r\n" L"\t= !Exp6"
L"\r\n" L"\t= Exp7 : first \"and\" Exp6 : second as BinaryExpression with {op = \"And\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp8"
L"\r\n" L"\t= !Exp7"
L"\r\n" L"\t= Exp8 : first \"or\" Exp7 : second as BinaryExpression with {op = \"Or\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp9"
L"\r\n" L"\t= !Exp8"
L"\r\n" L"\t= Exp9 : first \"??\" Exp8 : second as BinaryExpression with {op = \"FailedThen\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp10"
L"\r\n" L"\t= !Exp9"
L"\r\n" L"\t= Exp9 : condition \"?\" Exp10 : trueBranch \":\" Exp10 : falseBranch as IfExpression"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp11"
L"\r\n" L"\t= !Exp10"
L"\r\n" L"\t= Exp10 : first \"=\" Exp11 : second as BinaryExpression with {op = \"Assign\"}"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Expression WorkflowExpression"
L"\r\n" L"\t= !Exp11"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule SwitchCase SwitchCaseFragment"
L"\r\n" L"\t= \"case\" WorkflowExpression : expression \":\" Block : statement as SwitchCase"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Statement Block"
L"\r\n" L"\t= \"{\" {WorkflowStatement : statements} \"}\" as BlockStatement"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Statement WorkflowStatement"
L"\r\n" L"\t= !Block"
L"\r\n" L"\t= Variable : variable as VariableStatement"
L"\r\n" L"\t= \"break\" \";\" as BreakStatement"
L"\r\n" L"\t= \"continue\" \";\" as ContinueStatement"
L"\r\n" L"\t= \"return\" [WorkflowExpression : expression] \";\" as ReturnStatement"
L"\r\n" L"\t= \"delete\" WorkflowExpression : expression \";\" as DeleteStatement"
L"\r\n" L"\t= \"raise\" [WorkflowExpression : expression] \";\" as RaiseExceptionStatement"
L"\r\n" L"\t= \"if\" \"(\" [\"var\" NAME : name \":\" WorkflowType : type \"=\"] WorkflowExpression : expression \")\" Block : trueBranch [\"else\" Block : falseBranch] as IfStatement"
L"\r\n" L"\t= \"switch\" \"(\" WorkflowExpression : expression \")\" \"{\" {SwitchCaseFragment : caseBranches} [\"default\" \":\" Block : defaultBranch] \"}\" as SwitchStatement"
L"\r\n" L"\t= \"while\" \"(\" WorkflowExpression : condition \")\" Block : statement as WhileStatement"
L"\r\n" L"\t= \"for\" \"(\" NAME : name "
L"\r\n" L"\t\t((\"in\" with {direction=\"Normal\"}) | (\"in\" \"reversed\" with {direction=\"Reversed\"}))"
L"\r\n" L"\t\tWorkflowExpression : collection \")\" Block : statement as ForEachStatement"
L"\r\n" L"\t= \"try\" Block : protectedStatement [\"catch\" \"(\" NAME : name \")\" Block : catchStatement] [\"finally\" Block : finallyStatement] as TryStatement"
L"\r\n" L"\t= WorkflowExpression : expression \";\" as ExpressionStatement"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule NamespaceDeclaration Namespace"
L"\r\n" L"\t= \"namespace\" NAME : name \"{\" {WorkflowDeclaration : declarations} \"}\" as NamespaceDeclaration"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule FunctionArgument FunctionArgumentFragment"
L"\r\n" L"\t= NAME : name \":\" WorkflowType : type as FunctionArgument"
L"\r\n" L"\t;"
L"\r\n" L"rule FunctionDeclaration Function"
L"\r\n" L"\t= \"func\" "
L"\r\n" L"\t\t("
L"\r\n" L"\t\t\t(NAME : name \"(\" with {anonymity=\"Named\"})"
L"\r\n" L"\t\t\t| (\"(\" with {anonymity=\"Anonymous\"})"
L"\r\n" L"\t\t)"
L"\r\n" L"\t\t[FunctionArgumentFragment : arguments {\",\" FunctionArgumentFragment : arguments}] \")\" \":\" WorkflowType : returnType"
L"\r\n" L"\t\t(Block : statement | \";\") as FunctionDeclaration"
L"\r\n" L"\t;"
L"\r\n" L"rule VariableDeclaration Variable"
L"\r\n" L"\t= \"var\" NAME : name [\":\" WorkflowType : type] \"=\" WorkflowExpression : expression \";\" as VariableDeclaration"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule EventDeclaration Event"
L"\r\n" L"\t= \"event\" NAME : name \"(\" [WorkflowType : arguments {\",\" WorkflowType : arguments}] \")\" \";\" as EventDeclaration"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule PropertyDeclaration Property"
L"\r\n" L"\t= \"prop\" NAME : name \":\" WorkflowType : type \"{\" NAME : getter [\",\" NAME : setter] [\":\" NAME : valueChangedEvent] \"}\" as PropertyDeclaration"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule ClassMember WorkflowClassMember"
L"\r\n" L"\t= \"static\" Function : declaration as ClassMember with {kind = \"Static\"}"
L"\r\n" L"\t= WorkflowDeclaration : declaration as ClassMember with {kind = \"Normal\"}"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule ClassDeclaration Class"
L"\r\n" L"\t= ("
L"\r\n" L"\t\t(\"class\" with {kind = \"Class\"})"
L"\r\n" L"\t\t| (\"interface\" with {kind = \"Interface\"})"
L"\r\n" L"\t  ) NAME : name [\":\" WorkflowType : baseTypes {\",\" WorkflowType : baseTypes}] \"{\" {WorkflowClassMember : members} \"}\" as ClassDeclaration"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Declaration WorkflowDeclaration"
L"\r\n" L"\t= !Namespace"
L"\r\n" L"\t= !Function"
L"\r\n" L"\t= !Variable"
L"\r\n" L"\t= !Event"
L"\r\n" L"\t= !Property"
L"\r\n" L"\t= !Class"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule ModuleUsingFragment UsingFragment"
L"\r\n" L"\t= NAME : name as ModuleUsingNameFragment"
L"\r\n" L"\t= \"*\" as ModuleUsingWildCardFragment"
L"\r\n" L"\t;"
L"\r\n" L"rule ModuleUsingItem UsingItem"
L"\r\n" L"\t= UsingFragment : fragments {UsingFragment : fragments} as ModuleUsingItem"
L"\r\n" L"\t;"
L"\r\n" L"rule ModuleUsingPath UsingPath"
L"\r\n" L"\t= \"using\" UsingItem : items {\"::\" UsingItem : items} \";\" as ModuleUsingPath"
L"\r\n" L"\t;"
L"\r\n" L"rule Module WorkflowModule"
L"\r\n" L"\t= ("
L"\r\n" L"\t\t(\"module\" with {moduleType=\"Module\"})"
L"\r\n" L"\t\t| (\"unit\" with {moduleType=\"Unit\"})"
L"\r\n" L"\t\t) NAME : name \";\" {UsingPath : paths} {WorkflowDeclaration : declarations} as Module"
L"\r\n" L"\t;"
;

		vl::WString WfGetParserTextBuffer()
		{
			return parserTextBuffer;
		}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 114369; // 1038720 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 705;
const vint parserBufferRows = 112;
const char* parserBuffer[] = {
"\xFF\x00\x01\x80\x0A\x22\x85\x0A\x81\x20\x00\x74\x09\x80\x01\x30\x03\x30\x00\x68\x00\x05\x20\x06\x38\x01\x32\x00\x6E\x0B\x93\x98\x30\x00\x38\x00\x39\x16\x80\x33\x22\x90\x01\x34\x01\x37\x18\x80\x3F\x6B\x9F\x78\x0A\x80\x21\x25\xA9\x8D\x80\x99\x3A\x88\x00\x8E\x1E\xA0\x97\x83\x93\x96\x90\x95\x8C\x2C\xFF\x4E\x0F\x91\x99\x8C\x32\x9B\x38\x9F\xA1\x9C\x91\x9F\x9E\x94\x96\x43\x81\xB0\x8C\x37\x96\x84\x01\x35\x00\x53\x0B\x8D\x8A\x87\x89\x37\x90\x19\x8A\x81\xB1\xA0\x00\x9A\x9C\x86\x57\xD9\x9B\xAB\x8E\xA8\xB3\x85\xB1\x02\xC3\x28\xB4\xA4\xAB\x8D\x8E\xA5\x3B\xA4\xBE\x89\x91\xA7\x05\xB8\x88\x31\xD4\x87\xB6\xB9\x9B\xA6\xBD\xAA\x40\xAC\x89\x1F\xB1\x8E\x92\xC0\x00\x54\x00\x35\x9E\x87\x89\xA2\x97\x80\x72\xD4\x8D\x8C\xA4\x21\x93\x86\xCD\x4A\xDC\x8D\xBC\xBC\x93\x07\xBE\xD0\x4C\xCD\x21\x9F\xA2\x31\x90\x91\xA0\x13\x7F\x8E\xA3\x9A\x80\x91\x3A\xAB\x0A\xA8\xA0\x88\x80\x97\x30\x01\xDB\x5F\x97\xA1\xAF\xAB\x96\x80\xCC\xC4\x24\xB5\xFF\xD8\xD5\xA8\x90\xC2\xBC\x24\xBD\x88\xE1\xA1\x0A\xD9\x94\x85\x26\x99\xB7\xD7\x8A\xAA\x86\xD1\xB6\xC2\xEF\xA5\xC2\x8D\xCF\x8B\xCE\xB4\x20\xA2\xFB\xA9\xCB\x96\xBD\x81\xF2\x00\x54\x97\x9D\xAA\xB6\xEC\xB6\x00\xC1\xD7\xC4\xFF\x76\xE0\x00\xF8\xFB\x0F\x51\x43\x45\x45\xE1\x4A\x4F\x73\x59\x4C\x6B\x7B\x7C\x59\x13\x5A\x78\x7E\x6B\x68\x6D\x62\x7C\x64\x92\x77\x55\x64\x4B\x97\x76\x44\x82\x7E\xF0\x67\x73\x4C\x5A\xD8\x53\x7C\x4A\x02\x02\x47\x86\x62\x74\x4E\x70\x65\x8B\x4D\x77\x48\x87\x62\x53\xDD\x60\x8B\x6A\x5B\x62\x6C\x42\x06\x40\x46\x31\x75\x56\x7A\x29\x7E\x66\x89\x5E\x28\xA4\x6B\x49\x86\x39\xBA\x66\x4D\x43\x01\xB5\x72\x8C\x78\xFA\x56\x68\x8D\x73\x0F\xA2\x6F\x8D\x74\xA3\x6C\x7D\x4B\x93\xB7\x59\x4F\x41\x88\x4E\x7C\x60\x02\x6F\xC0\x74\x8B\x7D\x6C\x01\x79\x89\x94\x73\x0A\x9D\x8A\x8F\x87\x3C\xA9\x86\x8C\x96\x29\x5B\x95\x94\x52\x2D\xA7\x83\x9D\x50\x0C\x30\x9A\x97\x42\x0A\x91\x63\x65\x48\x78\x82\x49\x10\x00\x66\x34\x95\x60\x90\x77\xA3\x71\x43\xA0\x85\xB1\x8F\x77\x83\x05\xBB\x7E\x78\x00\x83\x99\x45\xA3\x45\xCE\x6C\x87\xA0\x95\x0A\x94\x72\xA2\x7E\x17\x7E\x68\xA6\xA1\xD0\x49\x82\x8B\x4A\x0D\x02\x4C\x11\x48\x06\x9A\xA5\xAB\x8B\x42\xBF\x36\x69\x40\xAB\xB3\x70\x02\x15\xE8\x71\x4D\x42\x84\x80\xAC\x45\x74\xAD\x31\x74\x79\x7A\x8E\x53\xA6\xAE\x9B\x4A\x07\x02\x4A\x69\x43\x1E\x7E\x96\x87\x7E\x19\xAA\x6D\x59\x6B\xA3\x85\xB0\xAE\x95\x06\x0A\xB5\x57\x51\xB7\x53\x8A\x89\x40\xAA\x68\x4C\xB6\x8E\x17\x55\x17\x61\x46\xBE\x79\x83\xB2\x6F\xF9\x43\x7D\x5E\xB6\xE2\x8B\x73\x86\xB9\xD2\x68\xB4\xA7\x7D\x5F\x41\x57\x04\xBC\x00\x23\xB3\xBF\xB9\x5F\x80\x0E\x10\x5A\xF9\x6A\xB8\x58\xBB\x62\xAF\xB0\xBB\xB6\xF2\xA1\x44\xBD\x51\x01\xD0\x12\x8D\x44\x41\x5B\x0C\xBE\xBF\x0E\xC0\xCE\x6F\x15\x81\x7D\xB0\x02\x5C\x1F\x87\x56\xC1\x43\x08\xD1\xA1\x50\x05\x02\x43\xCD\x41\x7E\x23\x5E\x48\x91\x48\x6A\xA0\x63\xB0\x97\xB1\xBF\xA2\xC1\x48\x77\x14\x8F\x9F\x45\xD6\x81\x96\x95\x9E\x01\x43\xCD\xB7\x9A\x00\x3C\xA7\x46\xB3\x94\x7B\x76\xCF\x13\x45\xE4\x43\xAB\x86\x3D\xC9\xAB\x4B\xBE\x01\x4C\xD0\x4B\x51\xA3\x97\x47\x53\xAA\x2B\xCD\xD7\x51\x43\x51\xDD\xAC\x49\x7F\x56\xDE\xC9\xD6\xC7\x2A\xD0\xA4\xAA\x8B\x3E\xCB\x82\x42\xC4\x67\x58\xD4\xA0\xC4\x5A\xFA\xCF\xB3\xB7\x00\x30\xD5\x55\xD2\x20\x4A\x45\x4D\xCC\xB9\xAD\x91\xAC\xD5\x00\x12\x18\x5A\x49\x23\x7C\xCC\x8B\x43\x17\x5E\x44\xCD\x46\x8E\xB8\xB9\xC0\x4B\x93\x86\xED\x42\xBD\x8A\xC9\x5C\xDA\xD4\x42\x42\x46\xE4\x00\x39\xD2\xC8\x49\x76\xF7\x60\x48\xD1\xAF\x2B\x64\x95\xE1\x48\x97\x90\x7B\x9D\xE6\x75\x88\xA2\xD8\xAA\x9E\xEC\xE0\x85\x78\x8C\xF6\xD9\xD2\xC2\xAB\xF6\xA7\x6C\x48\x90\xEB\x54\x7D\xBB\xE2\x6B\x48\xC9\x40\x5A\x76\xA1\x65\x5E\x21\xB6\xB1\xDB\xA9\xFF\x36\xCA\x55\x44\x1F\xB5\xD2\xE8\xC4\xC2\xBA\xE8\xEB\x3F\x8B\x48\xF2\xF3\x8C\x26\xD8\x82\x41\x8C\x20\x64\xEE\x8E\xAB\x9B\xF3\xEF\x3C\x89\xDE\xF9\xC6\x4A\x42\x49\xA0\xCE\xD2\xA4\xE3\xE0\xE1\xB2\x55\x11\x51\xE3\xF3\xE4\x2B\x56\x02\x41\x64\x28\x3E\x21\x14\x4B\x3D\x20\xAA\x26\x25\x50\x26\x35\x6F\xF3\x47\x57\x4B\x80\x00\x87\x2E\x03\x97\x35\x01\xB1\x28\x81\x90\x07\x2F\x74\x17\x4B\x24\xD0\x14\x44\x26\x25\x4F\x54\x78\x35\x4B\x24\x01\x7F\x75\x43\xDD\x63\x6C\x84\x3B\x7F\x60\x5A\x34\x30\x63\xF3\x5A\x76\x4E\xEA\x7A\x00\x0A\xCF\x5C\x69\x42\x4B\x81\x25\x37\x96\x4B\xF1\x5A\x77\x23\x1A\xBC\x83\x6D\x30\x90\x79\x7F\x18\x84\x42",
"\xE6\x6D\x80\x88\xB2\x70\x7B\xA4\x66\x59\x23\x0F\x75\x21\x87\x63\x42\x20\xAE\x1F\x46\x25\x5D\x64\x5E\x3F\x9E\x24\x6B\xCC\x1C\x76\x67\x29\x8A\x2D\x8A\x4D\x73\x42\xFE\x60\x7D\x48\xA8\x02\x24\x63\x8D\x37\x8B\x18\xCC\x4E\x5C\x96\x07\x15\x20\x07\x2B\x20\x80\x00\x33\x40\x31\x50\x8D\x00\x02\x37\x23\x86\x6D\x85\x39\x38\x8A\x23\x8E\x02\x54\x22\x1D\xE8\x71\x88\xA7\x08\x02\x20\x85\x47\x4E\x9C\x6A\x79\x42\x98\x24\x76\x89\x48\x9C\x50\x72\x78\x81\x21\x0A\xA0\x24\x85\x4E\x52\x28\xC4\x10\x90\x8A\x01\x02\x21\x80\xD0\x44\x2B\x23\xCA\x2F\x88\x42\x89\x8E\x29\xD9\x41\x21\xE2\x56\x2E\x29\xA3\x30\x2A\x93\xA4\x63\x32\x29\x92\x9E\x29\x1B\x41\x27\x22\x49\x37\x72\xD9\x1E\x60\x8B\x57\xA5\x28\x62\xB2\x8F\x87\x29\xA9\x2C\x7D\x90\x02\x9C\x96\xB1\x44\x2F\x54\x55\x2F\x20\xAC\x2B\x8A\x6D\xC3\x25\x98\x0B\x9F\x82\x4D\x91\x3E\x92\x7E\x74\x31\x92\xB1\x29\x2D\x7B\x5C\x60\x48\x9A\x0B\x36\x9A\x19\xC7\x33\x83\xBA\x33\x93\x9B\x19\x27\x91\x25\xCB\x3B\x4F\xC7\x74\x7F\x38\x69\x8F\x30\x14\xA3\x81\x21\x26\xAA\x6C\x77\x72\x31\x9C\x2F\xE7\x97\x5A\x00\x29\x97\x2E\xD5\x65\x8F\x4A\x5D\x99\x9F\x8E\x57\x85\x84\x21\x34\x9E\x4C\x77\x9A\x30\xC6\x06\xA7\x87\xFF\x8E\x66\xEB\x45\x7D\x80\x15\xA8\x34\x24\x80\x6C\x4C\x9F\x48\x3D\x9B\xD6\x1B\x31\x24\x44\x82\x9F\x90\x27\x3B\x84\x8C\x99\x8A\x66\x32\x4A\x42\x42\xD8\x21\x97\x50\x87\x3F\xA2\x23\x39\xA1\x68\x1B\xAE\x29\x64\x41\x21\x3F\xAC\x30\x42\x48\x95\xA9\x33\x92\xB1\xA7\xA4\x81\x74\xA5\x4A\x0A\xA6\x9F\xFC\x01\x2B\x56\x16\xBE\xA4\x00\x52\x5F\x40\x6A\x4A\x28\xA9\x72\x7E\x43\x4C\xEE\x97\xA8\x92\x9F\xA3\x24\x4C\xB9\xA7\xA8\x2B\xA0\x99\x28\x87\x3B\x36\x0B\x36\x34\x73\x46\x4E\x4B\x6F\xA0\x80\x00\x03\x02\x20\x56\x17\x25\x26\xBC\x72\x28\xAC\xCA\x37\x36\x9C\x64\xAA\x28\xB3\xA2\x4C\x92\x82\x93\x83\x76\x7B\x3D\x3F\xB7\xA9\x24\x85\x62\xB3\xAE\x52\x50\x8D\x9B\x0F\x76\xA9\x52\x3B\xA8\xAA\x4C\xDB\x8A\xA4\x81\x05\xAB\x7B\x93\x50\x3F\x84\x74\x3F\x99\xB3\x85\x98\x97\xB1\x68\x9A\x95\x7D\x3F\x3E\xB4\x09\x4D\x8E\x91\x50\x8A\x4D\x80\x3A\x97\xA3\x13\x47\x35\xE3\x96\x26\x83\x79\x33\x58\xA3\x7F\x83\xB4\x17\x33\x43\x59\x99\x9A\x42\x31\x4B\xB1\xA5\x1C\xA2\x22\x61\xCB\x37\xAD\x9D\x99\x40\xB4\x1C\x40\xAA\x46\xEE\x94\xA8\x82\x5B\x7A\x75\x50\x95\xB2\x98\x17\xBC\x9F\xB6\x41\x2E\x96\x00\x19\x44\x55\x28\x2C\x46\xE7\x4D\xBB\x4E\x78\xB5\x22\x5E\xDB\x74\x48\x28\x53\x27\x65\xF9\x7F\x78\x1B\x8B\x25\x99\x87\x28\x21\x9B\xE6\x22\xAA\x95\x5D\xB6\x49\xEF\xB8\x7E\x83\x92\x71\x51\x37\xC7\x26\x25\xB3\x0B\x90\x7A\xEC\xA3\xB2\x67\x80\x3A\xB9\x48\x45\xBD\x6B\x19\x95\xA1\x91\x7A\xB0\xBC\xF8\xBB\x7A\xBE\x02\x33\x99\x7C\x82\xA2\xC0\x28\x5F\x2A\x4A\xD7\xAA\x40\x74\x98\xB2\xA2\xA3\x16\x82\x9B\xFD\x94\xB7\x80\xA0\x2F\xC0\x8D\x11\xC3\x92\x02\x3A\xBA\x8E\x7B\xAA\xC2\x76\xA8\x48\x39\x65\xBC\xB6\x98\x7F\xBC\xA1\x91\xA5\x4E\xC4\xF7\xBD\x49\x5D\xAA\xCE\xBE\x81\x3E\x6F\x6E\x2C\x2A\x76\x99\x71\x4A\xBC\x2C\xA9\xB8\xA5\x82\x79\x21\x61\xA9\x2E\x29\x9A\x1F\x2F\x7D\x15\x58\x6F\x8E\xED\x93\x4F\xDB\x81\xC8\x00\x43\xDD\x34\x8D\xFA\x3B\xA6\x1D\xF0\xC5\xC7\x4E\xDD\xC4\x8B\xC6\xA9\xC6\x3D\x67\xC6\x29\x59\xCE\x9D\x31\xE7\x2A\x21\xDF\x69\x24\x88\x4A\xD7\xCA\x3B\xE1\xC3\x4F\x6E\x8A\xC7\xC0\x0C\xD0\xBB\x92\xDF\xC8\x87\x0F\xC6\x90\x91\x6A\xDC\x73\x06\xF3\xC1\xC7\x33\xC8\xA7\x22\x51\xC1\x61\x98\x08\xBB\x3F\x3D\xF9\xCD\x4F\x7F\xDE\x9E\x40\x2E\x43\x69\x10\xBF\x1B\x83\x8C\x58\xC1\xDB\x5D\x96\xBD\x94\x34\xBD\xC7\x81\x4B\x53\xDC\x50\x88\xA9\x42\x53\x83\x95\x66\x28\x2F\x9E\x14\x6C\x24\x48\xDB\xD6\xCE\xC4\x96\xC6\x52\x7B\xA1\xD4\x5D\x89\x4D\xAA\x9A\xCD\x52\x78\xE0\x9A\x20\xE6\x87\x98\x9D\xFB\x28\xA9\xA4\xFD\xBA\x3F\x4E\xF3\x2B\x7E\xAD\xDC\xC4\xA9\xAB\x2A\xD7\xB9\x7C\xD3\x38\x5B\xDB\x79\xB1\xB2\xD6\x3E\x38\xD1\x9A\xD5\x62\xB7\x21\xB0\xA3\xD9\xD7\x4F\x4C\xDB\x49\xB4\xC0\x02\x42\xB7\xC6\x85\xF6\x1F\x56\x52\x10\x50\x8A\xAD\x99\xB8\xD6\xDE\x55\x53\x6E\xD5\x48\xD5\x46\x5B\xD9\xD0\x4F\x5A\xD3\x38\xA1\x41\xDE\xBA\x80\x09\xBB\x5F\xE4\xC4\x25\xA9\x40\x5A\xAD\x62\xD9\x8F\x79\xC1\x29\xDF\x00\x15\x56\x87\xB7\xDD\x9F\x6E\xA2\xC5\x7C\x11\x57\x89\x62\xAA\x5C\x55\x5B\x79\x50\x8C\xAE\xA9\xD9\x80\xC8\xA2\xE0\x85\x1E\x88\xE1\x56\x93\x41\xBD\xDB\xB1\xC0\x9B\x6B\x50\xC9\xA3\x53\x83\x1D\xA1\xC6\xDF\xED\x63\xB3\x59\x77\x24\x89\x5A\x81\x2B\xAD\x24",
"\xEC\x27\xE4\x68\x2D\x59\xA2\x9B\xE3\xC4\x93\xDA\x5C\x59\x3F\x88\xA9\xCE\x08\xE6\x3F\xD6\x0E\x37\x7E\x6D\xA2\x7F\xC2\x53\x52\xDE\x82\xED\x6A\xE2\x2E\xAB\xAB\x8C\x4E\xA9\x52\xA3\xF3\x49\xA2\xB9\x41\x7F\x4A\x7F\x91\x5C\x8F\x43\x6F\x22\x1B\x91\xAA\x16\xB8\xB0\xAD\xA0\x14\xEC\x61\x57\xE0\x01\x31\xDF\x21\x5F\xB0\xE8\xCC\x25\x5F\xE5\xEF\x15\xC8\xEE\xEB\x8B\x4D\x67\x22\x78\xB2\xA2\x42\x11\x2B\xA7\x49\x55\xE8\x63\xE5\x5A\x63\xBD\x7B\x7D\x9B\x42\x6B\x59\xDB\x3B\xA4\x73\xDD\xEF\xE0\x01\x87\x66\x7F\x66\x00\xD1\xBB\x4C\xA5\x6A\x3E\xB6\xD4\x76\xED\x61\xE6\xF1\x8F\x79\x63\x62\x7A\xC2\x20\xE4\x0F\x5B\xA7\x0E\xE9\x6C\x64\x80\x96\x2F\x22\x6C\xCA\x41\xD6\xC2\xB3\xAB\x39\x5A\xF1\x65\xC6\xB9\x2E\x44\xB9\x71\xF4\xE4\x0E\xF3\x25\x36\x63\x63\x45\x39\x64\x88\xC2\xBA\xB3\xC6\x83\xD4\xCA\xD2\x28\xF3\xF7\x1F\xB6\xF3\x9D\x8A\x9D\xC7\x4E\xB1\xF8\x66\xDF\xF3\xDC\xDD\x29\x99\xD3\xCD\x43\x60\x34\xD7\x84\x88\xB6\x57\x93\xB6\xAF\x02\x2C\x69\xD6\x2B\x90\x24\x50\x73\xDF\x3F\xFA\x85\x9B\xDD\xD5\x6D\x69\xD7\xE2\x90\xEC\x1B\x58\xD7\x71\xE4\xF9\xC3\xD3\xFF\xFA\xF5\x90\x49\xFA\xA7\xCD\xB5\x9E\xA9\xFE\xF8\x00\x55\xF3\x7E\xEC\xE1\x24\xD3\x9F\x80\xFC\xFB\xA0\xAD\xDD\xF4\xF3\xFA\xFF\x4F\x37\x7F\xDA\x72\x10\x12\x57\x16\x7C\x4F\x0F\x84\x35\x36\x72\x31\x37\x01\x76\x5C\xAD\x1F\x35\x92\x63\x27\x0A\x5D\x1A\xF1\x21\x74\x7D\x4F\x7D\x57\x37\x3B\x68\x31\x7F\xF3\x4E\x58\xF1\x7E\x4B\x7A\x35\x37\x17\x15\x41\x19\x15\x37\x44\x4F\x7A\xFF\x0A\x3A\x7A\x30\x4A\xA3\x27\x63\xAD\x78\x4A\x02\x12\x2A\x72\x40\x21\x78\x3B\x82\xCF\x2D\x37\x15\x2F\x82\x43\x5E\x81\x89\x75\x83\x4A\x1C\x82\x4A\x1E\x82\xA4\x7C\x58\xC8\x1F\x4F\xAB\x4F\x47\x34\x8D\x65\x01\x16\x83\x7C\x3B\x10\x7F\x33\x84\x5C\x7B\x83\x01\x1C\x6D\xC7\x5F\x36\x3F\x87\x83\x4E\x8E\x63\x56\x10\x64\x3D\x66\x33\x22\x64\x15\x7B\x55\x50\xBA\x42\x83\xB2\x4B\x47\x14\x54\x38\x9F\x38\x38\x02\x8C\x11\xB9\x3E\x38\x73\x27\x6C\xE4\x5D\x6F\xEE\x7A\x44\xB5\x33\x86\x6B\x84\x6E\xFD\x48\x57\x4E\x5E\x1B\xA4\x3C\x3B\x9F\x38\x39\x11\x8A\x20\x00\x7B\x87\x10\x30\x13\x28\x17\x26\x10\x8D\x41\x7E\x82\x6A\x01\x33\x7E\xAF\x2D\x36\x2B\x7E\x16\xAE\x4F\x78\x01\x1F\x87\x8D\x81\x88\xC8\x18\x54\xE1\x17\x14\x86\x86\x62\x89\x8E\x72\x2B\x14\x16\x9F\x31\x3A\x55\x14\x3A\xD9\x3F\x7C\xFD\x62\x5B\xFC\x39\x82\xB5\x33\x82\x1A\x8F\x3A\x98\x8E\x14\x28\x80\x70\x86\x3E\x8A\x67\x30\x8B\x27\x8C\x83\x2D\x6F\x0F\x95\x3D\x70\x66\x61\x3C\xCD\x64\x46\xCF\x67\x4B\xFE\x6C\x12\x3B\x49\x3C\x0B\x1B\x3C\xC9\x17\x44\xFC\x61\x10\x95\x68\x5E\x74\x6A\x43\xF5\x3A\x3C\x86\x1D\x3C\x01\x32\x5A\xA9\x82\x8C\x14\x57\x8C\x0D\x7A\x8C\x2C\x47\x78\x1D\x83\x85\xD5\x82\x7F\xD3\x31\x75\x1E\x37\x3D\xA6\x80\x21\xA8\x84\x8C\xAA\x82\x75\x15\x54\x3E\xCC\x83\x6F\x34\x70\x86\xDB\x35\x4C\x5A\x1E\x3E\x0B\x11\x3F\x25\x57\x11\xE6\x7F\x88\x9C\x36\x8F\xF6\x38\x64\xFA\x8F\x51\x80\x69\x60\xB3\x62\x7D\xDE\x6D\x3E\xF7\x39\x24\x70\x8A\x10\x1B\x4F\x10\x04\x9F\x4B\xC3\x24\x6D\x79\x1C\x3B\xF7\x8B\x90\xFC\x57\x90\x62\x20\x70\x72\x3E\x69\x0D\x3A\x10\xD3\x6F\x5E\x16\x91\x90\xF9\x89\x91\xC1\x83\x5E\xB5\x62\x87\x78\x8E\x5C\x2C\x1E\x3F\x0E\x4B\x37\x00\x01\x41\xBF\x67\x40\x31\x1A\x40\xC7\x7A\x8B\x5C\x6E\x62\x14\x20\x4A\x32\x93\x41\x34\x99\x40\x1E\x39\x8B\xF0\x7D\x83\xA5\x64\x42\x1D\x4D\x90\x00\x04\x16\x10\x95\x92\xE1\x57\x92\xD9\x6A\x7C\x91\x17\x94\x1A\x91\x29\x19\x24\x82\xBF\x64\x15\x35\x18\x94\x50\x94\x4A\x06\x6A\x8D\x0A\x18\x82\x1B\x41\x95\x15\x28\x94\xD0\x55\x18\x28\x14\x1F\x72\x25\x37\x5A\x97\x42\x2F\x99\x42\xF2\x3F\x8D\x93\x7D\x8C\xC6\x4B\x92\x9C\x33\x44\x89\x6F\x96\x1B\x56\x5D\x73\x87\x67\xAA\x41\x56\xD8\x6E\x1B\x16\x8C\x1F\x33\x49\x34\x78\x96\x8D\x2E\x44\x97\xEF\x79\x85\xDD\x6F\x0F\x32\x4D\x96\x34\x47\x6A\x7B\x95\x67\x91\x99\x11\xFD\x89\x3E\xD0\x3B\x43\x44\x4E\x43\xB5\x77\x93\xE2\x89\x7C\x6C\x9F\x43\xDE\x89\x97\xD7\x83\x6F\x95\x95\x48\xB1\x26\x97\x29\x41\x9A\x86\x91\x8B\x52\x87\x1F\x98\x4F\x99\x44\x4A\x9A\xF1\x83\x99\xDA\x6A\x6A\x9E\x99\x90\x85\x7B\x50\x1D\x4D\x49\xF9\x7E\x11\xBC\x3C\x44\xB9\x25\x4A\xB4\x93\x5A\x40\x83\x91\x1E\x38\x37\x17\x7A\x2B\x61\x40\x33\x50\x8F\x64\xA5\x93\x4C\x56\x2A\x3A\xC9\x90\x71\x57\x4A\x83\xEB\x68\x93\x55\x81\x10\xD3\x99\x70\x13\x26\x9D\xB5\x9D\x99\x38\x60\x7B\x52\x4F\x70\xDC\x91\x12\x48\x9A\x4E\x79\x5F\x45",
"\xE5\x91\x60\x64\x18\x46\x1D\x3C\x1D\x53\x9A\x1F\x94\x68\x1C\x97\x64\x55\xA9\x5E\x9E\x3F\x70\x9F\x4E\x97\x56\x6E\x61\x9F\x07\x8D\x1A\x01\x12\x09\x01\x01\x10\x00\xA2\x10\x06\xA1\x10\x41\x11\x14\x07\xA2\x10\x09\xAC\x12\x0B\xA8\xA0\x0D\xA0\x10\x0F\xA1\xA1\xFF\x01\x89\x13\x18\x05\x94\x7E\x49\x01\x1F\x02\x00\x0E\x05\x07\xA1\x14\x91\x88\x10\x9D\x1D\x19\x1A\xA0\x00\x1C\xAB\x02\x00\x03\xA0\x10\xAB\x12\x91\x8A\x15\xE6\x20\x13\x2A\xA0\x00\x2D\x00\x00\x25\xA0\xA2\xDA\x26\x2E\xAB\x25\xA2\x1C\xAA\x02\x68\x5C\xA0\x2C\x11\x89\x9D\x13\x28\xB8\x2A\xA3\x26\xAF\x9D\xFB\x11\x89\xAA\x1C\x34\x9D\x11\xA3\x25\x06\x79\x2B\xAF\x0F\xFF\x42\x17\x4C\x33\x30\x72\x18\x10\x91\x11\xA3\x26\x0A\x68\x4F\xA5\xA2\xAB\x23\x11\x0A\x5C\xA1\x3C\x05\xA4\x3D\x00\x00\xA3\x51\x14\x25\xA7\x04\x36\x1F\xA5\x00\x0E\x03\x62\xA0\x00\xE8\x96\xA6\x0C\x71\x19\x44\xA1\xA6\xDD\x40\xA7\x01\x18\xA6\x72\xA2\x10\x1C\xAC\xA6\xC5\x46\xA7\x36\x13\x40\x6A\xA3\xA6\x1C\xA3\xA6\x48\x5E\xA7\x03\x3E\xA5\x7A\xA0\x00\x21\x0D\xA6\x1B\x4D\x76\x01\x18\x10\x5A\x1A\x15\x83\x28\xA6\x03\x34\xA4\x63\xA0\x70\xB0\x6A\x78\x08\x13\x28\x5D\xA8\x45\x5F\x04\x21\x48\x06\x13\x03\x3A\xA6\x3F\x05\xA4\xA5\xA4\x16\xFF\x62\x10\x03\x46\x2E\x13\x1A\x15\x91\x13\x28\x53\xA0\x00\x9F\xAA\x1A\x08\x16\x38\x4B\x04\xA3\x89\xA5\xAA\x93\x23\x92\x52\xA4\x79\x13\x1F\xA9\x9D\x13\x11\xAB\x23\x28\xAA\x13\x28\x91\x13\x11\x86\x35\xA2\x3A\x00\x00\xCB\xA9\x21\x41\x18\x57\xBD\xAB\x2A\xB1\xA1\xA3\xCB\xA6\x33\x41\x1D\x4D\x5A\x13\x11\xC5\xAA\x42\x4C\x32\xAD\x37\x31\xA3\x3B\x00\x00\xD0\x5F\xAC\x7F\x1C\x34\xAA\x14\xAB\x29\xA2\x10\x2C\x00\x00\xAA\x36\xA3\xEF\x1F\x7F\x57\xA2\x10\x2E\x00\x00\x3B\x41\x14\xC5\x4C\x34\x12\x33\x11\x03\x3F\xA9\xB5\xAB\x3A\x08\x19\x05\xB8\xAB\xA1\x00\x0B\x05\x00\x0D\x1F\x99\xA2\x17\xDE\xA9\xAD\xB2\xA0\x00\xFD\xA6\x38\xFF\xA1\xB0\x45\xAD\x05\x00\x0E\x92\xFB\x17\xAF\xBE\xA7\x33\x9F\xA0\x13\x0E\xBA\x42\x13\x14\xA4\x7B\x00\x00\x84\x37\xB0\x0D\x8C\x34\x0A\xB9\xB1\xFE\xAC\xB1\x10\xBC\xA1\x7D\x00\x00\x18\x0E\xA3\x1A\x44\x7D\x17\xBB\xAF\xBF\x4B\xB1\x72\x17\xAB\x13\x19\xA7\x02\xB8\x02\x00\x09\x01\x2E\xBF\x0F\x00\x78\xB0\xFF\x75\xB2\x33\xBC\xB0\x2A\x46\xB3\x14\x24\xA4\x29\x00\x00\x8D\x9B\x1F\xDD\x41\x19\x00\xB9\xAF\x0B\xB8\x2B\x4C\x33\x28\x9D\x1A\x50\x15\x13\x3A\x1E\x36\x31\x4F\xA8\x54\x4E\xB7\xB1\x9F\xAC\x34\x30\x14\x10\x13\x12\x17\x91\x1F\x4F\x28\x1D\x1A\x6A\x09\x45\x0A\x1C\x01\x3D\xB4\x16\x5D\xB0\xB5\x9F\xA3\x28\x03\x37\xAC\xAB\x39\x23\x08\x12\x17\x13\x1D\x4D\xE9\x83\x2A\x1E\x99\x3B\x1D\x0D\xB3\xE8\x9F\xB6\x36\x11\xB7\x37\x31\x19\x91\x89\x8E\x1E\x0D\xB3\x4D\xB0\x00\x4F\xB3\xB8\xB9\x92\xB7\x14\x2A\x50\xB7\x19\x8E\x1F\x0D\xB3\xC5\x42\xB8\xBF\xAA\x78\xDE\xA6\xA5\x4E\xA3\x37\xD3\x52\x23\x20\x0D\xB3\x5C\xBC\xB8\x5E\xB8\x45\x4C\x3F\xA2\x0D\x83\x11\xFF\x47\x14\x87\x8B\x9C\x17\x1B\xA8\x5B\xB4\x42\x8D\xB9\xB9\xAE\xAB\x3A\x90\xB8\xA6\x46\x8E\x97\x87\x72\x02\x8A\xB2\xBB\xA5\xB2\x17\xA1\xAD\xAF\x0A\x59\x24\x1F\x23\x02\xBD\xBF\x92\xB3\xBB\xB0\x30\x1C\x34\xDD\xA6\xA4\x14\x85\x15\x54\x14\x02\x3D\xB0\x70\x46\xB0\xB0\x1C\x3C\x34\x86\x3D\x19\x9F\xAD\xAB\x03\x35\xBB\x78\x55\x69\x19\x1C\x42\x4D\xA1\xBB\x01\x15\xBD\x00\x07\xBD\xAB\x3A\xBD\x6A\x11\xAA\xAB\x21\x89\x23\x11\x11\x54\x19\xA5\xE4\xB0\x00\xE6\xB8\xBE\xD9\xBB\xB0\x5A\x11\xAA\x86\x3E\xBE\x80\x10\x12\x27\x02\xBA\x02\x15\xBF\xFF\x77\xBF\x9F\xA8\xA1\xD8\xBD\xA3\x01\x1C\x11\x46\x2A\xB3\xF3\xB2\xC0\x07\xCA\xBE\x08\x13\x30\x9D\x11\x89\xA5\x50\x00\x49\xBF\xA4\xC5\x4E\xC0\xE9\xBB\xB0\x07\xC5\xA2\x46\x2C\xA3\x0D\xC6\x13\xD6\xB3\xC0\x9E\xA7\x33\x4C\x36\xB8\x1E\x87\x96\x00\x08\xA2\x4F\xAB\x41\x1A\xC4\xC0\x37\x38\xA3\x0D\x85\x5C\xCC\x70\x00\xEB\xAD\xC2\x01\xC2\xC2\xE7\xB4\xC2\xEA\xB1\x19\x86\x3C\xAA\x46\xA1\x57\x21\x13\xA3\x4F\xA4\xBD\x3A\xC6\xBF\x25\xC6\xB7\x0D\x8A\xB0\x78\x5E\x91\x54\x1B\x4A\xF3\xA1\xC2\x13\x13\xC2\x0F\xCB\xB0\x9D\xA8\xC2\x01\x13\x59\x45\xA8\xC1\x39\xC3\xC5\x3B\xC5\xC5\x84\xB5\xA9\x97\x79\x12\x30\x03\xBD\x5D\xC4\xBA\x48\xCA\xBE\x1B\xB3\x30\x68\xA3\x11\x78\x56\x9C\x32\x81\x03\x00\xC5\xBE\x47\xCC\xC3\x0B\xB7\xA8\x3B\xC1\x89\x25\x86\x3F\x32\x06\xB9\x67\xC4\xC5\x1B\xCF\xB5\x8A\x7E\xC1\x73\x33\x03\x7E\xC4\xC7\x5E\xC9\xC6\x0B\xB0\xA9\x10\xBF\x51\x34\x07\xC8\xF4\xB5\xC7\x60\xC7\x2F\x5A",
"\x15\xA2\x6A\x85\x03\x3D\xBE\xC2\x92\xC1\xC8\x2A\x4C\xC8\x91\x13\xBC\x25\x5A\x10\x36\x09\xC9\x7F\xCF\xC5\x9C\xC9\x23\xE6\x24\xA5\x46\xA9\x48\x3C\x67\x03\x6D\xB5\xCA\x8A\xCF\xA9\x98\xBF\x7F\x39\x2F\x4F\x54\x87\x11\x28\x15\x28\x38\x04\xCA\x88\xC8\xC6\x76\xC2\xCB\xA4\xB0\xB5\xC8\x7F\x2C\x39\x0C\xCB\x91\xC9\xC8\xBF\xCF\x4B\x90\xB5\xB5\x02\x1E\x73\x96\x6C\xAC\x3D\xB3\x29\x2F\xC5\xC2\x60\xBA\x16\xC8\xAE\x70\x13\x14\x9C\x00\x8A\x14\x1B\x21\xAE\x5C\xCD\xCB\x80\xC0\xC3\xB1\xA4\xC8\x19\x11\xA6\x4F\xA4\x16\xD3\xC0\xC1\x14\x21\x19\x77\xB0\x00\xA1\xAF\x4F\xA2\x10\x48\x00\x03\xA6\xE7\xC0\xCB\xC9\xC1\xAC\x14\x2D\xCE\xEF\xC2\x10\x72\x32\xCF\x6C\xA2\xC5\xBE\xC3\xC9\xB8\x2D\xAF\x91\x87\x70\x00\x05\xAA\x45\xC6\xCF\x93\xCA\xB1\x36\x18\x10\xB7\xAA\x87\xD0\x1D\x10\x58\x10\x04\x3D\xB9\x21\xE9\xCB\xB0\xDC\xB4\x21\x90\xB0\xC4\xE8\x90\xBE\xA2\x9B\x57\x08\x15\xCF\xE0\xC6\xCA\x30\xC6\x38\x37\xB9\x9B\x86\x33\x30\xFF\x44\x66\xCB\x10\x3C\xBF\x42\xD2\xC7\xC1\xD0\x9C\xC8\xCF\x57\xC6\x13\xAB\xB1\x12\x5A\xC7\x11\x72\x19\xD0\x23\xD1\xCB\x27\xB3\x28\x4C\xCB\x68\x87\x33\x3F\x9D\x1F\xCD\x31\xD1\xCE\x25\xC3\x28\x39\x26\xC9\xA7\x68\xC3\x3D\xD9\xCC\xC2\xA6\xCD\x46\xA1\x5B\xF3\x39\x23\x30\xD7\xD1\x9F\xAA\x15\x1C\x36\xAC\x2A\x4B\xCF\x7D\x98\x8F\xF0\x30\x18\x68\xAE\xD4\x47\xD4\xD2\x25\xC5\xA5\x52\xD0\xCA\x11\x91\xAA\x4F\xA2\xCD\x9B\xC0\xC3\xF8\xCA\xC4\x32\xC1\x19\xA3\x5D\x91\x68\x1D\x68\xF7\x2C\xD3\x65\xDE\xD3\x1C\x31\xAA\x9C\xA6\x13\x78\x59\x33\xFA\x47\x11\x04\x10\xD0\x48\xDA\xBE\x39\x27\xC0\x91\x85\x28\x46\x27\xAB\x4F\xA6\xD1\x6F\xD5\xC2\x26\xD8\xCD\xAB\x3A\xB0\x9D\x18\x9E\x67\x1B\x21\x97\x47\x61\xAB\x26\xD8\x66\xDD\xC3\xAB\x30\xB0\x91\x8A\x1C\x35\x1A\x1A\x7A\xD8\xD5\x9D\xC4\x21\xC0\xBD\xB9\x4B\x91\xD6\x11\x13\x30\x6D\xDA\xD0\xA7\xC7\x2F\x03\x38\x10\xAB\x2B\x2A\x00\xB3\x5A\x56\x95\x4E\x15\x2C\x34\xA7\xD1\xD9\xEA\xB0\xB4\x8C\xCA\x15\xDF\xB4\x34\x4C\x12\x31\x64\xD8\xDA\x12\x36\x38\xF8\xA6\xA4\x66\x90\x41\x66\xCF\xD4\x93\xC3\x11\xB8\x2A\xAF\x14\x28\x57\xDC\x71\x29\x86\x37\xD5\xC0\xD8\xBF\xF9\xCA\xD1\x2A\x49\xBB\xC1\x86\x12\x0F\x1A\x15\xBF\xD8\xCC\x93\xC6\x2E\x92\xA7\x33\x68\xA8\x57\xB7\x15\x2F\x01\x31\x19\x4F\xA6\x33\xA8\xD5\xDB\x4A\x7D\xAA\x94\x7D\xCE\x79\xB8\x9D\xAA\x7B\x5F\x79\x7C\xDD\xE8\xDC\xC9\x49\xA8\x45\x32\xCA\xBA\x02\x14\x76\x56\x77\x45\xB8\x29\xDC\xDD\xDF\xA9\xA9\xC7\x2F\x9F\xC2\x10\x67\x28\x64\x1C\x3F\xA4\x0A\x56\xDF\xAA\x13\x11\x1B\x44\xB0\x0D\x13\xA3\x7A\x04\xB4\x33\xAA\x05\x0B\xB2\xB1\x1C\xA9\x33\x3C\xA8\xA1\x64\xD5\xC5\xD7\xC3\x11\xEA\xB8\xE1\x36\x18\x9E\x1C\xA2\xBD\x04\xB5\xC6\x33\xA5\xCC\x12\xBC\xA3\x00\xBF\xA4\x78\x59\x23\x9B\xB4\x21\xA3\x5C\xA1\x47\x18\xA2\xF3\xA0\xE4\x2B\xC0\x00\x22\xEF\xA4\xA3\x50\xB9\x74\xBD\xC6\xAB\x31\x89\x44\xE8\xA2\x04\xBF\xA4\xFF\x45\xBB\x86\x37\xBB\x8A\xA2\x10\xFF\xBA\xB3\x04\xBE\xA1\xFF\xBC\x05\x00\x0E\xE5\x12\xBC\x07\x5F\xE3\xE6\x5E\xE3\xAF\x49\xBC\xA3\xFF\xB2\xE6\xBC\xBA\xE5\x1D\xA0\x00\xBC\xBE\xE5\x60\xE0\x00\x62\xE0\xE7\x63\xE6\xE6\x00\x0C\xA3\x6F\xE6\xCC\x89\xDB\x3A\xE8\xA1\x19\x54\xE4\xDB\x00\x08\xA6\xE3\xB5\xA4\xD2\xBA\xB3\x59\xE3\xB0\x6D\xED\xE5\x63\xE1\xE6\x64\xE5\xE7\x16\xC7\xE7\x00\x09\xE6\x6E\xE0\x00\x6C\xEE\xA1\x79\xE1\xE7\x73\xED\xE8\x76\xE8\xE7\x8F\xE2\xB1\x4F\xA1\xA3\x78\x5A\x15\x12\x3A\xDF\x08\xC5\xA4\x23\x18\xA2\x1E\xAF\xA4\x02\xA1\x10\xD0\xA6\xDC\x24\x13\x29\x3D\x57\x55\x00\x03\xAF\x86\x38\x12\x2A\xC1\x39\x38\x85\x4C\x14\xD1\xBA\xD2\xB1\xA6\xB1\xE4\x25\x6C\xAD\xEA\x30\x50\x00\x48\x5F\xEB\x4C\x13\xAF\xB8\xEB\x10\xDD\x4B\xEB\x00\x0E\xEB\xAE\xE3\x12\xC1\xE6\x55\x54\x23\x5A\xC6\xE4\x12\xF3\xA2\xC7\xD8\x0A\xA2\xCE\xE3\xEC\x6C\xAB\xAC\xA1\xBA\xB3\xDF\xE0\x00\xA1\xBC\xBB\x52\x5C\x14\xBC\xB1\xBA\x60\xD0\x18\xA1\xBF\xB1\xA1\xBC\x52\xCF\xC1\xBA\x63\xA3\xEE\x49\x52\xEB\xE7\xE0\x00\x2B\xB1\xBA\x49\xB1\xBA\x62\xE1\xEE\xF2\xEB\xB7\x4A\x1D\xB7\x21\x15\xEF\xE9\xE1\x11\xEB\xE2\xEE\x69\x1D\x52\xF0\xE6\xF0\xBC\xB7\x6E\xD9\x30\xF0\x17\x15\xEF\xF7\xEF\xE8\xF8\xE0\x00\xCC\xEE\xE2\x13\x11\xBA\xDE\xEB\x50\xF9\x11\xBA\x04\xB2\xEF\xCB\xA5\xEF\x1C\x36\x24\x58\x15\x28\x9F\xB4\x7B\x89\x68\xF1\x06\xFE\x51\xF3\x31\x52\x06\xFC\xEE\x93\xEB\xAE\x20\xF0\x25\x23\xFA\x23\x28\x16\xF2\x29\x48\xF2\xA1\xBA\xF2\xAB\x4C\xF2\xA1\xB1\xF1\x12\xB2",
"\xEF\x1F\xB5\xEF\x2E\xF1\xF2\x4A\x13\xF3\x25\xF3\xEF\x54\x29\x55\x4D\x33\x2A\x38\xFA\x36\x5A\x5A\x14\x23\x1D\xF3\x0A\xF6\xEF\x93\xE1\xBA\x1F\x51\xBA\xD5\xEF\x53\x3F\x61\x54\xEE\x49\x2A\x24\x2B\xED\x4A\x5D\xED\x06\xF0\xEE\x94\xE3\xF5\xE5\xE4\x12\x02\xF7\x3F\x04\xF0\x00\x2E\xFE\xEE\x16\x69\xF0\xF2\xE9\xF5\x55\xF4\xF5\x13\xFA\xEF\x63\xF3\xF5\xFE\xE0\x12\x0E\xF3\xF7\x03\xFD\xF2\x06\xFE\xF6\x1E\x30\xF7\x93\xEC\xF0\x10\x2B\xF7\x10\xF6\xF0\xF9\xEF\xE8\x15\xF4\xB4\x19\xE6\xF0\x19\xFF\x58\x17\x1C\xF1\x53\xFF\xF1\x06\xF4\xF4\x20\x16\xF4\x55\x16\xF3\xCF\x2D\xF4\x3A\xFC\x7F\x29\x41\xF5\x6C\xF3\xF5\x30\xF5\xF9\x32\xFE\xB9\x99\xFF\x43\x9C\xFB\x8F\x3F\x40\xFA\x3E\xF3\xF5\x41\xFE\xF7\xA1\xB6\xF9\x69\x14\xF2\xA7\xF2\xF7\x4A\xFC\x74\x8E\xF6\xF0\x38\x5B\xF4\x50\xF6\xF0\x11\xFC\xBB\x2B\xB5\xEF\x57\xF8\xF4\x9C\x1D\x9C\x3D\x62\xEC\x4A\x54\xED\xCF\xE3\xEB\x00\x0D\xC7\xEB\x02\x10\x60\xF2\xEB\x62\xFC\xEF\x65\xF2\xEF\x67\xF3\x12\x69\xF8\x64\x6B\xFD\xF6\x5D\x52\xF8\xBC\xB2\xF7\x87\xF5\xF7\x72\xE7\xF7\xFD\xE0\x2A\xFF\xEE\xDF\x7C\xFA\xF6\xB0\xF7\xF0\xEF\xE3\xCF\x53\xF4\xF8\x7C\xB8\xFE\xE1\xF2\xF1\xF4\xF6\xF1\xB9\xF1\xBA\x90\xF4\xF1\x06\xFD\xF1\x93\xE4\xF9\xB1\xF5\xFA\xB4\x7D\xE6\x68\x7C\x68\x69\xF3\x2A\x7C\xCF\x61\x7D\xF2\x73\xF4\x7F\x7E\x91\x76\xFA\x02\x80\x11\x29\x7D\x11\x4F\x00\xAD\x7C\xA0\x73\xF7\x43\x78\x00\x94\x79\xF6\x1E\xF6\x4B\x3A\x08\x1D\xF4\x3B\x7C\xEE\x6C\x7D\x53\x79\xF8\x46\x79\xE1\x72\xF7\x5E\x4C\xF2\x72\x75\xCA\x7B\xD8\x73\x57\x51\x69\xED\x01\x09\xF4\x60\x76\x04\x85\xFA\x72\x80\x72\x7B\xFC\x59\x7F\x42\x1B\x7E\x7F\x7D\xFB\x6E\x7F\xB8\x75\x03\xBE\x7C\xE2\x66\x78\xFB\x73\x06\x98\x1F\xC2\x72\xFF\x06\x79\xDF\x65\x78\xED\x72\x07\xB1\x77\xC1\x76\xFE\x7A\x79\x11\x92\x7A\xE2\x79\xF1\x76\x7F\xA6\x79\xFF\x12\x7E\xC7\x73\x7B\xB2\x78\xF3\x4E\x81\x93\x71\x03\x9D\x7F\xD1\x09\x34\xA0\x7E\xE5\x7C\x5D\xD1\x7C\xEC\x59\x81\x03\x96\x1F\x0F\x85\x0B\x86\x80\x30\x8E\x03\xA1\x5F\xCF\x73\x74\xAF\x78\x09\xBB\x60\x06\x81\x00\x99\x83\xF2\x77\x7D\x1C\x81\x06\x9E\x80\x9D\x2D\x06\x93\x76\x08\x96\x7A\x24\x08\xEB\x4B\x7E\xEF\x4E\xF5\x4D\x74\xF1\x64\x09\xD3\x7A\x06\xA4\x7A\x1A\x83\xEC\x36\x83\xDC\x2B\x7F\x80\x7F\x28\x1E\x7F\x43\x88\xFD\x7D\x81\xE2\x61\x82\x8B\x83\x08\xB1\x7F\x97\x1F\xF0\x46\x82\xFA\x72\x83\x91\x86\xE0\x4B\x83\x85\x7D\x04\xF3\x18\x27\x93\x7B\x11\x79\xF1\x52\x82\xC6\x76\x13\x54\x81\xFC\x36\x82\xFD\x7B\xD2\x65\x83\x0B\x87\xF4\x69\x81\xC6\x7E\x82\xAB\x7B\xFD\x63\x82\x2C\x84\x0B\xA7\x7E\x2D\x89\x79\x6B\x87\xF3\x7D\x83\x37\x8C\xBB\x71\x80\x02\x93\x83\x45\x7F\x0C\xB9\x18\x0D\x84\x74\x4C\x7A\x1E\x9B\x80\xA3\x10\x04\xB2\x77\x3F\x85\x52\x02\x87\xB0\x66\x81\xD2\x74\x29\x29\x80\xA5\x23\xAF\x06\x65\x0B\x86\x84\x72\x79\x11\xA4\x7B\x4C\x87\xFD\x69\x7E\xF6\x70\x84\x4A\x83\xEA\x60\x7E\x4B\x80\x04\xE4\x7F\xA4\x79\x7B\xA6\x87\xF3\x26\x87\x1B\x88\x0E\x88\x7B\x0E\x8C\x82\xF0\x37\xFC\x67\x85\xF9\x7A\x0A\x86\x7B\x14\x91\x81\x55\x80\xD1\x57\x83\x98\x74\x07\x98\x82\xE6\x69\x1A\x10\x83\xE5\x6C\x82\x39\x8B\x0B\x84\x89\x32\x95\x83\x07\x89\x24\x09\x89\x9D\x7B\x10\xF4\x78\x00\x04\x86\xA1\x7C\x77\x4C\x76\x0B\x85\x10\xC7\x78\x33\x8D\x2A\x79\x81\xE3\x7B\x83\x68\x8D\x07\xC0\x7F\xDC\x64\x81\x83\x86\xF8\x5D\x7A\xB1\x30\x0E\xCB\x7E\x38\x8E\x87\x8C\x82\xA9\x0E\x84\x75\x77\x0C\xA1\x87\x24\x8B\x87\x50\x84\xFE\x58\x84\xBC\x75\x0A\x86\x7E\x27\x87\x87\xA0\x81\x1D\xB2\x76\xF8\x7A\x0F\xF2\x84\x3F\x9F\x81\xA1\x5F\x1F\x8F\x7D\x57\x82\x10\xB1\x86\x43\x97\x7C\xCA\x83\x00\xB7\x85\x60\x8F\x2C\x61\x82\xE8\x7C\x85\x1D\x8E\x17\x9C\x83\xA9\x81\x01\x95\x8B\x04\x90\x83\x73\x7C\xA2\x5C\x89\x87\x86\x10\x94\x86\xD2\x2D\x86\x4A\x0D\x03\x90\x87\xDE\x79\x13\xA6\x8A\xF0\x61\x84\x66\x8E\x3B\x5B\x20\x33\x80\x11\xBF\x21\x7B\x5D\x85\x5B\x81\x85\x17\x76\x00\x0C\x0C\x14\x25\x98\x54\x8B\x65\x8C\x88\x09\x84\xDE\x55\x07\xA2\x0F\x5B\x80\x7D\x21\x43\x97\x16\x4A\x13\x49\x68\x4C\x77\x11\x87\x86\x01\x8B\x14\x8A\x3D\xCF\x56\x18\xBE\x81\x21\x9F\x8B\x78\x88\x0D\x89\x35\xC1\x83\x04\x87\x8E\xC1\x69\x8C\x76\x6C\x74\x0C\x8D\x14\x2E\x18\x9F\x84\x64\x8C\x8A\x92\x8C\xF0\x47\x7D\xCB\x88\x0C\xD0\x89\x5D\x82\x8C\x31\x84\x77\x53\x5C\xFD\x0E\x19\xA1\x5C\x68\x96\x1D\xA2\x89\x28\x4D\x8D\x9F\x84\x0F\xF2\x81\x64\x93\x7A\xE6\x12\x35\x96\x8C\x96\x88",
"\x19\xD9\x89\x5E\x8F\x16\x9C\x8C\x75\x4B\x0E\xD7\x25\x1B\x94\x3C\x03\x4E\x45\xB9\x8F\xA0\x24\x8C\xDE\x8F\x08\xBE\x8C\x6A\x93\x7A\x9D\x0D\x75\x4C\x8F\xE1\x8F\xF5\x2D\x8F\xEC\x61\x8C\x9B\x89\x36\x8B\x46\x84\x36\x2F\x4D\x8F\x6D\x90\x8E\x29\x0B\x34\x8F\x17\xD2\x80\x14\xA7\x8D\xE2\x33\x84\xF0\x43\x77\x5C\x8E\x43\x80\x18\xB5\x85\x78\x99\x78\x34\x84\x7A\x0A\x0A\xF3\x80\x1D\x21\x8D\x7A\x9A\x8D\xD3\x88\xDD\x66\x8C\x97\x7F\x1B\xBC\x82\x7E\x80\x09\xAB\x8C\x38\x9E\x8E\x2D\x8A\x19\xA9\x20\x67\x8F\x5E\xE7\x2F\x24\xB0\x8B\xF3\x83\x37\x51\x8F\x0F\x2C\x8F\xBD\x8E\x3D\xAA\x1B\x49\x8D\x89\x11\x91\x82\x9D\x8E\xF5\x8A\x2B\x8E\x90\xF1\x80\x0F\xBE\x88\x20\x88\x8C\xFD\x88\x37\xBF\x8E\xE9\x8B\x1E\xD4\x8C\x4D\x84\x90\xD7\x8B\x28\xBD\x89\x27\x84\xF5\x2C\x8D\x88\x87\x8E\x49\x19\x11\x8A\x8A\x83\x71\x10\xC3\x7D\x2D\x48\x37\x13\x29\x77\x04\x22\x8A\x66\x23\x99\x8D\x44\x97\x08\x9C\x8C\x95\x7B\x13\x7A\x7B\xE6\x73\x78\xFF\x77\x91\x0D\x93\xF3\x71\x81\xDD\x29\x7B\x43\x0E\x55\x89\x80\x58\x8C\x2C\xB6\x8F\x9B\x73\x25\xB8\x3C\xE0\x23\x86\x53\x79\x69\x4C\x92\x68\x6F\x14\xDF\x8F\x96\x92\x92\x19\x7C\xD1\x3A\x10\x85\x07\x22\x86\x78\x9F\x3D\x31\x43\x90\x00\x05\x92\xE3\x81\x25\xB9\x92\x78\x9E\x68\x2C\x25\x4C\x8C\x91\x23\x97\xFF\x69\x4C\x3D\x51\x7C\x93\x74\x60\x75\x77\x27\x96\x24\xD2\x89\x0E\x8C\x2B\x06\x78\x23\x92\x59\xE6\x88\x72\x32\x39\x80\x84\x49\xD5\x8F\x18\xBB\x39\xFB\x16\x45\x3F\x38\x92\x35\x09\x93\x87\x47\x8D\x08\xE5\x89\x11\x58\x48\x2A\x92\x93\x0A\x90\x4A\xBC\x92\xCE\x8B\xAC\x7E\x7F\xCD\x08\x08\x8D\x7E\x15\xAF\x8F\x6A\x8B\x93\x50\x6E\x04\x3A\x11\x3F\x4F\xC2\x31\x93\x39\x9A\x25\xA2\x90\x72\x91\x81\xA2\x96\x50\xA1\x5D\x02\x42\x26\x57\x82\xA9\x9B\x91\xF8\x7C\x29\xA8\x88\x7D\x2C\x22\xC9\x18\x91\x81\x95\x85\x90\x36\x99\x79\x5C\x9F\x0B\xA1\x5F\x17\x4B\x0E\x80\x94\x77\x42\x95\xFD\x74\xFA\x74\x90\x9F\x8D\x7A\x2D\x38\x53\x97\x89\xA9\x7B\x28\xA3\x80\x5C\x8D\x94\x17\x96\x45\xB8\x80\x01\x9C\x73\x09\x3A\xA5\x99\x42\x93\x84\x63\x25\x97\x8C\x31\xF0\x73\x8D\x71\x95\x95\x38\x91\x24\x09\x84\x66\x9B\x15\x86\x78\x55\x68\x49\xAE\x7B\xEE\x6E\x8A\x6F\x90\xFA\x0D\x13\x94\x2D\x2D\x57\x23\x56\x88\x96\x6B\x9F\x43\x73\x95\xB2\x95\x97\xA1\x5F\x5E\x99\x36\x79\x75\xAA\x4D\x8E\xD0\x1A\x11\xCD\x39\x60\xBB\x8C\x5A\x9E\x1A\xE0\x8F\x88\x8B\x96\x07\x9C\x4B\x99\x78\x85\x97\x56\x72\x74\xA7\x6D\x93\xA1\x5B\x14\x54\x3C\xAC\x59\x0F\xA6\x1F\xC4\x83\x98\xF0\x95\x4E\xB2\x96\x5C\x99\x31\xE8\x92\xBD\x91\x3E\xBD\x93\xD2\x56\x74\x7E\x96\xF0\x65\x45\x40\x27\x0A\xE8\x45\x14\x82\x98\x10\x9D\x32\xF6\x90\x7E\x95\x0A\x68\x5A\x6D\x52\x90\x14\x9F\x1C\x95\x93\x8A\x81\x97\x02\x95\x3D\xB0\x91\x55\x92\x19\xF4\x3D\xDA\x49\x2F\x0A\x0F\x43\xB4\x8F\x9E\x9B\x32\xBF\x9B\xD5\x51\x09\x47\x0C\x3F\x85\x9B\xC5\x80\x20\xAD\x91\xD2\x99\x90\x4B\x9B\x43\xB7\x86\xDE\x58\x2B\x58\x59\xD6\x9E\x81\x73\x8C\x6A\x97\x09\xBB\x84\x30\xC4\x23\xBC\x5D\x63\x6F\x26\x05\x8B\x91\xA8\x8A\x2C\xD3\x7A\x92\x96\x0A\x1A\x8B\xEA\x7A\x59\x41\x95\x2D\xA9\x9B\xB5\x9D\x92\x52\x35\x4A\xA1\x26\x5D\x86\xC3\x59\x91\xC5\x87\x93\x08\x88\x70\x82\x35\x2F\x99\x13\x98\x8A\x98\x93\x7C\x86\x9E\x4C\xB6\x95\xC4\x99\x26\x86\x0C\x5E\x60\x99\x8A\x39\xF8\x2E\x26\x22\x29\x36\xED\x99\xA2\x2C\x9B\x7E\x9F\x87\x33\x57\x5D\x65\x13\x72\x98\xBD\x97\x98\x66\x78\x39\x39\x92\xFD\x7B\x00\xA1\x9D\xB3\x9E\x93\xD0\x93\xEA\x53\x96\x58\x87\x3A\xAE\x99\x12\x88\x94\x6E\x84\x5B\x83\x9A\x83\x70\x2E\xE9\x83\x63\x8E\x79\x93\x90\xC9\x15\x94\x58\x98\x2E\xE3\x99\xEF\x08\x0B\x9C\x92\x47\x35\x09\xC3\x7D\x39\xAE\x9D\xA2\x33\x14\xB5\x99\x69\x3B\x8B\x32\x68\xC9\x26\x9E\xDA\x8B\x53\xE2\x8D\x54\xB2\x84\x7F\x8C\x0A\x97\x78\x40\x82\x96\x70\x8F\x81\x02\x20\x02\x24\x3C\x95\x22\x7A\x89\x1A\xCD\x9F\x70\x93\x9D\x90\x00\x3D\xD7\x9F\x5E\x92\x63\xF2\x5B\x6A\x9E\x9C\xD4\x92\xEF\x7B\x98\xEB\x97\x72\xD1\x9A\x22\x93\x75\xC7\x97\x02\xD3\x75\x36\x96\x76\x00\x00\x93\x4F\x7E\xB9\x91\x0E\xB1\x83\x38\x89\x9D\x8D\x82\x5C\xB5\x87\xF6\x72\x19\xB8\x8A\x45\x97\x84\x30\x8A\x13\x85\x8B\xDC\x13\x13\xE3\x94\xFB\x6F\x7B\xC6\x9C\x28\x8E\x83\x7D\x8C\x0E\xE2\x7C\xB0\x9A\x78\xFA\x9C\xFF\x7C\x5C\x53\x99\x3F\x80\x94\x57\x8A\x88\xC2\x84\x21\x85\x9C\x3D\x94\x37\x88\x99\xD3\x1D\x8A\x29\xA6\x22\x98\x88\x63\x83\x16\xEA\x9E\x00\x9F\x88\x4F\x78\x24\x2A",
"\x8A\xB4\x8B\xD9\x6D\x88\xD5\x6D\x8E\x25\x82\x25\xB3\x12\x8A\x6A\x3A\x39\x94\x0E\xBC\x7D\x20\x0D\x3F\x06\xA3\x3B\x8B\x16\xA0\x0B\x5E\x9F\x54\xD6\x9C\x60\x87\xA2\xDC\x7C\x19\xEF\x31\x4C\x0F\x08\x79\x99\x74\x6F\x92\x77\x2D\xF4\x5A\x38\x17\x5C\xA2\xAC\x93\x8A\xB9\x83\xDF\x99\x03\xF6\x86\x64\x83\x23\xE4\x6F\x53\x9D\x26\xCE\x36\x18\x2B\x3D\x48\x08\x2A\x6C\xA5\xBF\x67\x85\xBD\x84\x15\x72\x99\x1C\xA4\x09\x6E\xA0\x49\xA2\x8F\xFC\x7D\x32\x45\x83\xE2\x68\x95\xAD\x87\x7B\xAB\x95\x62\x85\x01\xFD\x9A\x0D\xB6\x1F\xDE\x4D\x8B\x82\xA2\x05\x12\x0D\xFE\x83\xEE\x89\x8A\xF1\x3D\x8F\xA7\x84\xEF\x48\x9E\x5B\xA3\x9C\x05\x26\x96\xA2\x41\x3B\x8A\x0F\x0A\xED\x19\x9C\x8F\x2E\x27\x49\x97\xCA\x19\xA2\x45\x8C\x3D\x80\xA6\xF7\x8B\x8A\x83\xA5\xEC\x55\xA1\xF5\x7A\x4B\x45\x33\x83\x17\x94\xA2\x83\xEA\x77\xA3\xB3\x99\x13\x90\xA0\xF5\x6D\x92\xAB\xA2\x0E\xAD\xA5\x94\x06\x64\x40\x39\x2C\xB2\x77\x08\x09\x23\x2E\xA4\x04\x7F\xDE\x1F\x95\x14\x94\x96\x5A\xA7\xD0\x28\x30\x2F\x97\x56\x23\x19\xC0\x1D\x98\x8A\x9F\xB0\x3A\x3C\x15\xAA\x00\x9E\xA4\x93\x2A\x10\x29\x32\x70\x8A\x08\x67\xAC\x78\x43\x0D\xD3\x74\x92\x8C\x9A\x86\xA1\x92\x7D\x94\x26\x86\xA6\xE4\x91\x97\x26\xA6\xE0\x6C\x69\x5F\x43\x00\xE4\x7B\x32\x28\x09\xCD\x25\x4F\x96\xA2\x7C\x96\xF7\x72\x75\xB8\x55\x77\x89\x7B\xF8\x59\xA4\xE4\x04\x49\xE3\x4C\x15\x2B\x4F\x2C\x8A\x3B\x64\x4E\x76\x97\x11\x7B\x89\xE9\x86\x84\xDB\x4C\xA0\x98\x9E\xAB\x99\x2B\x23\xA7\x07\xA1\x88\x22\xA5\x9C\xAD\x9D\x43\xAF\x37\x99\x7B\x2D\x69\x94\x53\x7B\x4C\x6C\xA1\xBA\x80\x45\x4D\x78\x85\x3E\x47\x0A\x16\x9E\x8F\xA4\x87\x3F\x4F\x8A\xA8\x36\x81\x08\xC0\x2B\x38\x23\x2D\x94\xAB\x10\x7B\x8B\xC7\x52\x9B\x2C\xAA\x21\x1C\x8D\xEC\x64\x1B\xF7\x9F\x43\xAC\x8A\xB8\xA0\x99\xB3\x9B\xD7\x8E\x42\xE0\xA5\x6F\x24\x9C\xD5\xA5\x84\xBD\x92\x9F\xAD\x7D\x0D\x9F\x38\xA3\x93\xF7\xA4\x66\xA1\x5D\x98\xAA\x85\x52\x28\x11\x5C\x4B\xCE\x88\x26\x6D\x41\x0A\x15\x4C\x4C\x40\x84\x17\x31\x7B\x8B\x13\x10\x7F\xA8\xA5\x9C\x59\x40\x67\x8F\x6E\x1E\x0E\xA1\x9D\x9F\x3E\x91\x10\xA3\xA1\xE4\x9B\x93\xBA\x92\x31\x7A\x9E\x42\xA5\xEF\x1F\xA2\x0C\x48\x42\xCE\x81\xA2\x95\xA7\x0F\xA7\x84\x25\x1C\x46\xB0\x85\x66\xAD\xAD\xA3\xAB\xA6\x7F\x2C\xE1\x40\x69\x33\x3C\x36\x4E\x0C\x6C\x93\x6D\x93\x0D\xA3\xAA\x55\xB3\xAA\x4F\x43\xEB\x43\x2E\xEC\x2F\x3F\xA3\x0B\x36\x92\x75\xF3\x57\x91\x5F\x87\x17\x8C\x14\x2F\x8B\x2D\xBB\x42\x32\x8A\x81\x81\x8A\x33\xAA\x0E\xBD\x81\x2D\xAD\x87\x97\xAD\x44\xB4\x90\x32\xA9\x04\x9C\xAE\x8C\x85\x99\xF1\x84\x82\x9D\xA1\xFA\x7B\x57\x82\xA6\xD8\x91\xA8\x24\xA7\x7A\x93\x88\xCF\x75\x15\xF7\x9E\x18\x8B\xA1\xE6\xA0\xAD\xAF\x9C\x5C\x82\x01\xF7\xA8\x58\x82\x7A\xB9\xA9\x2A\xA2\xA2\x67\x82\x12\xCD\xA0\x5C\x9F\x7D\x3F\xA2\xA9\xB1\x8B\x45\xA8\x1C\x2C\x8D\x01\xB9\x78\x07\xA6\xFA\x5E\xAC\x48\x9F\x22\xE5\xA0\x03\xBD\xAC\x09\xA7\xB3\xB5\xA6\x21\x82\x5A\x9C\xA3\xD7\x91\x94\xDC\x7E\xB4\xB8\x86\xBB\xA6\x22\x8F\xA0\x52\x87\x95\xF7\x6C\xAC\x8C\x8A\xD8\xA7\x56\xAD\xA2\xC6\x80\x86\x30\xA5\xB6\xA1\x5C\xB1\x87\x15\x9B\xAA\xC5\x96\x9D\x2F\xA0\x85\xB2\xAE\x71\xA4\x01\xC0\xAF\x44\xA7\xA7\x76\x83\xD8\x78\x82\xE2\xAA\xFB\x46\xAD\x23\xBB\x97\x98\x99\x88\x8A\xAD\xD2\x3A\x20\x2D\x5B\x8B\x3A\x9C\x73\x11\x9B\x99\x36\x6E\xA9\x6D\x4B\x5B\x3E\xB2\x31\x81\x9B\xC2\x8B\x3D\x6C\x3D\x0D\x94\x12\xDC\x97\xB0\x29\x0A\xC2\x8D\xA7\x0D\xB7\x56\x3A\x91\x6B\xA8\xA5\x62\x99\xAF\x81\xAE\x9E\xAF\x5E\xA1\x5F\x45\xB8\x9C\x20\xB1\x23\x22\xB0\x31\x14\xD1\x68\x4F\x61\xA1\x42\x54\xAE\x0A\x60\x09\xAE\xA8\x55\x80\x03\x23\x7A\xAA\x72\x9F\xC6\xB8\x41\x9A\x0F\x55\xD7\x41\x58\xA5\xA5\xE9\xAA\x55\xA9\xB0\x89\xAB\x53\xF7\xAC\xE5\x86\x78\x17\xAC\xD9\x6C\xAA\x24\xB9\x2A\xB1\x83\x5B\xB6\xAB\x78\xA8\xB7\x90\xA4\x53\xA2\x4F\x8D\x39\xF6\x19\x9D\x59\xB7\x57\xA7\xB0\x83\x7D\x57\xA1\x0A\x18\x40\xAC\xFB\x22\xB0\xBE\xAC\x04\xBC\x2A\xC2\xB1\x16\x5D\xA7\x02\xAD\xA4\xAE\x5D\x80\xA4\x52\xEA\x4E\x42\xB3\x57\x98\x67\xA0\xA1\x53\x84\xA3\x67\x9C\x8E\x41\x7A\xAB\x5C\xB2\xC9\x9B\x79\xA6\x8A\x62\xFF\xAE\x6E\xAE\xA1\x2F\xB3\x5B\x92\xB2\xF7\x76\x5F\xC7\x79\x47\xB1\x81\x1F\xAE\x32\x4E\x0A\x91\xAD\x1C\xFC\xB2\x6B\x3E\x4E\x36\x19\x57\x88\x4B\x1D\x2A\x69\xFE\x4D\x4B\xA0\x00\x86\x63\x94\x75\x05\xAD\xAD\x69\xFB\x4E\x98\x1C\x8C\x34\x4B\x4C\xB6\x9F\x2C\xBF\x67\xD4\xB1\x20\xA8\xB1\x83",
"\xB5\xD0\x8D\xB2\xC4\x9A\x3F\x96\xAB\x6E\x92\x77\x1A\xAE\xB7\xB9\x95\x47\xBB\x31\xF3\x36\xBC\x6F\x9C\xA1\x5F\x9D\x96\x0A\xAC\x0D\xF4\x42\x62\xB4\x33\x29\xD4\x31\xCB\x94\x6B\x55\x25\xEF\x42\xB5\x3C\xAD\x7A\x4E\x60\xD8\x08\xB7\xF7\x20\x66\xAC\x97\xAE\x3E\xB4\x0A\x0D\x92\x8A\xA6\xA7\x08\x49\xDB\xB5\x4A\x13\x57\xC5\x64\x93\x9F\xB0\x6F\xB9\x11\x21\xA5\xF0\x35\x77\xD1\xA8\xBD\x95\xB2\x58\xBB\x56\xAA\xA6\x66\xA7\x86\xBB\xA1\x23\x3D\xA4\x58\xA3\x09\xB3\xA6\x31\xBA\x89\x11\xA3\xD5\x94\xAE\x0B\xA1\x6F\x95\x13\x91\x25\x9E\x92\x89\x98\x88\x0F\x5E\xAD\xBA\x15\x86\x76\xB4\x7F\xFC\x79\xC6\x84\x5B\x0C\xB3\x62\xFF\x38\x34\xB9\x78\x44\xAC\xD0\x14\xA7\xB9\x7A\x70\xB3\xB1\xA4\x14\xB0\x0F\xBE\x5B\x8C\xB9\xA2\xAC\x5F\xFB\x9C\x39\xB1\xAD\xF3\x98\xBF\xAB\xA6\xA5\x09\x11\x71\x90\xF5\x6E\xB6\x69\x0D\xE9\x73\xA7\x85\x93\xFE\x14\xB7\x79\xBA\xA7\xE4\xB5\xA9\x9B\x3B\x27\x38\x57\x4C\xAB\x4A\xA2\x3F\xFA\x09\xB2\x80\x00\x7C\x0B\x55\xCC\xAB\x4C\xB8\xB9\xC3\x08\xD0\x89\xB2\xD7\xA1\x6B\xEE\xB4\xED\x92\xAD\xD1\xA3\xCA\x16\x92\xDB\xA5\x5F\xAB\xB2\x93\xB5\xB5\x1A\xBB\x71\xBF\xA8\xA3\xAF\x6B\xE4\xA5\x52\xB8\x9C\x4C\xAC\x10\x8A\x90\x9F\xB2\x1E\xB4\xA9\xD0\xAE\xB5\xA7\xA4\x47\xB8\xA8\xA3\xBD\x14\xC2\xAB\x37\xAC\xA6\x1C\xBC\xBE\x98\x93\x46\xBB\x3E\xE9\xA4\x20\x9B\xB8\x12\xBD\xE3\xBC\x5C\x60\xB3\xE9\x57\xB8\xAB\x99\xBA\xCC\xAE\x29\x29\x9E\x00\xBC\x27\xA0\x9C\x45\xA2\x9D\xA0\xB6\xFD\x51\xA2\xE7\x94\x3F\xB3\xB5\xDB\xBD\x93\x1C\x9C\xC6\x93\x7B\x8F\x9C\x2A\xA2\x99\xCE\x88\xAD\x9C\x9F\x8C\x17\x9E\xBF\xBC\x77\x80\xBF\x23\x74\x68\x83\xBF\xEF\xB5\x9A\x43\xBE\x5E\xF8\xAD\xE2\xB1\x14\x8B\xB3\x66\x98\x9C\x9B\x99\x22\x8F\xBE\x5D\xB1\xBC\x01\x0A\xA8\x94\xBD\x43\xBA\x17\x81\xA0\x00\x1E\x66\xF2\x9C\xF0\xB7\x94\x8C\x91\x72\xCF\xB1\xC2\x90\x99\xA0\xBB\xEA\x4D\x98\xE5\xAF\x30\xD9\x26\x42\xA8\xBD\x86\xB8\x9D\x89\x4A\xC9\xB5\x7B\xA1\x0B\x0A\x84\x5A\x99\xBD\xF2\x9B\xBD\xE0\xBA\x32\xEE\xB8\x4E\x7E\x4A\xF7\x9B\xCA\x85\xAD\xE6\x8E\x2F\xB9\x3C\xC0\x93\x10\xC0\xBA\xF5\x84\xBE\xD9\xB2\x3D\x80\x02\x2B\x71\x03\xA4\xB7\x7A\x86\x99\xE2\xBE\x7C\xE5\xB3\x45\x0B\xB4\xB3\x9D\xEC\x88\xBB\x8C\x79\x2D\xEB\xB3\xB6\x8C\x94\x31\x3B\x00\xA4\xAC\xFB\x1B\x2E\xCD\x1B\xB9\x97\x31\xE9\x92\x3D\x7D\x39\x2B\x2C\x3C\xDB\xBE\xE6\xBF\x9C\xFE\xBA\xF9\x89\x34\x70\xB8\x45\x49\xBC\xEB\xB3\xBD\x4E\xBC\xD6\x8E\xBE\x5E\x99\x7B\xBE\x97\xDC\x77\xA9\xAB\x93\x58\x8F\x29\xEC\xB7\x3D\xED\x9C\xF9\xAC\x7E\x72\x63\x94\x7A\xB2\xE6\xB3\x2A\xF7\x92\xEA\x8B\x08\x6C\xBA\xF8\xBC\xAB\x92\x37\x7E\xB2\x9E\x93\x89\xC0\x87\xB8\x5B\xA1\x08\x6D\x9A\x28\xA3\xA9\xEF\x9C\x82\xF3\xB9\x78\xAB\x0A\x67\x66\x40\x00\xBB\xD4\x7A\x94\x1E\x1E\x29\x1E\x95\xFE\xB9\x7A\x95\xC1\x00\xC7\xC0\xDD\xBA\x8E\x7B\x65\xF8\x9F\x2E\xFF\xBD\xE1\xB9\xA9\xA1\x5B\x51\x42\xAB\x45\xBF\x38\xFB\xB8\x10\xC1\x09\x9C\xB6\x7D\xAB\x1C\x5B\x7E\x61\x16\x32\xCD\x1D\x75\x1C\xC5\x60\x86\x78\x8A\x6E\x84\x9D\xBD\xD2\x16\xC0\xDC\xBE\xF8\x80\x00\x39\x65\xCC\x10\x01\x27\xA2\xAA\xE6\xB4\xC7\x2A\xB5\x13\xCC\x79\xAC\xB0\x7E\xB1\xB8\xBA\x3B\x23\x8D\xBB\x36\xCF\x74\xCE\xBC\x1C\xCB\xBA\x54\xBE\xE3\xA3\x92\x90\xB1\x86\xCE\xBE\x9A\x94\x0A\x83\xA8\xE6\x90\xB0\x44\x39\x42\x14\x9A\x00\xC7\xC2\x73\x1F\xDC\xBA\x9A\x36\xC9\x85\xAF\x9F\x1D\xC3\x9C\xF3\xAF\x18\x8D\x88\x14\xC2\x82\xC9\xBA\x36\xA7\xAE\xEE\xBC\xEE\xB2\xB4\xB3\xB1\x03\xFF\xC3\x42\x10\xB1\x31\xBC\x02\xD7\xC0\x30\xC6\x84\xCF\x17\xDB\x83\xC3\x00\x04\x1D\x21\xBF\x0B\xC3\x7E\xFD\xC1\x9F\x86\xBF\x26\xC4\x6F\xB4\xC2\x05\xCD\x27\xED\xBD\xEE\x8B\xB4\xDD\x90\x73\xAF\xC0\x2E\x91\x83\xFA\xBE\xB9\x84\x9E\xF8\xBE\x78\xAA\x96\x4A\x93\x67\xD2\x99\x11\xC7\xC4\x08\xC2\xBA\xB0\x2B\xF6\xAE\x86\xB6\xBC\xEC\x9B\x2B\xF2\x71\xFD\x84\x95\x0B\xCA\x82\xB8\x9E\xA2\xBA\x9D\xF0\xB8\xE7\x3E\x9D\x01\x9E\x09\xF5\xBC\x0D\xDE\xA5\x99\x91\x24\x1B\x94\xE4\x0B\x83\xE8\x9B\x8A\x09\x0A\x7A\x1E\x24\x3F\xB7\x10\x1B\x21\x13\x17\x73\x09\xC7\xAF\xA3\xA3\x1B\x11\x53\xCF\xC8\x38\x05\xCF\xAE\x15\xF0\xC3\x1D\xF1\x09\x0D\x1C\x19\xFB\x61\xCE\x01\xC1\xCD\xBD\x4F\x91\xB3\x7C\xBC\x88\xBB\xB6\xAF\xB6\xC4\xE1\xA7\xB6\x81\xAB\x42\x9C\x6B\xD1\xBA\x34\xB8\xC3\x72\xBF\xD1\x75\x77\x20\x82\x7D\xC7\x86\xC2\xB0\xB6\x31\xBF\xC0\x89\xAE\xF1\x73\xFC\x32\x3D\x40\xD0\x22\x1B\x27\x1D\xEA\x4E\x7D\xC6\x12\x6D\xC7\x39",
"\xD7\x0B\xF9\xC7\x7E\x25\xC8\x31\xC8\xC9\x45\x67\x2D\x0E\x0F\x61\x52\x24\xC8\x38\x92\xC8\x73\xC9\x8D\xC3\x25\x30\x6B\xC0\x20\xF9\x19\x86\xC1\xBA\x7A\x8E\x85\x27\x2D\x47\xAA\xB9\x9D\x2D\x02\x3C\x54\xD0\x23\xB1\x9D\x8E\x32\xC9\x26\x34\xC8\x7E\xC2\x1E\x97\xA9\x4E\xD4\xC4\xF6\x1C\x27\xF3\x4B\xF3\x3D\x36\x55\xB9\x73\x99\x4C\x90\x48\x31\x48\x0E\xA3\xC0\x2A\xC8\xC8\x3E\xC3\xC9\x2A\xCD\x26\xD9\x9E\x26\xB0\x81\xE2\x9B\xF0\x62\x9F\x31\x4C\x7C\xB5\xC0\xF3\x9B\x4F\x34\x4F\x51\xC6\x84\x49\xCA\x1D\xE1\xCA\xA6\xCF\x33\xF1\x67\x7E\x31\x08\x4F\xCB\x16\xE7\x7C\xA9\xCE\x75\x9F\xC7\xCB\x6C\xC6\x65\x8A\x2A\xF7\x9B\x3E\x39\x11\x56\xCA\x72\xA8\x08\x48\x44\x28\xC0\xBB\x81\x3A\x95\xCE\x0B\x5B\xD1\xC9\x5F\xCB\x26\xF3\xCB\xAA\x96\xF0\x71\xC9\x3C\xCC\xC7\x50\xBF\xF6\xAD\x46\xFD\x04\xFD\x19\x84\xE9\x19\xA5\xC7\x84\x3E\x2C\x21\x49\x87\x6E\x47\x8B\x76\xB9\x84\xC2\xA0\x04\xFC\x89\x8C\x00\x9A\xAE\x7A\x68\xDE\xCB\x92\x8B\x60\x2A\x61\xD2\xCB\x5A\x89\x7E\x41\xD4\x4D\x4D\x7F\x19\x57\x22\xC2\xCA\x5C\xC8\x46\x42\x12\x4D\xE0\x43\xDE\x0F\xCC\x52\x19\x92\xC8\x33\x4A\xDA\xA3\x19\x7E\x32\xCB\xCB\xCC\xC3\x95\xA0\xA8\x72\x1D\xCC\xEE\x86\x33\xE8\x7B\x77\xBE\x9A\xE3\x44\x69\xC4\x09\x44\x26\x34\xED\xB8\xEE\xA3\x9D\xF2\x75\x6A\xD1\x9A\xD4\xC8\xCA\x96\xCF\x0C\xA4\x12\x32\xCD\x32\x49\x34\xDA\xCE\x36\xEB\xBE\xF1\xCC\x25\xE7\xC9\xA2\x20\xCE\x71\x4F\x20\xF6\xA4\xEE\xC6\x70\x93\x76\x83\x19\x26\x57\xCF\x3D\xE3\x47\xE0\xC8\x9B\xFB\xB7\xFA\x6F\xCD\x83\xA9\x35\xA5\xCF\x86\x14\x15\x5A\xCF\x4E\x85\x7F\xF5\xCC\x77\x5F\xCE\x72\xA7\x9F\xBA\x11\x7E\xC9\x4D\xFB\xC9\x3E\xFD\xCF\xF9\xB0\xA0\xBF\xA4\x13\x83\x09\xE6\xCA\x21\x3D\xBC\x07\xD5\x9B\xFA\x7C\x6B\x8A\xCE\x93\xC8\x39\xD5\xCD\xC8\xCA\x94\xA1\xD0\xE2\xA7\xC8\xBC\x59\x97\x40\xCC\x5A\xC5\x6C\xDC\x83\xF0\x67\x37\xAD\x1D\xE9\x0D\xCD\x94\x03\x9C\xA0\xD2\x71\xC2\xCB\xC9\xCC\x44\xF2\xCB\x1B\xDB\x21\x1E\xAB\x41\xC9\xB7\xE9\xB4\x77\x6A\x43\xD6\xC2\x9E\xC6\x23\x75\xC3\x09\xD9\xCB\xB5\x87\xD1\x77\x8D\x9D\xF6\xCD\x55\x00\xCF\xDF\xAD\xBA\xAE\xB1\xF1\xC2\xA0\x98\xD3\x93\xDF\x21\xE9\xC8\x2A\xD5\xA8\xF6\xC2\x25\xEE\xCC\x84\xC6\x22\xFC\xCB\x46\xC5\xCC\x7C\xB1\x5A\xCD\xD2\x82\xC4\xD0\x23\xA9\x36\x51\xD0\xBD\x42\xA6\xE1\xCF\x94\xC6\xD2\xE4\xCE\x4A\xF5\x60\x03\xD1\x41\xC3\xD3\xD4\x6B\xD0\x63\x95\x41\xC5\xD0\xE5\xAA\xA6\xE0\xD2\x84\xCD\xD3\x51\xD6\x82\x95\xD1\x23\xD7\x33\x2A\x63\x86\xDB\xD3\x07\xB9\x69\x75\xD0\x1D\xD7\x99\xFB\xC4\x65\xCB\xAA\x8C\xD3\x39\xCE\xBF\x48\xB6\x9A\x63\xD0\x90\xD5\xD3\x4D\xD4\x42\xD4\xD3\xF7\x78\x9D\xE8\xCE\x92\xD8\xD4\x09\xD4\xC8\x2A\xCD\x40\xDF\x9F\x9B\xD6\x8C\x96\xD2\x2A\x61\x49\xC9\xD4\x2D\xD9\x56\x89\xB6\x97\xCF\x16\xF0\xCC\x4D\xD4\xCB\x39\x12\xFE\x4B\xD2\x90\xC6\xD3\x29\x0B\x4E\xFC\xD2\xFD\xCE\xA7\xB2\xD6\x73\xD3\xB4\xFE\xCA\x0E\x83\xD5\x38\xDB\x7C\x10\x9B\xBD\xB3\xCF\xD2\xC9\x54\xF8\xD3\x3B\xD8\xA6\x8F\xD0\xAC\xCB\xD3\xA3\x4B\x42\xDC\xC7\x37\xDB\x8C\x04\xD5\x86\xC5\xD6\xF8\xCD\x43\xCB\xD4\x74\xC0\x96\xBC\xD3\xA3\xC4\xCE\xDD\xD2\x1E\xCC\xCE\x4B\x25\xAD\x81\x97\x8A\xDB\xCB\x07\xC9\xE3\x6B\x24\x8F\x62\x09\x93\x75\x2E\xCC\x95\x8E\x22\x37\x55\x10\xAE\xC4\xAA\xF2\x80\x28\x37\xCE\x16\x30\xB3\x06\xC6\x70\xD2\x99\xDE\xD6\x88\xD0\xD4\xDC\xD5\x5F\xE2\xD7\x49\xD8\xA2\xA5\x2A\x4E\xCD\xD5\x2E\xD1\x7C\xB7\x4B\x50\x63\x9B\x6D\xD0\x86\x80\xAF\x06\x78\xB0\x3F\x4B\x0A\x19\x7F\x97\x0A\x44\x7F\x94\x1F\xD1\x52\xE6\xD0\xCE\x87\x51\xAA\xD1\x5E\xCD\xC4\x88\xB4\x0B\xB3\xBB\x34\xD9\x68\x1A\x4D\xA2\x3C\xCA\x19\xD9\x60\xE5\xD0\x7F\xDB\x50\xA3\xD2\xCA\xDB\xD1\x03\xDD\x4F\x8C\xC0\xCE\xC3\xE9\x73\x57\x98\x87\x5B\xF5\x38\xE7\xA3\x93\x8F\x22\x74\xEB\xB6\xD8\xA9\xA5\xFA\xB7\x36\xC0\xD4\x48\xB7\x90\x91\xAA\x53\x07\xD8\x7C\xCB\x31\xCA\x09\x2B\x9F\x97\xC8\xD9\xBA\xCF\x99\x6A\xB5\x91\x8E\x9D\x91\xA4\x7F\x61\x3D\xFB\x2E\xD8\x6E\xD0\x68\xB9\xD9\x0D\x19\x06\x92\x8E\x5D\x14\x0F\xF9\xD6\x63\x15\xDB\xFD\x3D\x09\xD2\x79\xCA\xC8\xC9\xE1\xD0\x33\xFF\xD6\x7E\xDB\xB2\xB1\xD8\x46\xC3\xC4\xCF\xCB\xD2\x7A\xB7\x69\xC1\x3A\xD2\xCB\x23\xCB\xDA\x40\xAF\x5C\xC2\x80\xBB\xD8\x76\xF1\xBB\x57\x83\xD9\x40\xA7\x2A\x6C\x4D\x8C\x0B\xAD\xE8\xDA\xC0\xCA\xDB\x2D\xD8\x60\xC6\xDD\xB6\xD8\xB8\xCD\x7B\xCC\xDE\xA6\x35\xDF\x01\xE3\xB3\x60\x91\x81\xDF\x96\x71\xA8\xD9\x5B\xBA\x63\xEC\xD9\x44\x86\xA3",
"\xEE\xD9\x0C\x8F\xDC\x7E\xCE\xAC\xA2\xB3\x40\xB4\x74\xFA\x9E\x04\xDF\x39\xC1\x20\x6B\xE7\xDA\x8F\x05\x9C\xB1\xD8\xE7\xDA\xDC\x9E\xD9\xE3\x60\xDD\xC1\xAC\xBB\x36\xDB\xD4\x78\xD9\x56\xDD\x5D\xB5\x9E\xBD\xD1\x95\xCF\xDB\xED\xBD\xCF\x46\xD9\x25\x0E\xDB\xFE\xCD\x6B\xD1\xD9\xDE\xC3\xDE\x43\xDD\x78\xDC\xB9\xBF\xD2\x91\xCA\xAF\xD8\xC1\x40\x8E\x42\xD2\xB4\xD1\xAC\xD8\xBB\xE4\xDB\x00\x87\xA3\x25\xD6\x23\x13\x11\xE7\xDC\xCD\x3A\xDD\x8D\x99\xDC\x2F\xDD\x51\xC7\xCF\xC4\xD3\xE9\x4E\x66\x85\x3F\xD8\x42\xDB\x56\xE1\xA8\xA2\xDD\x9F\x80\xDE\x72\xB1\xD7\x16\x30\x73\xDE\xCB\xF0\xD2\xA9\xE4\xDF\x99\xDD\x3D\x07\xDF\x75\x89\xB5\x4C\x83\xB7\xAC\xD4\xDF\xD0\xBB\xD3\xA2\x12\xDA\xB3\x2C\xCF\xBF\xD2\xBB\xF2\xD9\xC4\x73\x7C\x22\xD9\x89\xF5\x77\x91\xB1\x83\x60\xC2\x3E\x25\x8B\x23\xF4\x7F\x8E\xC5\x7C\x1B\x4E\x5B\xDD\xCA\x70\xC8\x76\xC8\xDC\xCE\x84\x43\x86\x7A\x5C\x19\x0D\x4A\x08\xE3\xB1\x98\x88\xBD\xB7\x81\xE0\x72\xB4\x86\x28\x8B\x19\xC1\x2D\x85\x0D\x5E\x42\xCC\x06\xF0\xCC\xF4\xDB\x63\xE2\x8E\x38\x6E\xBD\xC1\xD0\xD9\xB3\xBF\x84\x44\x74\x1D\x44\x44\x41\x9C\x16\xD0\xEF\x56\x0B\xE7\x0D\x98\xA3\xDE\x3A\xD7\x59\xE9\xBC\x0E\xE1\x09\x7C\x41\x25\x3B\xE1\x67\x60\x49\x78\xD4\x66\xA2\xE2\x3A\xDD\x43\xFA\xCB\xBD\xDE\xBB\xBC\x7D\x12\xE3\xD3\x93\xC3\x8A\xFD\xDC\xE2\xDF\x32\x98\xA2\x0D\xF4\xBB\xF3\xBB\x13\x7F\x25\xD6\x56\x61\x4D\xE2\xF1\x80\xE2\x35\x3A\x3A\x1B\x10\x22\xE2\x04\xEF\xD5\x18\xEF\x66\x4B\xE5\x8C\xDC\x4A\x27\xE1\xC4\x87\x0F\x1A\xF2\xE2\x8D\xBC\x11\x72\x40\xF9\xD9\xC1\xB1\xE3\xE6\xD3\xE1\x7A\xE5\x86\xC4\xC8\x22\xD5\x00\xF1\x36\x0E\xF5\x0A\x3C\xE6\x8C\xDE\xDB\xC5\x19\xC6\x8E\xD5\xD9\xC6\xAF\xA7\xC9\x16\xD9\xDB\x1C\xEA\xC4\x88\xE4\x13\xF3\xE3\xE4\xCB\x4F\x34\x46\x35\xEE\xBD\xA9\x87\x79\xA9\xDF\xBF\xD1\x25\x29\x7C\x43\xE2\xCA\xCD\xDA\xFF\xD5\xE2\x62\xE0\x3A\xC6\xCD\x7A\xD7\x0C\xE2\xE1\x1C\xFE\x18\x8A\xE3\xEA\x68\xE3\x4D\xEE\xC8\xC7\xD4\x68\xAD\xE3\xF3\x80\x62\xF7\xBC\x0B\x3F\xCA\x9F\x46\xB6\x82\xD0\x9A\xE3\x39\x1C\xE5\x47\xEE\xC9\x9C\xC8\x5C\x96\x44\x7B\xE6\x85\xEB\xDD\xA8\xA0\xB3\x9B\xE1\x0C\x85\xCB\x83\xB6\x47\xB6\x1D\x5B\x42\x0F\xFC\xE0\x0C\xEB\xDC\xCD\xE5\x96\xC9\x84\x15\x7B\x3A\x2C\x73\x1D\x73\xDC\x20\xA0\x50\x83\x7E\x05\x4A\x81\x47\x0B\x1D\xB6\xE6\x6C\xD9\x9B\xE3\xDE\xCE\x89\x7E\xA0\xE6\xF4\xC3\xD3\x53\x8D\x02\x58\xC6\xE7\xDA\x14\x0B\x40\x67\x6E\x40\xB0\xE3\x70\xDE\xD0\xF0\xD8\xCD\xE2\xDC\x8E\xD3\x7A\x5A\x65\xDE\x55\x39\x3A\xB8\x71\x73\xB2\x08\xF1\x14\x23\xC2\xCE\xAE\x2C\xA6\xD9\xC5\x8D\x42\xAD\x16\xB4\x57\x27\xA0\xF4\xD9\x8C\x76\xD0\x54\x4F\x84\x1A\xC8\x9F\xCB\x11\xC8\xDE\xF5\xD1\xB7\xBD\xB5\xFB\xCD\xDE\x98\x9B\xA0\xE8\xE7\xCE\xDE\xCC\x99\x79\x03\xF9\x78\x0F\xE0\x8C\x82\xC5\x4F\xA3\x27\x5C\xC9\x48\xDA\xE0\xB5\xE6\x1D\xF0\xE9\xF1\xDA\x73\xC5\x67\x1B\x1A\x50\xD7\xE4\x75\xE9\xDA\x6D\xED\x94\x9E\xD7\xEE\xDB\xE8\xA1\xE0\x9E\xEF\x99\x0B\xEB\xCA\xAC\x94\x56\xD6\x21\xF3\x30\x8A\x0B\xE7\xD6\xD5\xD2\xD3\x79\x3F\x77\xCB\xE4\xA1\x68\xCC\xC9\x2A\xEE\x93\x9E\x18\x50\xCC\xC2\x23\xAB\x28\xEF\x2F\xA2\xC3\x6F\x4B\xEB\x4E\xEB\xE7\xE2\x8E\x2E\xF8\xC8\x8D\xE7\xCA\xDC\xE3\xED\xAA\xB3\x6B\xBD\xAC\xC9\xDE\x83\x79\xD2\xC3\xA1\x50\xD8\x9C\x88\xCB\x2D\x1F\x2C\xA5\xDA\xCF\xDE\xEB\xE1\xDC\xE9\x3F\x9D\x63\xF3\x1A\xF4\xDB\x9E\xD3\xD3\xA3\x8E\xDF\x98\x9F\xA8\xC6\x3E\xDA\x46\xD7\x8C\xDC\x5E\xF3\x7A\xE6\xDE\x63\x3C\xEA\x82\x99\xB4\xC4\xEA\x1E\xCF\xDF\x5D\x2A\xA9\xFC\xE6\x9D\xE7\xD7\xE0\xEB\xCF\x81\xE8\x06\x7B\xA0\xD0\xE9\x09\x12\xD1\x90\xDC\x45\xE3\xA8\x73\xB4\xA1\xC3\xE0\xCD\xE0\xDA\xAE\x2D\x67\xFE\xCB\x9F\xEA\xA1\xCA\x39\x08\xE9\xD1\xBF\xEA\x5A\xFC\xE8\xC0\xD6\xA3\xD8\xDB\xA2\xE3\xFC\x22\xE8\x67\x44\x15\x65\x67\x9F\x0F\x0F\x32\x68\x67\xE9\x08\x4C\xAE\x15\x65\x64\x33\x8B\x4B\xD5\x9A\xC5\xDB\xD2\x5F\xFE\x9A\xB8\xEF\x44\xFD\xCF\x57\xD4\x98\x0C\xD9\x98\xD0\xED\xA5\xE3\xFE\x92\xD9\x47\x10\x98\x3E\xE2\x92\x1B\xB1\x93\x3C\x07\xE0\xD9\x14\x24\x8A\xC8\xC5\x10\xC1\xBC\x71\x99\xF6\xA5\xC4\x9F\x96\x37\xA2\xA4\x59\xEC\x76\x74\xDB\xBC\xCC\xCF\xBB\xD0\x17\x8A\xC8\xEF\xC6\xEE\xDE\x22\xE9\x90\xC5\x88\xCA\x89\xCC\xB0\x27\xD5\x9C\x79\x0F\x72\xAC\x94\x85\xB4\x44\x7D\x9C\x53\x1F\x59\xCB\x7C\xD6\x55\x0A\x15\x6E\x2F\xC7\x09\x31\x38\xC2\x05\xA1\x12\xC5\xA3\x42\x9E\x9D\x4A\xA0\x83\xF9\xBB\xDF\xB0\x15\xCB\x07",
"\x55\xC1\x3A\xDE\x4D\x22\x8B\x54\x4C\xAB\x38\xF9\x94\x0B\xF1\x03\x8B\x57\x1D\xB2\xA4\xF2\x82\xC3\xCF\xF1\x05\xBF\x54\xA9\x0B\x85\xE4\xE8\xCA\x4E\xB5\x22\xF0\x82\x9C\xE1\x99\x7B\xA2\x4E\xB3\x37\x33\xC5\xD5\xF0\x08\xF5\x6E\x9D\xF2\x35\xB1\x46\xFB\xE4\x67\xAC\xF0\x1A\xF4\xBE\x8B\x56\xDC\x74\x68\x6B\xA1\x92\x9E\x3D\xDC\x10\x47\xC2\xF1\x1E\xAC\x7E\x7D\x65\x8E\x86\x85\x0F\xF3\xE4\xDF\xD7\x99\xC9\x3C\x20\xF2\xB5\x9B\xB3\xA1\xBC\x6E\xA5\xC1\x7F\xAB\x7F\x1B\xF4\xC7\xCA\xA4\x12\xF1\x85\x61\x5D\x04\xE8\xE1\x70\x8C\xC9\xC7\xF2\x38\xB7\xE3\xBC\xCD\xB7\xB0\xDB\x4E\x0D\xC3\xA2\xB6\x43\x8A\x70\xE9\xC3\x92\x91\xCE\x60\xBA\xBD\x80\xDB\x5C\xE2\xA5\x8C\x47\x30\xA0\xC7\xC6\x9E\xDE\xAC\xE2\xFE\xD4\xE7\xFC\xB6\xA8\xD2\xB7\x8D\xD7\x97\xD3\x7A\x81\xB7\xE7\x85\xBA\x2D\xF3\x78\xE8\xEE\x4D\xB1\xB8\x8B\xBA\x1F\x27\xEF\x60\xA4\xE1\x00\xE0\x22\xEE\xEF\x7A\x75\x71\xA5\xE3\x70\x0E\xF4\x43\xAE\xD2\xF3\xEE\xE6\xD5\xDF\xFC\xC2\x7A\xFE\xC3\xBE\x44\xE4\xAD\xA6\x83\x78\x72\xC4\xB5\x0C\x8B\xB9\xD0\xA2\x81\xF6\xBB\x7C\xA0\x17\x8A\xB8\x99\xEA\xB8\x67\xF4\xA5\xDA\xA5\xE6\x70\x00\x6B\xF1\x98\x4D\xF3\xE2\x8F\x81\xE8\xB6\x77\x80\xCD\xA1\x0B\xA2\xBA\xB7\xF3\xBD\xDF\xB3\xB6\x1B\xC2\xEF\x7A\xF3\xA7\xD7\xAC\xC0\xF3\x5A\xF6\xF2\x5E\xA1\xE8\xD6\xEC\xA1\xEC\xF6\xC4\xA5\x49\xC5\xE6\x84\xBA\xE8\xE8\xF1\x88\xBA\xF4\xDB\xA4\xC4\xA3\xE0\x87\xC2\xDF\xF8\xDB\xC4\xB4\xF4\x8B\xF0\xDB\xCA\x3C\x87\xBB\xED\xEF\xBA\x01\xFE\xDB\x08\xE3\x0F\xEF\xEF\xB4\xA3\x72\xAE\x69\x1A\x8E\xA7\x18\x87\xD9\xA7\xF4\x6C\xB7\xCB\xBC\x5F\xAA\xEA\xAE\xAE\xF4\xC7\xE8\x4F\xCD\xE1\x12\x45\x24\xBF\xE5\xA8\xB4\xF3\x03\xFF\xF6\xFB\xD9\x9E\x08\x91\x9C\xE2\xB4\xBE\xF2\xA7\x9B\xC5\xBE\xEA\x56\x80\x94\x46\x99\xB5\xC5\xEA\x9F\xFE\xD1\x8F\xE6\x77\xC3\x7F\xC0\xE7\xA9\xB5\x29\x52\x37\xB8\x35\xB7\x8A\xAF\xA9\x06\xEA\xB3\x3F\xBA\xCD\xBD\xD9\x57\xBF\xB3\xEA\x1B\xAF\xE5\xC8\x0C\xFC\xBD\xE2\xED\x85\xC4\x8D\x88\xCB\xD4\xB4\xEF\x56\xBB\xA4\xB8\xBA\x2E\xFF\x64\x36\xB2\x91\xB7\xAA\x39\xB3\x09\x77\xF8\xC4\xA8\xE4\x80\x00\x90\xA6\x84\x30\xF5\x42\x05\xB2\xEC\xE7\x64\xD3\xF2\xCF\xD4\xDC\x26\xF8\x72\xB9\xDF\x90\xDC\x25\x95\xCA\x5B\xBE\xB2\x79\x82\xAE\x92\xDC\xD2\xDA\xAE\xD0\xFA\x33\x8F\x83\xEC\xAB\xE4\xE1\xBA\x67\x94\x82\xAA\x21\x55\xE4\x43\x19\xFC\x66\xD8\x88\x30\xF4\x34\xD2\xA8\x8E\xA9\xAC\x98\xAB\xB1\x8D\xB0\x2F\x3C\x9B\x8C\xF7\xA5\xFA\xF6\x08\xEC\xED\xFD\x30\xB7\xFB\x10\x18\xF6\x80\xF4\xC2\xAD\x16\xC2\x3F\x5B\x80\x08\x85\x95\xF5\xA4\xF5\xFB\x70\xFA\x3F\x2C\x53\x48\xCA\x6D\xD6\xF4\x65\x52\xFB\xEE\x25\xB7\xFE\x00\x9C\xE5\xE6\xBD\x32\x9B\xF8\x9B\x70\xF6\xE8\xE4\xF8\xA4\xF5\x74\xC9\xF6\xD2\x9E\x96\xA9\xC8\xD0\xFA\xC6\x41\xF5\xEC\xF1\x3C\x2D\xB0\xE4\xDB\xCC\xCF\xC4\xE5\x65\xFA\xF9\xF8\xF1\xC0\xBF\xF3\xFE\xB6\x92\xF5\xCF\x69\xF9\xF8\x09\xB9\xB8\xFF\xFB\xD9\xF4\xDC\xF1\xFA\x48\xF7\xEE\xF1\xC3\xF1\xD5\xF6\xB2\xF3\x99\xB0\xFD\x71\xF7\x30\x2C\xB8\xED\xEF\xC8\x9B\xF1\xDD\xCA\xFA\x56\xDF\x3A\xED\xF6\x9F\x3C\x92\xF0\xF7\x73\x72\xF7\xAA\xF6\x6A\xF1\xFA\xAA\xF3\x7B\xAC\xF0\xF4\x79\xF6\x9A\xFD\x63\x2C\x8C\xAE\xFF\x99\xBA\xF1\xF2\xEA\xB7\xC9\xF1\xCE\xE4\xE8\x2B\xEE\x79\xC2\xF5\xD9\xF5\xB6\xCF\xF7\xE8\xA1\xFE\xF7\xE1\xD6\xF0\xB0\xF5\xC3\xF7\x60\xC7\xFA\x99\xFD\xEA\xE6\xF4\x59\xD0\x16\xBE\xFB\xDA\xFF\xF6\xB2\xFF\x44\xFC\xF6\x97\xC0\xF4\x6A\xBA\x53\xE9\x4C\x86\xFF\xC2\xB4\xFF\x80\x7E\xFD\x7E\xD9\x78\x7F\xE1\x50\xA7\x7F\x71\x6B\x7B\xC5\x7D\xA8\x7E\xEE\x5C\x41\xC9\x7C\x33\x19\x72\x73\x7B\xCD\x7C\xCD\x6F\xFC\x78\x53\xF8\x79\xCC\x54\xE6\x41\x7D\x35\x05\x55\x5B\xF3\x67\x7D\xCC\x3C\x26\x3F\xF3\x61\x29\x18\x80\xC1\x70\x56\x53\x7D\x54\x79\xC9\x75\x74\x5E\x7A\xDE\x74\x73\x69\x68\x53\x59\x7F\x51\x09\x81\xBA\x17\x59\x5F\x58\xA1\x53\xC0\x74\x55\x56\x7D\x5A\x44\x58\x72\x80\xA3\x6E\x0B\x8F\x8C\x66\x59\x7F\x54\x20\x25\x86\x31\x4C\x63\x7E\x61\x5B\x01\x83\x59\x32\x5F\x17\x53\x27\x3B\x7B\xA5\x77\x15\x1E\xEF\x49\x81\x13\x0A\xCE\x52\xF0\x4C\x81\x4E\x79\xC1\x74\x02\x87\x7D\xDD\x7D\x98\x58\x00\x8C\x7D\x52\x4B\xC3\x7B\x3D\x51\x7C\x8D\x77\xD0\x66\xEF\x63\x54\x17\x7C\x8F\x79\x69\x45\x4A\x9B\x5B\x0F\x61\x15\x48\x25\x3A\x5E\x1C\x33\x6A\x46\x60\x67\x80\xBD\x78\x6A\x7B\x75\xE7\x7D\x44\x5D\x6A\x52\x7E\x5B\x7D\x15\x8E\x14\x44\x7F\x58\x81\xE2\x4C\xBB\x10\x7C\xD7\x60\x17\x88\xCA\x45",
"\x6C\x74\x5D\xA9\x72\x90\x6B\x1A\x21\x05\x48\x29\x24\x0A\x5B\x3A\x08\xB3\x54\xEA\x71\x7B\x0F\x80\x4A\x7F\x6B\x20\x1A\xD3\x5B\x21\x87\x03\xAF\x68\xC6\x18\xBD\x75\xF8\x79\x7E\x4E\x04\x52\x1A\x70\x53\x4F\xB5\x79\x27\x57\xFD\x65\x77\x8A\x62\x2A\x7B\xFD\x75\x81\x65\x57\x0D\x7A\xEC\x61\x7F\x9B\x7E\x75\x76\xEC\x47\x5C\xB6\x6A\x29\x87\xF9\x40\x42\xEE\x7F\xFA\x74\xB1\x46\x4F\xCF\x79\xE9\x70\xFF\x78\x71\xAE\x7E\xFF\x74\xF7\x71\x7E\xBD\x7D\xC6\x56\xEE\x40\x7F\xDE\x7A\x00\x75\x4D\x73\x7F\xC0\x80\xEF\x74\x32\x3E\x7E\x04\x83\xCB\x76\x00\xAA\x7B\x4B\x7D\x8B\x50\x1D\x25\x19\xA2\x7B\xBB\x7B\x08\x8A\x7F\x8D\x81\xC4\x64\xEF\x5B\x57\x5F\x80\x05\x80\x8A\x7E\x7F\xDE\x24\x45\x38\x57\x02\x82\xA3\x16\x20\x87\x8A\x4E\x02\x5B\x56\x20\x8C\xC1\x61\x45\xC7\x41\xA9\x58\x6D\x3E\x82\xCB\x20\x35\x18\xEE\x53\x5F\x90\x74\x35\x8E\x4C\x34\x7B\xAC\x46\x39\x82\x1E\x6F\x3E\x72\x61\xC4\x78\x94\x2A\x5C\xF4\x7A\x46\x64\xF6\x53\x83\x0E\x83\x3C\x81\x01\x83\x07\x35\x5C\x5D\x7B\xF1\x62\x09\xC7\x5E\xC7\x70\x99\x60\x7C\x5D\x5C\x5D\x7A\xF5\x72\x79\x4B\x59\xFF\x61\xF1\x4E\x62\xE2\x7B\xCA\x7B\x05\x9B\x77\x6F\x61\x45\x80\x26\x45\x75\xD9\x82\x72\x53\xF3\x69\x7D\x0C\x58\x88\x18\x52\x46\x84\x2B\x08\xC7\x7E\x7A\x4A\x84\x61\x7F\x70\x01\xF2\x62\x09\x0F\x84\xC2\x71\x2D\x64\x5D\xE9\x75\x0A\x86\x87\x5A\x84\xDF\x78\x1E\x8E\x0C\xAA\x7C\x1B\x87\x63\x7B\x68\x55\x7C\x70\x47\x47\x8E\x54\x5D\x79\x00\x01\x17\x6D\x8C\x6C\x4F\x66\x83\x50\x80\xF0\x72\x31\x8F\x31\x48\x32\xDE\x72\x84\xE4\x6F\x7D\x7F\x32\x5B\x66\x90\x6C\x0B\x81\x02\x72\x7C\xB9\x6A\xDA\x07\x7D\x74\x56\xE8\x4D\x51\x85\x87\x40\x00\xDD\x77\x13\x67\x14\xAE\x5E\xE0\x5C\x1B\x86\x14\x8D\x85\x0C\x7C\x2C\x61\x8D\x57\x84\x31\x86\x57\x85\x8B\x6B\x60\xEE\x5F\xBB\x63\xFC\x3B\x62\x52\x49\x2F\x6E\x8D\x5D\x0C\xF4\x5A\x30\x6E\x8B\x4A\x54\xDA\x76\x50\x5D\x15\x9E\x61\x62\x62\x1C\x3E\xCA\x05\x35\x4B\x86\x5A\x8D\x8A\x5F\x7A\x32\x6E\x39\x21\x15\x90\x33\x94\x3D\x0B\x84\x05\xBD\x48\x70\x45\x41\x18\xBA\x7F\x10\x42\x87\x56\x8B\x17\xA3\x85\xA7\x61\x1F\x3B\x81\x68\x61\x1E\x63\x32\x6D\x0C\xB8\x57\x66\x86\xB9\x63\x4A\x69\x85\x7C\x86\xF3\x56\x8B\x77\x80\xBC\x2E\x5B\x86\xB9\x5A\x63\x30\x62\xB2\x72\x83\x7B\x5F\xF7\x5F\x2C\x82\x19\x78\x60\xC9\x4D\x39\x62\xF5\x11\x86\xB4\x63\x64\x8B\x15\xBB\x45\x7D\x30\x3D\x0E\x17\x58\x84\xE4\x76\xBC\x32\xB1\x72\x47\x98\x4C\x85\x4C\x35\x45\x4B\xFA\x4F\xFC\x55\x20\x53\x3A\xF1\x45\x76\x7E\x03\x72\x78\x84\x85\x28\x54\x19\x63\x6A\x6D\x59\x8A\x48\x1E\x7B\x31\xC4\x84\xA0\x46\x1C\xB1\x48\x93\x3A\x74\x1B\x23\x10\x87\x2B\x2C\x73\x8C\x14\xB6\x64\xDA\x44\xFF\x5A\x5C\x42\x87\x74\x0D\xD7\x49\x38\x57\x87\x4C\x4C\x76\x46\xC9\x5B\x47\x52\x3E\x77\x82\x18\xA4\x48\x35\x55\x70\x82\x1D\x86\x4D\xD4\x86\xFC\x5A\xEC\x47\x87\xA4\x43\xD7\x5D\x1E\xAF\x70\xBC\x85\x14\x8D\x5D\x46\x45\xE3\x87\x7C\x83\x1C\xB6\x87\xAF\x82\x1D\x80\xCC\x64\x57\x34\x49\x77\x8C\x1F\x98\x86\x3F\x4C\xF1\x2B\x1F\x41\x88\x5B\x4D\x79\x85\x1D\x99\x6D\xF8\x86\xD7\x7D\x50\x4B\x87\x0B\x8A\xF8\x52\x1E\x73\x46\xFA\x85\x74\x81\x21\x96\x48\xDB\x61\x81\x85\x21\x81\x47\xF1\x84\xD5\x3E\x1E\xA1\x86\x04\x7C\x84\x4C\xA1\x72\x87\x1F\x8B\xD1\x41\x22\xA0\x4D\x26\x82\xFE\x42\x19\x5D\x48\x2B\x8A\x89\x89\x21\xAC\x62\xB9\x7A\x79\x7E\xDA\x47\x5D\x2D\x7F\xEF\x7D\xED\x6D\x77\x73\x61\x7F\x83\x13\xBB\x7E\x52\x6F\x5B\x77\x07\x93\x84\x2E\x52\x27\x61\x88\x6D\x7A\xA1\x63\xC9\x4A\xE3\x6E\x62\x26\x58\xD5\x71\x23\xA2\x73\xC7\x73\x34\x71\x24\x58\x85\x09\x7E\x21\x6F\x1E\xB4\x5E\xAE\x62\x8F\x60\x15\xA1\x6E\x90\x39\x73\x4E\x78\x65\x22\x3A\x4E\x93\x81\x18\xA8\x88\x9C\x46\xBE\x5A\x84\x48\x5D\xEE\x6F\x89\x83\x16\x82\x77\x1F\x60\x94\x62\x24\xAF\x62\x5D\x7F\x59\x82\x8B\x73\x89\xD5\x63\x2C\x8D\x82\x59\x63\x29\x1D\x6A\x85\x20\xAB\x86\xBF\x61\x0D\x6C\xFE\x77\x60\xE2\x61\x0E\x69\x12\x32\x86\x36\x8A\x96\x88\x26\xA3\x65\x39\x83\x62\x80\x3E\x60\x3E\x68\x65\x4F\x25\x3E\x75\x24\xE6\x85\x96\x88\x32\x4D\x87\x2C\x4D\x8F\x86\xF0\x33\x6E\x90\x4D\xA3\x8C\xFD\x4C\x86\xA0\x3E\x63\x8A\x23\x13\x88\x6E\x8B\x56\x83\x18\x8C\x85\x09\x75\xCD\x1F\x12\x92\x63\x36\x84\x7E\x53\x1A\xBB\x89\xCA\x54\x5C\x87\x1E\xAA\x86\x77\x86\xFD\x50\x8C\x6E\x86\x53\x3F\x30\x62\x3C\x45\x63\x18\x8A\xA2\x8F\x26\x99\x8A\x5D\x88\xD1\x6F\x25\xB4\x6E\x07\x37\x48\x57\xA8\x40\x54\x3B",
"\x4F\x99\x8F\x2B\x9C\x89\x84\x86\x97\x80\x7D\x57\x79\xF0\x80\xD6\x55\x15\xAC\x16\xC8\x8A\x99\x87\x8C\x5B\x89\xAD\x8A\x33\x6F\x79\x74\x6C\xBC\x2E\xE8\x5C\x2A\x64\x5E\x0C\x22\xE9\x57\x8A\x16\x8B\x73\x8A\x9F\x54\x26\x9F\x7E\xC3\x3C\x79\x80\x22\xBE\x89\x30\x88\xE5\x72\x23\x93\x3D\x65\x4C\xD6\x4F\x29\x65\x8A\xB4\x60\x67\x48\xB3\x4F\x4D\xCC\x06\xD6\x47\x61\x13\x87\xB2\x48\xBB\x8A\xCB\x46\x88\x53\x3E\xD3\x42\x34\x47\x3E\x5C\x62\x56\x85\x1B\x86\x8C\x87\x5F\x29\x66\xC8\x21\x77\xD7\x8B\xA2\x88\xFD\x7A\x88\x72\x6C\xCA\x7A\x29\xBF\x82\x3F\x8A\x45\x83\x4A\x4E\x85\x14\x8D\xFE\x79\x13\x80\x76\x47\x88\x9E\x8D\x89\x56\x4E\x6B\x49\x05\x8E\xFF\x62\x62\xAE\x62\x6D\x84\x8B\x67\x62\x65\x30\xC3\x85\x2E\xB9\x88\xA1\x81\xC4\x87\x27\x98\x8C\xF1\x76\xC6\x85\x13\x88\x89\x37\x84\x4D\x80\xF3\x63\x52\x0B\x7F\xC4\x8F\x2A\x3A\x77\x2B\x77\x35\x58\x1C\x00\x5F\x24\x75\x4C\x77\x92\x54\x76\x86\x74\x4D\x7E\x63\x41\x5E\xF6\x63\x6F\x7E\xC7\x6E\x6E\x7B\x51\xF1\x1B\x19\x8E\x63\xFB\x6F\x79\x7A\x53\x6E\x73\x95\x69\xA6\x74\x24\xB7\x7E\x7E\x82\x59\x71\x33\x85\x80\xC2\x7C\x36\x8B\xC0\x72\x41\x27\x74\x5B\x79\x91\x5F\x79\xD0\x7C\xEF\x55\xC1\x67\x6C\xF3\x1B\x4B\x7B\x34\x88\x6E\x32\x77\xDA\x85\xCB\x7D\x76\x8F\x32\x1C\x0D\x49\x41\x8D\x96\x74\xB3\x68\xBF\x59\x8B\x2A\x80\x03\x81\x07\xAF\x76\x41\x76\xD5\x80\x00\x81\x83\x93\x78\xDF\x8F\xCE\x7E\x8D\xC5\x81\x91\x85\xD4\x4A\x70\xC6\x43\xFE\x71\x36\xA1\x2E\x6D\x74\x23\x54\x36\x9A\x83\xAC\x4A\x47\x6C\x27\x52\x76\xF3\x6D\x3F\x75\xBF\x7D\x63\x4E\x8C\xDE\x8E\x7C\x51\x8D\x3B\x8A\xFA\x5C\xD8\x55\x71\x38\x87\xCC\x84\xC0\x60\x8E\x36\x8F\x32\x85\xEF\x4B\x70\xF9\x81\xE3\x70\x46\x4E\x82\xFE\x7E\x3F\x85\x36\x98\x4E\x92\x8F\x60\x7D\xA6\x6A\x8D\x96\x8E\x89\x6C\x20\x33\x74\x38\x5F\xF1\x57\x0D\x33\x8D\xB8\x8C\x5D\x6E\xB2\x75\x8E\x2C\x6E\xE3\x66\x18\x8B\x04\x8B\x5A\xED\x62\xEF\x15\x6F\xD0\x6D\x54\x7B\xEE\x5D\x81\xD0\x77\x98\x61\xBC\x6C\x66\x82\x8D\xD5\x8E\xA3\x46\x6F\xA2\x8C\xD5\x80\x9D\x27\x68\xD4\x8F\xCD\x84\xCF\x6B\x1F\xC9\x8F\xA3\x53\x7F\x48\x8F\xDD\x6F\x17\x4C\x25\x58\x6F\x72\x66\xF6\x61\x12\x1C\x6F\xF6\x1C\x31\x7C\x1F\xB4\x8D\xFF\x72\xE2\x64\x34\xAA\x73\x38\x5E\xF0\x81\x50\x03\x07\xC5\x8C\x39\x50\x3E\xA9\x8F\xE4\x50\xCF\x67\xF0\x65\x6E\x2F\x86\x54\x7F\x39\x9A\x8D\x94\x6B\xF5\x89\x65\x47\x6D\xD1\x8E\x00\x94\xB4\x59\x8F\x81\x8D\xD6\x8B\xD6\x67\x75\x07\x71\xB5\x5C\x31\xA3\x73\xDB\x30\xFE\x8E\x3D\x8A\x7B\xF7\x8C\xCE\x5D\xB5\x72\x72\x2C\x08\xD8\x6B\x4B\x07\x05\xE8\x8D\x14\x73\x1B\x83\x8D\xCC\x72\x3F\x7B\x21\x37\x8E\x6E\x8E\xD1\x8E\xCA\x0C\x02\xF7\x61\x09\x9D\x3E\xA9\x73\x22\x93\xB8\x61\x73\x67\x7C\x2F\x8F\x54\x7A\x35\xA1\x8E\xC2\x83\xF2\x84\x3A\x97\x8D\x79\x63\x03\x9D\x18\x82\x6E\x20\x64\x08\x9C\xD4\x75\x72\x24\x90\xF0\x81\xB3\x63\x4E\x03\x05\x0A\x92\x44\x8D\x75\xEE\x8D\x08\x95\xBF\x72\x8F\x13\x16\x42\x05\x3F\xAD\x84\xFC\x8D\xAC\x87\xB9\x69\x8D\x3E\x93\x57\x78\x73\x41\x91\xEF\x8D\x0B\x90\xF0\x45\x33\x85\x35\x1F\x77\x44\x87\x76\x49\x93\x0F\x93\xBE\x4C\x91\x06\x20\xF1\x8D\x29\x93\x81\x9F\x8B\xA3\x8E\xC1\x40\x06\x8F\x85\x0F\x93\x12\xAA\x90\x26\x67\x1B\x9F\x45\x86\x8D\x72\x31\x19\x33\x12\x0A\x8D\x73\x93\x0A\x9C\x3E\xBD\x68\x0E\x71\x4C\x0B\xD9\x0E\x91\x92\x72\x02\x9D\x3C\x9D\x59\xE9\x15\x2B\x13\xCF\x58\x4E\xF0\x6D\x0F\x73\x41\x85\x88\xF7\x69\x26\x7B\x4B\x1C\x04\xDA\x77\x1E\x94\x14\xB2\x91\x59\x91\xFD\x6F\x3E\x40\x00\xAA\x02\x11\x95\x49\xB2\x70\x39\x68\x1C\x9C\x9C\x5B\x8B\xF4\x8E\xF6\x77\xAB\x50\x8F\xDF\x7D\x91\x65\xAE\x47\x88\x7B\x78\xB3\x6A\xC2\x23\x49\xAD\x74\xFA\x75\x9D\x70\x69\xB1\x67\x95\x64\x9B\x6B\x6A\x82\x91\xDF\x89\x9B\x50\x2F\xBB\x65\x8F\x13\x7A\x5D\x23\xD0\x6B\x61\x23\x48\xB4\x8E\x9B\x90\xCB\x6D\x36\xB9\x91\xF3\x60\x2A\x6D\xC7\x0B\x38\x5E\x91\x30\x9C\x34\x9D\x92\xC4\x93\x27\x9E\xC2\x47\x8F\x70\x80\xCD\x88\x5F\x6E\x6A\x70\x44\x8C\x65\x74\x33\x8E\x55\x91\x65\x78\x73\x43\x93\xCA\x90\xE2\x6B\x17\x46\x32\x43\x00\xEF\x8E\x49\xAB\x6D\x92\x90\xC1\x6E\xD8\x57\x6A\x65\x69\x7D\x6A\xA9\x70\x92\x9C\x68\x92\x6E\xD3\x60\x7E\xAD\x82\x9D\x6E\x9D\x57\x69\xA3\x7F\xB0\x65\xA5\x45\x6A\xE7\x65\x0A\x11\xFF\x5E\x8C\xB6\x59\x7B\x6A\xB0\x5F\x69\xCB\x23\x73\x76\x4B\xA4\x69\xF4\x64\x83\x6D\xAC\x7B\x6A\x00\x94\x5C\x2E\xAB\x43\x8E\xA5\x90\xB5\x63\x9A\x44\x6B\xC7\x89\x2A",
"\x98\xA0\x46\x94\xAB\x90\xB3\x6A\xAB\x41\x76\xBC\x69\x40\x9F\xA7\x43\x92\x0D\x96\x6B\x20\x9B\x6D\x93\xF8\x92\x86\x67\x50\xAB\x6A\xC0\x92\x12\x96\xA2\x5C\x93\x26\x94\xCB\x6B\x17\x4F\x32\x39\x0C\x1E\x9D\x4D\xA0\x91\x2C\x93\x12\x9C\xBE\x73\x76\x93\x3A\xFE\x82\x4D\x90\x8D\x09\x6C\xA4\x8B\xB0\x5F\x14\xAB\x27\x22\x9D\x2E\xA3\x47\x13\x6C\xE7\x73\xE9\x1C\x0C\x16\x6D\x5A\x01\x49\xBD\x8E\x50\x61\x36\x95\x34\xB9\x8E\x53\x63\x95\x65\xE0\x40\x00\x57\x61\x32\x99\x52\x8C\x8D\x91\x62\x42\x1B\xDB\x5A\x29\xC9\x77\x5E\x4B\x05\x22\x93\x77\x05\x70\x76\xE3\x65\x93\x39\x7A\x54\x9E\x55\xBF\x4C\xCB\x69\x12\x95\xC6\x0D\x3D\x5D\x55\x05\x38\x39\x40\x27\x9C\x13\x41\x6F\x3D\xB7\x05\xE3\x7D\x45\x9B\x1F\x8B\x73\x63\x97\xD4\x33\xA3\x35\x3B\x57\x94\x5A\x98\x85\x2A\x95\xAC\x48\x5B\x9C\x95\x3E\x94\xFF\x89\x23\x91\x4B\xB1\x1B\x3C\x0B\x1D\x73\x57\x93\x76\x00\x01\x5D\x92\xEF\x28\x28\x78\x94\x70\x7D\x27\x69\x95\xED\x3F\xF0\x3E\x57\xBB\x26\x6E\x94\x05\x90\x57\x86\x4F\xD7\x0E\x74\x08\xB8\x44\x8C\xEB\x8E\x63\x90\x27\xBC\x94\x57\x82\x33\x89\x68\x79\x95\x33\x94\x47\x96\xD4\x7B\x94\x1A\x97\x42\x92\x3D\xAE\x92\xD6\x82\x72\x04\xDD\x78\x8A\xF2\x38\x3C\x2E\x14\x3E\x06\x9C\x97\x68\x1F\x71\x36\x55\x13\x11\x37\x17\x5B\x99\x0F\x13\x13\x5E\x43\x0C\x1B\x55\xBB\x94\x84\x03\x41\x21\x52\x9F\x1A\xF7\x65\xDB\x77\x0F\x21\x1C\xB1\x0F\x4C\xAC\x96\x5C\x7C\xC7\x16\xDD\x79\x08\xC5\x96\xFA\x8C\x1A\x41\x97\xC9\x94\x55\x0C\xB1\x44\x82\x8F\x73\x71\x98\x79\x03\x0B\xE6\x12\x63\x73\x7F\x5D\x86\x92\x46\x58\x2B\x57\x3B\x6B\xD4\x97\x4C\x16\x5D\x8D\x8D\x17\x94\xAB\x45\x5E\x9C\x97\xFA\x73\xC3\x65\xE7\x60\x97\xB2\x53\x48\x94\xF5\x09\x39\xE6\x3E\x0C\x20\x12\x1D\x13\x44\x46\x7D\x98\x81\x49\x96\x5B\x55\x7E\x90\x21\x09\x42\x4A\x3A\x4D\x0C\xE4\x06\x0E\xA9\x8B\x9F\x4A\x5C\x7E\x97\xE9\x1B\x05\x70\x70\x1A\x87\xD4\x16\x68\x2E\x1B\x22\x8B\x5C\x87\x93\x0F\x1C\xAB\x26\x10\x9B\x5E\x45\x3D\x6C\x79\x18\x41\x75\x11\x31\x24\x89\x2A\x85\x0C\x4C\xE3\x3F\x1F\x9C\x2D\x81\x91\x3B\x60\x62\x13\x99\xC3\x63\x48\x94\x34\x53\x3A\xEE\x23\x79\x28\x27\xC9\x86\xBD\x0B\x17\x44\x31\x86\x41\x8B\x91\x30\x09\x42\x7F\x3A\x95\x32\x62\x90\x63\xDF\x8A\x8A\x9A\x5A\x97\x8F\x05\x8F\x8B\x16\x24\x1D\x18\x0A\x06\x8C\x9E\x1B\x24\x05\x1B\x19\x94\x0B\x10\x02\x99\xFB\x95\x31\x33\x6E\x7F\x98\x32\x08\x92\x99\x08\x7B\x39\x86\x0D\x9F\x3A\x16\x3E\x30\x80\x38\x9A\x27\x63\xA6\x6E\x4C\x88\x93\x90\x61\x17\x70\x25\x96\x18\x97\x45\x8A\x95\xF0\x8D\x31\x92\xC7\x37\x30\x52\x96\x97\x9E\x3B\xAE\x76\xCC\x3B\x9A\x8F\x3F\x9E\x81\xCD\x6D\x97\x96\x45\xA3\x90\x60\x9A\x16\x9D\xF3\x66\x36\x65\x9B\x9B\x91\x05\x93\x4B\xB3\x43\x9A\x96\x5A\xB1\x73\x1E\x0E\xB6\x45\x1A\x94\x6D\xF5\x71\x39\x7D\x80\x1D\x0D\x0F\x20\x5A\x0E\x46\xB1\x94\x27\x95\x9C\x96\x49\x87\x8D\x72\x32\x0E\x0C\x55\xAF\x94\x75\x8E\xBC\x38\xD9\x61\x2E\xA4\x76\x6A\x7C\xD9\x41\x7E\x03\x81\x73\x96\x67\x61\x76\xB7\x7C\xB3\x35\x69\x9B\x9A\xA6\x74\xA6\x98\xDA\x64\x59\x50\x81\x5E\x0E\x43\x6D\x92\x48\x63\xE8\x80\x40\x80\x82\x23\x56\x6D\x74\xD8\x48\x96\x66\x99\x14\x88\xD9\x5E\x9A\x0D\x1F\xC0\x78\xE9\x69\x8A\x05\x77\x42\x78\x35\x8E\x74\x0B\x06\xAD\x92\x6A\x8F\x7A\xA4\x9A\xA5\x96\x18\x27\x9A\xC2\x6F\xF9\x76\x3D\x9A\x16\xCA\x74\x9B\x94\x77\x47\x97\xFB\x18\x15\x94\x49\x93\x95\x88\x6C\x16\x90\x6D\xAF\x8D\x81\x5F\x07\x0F\x68\x93\x9B\x91\x9B\xA4\x34\xC3\x5D\x42\xCC\x3A\x0D\x76\xF9\x7F\x94\x94\x71\x46\x0D\xCB\x7D\x70\x93\x43\x2C\x72\xCC\x75\x72\x12\x96\x67\x83\xC9\x48\x71\x85\x22\x25\x72\xC7\x5D\x10\x74\x71\x23\x73\xC4\x78\x71\xC7\x98\xAE\x13\xCA\x41\x0C\xA4\x0D\x5A\x75\x4B\x8C\x94\x44\x6E\x17\x71\x41\x60\x71\xCA\x7A\x2B\x7E\x6E\xB9\x73\xF0\x9B\x19\x7C\xC8\x74\x72\xF3\x98\x2B\x81\x41\x6E\x71\x01\x9C\x1C\x73\x70\xBE\x72\xD6\x77\xB9\x15\xC7\x43\x73\xE5\x7D\xF4\x76\xF0\x08\x73\x77\x23\x2F\x9A\x68\x89\x9A\xCF\x99\xAC\x90\xF0\x7D\x31\x86\x32\x27\x0A\x49\x98\x9B\x2B\x91\x45\x6B\xFF\x5F\x70\x50\x0B\xAD\x9E\xF2\x4D\x90\x8E\x51\xE0\x6A\xC2\x4B\x07\x82\x16\x8C\x63\x48\x85\x76\x61\x99\x14\x88\x0F\xAB\x3F\x28\x9E\x91\x0A\x72\xBE\x88\x32\x8E\x45\x4C\x66\x69\x70\x7F\x16\x5F\x22\x57\x2C\x70\xFA\x14\x6D\x2E\x66\x9A\x93\x70\x99\xC7\x96\x67\x80\x7C\xF5\x63\xC8\x9E\x71\x84\x7C\xFE\x63\x45\x80\x33\x9C\x8E\x2E\x8F\xD4\x82\x43\x8B\x90\x5B\x8F\xCB\x79\x40",
"\xAA\x9A\x58\x9C\x0D\x96\x3A\x9E\x8D\x1D\x71\xFF\x78\x09\xA5\x72\xAC\x8F\xD8\x9E\xE5\x7E\x50\xD4\x42\xC5\x90\x49\x7D\x1E\x16\x70\x36\x9A\x74\x88\x9D\x21\x06\xB4\x9F\x74\xBD\x76\x03\x12\x4B\x94\x72\xA7\x99\xE5\x6D\x57\x18\x33\xA4\x5D\xF5\x99\x3F\x13\xF1\x4A\x9B\x23\x55\x22\x99\xBA\x5A\x9C\x6F\x9F\x52\x91\x47\x88\x9A\x2A\x94\x2A\x68\xC9\x34\x99\x39\x77\xDD\x91\x05\xBA\x75\x85\x0B\xDE\x9E\x3F\x81\x8B\xFD\x92\x94\x4A\x43\xBA\x94\x29\x12\xC9\x69\x42\x07\x9A\x60\x94\x4A\x93\x77\xA8\x62\xA3\x32\xA7\x35\x67\xB0\x9D\x6B\x6C\xEF\x2E\x94\x51\x5F\x7C\x9F\xD5\x9B\x67\x83\x75\x80\x9E\xB3\x69\x34\x3E\x10\x50\x10\xE7\x98\x54\x97\x04\x9E\x9F\xD2\x9B\x5F\xAE\x32\x2D\x97\xE8\x96\x78\x91\x81\x62\x77\x7B\x12\x79\xB6\x90\xAB\x98\x5A\x7C\xFF\x5C\x9D\xAB\x9C\xE3\x81\x73\x74\x76\x70\x45\x5C\x72\xCF\x1C\x75\x46\x9F\xC6\x92\x4C\x8E\x9F\x43\x90\x2A\x6B\xCB\x15\x38\xBA\x9D\xCD\x95\x7A\xBB\x12\xF2\x33\xEF\x90\xD4\x7C\x9B\x19\x3D\x55\x76\x5A\x39\x41\x97\x9E\xC1\x3A\xD5\x73\x75\x6A\x5A\xEC\x93\x4E\x91\x98\x85\x9E\xF5\x99\x64\xAF\x5E\x4E\x9E\xED\x94\x2A\x65\x53\x8A\x85\x1A\x95\xB9\x7A\x94\x3C\x26\x5A\x64\x41\x14\x8A\x83\x9D\xDF\x86\x55\x8E\x96\xBA\x76\x63\x97\x8A\x56\x03\x23\x9E\x62\x93\xE9\x37\x95\xF7\x4C\x69\x99\xF1\x10\x96\x18\x52\x64\x92\xAF\x42\x27\x43\x6F\x5B\x9E\x11\x23\x7F\x84\x95\xCC\x6B\xAF\x57\x95\x98\x8D\x45\x9C\xEC\x06\xA0\x06\x3C\x02\xA1\xF8\x3D\x95\x0B\xA2\xC4\x7C\x5C\xB0\x24\x71\x94\x77\x8D\x59\x89\x05\x02\xA0\xEF\x2C\x58\x85\xA0\x8E\x96\x5E\x9D\x84\x3C\x95\x0A\xA2\x3D\x14\x59\x92\x6B\x8C\x93\x65\x92\x19\x59\x96\x26\x6B\xE1\x3B\x7F\xA4\xA0\x58\x97\x55\x9D\x61\x58\x05\x76\x9D\x09\xA6\x15\x20\x96\x17\x8C\xC3\x73\x5A\xA9\xA0\xA5\x97\x40\x9C\xDC\x7C\x80\xA0\x96\x40\x9C\x6F\x92\x77\x7E\x27\x6B\x92\x54\xBC\x2E\xB2\x96\x72\x82\xF5\x0B\x78\x52\x50\x13\x5C\x43\x45\x2C\x08\x8F\x0D\x56\x85\xA0\x44\xA3\x0B\x29\x62\x0C\x14\x78\x7F\x5F\x70\x5A\x14\x15\x51\xDF\x0D\x1A\x50\xEE\x7E\x7F\x5B\x78\x48\x85\xE2\x63\x69\x28\x46\x80\x56\x5C\x6E\x97\x16\x52\x4D\x46\x3C\x68\x51\x90\x7E\xD9\x67\x29\x95\x5E\x62\xA0\x48\x07\x2A\xA8\x55\x89\x51\x0C\x4E\x45\x5C\x3D\xB4\x69\x18\x5B\x85\xB9\x50\xF7\x4F\xFC\x52\x87\xB1\x92\x5A\x99\x8D\x8B\xB2\x14\xA1\x33\x78\xF5\x7E\x4E\x1A\x2D\x59\x62\x77\x27\xF7\x4E\x95\xCF\x32\x83\x50\x00\x18\x61\x59\x7A\x23\xA3\x27\x03\x7E\xFA\x3F\xEA\x51\x15\x43\x1E\x61\x1D\x86\x09\x2B\x60\xA2\x57\x11\x6F\x7F\x5B\xA2\x85\x65\x44\x29\xA3\x21\x16\x56\x42\x40\x82\x38\x77\x3D\x79\xEB\x3E\x2B\xA4\x78\x17\x90\xF2\x3A\x2A\xAD\xC9\x67\x57\xAD\x83\x84\x30\x1D\xB3\x5F\xB2\xA2\xD9\x1C\x05\x52\x46\xC0\x24\x92\x1B\x4F\xBD\x7A\x2F\x86\xDD\x5E\xF2\x12\x1E\xF6\x0A\xC4\x02\x1A\x2B\x3D\xB2\x6D\xE5\x1D\x48\x7B\x7F\x99\xA2\x1A\xA0\x14\xA9\xA1\x3F\x87\x93\x1D\x48\x6F\x85\x60\x1F\x15\x11\xE4\x50\x79\x4D\x7B\x45\x05\xE4\x5C\xA3\x47\x79\x87\x5A\x0D\x1B\x55\x62\x78\xFA\x38\x39\xA0\xA3\x34\x48\x31\xA9\x2F\x63\x52\x35\x51\xE5\x5D\x87\x99\x3C\x7F\xA2\xDA\x7F\x81\x68\x9D\xC6\x8A\x91\x78\xFE\x1A\x5D\xDD\x45\x39\xA7\x0A\x67\xA3\x6A\x0D\x94\x7E\xBD\x6A\xA3\xD0\x8A\xFE\x3D\x8E\xBC\xA1\x5A\x7A\x1F\xAC\xE3\x6E\x8E\x0E\x4E\x3D\xA3\x49\x7A\x7B\x88\x7F\x25\x5D\x90\xB3\x7A\xA3\x32\xAD\x7A\x3A\x9B\xA2\x2C\x8E\x1A\x6A\xFD\x40\xA4\x55\x9D\x47\x98\x0A\xA6\x7E\xF1\x95\xE2\x1F\xF9\x53\x7B\xAD\x83\xB7\x9F\x2F\x9B\xA4\x75\x85\xFB\x73\x70\x4F\x08\xB7\x80\x2D\x9D\x14\x44\x83\x3F\x8B\xCE\x99\x0C\x9C\x5C\x5B\x9C\x4B\xA7\x89\x6E\xA4\x19\x8C\xD7\x8E\x40\x8D\x6F\x8B\x58\x0A\x8A\x16\x8D\x3D\xC6\x7D\xC9\x5A\x37\x81\x5B\x8C\x82\xA9\x7C\xFC\x6B\x83\x31\x4F\x04\x8F\x72\x4C\x89\xDC\x80\x8F\x76\x89\xB2\xA4\x1A\x5A\x00\x8B\x10\x16\x58\xAF\x7F\xDF\x86\x0C\x8F\x53\x08\x84\x2A\x62\xDF\x18\x98\xBA\x82\xB8\x78\xE9\x51\x89\x3A\x81\xFE\x39\x93\xA1\x96\xD3\x91\x4E\x98\xFB\x7E\x8C\x18\x5A\x54\xA7\x09\xA4\xA5\xA9\x1B\x83\x56\x76\x8C\x3F\x8F\x32\x44\xAF\x09\xB2\x3B\xD9\x7E\x28\x88\x91\xA9\x9A\xC1\x7A\xFA\x72\xFE\x79\x79\xE4\x7D\xBA\x94\x97\xA7\x82\x76\xA5\x2A\x83\x09\x75\x82\xEF\x7F\xB9\x99\xA5\x49\x7A\x62\x9C\x5A\xA2\x63\x5A\xA5\xBF\x98\xE1\x85\x31\xBB\x9A\x4C\xA5\xC3\x5D\x0B\xA5\x7B\x59\x9C\xCB\x93\xB5\x4C\x83\x9A\x8D\x9F\x4D\x93\xA3\x7A\x40\xA6\x3C\x8D\x65\x43\x84\x7E\x66\x51\xA6\xCC\x52\x7F\x16\x80\x43\xA1\x67\x60\x9A",
"\x4A\x82\x3F\x54\x9A\x8D\x81\x81\x5F\x13\x82\x6C\x97\x9F\x73\x83\x28\x80\x11\x83\x5A\x59\x7F\xFD\x43\x75\x9C\x41\x5A\x83\xF6\x9B\x5A\xB2\x76\xA6\x95\x47\x88\x39\x61\x81\x9A\xA2\x82\x05\x10\xAA\x59\x07\x85\xA4\x0D\x61\x68\x84\x5C\x5F\xCF\x4D\x97\x72\x89\x73\xA6\xBB\x54\x98\xBC\x93\x2F\xA5\xDC\x5B\x75\xB0\x8C\x5E\x9D\xD7\x85\x77\x54\x85\x6A\x5B\x05\x83\x04\x99\x21\x1A\x80\xD1\x78\xF3\x75\x04\x1D\x5B\x07\x8C\x55\x58\x21\x37\x1B\xD0\x70\x93\x10\x91\x55\x7B\xF0\x79\x67\x94\x9E\x5C\x6A\x1E\x8F\x35\xAE\xA6\x4D\x3C\x0C\x81\xF5\x41\x89\x34\x82\xAD\x01\x03\x98\x7D\xC3\x7C\x1D\x84\x27\x8E\x97\x67\x5A\x0F\x89\x12\xBE\x65\x41\x82\xBE\x8C\x63\x79\x20\xA2\xA7\x44\xAA\x20\x31\x7A\x86\xA4\xF3\x3E\xCA\x2E\xA5\x31\x5F\xE3\x78\x45\x57\xA4\xE0\x71\x29\x82\x92\xB5\x79\x24\xA4\xB1\x73\xE9\x2B\x82\xF0\x93\x20\x79\xB5\x51\xA8\x83\x88\x30\x5D\x97\xAA\x7E\x15\x9E\x4E\x5D\x98\xA2\x09\x34\xA5\x64\xAE\x9C\x8D\x5D\xCC\x3B\x87\xA7\x71\x49\xA6\x67\x5C\x0E\x9A\x3D\x83\x44\x95\xA4\x4F\xAA\x00\x87\x7F\x52\x49\x03\x80\x4F\x55\x83\xA1\x2C\xAA\x75\x94\x93\x3D\xF7\x7B\x36\x8B\x96\x96\xA7\xDA\xA4\xCF\x79\x9D\xA6\x7D\x44\x83\xF1\x5E\x9D\xA1\x80\xE2\xA4\x28\x14\x9E\x93\x89\xF5\xA4\x73\xA7\xDC\x6A\xA7\xC6\x43\xD3\x72\x9F\x90\x08\xCB\xA5\x43\x71\x9F\xB3\x20\x57\x7E\xC2\x74\x96\x60\x73\xB0\x61\x7E\xA7\x89\x3F\x80\x71\x7D\x7F\xA0\x21\x80\xA9\x6F\x59\x80\xAA\x70\x5D\x17\xFE\x7F\x24\xA4\xE0\x4F\x33\x00\x1D\xDF\x79\xA0\x9B\x61\x9D\x2C\x38\x84\x14\x1A\xA6\x7B\x46\x55\x36\x08\x76\x83\x3F\x4D\xD8\x99\x85\x7B\x83\x10\x80\x51\xAF\x0E\xAD\x9C\xF1\x81\x40\x8D\x95\x38\x4B\x14\x37\x18\x84\x30\x65\x81\x3D\x63\xA0\xA4\xEF\x5C\x82\xD4\x03\x19\x64\x06\xAE\x81\x80\x71\x43\x0A\x86\x0F\x72\xA0\x84\x47\x5F\x07\xBD\x67\x12\x2F\x4E\x83\x52\x69\x21\xF3\x0C\x1A\x7D\x38\x3D\x18\x48\x26\xAF\x85\x16\x48\x25\x70\x8A\x53\x06\x8D\x23\x97\xA8\x9C\x4F\x81\x2A\x88\x07\xA3\xAA\x79\x24\x0F\xB7\xA1\x68\x54\xA8\xA0\xC8\x7E\x0E\xA2\x79\x0C\x9A\x67\x83\x94\xB8\xA7\x40\x95\xA9\xB8\xA8\x97\xAB\x8B\xA0\x8C\x3A\xA9\xFA\x06\xA7\xA7\xF4\x2E\xAA\x3F\x4E\xDC\x09\xD3\x00\x9F\x58\x9D\x00\x98\x6C\x96\xAA\xCD\x46\x64\x1D\x70\x3A\x27\xBC\xAB\x70\x0E\xAB\xA7\x3E\xC0\xA8\x62\x71\xD1\x06\x95\xA5\xA9\xE0\x93\xAD\x82\x84\xCD\xAB\x42\x0F\xAC\x82\x40\xD1\xAB\xBE\x97\x9B\xAC\x9E\x27\x98\xAE\xA4\x7D\x73\x1B\x48\x26\xA0\xA1\x3A\x48\x25\x8C\xA3\xDF\x58\x06\xA8\x62\x39\x3A\xB2\x8F\xA9\x8C\xAA\x3F\x4F\x65\xAF\x19\x85\x90\xC8\x9B\xDF\x96\x5A\x98\x44\xA6\xAB\xC5\x9A\xAB\xBF\xA9\xD9\x1A\xB9\xAA\xAE\xB4\x7B\xE9\xA9\xE5\x5B\xAE\xBD\x31\xE6\x08\x2A\xAF\xAB\xB0\xAB\x4E\x77\xF3\x56\x2B\x1C\x9B\xF4\xAA\xBD\x95\x84\xBC\x9B\xBA\xA4\xAB\x4A\xAC\x8B\xAC\xFC\xAB\x59\x1E\xAF\x82\xAC\x00\xAD\x16\xA6\x3F\x2B\xAB\x86\x30\x18\x00\x86\x98\xAC\x9C\xA6\x4C\x5D\xA8\xB1\x04\x8A\x83\x72\xAD\x77\x95\x65\x0F\xAF\x6A\x98\xAF\xB9\xAA\x8E\xA9\xA6\xAC\xC8\x5B\xAA\xEE\x11\xB9\xAA\xB1\xB9\x0C\xE8\xAB\xCC\xA5\xB1\x95\xA5\x8F\x33\x1A\x8E\xAE\x87\xAC\x21\xAC\xC1\x79\x6A\x68\x9E\x12\x87\xA4\x3D\x9A\x89\xA7\x3A\xA4\x8A\x8D\xA2\x4D\x7D\x8C\x5A\xAE\x5A\x7A\xB4\xAA\xE0\xAB\x40\x9C\x31\x82\x82\x2D\x69\xB4\x12\x91\x0C\x22\x92\x81\x44\x5B\x6C\x5E\x6F\x50\xAD\x1F\x91\x5D\x93\xAD\xAE\x18\x4D\x4F\x06\x54\x82\xD7\x1A\x3B\x8A\x1F\x17\xAC\xAD\xA9\xC6\xA5\xA8\xA7\xAB\x87\xAA\xEB\x5F\x0A\x1F\xAC\x65\xAD\xCF\xA4\x86\xA9\x3B\x49\x0A\xF6\x9D\xB0\xBE\x9D\x29\xAE\x01\x9C\x31\x95\x64\x2E\x3F\x45\x22\x90\x00\x06\x78\x27\x45\x01\xA2\x83\x77\x85\x81\x24\x80\x18\x26\x9A\x16\x45\x44\x56\xD7\x0D\x04\x78\x34\x65\xA9\x99\xBE\xA9\x69\xA2\x47\x28\xD7\x06\x82\x5E\xAF\x54\x8D\x1C\x7A\xAD\x4C\x27\xCD\xA1\x29\x24\xAD\x6D\x81\xCF\xA1\xB0\xAD\xAD\xD9\xAA\x42\x07\x7C\x51\x04\x06\xAC\xB4\xA8\xB0\xB2\x3B\x82\x37\x7B\x27\x11\xA9\x9A\x27\xAD\x20\xA9\xF1\x2C\x6B\x61\x64\xB0\x6F\xB4\x81\xA5\x9B\xA5\xE7\xAA\x5C\x78\x27\x6A\x10\xBD\x78\xB9\xB5\x45\x35\xAF\xD9\xAF\xAF\xBD\xAC\xF3\x2A\x2B\x30\x80\xA1\xAE\xDC\xAB\xE8\xA3\xE9\x0C\x36\x0F\x88\x0C\x9B\x3F\xA5\xA7\xA2\x83\x28\x90\x8B\xB2\x41\x97\x1A\x7D\x1A\x4B\xB8\xA5\x89\xA0\xA2\x65\xA1\xA5\x69\xA4\x92\xB6\x91\x12\x1A\x36\xF3\x0F\xE7\x73\x7F\x4D\xAF\x42\x4F\xFA\x6F\x1A\x97\xAF\x7C\x41\xDD\x0B\x4F\xA9\xAE\xEB\x6F\xEA\xA8\x4B\x93\x08\xBC\x65\x51\x79\xB5\x83\xA5\x62\xAC",
"\xE4\x60\x73\x6D\x70\x05\x1A\xCC\xAA\xBB\xA0\xAC\xB2\xAF\xE6\xA9\xB9\xB2\xAE\x44\x90\x29\x0C\xB6\xB7\xAF\xED\xAF\x42\x07\x5D\x9D\x10\xA3\x53\xFA\xAB\x29\x97\x21\x68\x27\x7D\x07\x14\x38\xA9\x11\x55\x6B\x3E\x7B\xA7\x7F\xC9\xA5\x20\x80\xBB\xB7\x92\xA2\x04\x43\x27\x0D\xB7\x80\x11\x57\x6E\x36\xAC\x4B\x4F\x00\x87\x8C\xA2\x94\xA2\x8D\xA3\x11\x36\x19\x95\x13\xB0\x5F\xAE\xC2\x62\x95\x3D\xAC\xBF\xA6\x98\x01\x9C\xB9\x5C\xDE\x5D\xE8\x3F\xDB\x4C\x84\xC6\xA6\x43\x87\xBC\x88\xA9\x9D\x8D\xA4\xAB\x15\xA9\xA8\x52\xA6\xC5\x8D\xA2\xAB\x9C\x7B\xAB\x64\xA2\xAE\x9E\x84\x74\x75\x37\x81\x14\xB6\xAC\x44\x12\xC9\x89\x30\xB4\x7A\x8F\x32\xCA\x8C\x20\xA0\x82\x16\xA5\x0C\xB7\xC3\xBC\x9C\x09\x65\x90\x80\x9D\xA5\x8E\xD2\xA6\x8A\x57\x9E\x8D\x8B\x1F\x8D\x7E\x71\x32\xBA\xA8\x05\xA8\xD0\x83\x7B\xA8\x9F\x88\x9D\xF4\x9D\xC7\x23\x32\xBB\x8E\xDD\x9F\x74\xAF\x6E\xE7\x9C\x19\x91\x33\x75\x6E\xA7\xAE\xD6\x69\xBB\x4F\x72\xA8\xAF\xD2\xAC\x7D\x8D\xAD\xFC\x9B\xF3\x84\xAC\x85\x9F\xE0\xAF\x88\xAA\x6F\x84\x9F\x4C\xAC\x03\x99\xC3\x86\x89\x10\x90\xF7\x81\x3E\x9E\xA0\x6F\x96\x1F\xB8\x3F\xB4\xA2\xC8\x85\xF6\x67\x45\x1D\x90\x86\x97\xF7\x65\x39\x90\x9A\x7A\x93\x16\xB6\xC6\xB1\x7D\x68\xB3\xDE\x95\x41\x89\xB2\xBC\x2E\x4D\x9C\x9E\x91\x91\x9D\x8C\xF9\xAD\xD1\x70\xB1\xAB\x96\x1C\xB6\x9B\x86\x90\xCA\x6E\x1D\xB3\x7C\x9A\xB2\xB1\x74\xD4\x62\x99\xBC\xB1\x70\x44\x22\xB9\x71\x83\x94\x81\xB3\xD6\x68\x25\x80\x4A\x8B\x70\x47\x0A\x41\xB2\x0D\x1C\x91\x04\x9E\x41\x94\x3D\x47\x9F\xEE\x94\x7B\x90\x9F\xDE\x90\xAD\x77\x42\xAD\x9F\xA4\x9C\xF9\x60\x56\xAF\x6D\x6B\xA4\x9A\x96\x75\xB3\xAA\x6F\xB1\x4D\xAA\x75\x8E\xB1\x6E\xB3\xB7\xAA\xCC\xA7\xB2\xC8\x9F\xA9\xAC\xDB\x26\x9F\xCD\x93\x2E\xB9\x7E\xB2\x99\xA7\x63\x2E\x3D\x45\x8D\x9E\x63\xB1\x0C\x43\xCC\x9F\x6E\xC3\x8C\xB1\x86\xBB\x71\x9F\xA4\x82\x1A\x91\xBA\x03\x58\x45\x9E\xDB\x9D\xC5\xAC\x8D\xBC\xB0\xB5\x9D\xC7\x1C\x91\xC0\xB2\x2E\xB2\xCC\x8E\xB2\xE0\xB3\xFC\x80\x26\x9A\x4F\x62\x56\x94\x8E\x2E\x94\x89\xA7\xA8\xB1\x4A\xCF\x79\xB2\xEA\x9D\xED\x91\xCC\x9D\x58\x76\x91\x3C\xBA\x7E\xA4\xB1\xD5\xB1\x9F\x44\xAE\x4F\x94\xD2\x4A\xD4\x9D\xCC\xA0\xB2\xD6\x81\x21\x9D\xFE\x3F\x99\xCD\x45\x22\x9D\x56\xB0\xA0\x3F\x96\x60\x9C\xA9\x61\x6D\x90\x92\x39\x67\xCD\xB5\x6F\x02\xB6\x3C\xBD\x61\x72\x31\x56\x03\xB5\x9D\xCD\x8C\x93\x8C\xB0\x1F\x9D\x6B\x43\x8B\xA2\x90\xC4\x05\x4F\xA6\x6A\xE3\x56\x5E\xA2\xAA\x72\x89\xCA\xAF\x4B\xBC\x4E\x9D\x7E\xB3\x65\xB1\x9B\xAA\x53\xB1\x95\x5E\x54\x6A\x9B\x68\xAF\xCF\xAF\xF0\x3E\x9B\x45\x11\xA9\x95\xB4\x6D\xA6\x74\x9C\x72\x98\x42\xB9\xD2\x8E\x93\x2C\xB5\xF2\xAE\xD2\x99\x6D\xF6\x93\x46\xB5\xFE\x6D\x82\x65\x94\x93\x65\xBD\xAB\x93\xA7\x91\x7C\x99\xD3\x95\xAF\xAC\x7E\x6C\xAF\xD0\xB5\xAB\x31\x43\x4F\xBD\xBD\xB1\x6D\x42\xB4\x2F\x9D\xAB\x46\xB5\x84\x9F\x3A\xB2\x34\x9F\xB4\x26\x69\x87\x5D\xC7\x19\x92\x62\xB2\xFB\x9E\xCD\xB4\xB3\x2B\xB7\xB3\x84\x4A\x65\x3F\x57\xB6\xB2\x71\xD5\xA7\x56\x53\xB5\x04\x5B\xAC\x4B\x5A\xAD\x90\x56\xBF\x50\x88\xA2\x0B\x07\x2C\x90\xFA\x6A\x67\xC8\xB2\x33\xBC\x4A\x06\x6B\x50\x4D\x20\xA5\xD6\x94\x23\x67\xB6\x2F\x9D\x37\x80\xB4\x72\x99\x48\xBA\x7E\x9D\x58\x86\x30\x32\x9C\xCD\xB2\xB5\x28\xB6\xE3\x96\x4E\xAC\x99\x1E\x6E\x57\xBA\x33\x94\x93\xA0\x3E\x35\x99\x60\xAA\xB3\x9D\x9D\x3B\xB6\x34\x8F\x32\xAE\x30\x22\x0C\xF8\x60\x95\x4A\xB6\x67\xB9\x6C\xA6\x96\xE8\x91\x41\x96\xD3\x99\xB5\xA7\x68\x96\x67\xEC\x76\xB6\xAA\x93\x2E\xAA\xD7\xB0\xB4\xA4\x40\xAA\x69\x4F\x8F\x0B\x83\xA7\x12\xB9\x9E\x98\x99\x98\x9F\xB3\x61\xD9\x9E\xA0\xC8\x68\x4F\x4A\xAC\x72\x97\x47\xA3\x17\x4B\xDC\x80\x96\x75\x7B\x5E\xB7\xA1\x58\x6B\x8A\xA0\x2E\xA0\xAA\x54\x94\xD0\x87\x99\x69\x5E\x91\xB7\x44\xB6\x42\x98\xD6\xAC\xB2\xBF\xB7\x4D\xB7\xDD\x97\x6B\x11\x95\x87\x68\xD4\x97\x8E\x73\xB5\x19\xB5\xB7\xA0\xB5\xB5\xB5\xB2\x6B\xBC\xA1\x66\xC0\xB7\xBD\x0E\x4E\xBA\x93\xBB\xB6\x7C\xB9\xA7\x74\x93\x50\xB5\x7D\xB3\x28\x02\xB7\xBF\x67\x3B\x9D\xD5\xBC\xB4\x3B\xA5\x0C\x44\xDA\x86\x3C\x7D\x69\x51\xB2\xD9\xBC\x9B\xCD\xB7\x44\x9B\xDF\x9F\xB7\xFF\x92\x72\xBA\xE0\x80\xB2\xE5\xB4\x6E\xB7\xDE\xB2\x97\x20\xA7\x76\xBB\xDF\xB2\x95\x4E\x68\x84\xB9\xDC\x89\x0D\xB1\x6B\x78\xBB\x84\x95\xB8\x83\xB4\x48\x98\xDE\x98\xB8\xE7\x55\xD2\x24\xD9\xA0\xB4\xAA\xB4\x53\x96\xC8\x0F\x32\xCD\x03\xCA\x1B\xD9\x81\xB3\xB1\xB7\xD3\x96",
"\xAF\x83\x94\xF1\xB6\x73\xB3\xDF\xAF\x92\x16\xB9\x70\xBA\xDB\x8A\x9C\xE9\x90\x77\xB2\x27\x82\xB6\x1F\x95\x6E\xB7\xAD\x6A\x6A\x87\xB6\x71\xBB\xA4\x88\xB7\x08\xB9\x46\x92\xDE\x8B\xB8\xAB\x95\x83\xBC\xA4\x55\x42\x8B\x5A\x9E\x64\xB2\x49\x94\x0E\x98\x85\xB5\x20\x96\xB7\x3E\xB9\x7A\xB0\xE4\xBC\xB6\xF3\x90\x87\xBE\xDD\x86\x6B\xAE\x9C\xFF\x13\xDD\x95\x96\x5B\xBA\x7F\xB3\xA0\x46\x6A\x28\xBB\x31\x5B\xDE\x9C\x92\xBF\x8F\x52\xBF\xD9\xB4\xB6\xDA\x7E\x7E\xBD\xDF\xA6\xB7\x3E\xB8\x92\xB9\xE1\x81\xB9\x1B\xBA\x6F\xB9\xE6\xB8\xB9\xF6\xB5\x48\x9F\xE3\x89\xB9\x37\x95\xDE\x8E\x4F\x9F\xB8\x66\xBB\x84\xBF\x68\x52\xB9\xB7\x6B\x73\xBE\xE1\x8D\xB9\x58\xB9\x4F\x98\xE6\xBF\x94\x5C\xB9\xA0\xBE\xE5\x93\xAF\xBC\xB5\x95\xBC\xDF\xB3\x93\x8F\xB9\xE8\x29\xE0\x8F\xB9\x5A\xB8\xA5\xBA\xE6\x80\xB8\xD8\xB6\xF4\xAD\xD5\xAF\xB9\x7F\x71\x67\xB6\xE3\xAF\xB7\x0E\xAD\x8E\xBE\xE0\xB7\xB9\x3D\xB9\xA0\xBA\xE7\x9A\xB7\x7C\xB8\xEA\x95\xD5\x84\xB9\x01\x6A\x89\xB7\xA5\x73\xBA\xC7\x51\xA1\xBB\x39\xA2\xA5\x9E\xBA\x93\xB9\xE5\x8B\xBA\xB7\x72\x9D\xBC\xE9\xA4\xB9\x08\x96\x84\xB0\xEA\x94\xB7\x82\x6B\xA8\xB5\xEA\xBD\xB5\xB5\xB9\x98\xBD\xDD\x95\x85\xD9\x68\x46\x91\xE9\xA6\x98\xE4\xB7\x9F\xB1\xEB\xBF\xB7\x82\xBB\xA5\xBD\xD5\xAB\xB8\x1C\x9E\x5A\xB6\x34\x86\x32\x98\x31\xEE\x93\xE3\xB2\xB3\x35\xBA\xED\x97\xE3\x90\xAC\x06\x6E\x68\xB8\x9E\x8B\xB9\xFC\xB0\xA4\xBF\x2C\x05\x26\xD8\xBB\x88\xB5\x20\x93\x77\xF7\x05\x75\x75\xB1\x68\x05\x58\x06\x0D\xA0\x42\xA5\x31\x25\x94\x6F\x7D\x54\xA7\xA9\x16\x19\x37\x18\x85\x54\xA0\x6C\xAB\x0D\xAD\x55\xB9\xA0\xFE\x9F\xD1\x81\x4E\xBD\xA0\x04\x7C\x01\xA6\x56\x8F\x96\x7B\x95\x64\x90\x17\x53\x96\xF3\x6B\x72\x9E\x80\xAA\x82\xEC\x99\x61\x97\x8B\xB4\x95\x50\x9F\xA6\xB9\xDC\x6A\xA0\xC2\x96\xC5\xB0\xFA\x18\xBC\x0C\xA1\xB8\xAD\x51\x9A\xB4\x38\xB6\x08\xA0\xF2\x9C\x46\x27\xA3\xC4\xB4\xF2\x89\x97\x09\xA3\xC5\xBD\x81\xB4\x6B\x1F\xA0\xCB\xB3\xE9\x34\xA0\x2C\x6F\x04\xAE\x59\x9E\x60\x40\xA2\x92\xBD\xF0\x71\xB9\xFC\x97\xBA\xBB\x5A\xA0\xB7\xF4\xBA\x12\xA5\x35\xB0\xA1\xEB\x3C\xBE\xB4\x1F\x3A\xBB\x73\xA2\x5F\x23\x5B\x9F\x4A\x0A\xBE\x47\x02\xC7\x3D\x9F\x49\x06\x1C\x3A\x73\x50\x51\x52\x96\x1C\x31\xDB\xB2\x31\x18\x65\x7D\x15\xAE\x5D\x8B\x73\x3C\x06\xA5\xA3\x99\x11\x86\x90\x22\x9B\x49\x3F\x95\x93\xB9\x60\x92\x83\x98\x90\x49\x04\x67\x9B\xCC\x5E\xBD\x5F\x96\x63\x94\xD1\x15\xBD\xA8\x60\xD6\xB7\x17\x1A\xBD\x81\x5E\x6F\x3D\xF5\xB3\xB3\x59\xBE\x42\xBE\x47\xA3\xBD\x6D\x39\x63\x98\x83\xBC\x83\x12\xB5\xCD\xB0\xFA\x16\xB4\x6C\xBE\x77\x96\x59\x8F\xA0\x06\x9D\xDC\xBE\x03\x76\x96\xC8\x96\x79\x9C\xC5\xAB\x97\xBF\x1A\x99\xA5\x85\x5E\x0C\x1B\x10\x16\x68\xF9\x83\x97\x6C\xA8\xB8\xBF\x7C\xAC\xB5\x89\x9F\x28\x33\xCA\x0B\x03\x40\x0F\xB9\xB7\xD0\xA1\x75\x33\x23\x58\x79\xC9\x9F\xB5\x0E\xAD\x28\xBC\x2D\x83\x70\xA4\xB0\xD9\x92\x36\xA8\xA1\x8F\x74\x5C\x7D\xFA\x9B\x75\x74\x77\x48\x7B\xC5\xB6\x64\xB6\x0A\xEB\xB9\x91\xB8\xB1\xC9\xB1\x0F\x86\xD5\x60\x9F\x20\x76\xC4\xA7\x93\x7C\xBE\xE5\x9E\x32\x70\x6B\x9C\xB6\x67\x93\x91\xAB\xCF\xBB\x6A\xF5\x9F\xAB\x4B\x96\x78\x9F\xED\x97\x08\xA9\xD0\x97\x97\xF8\xB7\xEB\xB9\xD8\x90\xB4\xBF\x6D\xEB\x99\xEC\xAF\x9E\x59\x67\x20\x9E\xFB\xA7\x9F\xE9\xB9\x30\xBE\x2C\xB4\x53\x77\xB6\x55\xBB\xE3\xA6\x92\x25\xB8\x5F\xB2\xD3\x95\xB5\x35\xB4\xAC\xB1\xFF\x93\xA8\xB2\x92\x4E\xB4\xE8\x84\xBF\x8A\xB6\x58\xBD\xD8\xAB\x6F\x8F\xB7\x79\x67\xE6\x8A\x98\xCF\xBC\x8D\xBD\xDE\x89\xB4\x46\xBE\xDD\xA5\x15\x11\x9E\x42\xBF\x81\xB1\xBA\x26\xB6\xE9\xB1\xB8\xA8\xEA\x8B\x93\x44\xBF\xAA\xB5\xAB\xBC\x9B\xAE\xBB\x94\xBF\xFE\x8E\x94\x45\xBB\x75\xBC\xEB\x84\x94\xC6\xBA\x93\x6C\xE1\xB8\xBA\x11\x9F\x9A\xB3\xDC\x89\x0D\xE3\xAE\x10\xA0\xEC\xA0\x26\xBD\x90\x73\xB5\xEC\xBA\xB8\x0F\xB8\xB2\xB6\xED\x8A\xBB\xC3\xB9\xDB\xB5\xDD\x8E\xBB\xDE\xB8\xAD\xB0\xE6\xA2\xC0\xD3\xBA\x95\xB5\xE6\x92\xB7\x8A\xBA\x0D\xCD\xEC\x80\xBA\xDC\xBB\x89\xB9\x5E\x83\xB8\xDA\xBE\x9C\xB4\xF0\x50\x9E\xCA\x8F\xD3\x86\xE8\x96\x9E\xC9\xBC\x78\xBA\x79\x8F\x0B\xE7\xBF\xF6\xB7\x00\xCA\xC1\x09\xC0\x58\xB5\xC9\x8D\x69\xB3\xA7\xA1\xB2\xEF\x8D\x77\x49\xA3\x46\x99\xED\xBF\x94\x4E\xBC\xBB\x9F\x84\xBB\x30\x45\x95\xBF\xBD\x2B\x85\xC0\xE8\xBB\x15\xC2\xDB\x8F\xB2\xB3\xBE\xF1\x83\xE9\x13\xB2\xDE\x6F\x16\xC5\x9F\x49\xA7\x93\x9F\xDF\x5C\x3C\x83\x94\x9E\xB3\xDC\xA8\xB2\xB2",
"\xBE\x92\x78\x33\xBF\xFD\xA0\xB5\x80\xC1\xF0\x77\x93\x8B\x9B\xA9\xB2\x2D\xB7\xB5\x66\x96\xAD\xB3\x1A\xB7\xBD\x70\xBD\xF7\x05\xD8\x65\xCB\x82\xB2\xB7\xB2\x82\x83\x01\xC8\x91\xE2\xB9\xFC\x8D\x47\xB8\xBE\xA9\x9A\x0C\xBE\x68\x77\x90\x35\xB3\xAE\x95\xFB\x82\x75\xCF\xB3\x1E\xB1\xCD\xAB\x91\xD3\xB2\xF3\xBB\xC8\xB2\xB6\xE9\xBE\x3C\xB0\x07\xC7\x86\x72\xC0\x46\xA8\x8D\x97\xA1\x55\xC2\x12\xCD\x0A\xEA\x9F\xAF\xC3\x3D\xB7\xA5\xBA\xB3\x76\x83\xE9\x63\x2A\x99\xBF\x97\xC0\x4C\x9F\xCD\x8E\x82\x62\xBC\x43\xB8\xE8\x1F\xB2\x84\xC1\x44\xBB\xD8\x98\x50\x14\xB4\x64\x73\x4A\x2F\xA0\x0D\xA3\xE3\xB5\x02\xDC\xB4\xF3\x89\x12\xCC\x0A\xCD\x8D\x77\x8E\xAF\xB3\x08\x88\x7F\x7B\x8E\xB7\xA0\xFE\xA2\xA8\x01\x73\x73\xA0\xFB\xB4\xAD\x4C\xB2\x32\x82\x9D\x88\x8E\x85\x51\x61\xA8\xE3\x44\xB3\x05\xA8\x42\xA7\x94\xA0\x3E\xB1\x8D\xDB\x92\x01\xEC\xC1\xAB\xBF\xCF\x49\xD8\x5F\x7E\x6D\xB3\x20\xC1\xFB\x9C\xB2\x0A\xC0\x22\xCB\xF8\x91\x76\xAA\xC1\xF5\x99\xD4\xAE\xC1\x16\xC3\x00\xB6\xCF\xA2\xB3\xF6\x8E\x22\xC5\x07\xE9\x9E\xFA\xC0\x39\xCC\x0F\xE0\xB5\x7D\xC2\x37\xC9\x0C\xFA\xB1\xE1\xC2\x20\xC5\xB7\x7F\x81\xD9\x8F\xD7\x9C\x2A\x6A\xB2\xD1\x6F\x6A\x9D\x08\xD6\x6F\x84\xB0\x14\xA6\xC8\x9B\x6F\x0A\xC6\xFA\x85\xB8\x76\xC2\x23\xAC\x20\x2B\xEB\x48\x7B\x1B\xC2\x15\x7D\x6E\xA4\x71\x04\x9C\x6C\x93\xE9\x26\x9B\x50\x71\x22\xBB\xE7\x82\x41\x46\x72\xB2\x71\x6E\xA3\x71\x9E\x20\xB9\x9E\x48\x93\x9C\xE8\x98\xBD\x93\x0E\xFF\xC1\xC0\x40\x29\x78\xC5\x74\xBE\x43\xC6\xEA\xAD\xC5\x5B\xA0\x5F\x71\x4B\xC2\x70\xB0\xC4\x10\x9D\xB9\x97\x70\xA7\x9B\x09\x9C\xA6\xB9\x09\x4C\x9C\x05\x8B\x53\xCD\x13\xF1\x72\x7C\xB4\x50\xC5\x15\xDD\xB5\x98\x4C\xC6\x9D\x11\xFC\x98\xD6\xC3\x49\xBB\x8E\xB8\x9C\x44\x9C\x48\x01\xA2\x91\xA7\xD1\x8A\x20\xAF\x72\x83\x9D\x20\x72\xCC\x9D\x37\xA7\xC4\xD7\xC2\x8B\x77\xDD\x47\x11\x74\xC6\x59\xC9\x84\x4A\x1E\x89\xA1\x90\x9A\x63\x81\x0C\x79\xC4\xF4\xBB\x17\xCC\x98\xB8\x15\x32\xAC\x61\xA6\x91\xC1\xC1\xB6\x9C\xCD\x53\x36\x2D\x39\x83\xA6\xCE\xBF\x1F\x19\x23\xD9\x06\xCE\x5C\x20\x01\xC6\xEA\xB3\x10\xD9\x3C\xB2\xC1\x95\x86\x8B\x17\x89\x63\xC7\xB1\xA5\x16\xC2\xC6\xC3\xBE\x9A\x97\x11\xDF\x74\x8F\x4D\x60\xC6\x00\xFF\x4C\xED\x71\x52\xC5\xBE\x80\x43\xF2\x72\xBC\x36\x1A\xA0\x3E\xE4\x72\x64\xC3\x68\xA0\x44\x10\x21\x2D\xC5\x17\xC6\x3C\x8B\x2B\xE7\xBA\x23\x26\xC6\x6D\xC2\x5D\xC8\x60\x8A\x05\xBC\xC5\x3D\xC3\x96\xAB\xC3\x9B\xC1\x31\xBB\xDF\x71\x5C\xB6\xC6\x5E\xC3\xE9\x13\x9A\xBC\x9A\xC5\x15\x6A\x93\xA5\xDD\x53\xA8\x9A\x69\xB9\x9A\xAB\x76\xE8\x8F\x69\x94\xC7\x97\x9A\x53\xA0\x6C\x93\xC7\x29\x79\x75\xCE\x73\x8F\xB5\xDE\xBF\x68\xC5\xAC\xAC\x9A\xCD\x46\xAB\x98\xB5\x74\x97\xF9\x42\x7E\x93\x29\x3F\xC6\x4E\x53\xC0\xBB\xF9\x87\x05\x9D\xBE\x21\x4C\x1E\xD8\x4F\x91\x63\x82\x99\x61\x99\xB9\x10\x99\x7F\x04\x18\xDA\x98\x0F\x9B\x61\xCE\xB9\xAE\xC7\x79\x7E\xC7\x00\x5D\x2A\xA9\x25\x9B\xE1\x10\x61\x9C\xA2\x28\x99\xFD\x0A\x1C\x07\x1E\x64\x04\x92\x9A\xF9\x81\xC8\x47\x04\x52\x18\x85\x4E\x99\xA1\xBF\x93\x0D\x17\xF7\xC5\x87\x1F\x0E\x15\x64\x80\x99\x18\xCB\xE4\x1F\x20\xEA\x16\x1E\x0D\x54\x97\xEB\x4E\x18\x4D\x9B\x5F\xCE\x1B\x08\xC8\xEC\x28\xC3\x1F\xD0\x4F\xC7\x98\x79\x7F\x07\x1D\xDD\xC7\xD9\xC7\x63\xA2\x9C\xA8\x62\x75\x9E\x21\x4F\x22\xD6\x74\x21\x07\x56\xAF\xCC\x4E\xC6\x89\x1F\xA2\x5C\x07\xA3\xC2\xF7\xA6\xAA\x8A\x5C\x77\xC8\x00\x56\xE8\xB1\xB3\x56\xB6\xD8\xB0\xAD\x7D\xC7\x00\x01\xAF\xB7\xEF\xB9\x12\xD7\x22\x2B\xC6\x10\x4F\xA0\x96\x50\x3B\xC7\xB8\x9C\x15\xF3\xC4\x53\xC5\x4D\xC7\x8B\xB5\x6A\x11\x51\x4E\xC5\x20\x95\xC9\x0F\x9E\x4F\xC7\x20\x9E\xC5\x95\xC1\x8A\xBE\xEE\xBA\xC1\x55\x73\x4E\xC7\xC7\x80\xC9\x3E\x6A\xBF\x97\x59\x40\x9C\x59\xC6\xC3\x90\x15\xE2\xC9\x90\xC0\x99\xC6\x13\xFA\xC0\x57\xC6\x53\xC2\x27\xDB\xC5\x98\x73\x98\xC2\x6F\xA5\xC9\xBD\xB9\x1E\x76\x87\x1D\xC6\xB8\x19\x62\xC5\x72\x93\x5B\x32\x21\x94\xC2\xFA\x6B\x9B\x46\xC4\x4F\xC9\xC8\x7D\xC9\x75\xCB\x9F\xC7\x27\xDC\xC9\x45\x71\x4B\xC0\x26\xF3\xC9\x57\xC9\x7E\x8F\xC4\x76\x71\x5B\xC8\xFD\x3A\xA8\x7E\xC1\x4A\xC5\x21\x78\x6F\xA5\x72\x0D\x74\x9B\xCD\x6F\x8C\xC5\xFF\x9A\x9E\xCC\xCB\x61\xC9\x99\xC8\x9D\x06\x27\xDD\xCA\x8C\xBB\xFB\x59\xB5\x5A\xC5\x8F\xC9\xC1\x9E\x27\xC8\x9C\x80\xCA\xA7\xCA\x5C\x62\xC5\xFF\xB1\x8B\xB7\x78\xA0\x95\xA7\x60\x26\x35\x23\xD6\xC6\xEC\xB6\x3D\xCA\x77\x92\x8D\x12",
"\xC7\x3E\xC1\xFE\xB9\xA6\x51\xC0\x5C\x42\x78\xBD\xCA\xA4\xBF\x91\xCE\x2B\xE2\x61\xA1\x5A\xD2\x11\xD7\xA7\xC6\x53\x3C\x13\xCF\x94\x44\xB8\x46\xAE\x81\xB2\xB2\x4D\xCB\x88\xB9\x0F\x13\x37\x32\xC3\x93\xB7\xB4\xC6\xCD\x99\xC2\xC5\x92\x21\x3E\xCA\x22\x9E\xC4\xC8\x9C\xB2\xEF\x27\x9E\xC6\xB1\xB2\xCE\x10\xCB\xCB\x4E\xAC\xB8\xCF\x05\xE7\x8F\xE5\xBD\xDF\x84\xCD\x8A\xC1\x48\xCB\xA2\x96\xC8\x3B\x32\xE6\xB8\xBA\xCC\x7B\xBB\xBE\x71\xAC\xB2\xCC\xFF\x9F\xC3\xC7\xA6\x45\xC8\x26\xDA\x8D\x8D\x8D\xDC\x61\x7E\xA1\x2E\xCA\x9C\x54\x7C\x7C\xA8\xB6\x5B\xB1\xBF\xCD\xD6\x81\x5E\xC5\x30\xF5\x9D\x2E\xE9\xBA\x09\xAD\xF0\xBB\xC0\xB1\xCB\x07\xCF\x44\xC6\xFC\x9F\x9F\xCE\x43\xC3\xCA\x85\x0B\x9F\xBD\xBF\xBC\x16\xBF\xB5\x45\x79\xA0\x00\x00\x89\x8B\x51\x6E\xA3\x15\xAF\x21\xCF\x95\x96\xA0\x26\xA5\x28\x6D\xCC\x28\xCA\x27\xA5\x17\x76\xA2\x17\x04\xC5\x23\x8A\x99\xA3\xA8\xA5\xAD\x34\x89\x96\x18\xAA\x0E\xCD\xC4\x30\x7C\xCC\xF4\xC6\xFE\x3B\x8D\xBD\xA3\xDD\xA0\xB1\x38\x7A\x28\xA3\x73\x53\xD1\x8A\xE4\x61\x29\xFA\xA2\x3C\x4C\x8F\x9D\x1E\x47\x7A\xF4\xB6\x07\xB8\xAD\xAC\x6B\x3B\xA6\xF0\x31\xA3\x21\x84\x58\x14\x8F\x89\xA4\x50\xCE\x3C\x4E\xC3\xA7\xA5\x38\x78\x81\xA8\xE3\x44\x91\x08\xAA\xFF\x7A\xA0\xB3\x3D\xE9\x58\x1E\xCD\x12\xD8\xA8\x32\xC4\xEF\x24\xA1\xB7\xC4\x8B\xCA\x46\xAB\xA1\xA5\xA4\x83\x7B\x86\xA9\x92\xBB\xBF\xB9\x83\x5A\xAB\x0B\x90\xC7\xC8\x81\x29\xC5\x11\xF7\xB1\x26\xA9\xA3\x78\xA2\xB8\xB0\x26\x71\x14\xB0\x7F\x82\xBD\x97\xA6\x34\x8B\xB8\x9A\xB0\xB1\xAD\xFF\xA3\x58\x5E\xA6\x13\x70\x52\xAB\xA3\x8A\xA5\x0F\xA6\xEE\x72\x95\x98\x7A\x50\xA5\x56\xAB\xFB\x76\x7D\xB4\x7B\x55\xA3\x22\xE2\xCE\x9F\xCD\x62\xAC\x95\x8E\x8A\xA9\x51\x62\x8D\x00\xEB\xC0\x89\xCF\x70\x06\xF3\x7D\xA8\x1C\x83\x8F\xAF\x9F\x9C\xA7\x00\x01\x31\x33\xA4\x97\xA7\xE1\xA6\x78\x43\x02\x9A\xCD\xA5\x81\xD1\xA3\x16\x87\xAD\x50\xC1\x93\xA0\xCE\x6E\xA7\x71\x54\x7C\xA0\xCE\x75\x55\xF3\xA6\x95\xAE\x29\xB5\x81\x59\xAA\xF1\xB0\xF6\x4C\x55\x37\xA7\x3F\x86\x1B\x7C\xCE\x00\xA9\x6F\xA8\x1C\x35\x58\x3A\x58\x98\xA7\x63\x36\xCE\xE0\xA5\x85\x04\x44\xBB\xCE\xB4\xCC\x11\x85\xA4\xB7\x05\xC0\xCF\xD8\x52\x3C\xF3\xB0\xDE\xC8\xD2\xA6\x3C\xFC\xC2\xC8\xCE\x0D\x82\xF5\x5A\xCD\xCC\xCD\x1E\x44\x9F\xAC\xA8\xE4\xB1\x90\xC6\x60\x9A\xA9\xD3\xCC\x5D\x75\x3D\xC2\x81\xE5\xCD\x98\xAA\x3D\xD0\x55\x21\x80\xF8\xCD\x84\x3D\x58\xAE\x30\xF9\xCE\x3D\xC2\x7D\xBE\xCF\xCD\x79\x3E\xED\xCE\x60\xA4\x4E\x9E\x3E\xE8\x91\x75\x81\xFC\xCA\x43\x72\x80\x64\x43\x0B\xB7\xF6\x8F\xA9\x55\xAA\x15\x8A\x35\xD1\xCF\x5F\x7F\x85\x14\x3D\xE4\x86\x12\x71\xBA\x88\x3D\xE8\x7D\xD5\xA1\x8F\x10\x5D\x14\xAE\xAE\x36\x0A\x11\x91\x18\x7A\xDC\x20\xDC\xAC\xB7\xAA\x3E\xA4\xCF\x23\x3D\x10\x32\x4D\x2C\xD3\x7B\x1D\xB7\x84\xCE\x25\x58\xD0\xB3\x3F\x08\xC3\xCA\xC9\x73\x6C\xEE\xA6\x4A\x02\xB3\xD9\xBD\xB3\xBB\x92\x32\xD1\x44\x0B\x43\xC1\xAA\x36\xAC\xA1\xA7\xA7\xA9\xAD\x19\x60\x00\x02\x08\x3B\x86\xEA\x82\xE5\xC4\xF0\x72\xAB\xC7\xB2\x78\xC4\xC7\x86\xAB\x0E\xAF\xCA\xA2\x26\xBB\xAB\x48\x24\xBD\x82\xBA\xAE\xAD\x23\xAF\xA3\xA2\x31\x9A\xD1\x79\xB2\x10\xDA\xB2\xBB\xB0\x61\xC7\x50\x3B\x4A\x1A\xAA\x77\x05\xCC\xA4\xEF\x62\xD1\xC1\xAC\x19\xD6\x2C\xE7\x05\x17\x6C\x52\x56\xAD\xB8\xD1\x69\x05\x18\xD7\x23\xA8\xAD\x76\xD1\xEA\x42\xAA\x90\x0C\xA4\xAA\xCB\x59\x60\x68\xAA\x84\xD2\xAA\xAD\xB3\xB4\xD1\x1B\xAE\xF0\xA7\xAB\x4C\xC0\x4A\xB2\xBC\x33\xB4\xBC\xC8\x4B\x5B\xFA\xCC\xA2\x6D\xCF\x50\xC0\x1F\x8F\x06\x66\xCA\x17\xC3\x6A\x9F\xBA\x9A\xA6\x51\xAD\xEC\x40\xB9\xAB\x3D\x56\xAD\x22\x88\xB5\x8F\xB0\x5A\xAE\x29\xD7\x6C\x46\x27\x92\x81\x08\xB5\xDA\x95\x82\x8B\xD3\x1F\xDB\xBB\xB2\xAE\xC0\xBF\x15\x14\x1F\x00\xD1\xF3\xCA\x1A\xDA\x00\xF9\xAB\xA1\x2F\xC4\xA7\x1F\x3E\xD1\xDB\xA9\x23\xD1\x48\xE1\x2E\x03\x7C\xAE\x90\x23\xCC\xB9\xC4\xD3\x73\xC0\x4C\xEC\xAA\xFC\xAF\x82\x1D\x61\xB6\xC5\x82\x80\x23\xD4\xB3\x8E\xD2\x24\x05\x12\xDD\x04\xE0\xCA\xAB\xC4\xBD\xCC\xEE\xB5\x77\x76\xA9\x0E\xD3\x90\x15\x35\x8B\xCE\xF9\xA1\x91\x23\xD2\xC3\x99\xE1\xAD\x31\xF1\x43\x89\xAD\x92\xA5\x44\xCA\x46\x77\x35\xC8\x84\x4E\xFF\xCF\x93\xAC\x75\x52\xC1\xB1\xD2\xC1\xD3\x34\xD3\x4C\xD3\x3A\xA5\xAD\x7E\x27\x4D\xF2\xCB\x44\xC5\xE8\x2C\xBA\xB7\x68\xAE\xAD\xF2\xBB\x4E\xF6\xA8\x71\x7F\xF0\x34\xBB\xA2\x11\x73\xD2\x2C\xD4\xBF\x96\xD1\xA1\x52\x91\x0F\xB1\x58\xA4\x36\x71\x60",
"\xBA\xEC\x5C\xAF\xFF\xBD\xDC\x64\xD8\x9C\x18\xBF\x1A\x4C\xB8\x6A\x90\x07\xD8\xAF\x2A\x1A\xBD\x93\xD4\x83\xBD\x45\xD0\xAC\x5F\xAF\x34\x57\x66\x32\xBE\x82\xC5\x0D\xC5\x3F\xDB\xD8\x90\x23\xE9\xAD\xEE\xBF\x4B\x20\xD2\x79\xAA\x15\xD0\x8A\x70\xAF\xEF\x17\x32\xDF\x24\xB3\xD2\x0C\xD5\x4F\x70\xC0\x99\xB0\xC3\x59\x61\x88\xDD\x45\xB0\xF4\x07\x01\xB3\xC1\x89\xB0\x32\x09\xC1\xCD\x39\x8D\xB0\x73\x3F\x3A\xDA\xC0\xB3\xD3\xB2\xAD\xB5\x55\xC1\xAB\xBD\x1E\xB1\x52\xD8\x4A\xC4\xC3\x0B\x15\x54\xD8\xA7\xAE\xD2\x4D\xBB\x08\xB2\xBB\x92\xD3\x96\xAE\xE0\x70\x2C\x8B\xCC\xE3\xC4\xC5\x74\x15\xB4\x26\x7E\xD3\xED\xAF\xAE\xBD\xAC\x51\x62\xA1\xAC\xBB\x8A\x9E\x00\x02\xFE\xA0\xBC\x82\xD3\xB4\xD2\x4E\xD5\x21\x0D\x5B\x53\xD7\x00\xBF\x53\xC2\x4D\x6A\x25\x42\xD9\x65\x4B\xD5\x80\x07\x43\xD4\x49\xC5\x5D\x0E\xB0\x4C\xD2\x4E\xD5\xAE\x57\xD6\x95\xA6\xC1\x91\xD5\x74\xD6\x60\xDC\xC1\x95\xD5\xCA\x4D\x57\xD0\xB9\x58\xD5\xC1\xBA\x56\xD6\x45\xE6\xD5\x3C\xAD\xFD\xAD\x44\xE9\xAD\xC5\x30\x19\x04\x45\xCB\xAA\xF7\xD0\xEF\x28\x45\xFC\x88\x68\xD1\xF1\xBC\x45\xF4\xAD\x5E\xD3\xAE\xC0\x46\xC9\xD4\xF5\xD2\x63\xDE\xBF\xA5\xD1\x3F\xD1\x16\xD0\x56\xDB\xD1\x07\x65\x69\xDD\x46\xED\xAC\x6F\xD3\xCB\xA1\x47\xEF\x21\xA8\xD4\x33\xD8\xBB\x94\xD3\xAD\x04\x1F\xDA\x06\xC6\xD2\xF0\x6B\xB5\xAA\x5A\xC0\x92\xA9\xD5\xB7\xA3\xE9\x1E\x34\xA9\xA8\x1B\xBC\x7E\xAE\x9C\xFA\x04\xE9\x0B\x57\x36\xD4\x3B\xAF\x18\xD1\x57\xFF\x4C\x3F\xAD\x24\xD2\xB4\x97\x88\xF6\xA6\x4B\x89\xA4\x9D\xC1\x99\xD3\xDC\x3B\x49\xEA\xC6\x9B\xB2\x36\xDE\x49\xC2\xD4\x75\xD7\x94\x62\xB5\xAF\xD3\x32\x83\xD5\xAF\xC8\x6B\xD3\xD1\x58\x24\x8C\x4A\xD1\xAE\x98\x4F\xB5\x54\x4F\xFA\xD6\x67\xD7\x74\xD7\x4E\xC3\xAB\xB8\xD2\x4A\xD3\x5A\xE8\xAC\x11\xAF\xF0\x3E\x4B\xD4\x16\xB9\xD7\x4D\xDB\x50\xCE\xD3\xAB\xD5\xC6\x35\x4C\xF1\x40\x15\x74\x40\x5B\x9B\x8A\xD3\x01\xD9\x74\xD5\x47\xF6\xD7\xBE\x86\x3C\xDD\x57\xC6\x9B\xE0\xD5\x29\xB2\x5E\xFD\xC3\xE4\x51\x37\xD2\x61\xCA\xD1\x34\xD1\x38\xD6\xF0\x00\xAE\xAB\xD0\xD5\xA3\xB8\x98\x62\x59\x5B\xE1\xAF\x91\x07\x80\x89\xD4\xE3\xA6\x90\xAE\x22\x88\xAE\x3B\xD2\xB8\xAB\x3D\x5E\xA8\x12\xD8\x91\x0D\x25\x5B\xD6\x42\xDC\xB9\xB9\xD4\x3F\x4D\x3E\xD2\x1E\xA1\xC7\xAF\xD5\x1A\xDF\x4F\xCF\xAF\x9F\xD2\x8A\xDC\xBE\x84\xD8\x4B\x88\xE8\x37\x50\xCA\xD2\x35\xD9\x71\xD4\x4D\xC4\xAF\x06\x7F\x51\xDF\x57\xFA\x4F\x11\xD6\xFE\xBB\xBD\xA1\xD4\xC4\xC7\x45\xD6\x64\xA6\xBA\x78\xCB\x6A\x64\x4E\x59\x36\xE1\xAE\x62\x79\xB5\x54\xD4\x55\xD8\xA1\x85\x52\xD9\xAF\x1D\xA8\x3F\xD1\x2A\xEB\xD4\xB9\x90\x18\x51\x64\xD4\xCE\xFC\x83\x11\xD7\x1C\xF4\xD4\x4C\xD6\x15\xDC\x55\xC6\xD7\xA6\x9C\x57\x29\x62\xEC\xD9\xE0\xB3\x5D\xDD\xD8\xB9\xD5\x6E\xD8\x51\xD1\xC1\x93\xD8\x4E\xD8\x2F\xC5\x0A\x81\xD6\x42\xDB\x87\xD5\x54\xE6\x24\x4D\xD4\x05\xB5\xDE\x5D\xB0\x8D\xD7\x9D\xDD\x53\xE1\xBD\x8C\xD6\xA7\x45\x58\xD8\x94\x92\xD4\x91\xD1\x56\x8D\x8C\xBB\xD7\x3D\xDC\x49\xCF\xC4\x0E\xAD\x7F\xDD\x13\xA4\xAB\x09\xD4\x65\xD2\x5D\xD6\xD1\x69\xD4\x20\xD8\xBF\x81\x5E\x6A\x83\xFE\xA9\x69\xD0\xD8\x4C\x68\x24\xD3\xFC\xB2\x81\xD8\xD7\x25\xB8\xBC\x9D\x8C\xDC\xD6\x7A\xAA\x49\xD8\xD3\xE1\xD6\x2E\xDA\x05\xE4\xD7\x8A\xD6\x79\xD2\x4A\xEF\xD8\xF7\x4D\x29\xDF\xC4\x27\xD2\xBD\xD9\x3C\x43\x6C\xE1\xD8\x5D\xAC\x8C\xD7\x60\xB0\xD2\xB2\xAE\xA8\xDF\x60\xE4\xDA\x97\xD7\x5A\xDF\xC8\x06\x32\x6E\xD6\x83\xD0\x57\xF8\xD8\xD9\xCA\x9D\xDC\x53\xCB\x7F\x76\xD7\x95\x6B\x67\xDE\x0C\x08\xB1\xEA\x4F\x67\xF8\x65\x0C\xB3\x93\xDF\x12\x84\xDA\x78\xDB\x60\xDD\x42\xC5\xD6\x51\xA8\x7D\x82\xB8\x58\xB0\x93\xCF\xA3\xDD\x47\x8C\xDA\x92\xD8\x08\xBB\xAB\x55\xDA\xCE\x1B\x42\x0E\x6C\xD7\xDB\x96\xD9\xA9\xD8\x53\xD6\xDA\x3A\x5F\x23\x3B\xB6\xAF\xD5\xF6\xD0\xAB\xDC\xBB\x23\x04\xD6\xD3\x62\x71\x5A\xCA\xB6\xFB\xD5\x20\xA7\xB7\xAB\xA7\x79\xAF\x86\xDE\x42\xE0\xD3\xDA\xC5\x9F\x40\x62\xDC\xAD\xC2\x19\x39\xD1\xF1\x06\xAE\xB6\x0D\x8B\xD0\x88\x68\xD8\xDB\xD8\x8D\xAC\x4E\xDE\xDC\x0B\x04\x7A\xD7\xAB\xAD\xC5\x65\xB6\x35\xD8\x94\x1F\x83\xB0\xAC\xC0\x12\x0E\x80\xC8\x20\xCA\x81\x72\x10\x18\x61\xF6\x81\x24\x6B\x6F\xC5\xDC\xD0\xDB\xFC\xA7\x63\xC0\xDC\xA8\x61\xAA\xD4\x70\xC3\xD7\x3E\xAD\x34\x95\x75\xAD\xDB\x93\xD2\xA0\xDA\x3E\xD1\xD0\x4F\xC2\xAD\xDE\x5D\xF8\xDA\x16\xDA\xAE\xDD\x69\xFC\xDA\x85\xDA\xAF\xDC\x6A\x00\xDB\x88\x83\xB1\xD2\x55\xC5\xDB\xED\xD5\xE0\xAF\x5E",
"\xCA\xDB\xF1\xD4\xB3\xD3\x59\xD1\xDB\xB2\xAE\xBF\xD3\x60\xF9\xDB\xFF\xC6\x1C\x3D\xC7\x03\xDC\xD6\xD8\xCE\xD6\x69\xEF\xAD\x33\xDB\x35\xDC\x2D\xD2\xAA\xAB\x98\x69\xC9\x61\xE9\xC3\x6A\x06\x35\xDB\x43\xFF\xAD\xAA\x3C\x39\xD4\xB8\x9B\xDC\xE7\xD2\xE3\xA1\x32\x8A\xAE\x2F\xD5\xD4\xD3\x72\xE7\xD8\x26\xDE\xE4\xAD\x9B\x52\xDC\xF2\xAF\x13\xD8\x56\xE0\xDD\x56\xD3\x37\x90\x18\x3F\xDC\x74\xDA\xFD\x03\xD8\x2E\xDD\x4C\xDE\xED\xBE\x4F\xF4\x27\xAD\xAC\xA9\xC0\x75\xE9\xDB\xAD\x95\xA2\xD6\x50\xEC\x91\xB5\xAD\xCF\xA7\x73\xC0\xDD\x62\xDF\xCE\xD4\x76\xFB\x97\x8F\x33\xEF\xA9\x76\xC0\xDD\x0D\xD7\x83\x80\x32\xD0\xD4\x98\x69\x5E\xB5\x20\xA0\xD9\x2D\xD6\x95\xDD\x61\x18\xD9\x94\xC8\x77\x65\xBD\x9E\xD6\x75\xB1\xEF\x37\x52\xDD\x94\xB4\xDF\xF3\xA4\x52\xF8\x5C\x26\xD6\x97\xDA\x92\x9B\xDA\x97\xDD\x84\x40\xD4\xAA\xD9\x9B\xDE\xBC\xD3\x64\xE7\xDE\x33\xD4\x81\x15\x53\xF4\x7B\x25\xB1\xA4\x00\x70\x0C\x55\x33\xCF\x33\x37\xE0\x5F\x7C\xA7\x59\x85\xC1\x2D\xEC\xB3\xDF\xDC\xB5\x9F\xC8\x0F\x32\x61\xB2\x40\xC5\x2C\xD5\xC0\xEA\xB9\x3D\xBD\x44\x93\x3D\x72\xC1\x8A\x65\x12\xE9\xB1\x79\xC1\x4F\xB3\xA9\x83\x6D\x11\xC5\xC8\xC1\x44\xC9\xCC\x36\xB2\x99\xD9\x4D\xFD\xDE\x10\x66\x46\xCD\xC7\xAE\xB2\x84\xC8\xDD\xAF\x11\xC9\x8F\x21\xC6\x5A\x05\x3E\x87\xB2\xEF\xDE\xCF\xB8\xFE\x84\xC4\xE9\xDD\x33\xA7\x10\xEC\xDF\x09\xC4\x25\xC7\xC7\x4B\x5A\x96\xB2\xDC\xC9\x5F\xE7\xD9\x0D\xDF\xFA\x65\x7F\xC8\xDF\xFC\xDF\x7C\x72\x0E\xE9\xD4\x18\xE0\x5D\x76\x38\xAE\xD4\xFF\xDE\x23\xCC\xEC\xAB\x3F\x74\xC2\xF8\x82\x25\x71\xB2\x91\xC3\x06\x9F\x7F\x12\xE0\xB7\xA2\x91\xC0\x7E\xC2\xCC\x4C\x9C\x00\x0B\xCB\x0F\xBC\xE6\xDE\xBB\xC4\x83\xF3\xB6\x38\xB9\x9D\xB0\x03\xF6\xBF\x1D\xC1\x9E\xB2\xE0\x99\xD9\xAF\xBA\xB4\xB3\xE4\xA4\xB8\x41\xE2\xA5\xBB\xEB\x83\xE1\x81\xC9\xAD\xD8\x4C\xEC\xC0\x03\xC3\xD0\x61\x2B\xF2\x93\x1D\xBA\x0C\xC7\x5A\x97\xBB\x4A\xBE\x01\x94\x02\xD6\x6B\x6D\xB8\x08\xCF\x83\xC6\xE1\x69\xB2\x0F\xC3\xFE\x89\xBA\xCB\xBA\x10\xC5\xAA\x44\xC1\x26\xC2\x48\x97\x04\xE6\xC9\x78\xBF\xD5\xB0\x42\xBC\xBD\x72\x32\xDF\xBD\x78\xB4\xBD\x9D\xB4\xD8\xB3\x6F\xFD\x3E\x80\x92\xBC\x3E\x2D\xA6\xBD\xF3\x0C\xEB\xAA\xF6\x8F\xC3\x19\xBC\x46\xBE\xF6\x90\xBE\x2C\xE1\xD1\x74\xF5\x2D\xE1\x3F\xB3\xB3\x9C\xF7\x82\xCD\x04\xBE\xC7\x06\xF0\xBF\xBD\x28\xC8\xDE\xBD\xC7\x3A\xBD\x1E\x05\x1F\x3B\x17\x41\x00\xD7\x99\x1F\x37\xE2\x4F\x07\x72\x30\x5D\xCA\x89\xEE\xC1\x7D\x30\xA4\xDF\x47\x8B\x5E\x65\xBE\xAB\x06\x87\xD5\x7D\x89\xBF\x06\xA3\xFC\x0C\xBE\xD0\xC0\x23\xC2\x0D\xD3\x42\xAA\x07\xD0\x02\xF7\x88\x96\x9F\xE1\x67\xB1\x8A\xF7\xE1\xA3\xE2\xBC\x3D\xA4\x06\xBE\x7B\xBC\x21\x9B\x0C\xEA\xE2\xCE\xCB\xDA\xBD\x8A\xE3\xC1\x83\xE2\x75\x73\x78\x33\xE2\xAB\xC1\x2D\xE4\xF4\xB7\xE2\x54\xD5\x2E\xE3\xE9\x1C\x28\xBC\xE2\xD5\xBE\x8B\xFE\xE1\xC1\xD4\x20\xE9\xF2\x84\xE3\x75\x7A\xCE\xBC\xBB\x1D\x06\x2B\x64\x67\x92\x89\xCC\xBC\x49\x06\x25\xE7\x34\xB1\x03\x23\x9E\x32\xE9\x44\x8C\xE3\x8B\xD6\x33\xEC\xBB\x3B\xE2\x44\xBF\x29\xEA\x0C\xD4\xE3\xAB\xE2\x30\xE1\x88\xF4\x94\x1B\xBC\x2C\xEC\x30\x0A\xE0\x77\x06\x39\xE4\x2A\x28\xE3\xC6\x9D\x31\xC0\x26\x90\xE3\xED\xE3\x34\xE8\x79\xFF\xE1\x37\xBE\xC6\xBF\x8A\xC6\x4F\xDC\xE2\x20\x18\x8F\xD5\xE2\x80\xBD\x3E\xE2\xF8\xBE\xE3\xC4\x88\xE3\x5C\x89\xC2\xE4\x69\xBD\x35\xE5\x90\xCE\xBE\x31\xA0\x21\xE3\xF5\x31\xE2\xD9\xB6\xEA\x04\x24\xCA\x54\x2D\xCA\x8A\xCD\x6B\xAC\xC8\x89\xA7\x29\x63\x2C\xCD\xC7\x28\x78\x8E\xCE\xB7\xAA\xCE\x3B\xCA\xD1\xD9\x4A\x79\x5A\x6F\xDD\x60\x65\xC5\x5D\x86\xCC\x9B\x48\xEB\x9A\x90\x19\x4F\xCC\xD3\xC7\xE4\x44\x1F\x65\xCD\xEE\x09\x7D\xD6\x18\x64\x04\x16\x65\x35\xF9\x0E\x28\xCB\xEC\xCB\x40\xF5\x04\x19\x09\x08\x8F\x93\xDE\x0C\x69\xA8\xD0\x77\x42\xC9\xCD\xDC\xCE\xCE\x71\x40\xF7\x18\x48\x16\x52\xED\x73\xFE\x7C\x5B\x54\x91\xAD\x40\xDA\xA7\x0F\xD1\x25\xD8\x74\xFF\xBA\x13\xD2\xD6\xC6\x41\xD6\xA9\x73\x57\xF2\xC5\x03\x97\xD0\xF7\xCD\xC7\x8F\x41\x60\xD0\x81\x71\x60\x50\x04\xA8\x9E\xD6\xCF\x77\xA7\x40\xD9\xCF\xD2\xA1\xCD\x7D\x3D\xF7\xCE\x4E\xCE\x54\xE7\x94\xFB\x97\x65\x32\x02\xD8\x97\xE7\xCF\x86\xE0\xD1\xAF\x95\xDB\xC3\xC5\xCC\x05\xDD\x27\x63\xE5\x59\x59\x59\xEC\x0B\xF5\xCF\x55\xA9\xBB\xDF\x3C\xFA\xCF\xB1\x4C\xFF\xC2\x42\xFE\xCF\x24\xD1\x5C\xE1\x02\x9E\x27\x2B\xD2\xC4\xD7\x77\xC9\xA6\x4B\x2E\x37\xD3\x43\xEF\xD0\x25\xE4\xCC\xDF\x54\x84\x0E",
"\x13\xCA\x66\xED\x61\xD5\xDC\x28\xCB\xE8\xDE\x44\xD5\xD1\x3C\xDE\x21\x3D\xC7\x20\x01\x8A\xAA\x5A\xD6\x70\xD5\xD3\x6D\xDE\xC2\xDD\x63\xE2\xD6\xE4\xC7\x59\xC9\x3A\x9E\xE6\x1C\xD8\x68\xE5\x71\xD0\xB0\xD2\x5B\xD6\xDA\x71\xD6\xA9\x26\xD9\x3A\xDC\xA2\xB1\xDB\xDC\xD9\xE8\x25\x9C\xEE\xD8\xC2\xE4\x3C\xD7\x78\xEA\xDC\xAB\xAA\x80\xD6\x7A\xD0\x5F\x6C\xDF\xDE\xA4\x6E\xFC\xD8\xF2\xDD\xDC\xD2\xFE\x81\xA4\xFB\x7C\x6F\xE3\x71\xEB\x12\x78\xDF\x38\xD0\x6C\xFB\xDD\xC4\xE5\xC7\xD7\x62\xC0\xDE\xEB\xD3\x72\xEF\x71\xC5\xDE\x28\xDC\x5C\x4E\x9D\xC9\xDE\xAC\xE7\xE9\xDC\xB3\x3A\xDC\xCD\xD3\xE9\xDB\x94\xC7\x05\x14\x2E\xD1\xC6\x6A\xF9\xD4\x36\xDC\xE3\xDD\x6F\xFE\xE7\xF6\xE4\xAD\x74\x6D\xEA\xDA\xF5\xD4\xB6\xDF\x2E\xDA\xDB\xC8\xE6\xC8\xDF\xDC\x00\xD5\x17\x19\xB8\xD2\x5D\x63\xDB\xFB\xD2\xAC\xD0\xC3\xAE\xD4\x4A\xD7\xA1\xD4\x63\xF2\xD4\x8A\xD8\x5C\xA0\x55\xCD\xDA\xF7\x4C\x7B\xDB\xA1\xF5\xDB\x6E\xD8\x64\xDC\x41\x23\x25\xB6\xAC\x80\xE0\x7D\x65\xDE\xF5\xE4\xF4\x55\x19\xAD\xD5\x04\xE9\x65\xD6\xA0\xD3\x3A\xA4\x37\xD5\xD2\x78\xCB\xE8\x78\xD4\xB8\xD3\x54\xE2\xDB\x95\xAE\xDC\xA9\x5D\xD8\xB2\x14\xE9\x79\xDF\x83\x84\xD6\xF6\xD9\x96\x57\x58\xDC\xE8\x09\xEB\x06\xBD\x8F\xD1\xDA\x24\xE9\x88\xE7\x6F\xC9\xE9\xCD\xDA\x89\xE8\x2F\x68\xE8\xAB\xD9\xE3\xD1\x78\x6E\x32\x3A\xAC\xA6\xD5\xA0\xEB\xDD\xF0\x86\xAB\xDD\x09\xD3\x3D\x45\xDD\x57\xA7\x74\xCE\xC1\x60\xE5\x77\xD5\xEF\x1F\xD7\x20\xE3\xFE\xD9\x81\xCE\xCC\xCD\xDD\x72\xE2\x74\x9A\xDD\x22\xD8\x29\xD3\xF5\x2A\xD7\x17\x86\x87\xEB\xB5\xAC\xE7\xD6\x5A\xD7\xD6\x69\xEA\xE6\xF4\x78\x94\xE7\xA5\xC1\xE8\x7E\x84\x00\x05\xA5\xCA\xDE\xB3\xE5\x75\xDF\x6A\xDC\xE9\x17\x89\xFE\xCA\x5D\xC7\xE7\x4A\xAB\xD0\xB8\x6B\x4B\xDD\xFA\xDD\xAE\xD7\xA6\xC1\xD4\xE8\xDA\xF3\xD2\x9E\x67\xD7\x54\xDD\x7A\xDA\x4A\xF2\xE8\x9C\xDE\xF1\x93\xA7\xD5\xEA\x22\xEA\x7C\xDD\xA4\xF4\xE7\x51\xEB\x7F\xE0\xAA\xFB\xE9\x2A\xE8\xAD\x72\xC7\x2A\xDE\x56\xEA\x8B\xE8\xA5\xCF\x8C\x0E\xD5\xB9\xDE\x92\xC9\x7D\x4E\xB6\x44\xD3\x7B\xD4\xD9\xB5\xDE\x56\xBA\x14\x37\xDE\xD0\xBA\xEE\xDB\x65\xFD\xDE\xC5\xDF\x47\xD3\xAB\xE2\xBD\x22\xD5\x29\x73\x7C\xDD\xD4\x17\x19\x0A\xC5\xA6\xF9\xDA\xFE\xBC\x71\xCB\x66\xD2\xEA\x46\xD2\xE7\xD9\x65\x92\xDF\x71\xDA\xA5\xD2\x83\xEB\xB5\x3B\xE1\x6F\x78\xC9\x21\x03\x06\xB7\x65\xC8\x7E\xEA\xBF\xEA\xDD\x19\x98\x10\xF7\x6C\x09\xE2\xC1\xCC\x81\xCF\xEA\xA5\x73\x06\xE5\x61\xD6\xDE\x1D\xE0\xE0\x8A\x30\xD9\xE7\xE3\xC5\x46\xC2\x9D\xA5\xE0\xD6\x6F\x09\xE6\xAF\x6F\xDF\x05\xE2\x56\x07\x80\xE4\xC4\x30\xE2\xFA\x83\xAD\xE3\x6F\x16\xCD\xE2\x98\xC9\x23\x32\xF4\x01\xB6\xE7\x7E\xE1\x91\x0D\xE2\x41\xCB\x7E\xF2\x3B\xED\xDE\x1A\xB6\xBD\x7B\x6C\xD3\x66\xA1\xEC\xA3\xF9\xC3\x0B\xDC\xC2\xC5\xB4\x77\x6E\xFA\xBF\xB8\xE2\x82\xE2\xC2\xE7\xE8\x29\xC9\xAE\xE4\xD8\x24\xD2\x3F\xC6\xF0\x1C\xC4\xA1\xBA\xDB\xB9\xAF\xCF\xC2\xF2\x3B\xD7\x62\x89\x17\x18\x20\xEE\xBF\xBA\x88\xE0\xE3\xBD\xE3\x29\x62\x87\xE4\x0A\x74\xE1\x40\xE2\x8A\xC4\xBE\x33\x4F\x05\xA4\x84\xA8\xE2\xBF\xE1\xBB\x61\x8F\xD6\xE3\x21\xED\x36\xEF\xF6\xA5\xEC\xAE\x0A\xCA\xE4\x2A\x06\x32\x94\xE1\xE0\x5A\x73\x44\x00\xD7\x9A\x21\x31\xDB\x86\x32\x33\xEE\x31\xC9\xA5\x11\xE3\xB4\x78\xE2\xB9\xB3\xCE\xC3\x17\xE5\x34\xC9\x91\xD6\x77\x7E\x17\x9E\x05\x19\x47\x96\xAB\xC2\xD2\xE5\xF7\xA1\xE3\x97\xDB\xD0\xED\x90\xDE\x04\x4C\xEC\x2E\xE4\xF8\xB1\xBC\xFB\xE0\x45\xE6\xF2\x8B\x82\x3C\xEE\xBC\xE7\x0C\x5A\xE3\x44\x2F\x51\x0F\x91\xA1\xED\xCF\x06\xD7\xED\xD9\xA5\xED\xCD\xE0\xE1\xB2\xF1\xA9\xED\x52\xEC\x3C\xE1\x8C\xED\xED\x66\xE3\xBC\xEA\x91\xF1\x96\xCB\x45\x35\xC8\xF7\x84\xED\x20\x92\x21\x3D\x61\x41\xEC\x76\x9E\xDD\xE4\xF4\xB8\xED\xE9\xE3\xD9\xE5\x8A\xE0\xED\x7D\xEF\x40\xE6\x91\xEE\xA0\xF3\xE2\xCA\xB9\xF3\xBF\xEC\x93\x38\x42\x02\xB7\xD8\x6C\x88\x96\xE3\xE9\x44\x90\xEE\x47\xEA\x3A\xE0\x00\x0F\xED\xCB\xE2\xDA\xEA\xF8\xAC\xED\x55\xEE\xE6\xE5\x8F\xC6\x4F\x59\xEF\x8F\xE2\x27\xAB\x2C\xCB\x72\xE8\xE2\xB6\xCD\xED\x60\x8B\xDE\xEF\x1C\x3C\xE3\x7D\xE2\xE5\xEB\xB3\xED\xEE\x73\xC4\xF5\x6C\xB9\xE2\xC4\xB7\x05\x6B\x02\xB4\xFB\xEE\x2C\xEC\x43\xE7\x8A\x64\xE3\x76\x9E\x3E\xE8\xBC\xF8\xEE\x79\xE3\xA4\x3C\x8E\xC9\x91\xEE\xE3\x06\xD3\xB5\xC4\xE4\x98\xEF\x35\xE6\xEF\x99\xB4\xC3\xEE\xD2\x11\x2F\x0B\xE4\xB4\x79\x6C\xBC\xBB\xCB\xB4\x66\x92\xBC\x30\x90\xD4\xEF\xAA\xEC\x30\xEF\x0F\xC0\xEE\x82\xE2",
"\xCF\xE3\xB8\xD3\x3A\x09\xE5\x45\x00\xBE\xCE\xEF\xAE\x0B\xF8\xE3\xF8\xAC\x10\x8B\x5A\x44\xE6\x8A\xE9\xEF\x3A\xEF\xDF\xE0\xBC\xDB\xEF\xC5\xE2\x3D\xE2\x8B\xFE\x40\xDF\xE1\x49\x92\x8E\xCC\xE2\xEF\xC4\x4E\xEC\xF7\x52\x95\x9F\xE1\x7F\xE3\xAA\xEA\xEA\xA7\xDE\x9E\xE0\xC1\xE5\xEA\xFF\xC8\x00\x08\x76\xE9\xEA\xA3\xDB\xAA\xE3\xF5\x08\xDC\xB5\xE4\x85\xD7\xAC\xCD\xDD\xE4\xEB\x51\xCC\x4D\xF4\xDD\xDE\xE7\x66\xEF\x9B\xE1\xB5\x79\xDF\x78\xEC\xB1\xDC\xDC\x2C\xDB\x79\xE8\x7A\x84\xD1\x3E\xEA\x7A\xE5\x72\xDC\xEA\x86\xDE\x8C\xD6\x9D\xC0\xDD\x99\xE6\xDD\xD7\x9A\xF2\xC8\xFA\x05\x0C\xDD\x76\xE6\xF0\x3C\xF3\x70\x0B\x17\x77\xD0\x31\x9A\x69\xEE\x9B\xC1\xF1\x05\xD8\x8E\xE5\xB2\x95\xDE\x1A\xED\x08\xFA\x4E\xFE\xE8\x04\xD4\xCD\x69\x72\xFF\xF0\xAA\x3C\x9E\xEB\x78\xCF\xF0\x19\xF1\x80\xEF\xCE\xAC\xE8\x90\xDC\x35\xD1\xA3\xCE\xDA\x6A\xE8\x8D\xEF\x6D\xC2\xD5\x7D\xD8\x8E\xED\x42\xDB\xCB\x1A\xD3\xD6\xC9\xA6\xE2\xDC\x7C\xD7\x85\xE6\x69\xCE\xD5\x8B\xD8\x92\xE0\x6F\xC1\xDE\x99\xEA\xBB\xDC\xDB\x1F\xB0\x4A\xE8\xA5\xDC\xA4\xDF\xDD\x58\xF3\xB3\xD2\xAA\xC0\xEA\x52\xE9\x1F\x39\xB3\xAD\xE8\x59\xF0\x75\xE9\xA5\xD1\xE8\xB0\xDB\x87\x0D\x95\xF9\x07\x5F\xA4\x98\xE4\x98\xCA\xDD\x63\xE8\x13\xFC\x83\xDB\xD3\x98\xE8\xB3\xEB\xA6\xC8\xDB\x19\xDD\xD5\xDD\x5A\xC5\xE9\x82\xBF\xA6\xED\x9C\xD3\x82\xD5\x92\x9D\xE7\x7A\xD6\xF1\x61\xDE\x93\xEC\x61\x74\x7A\xBB\x32\x2B\x01\x9B\xFB\xE7\x1A\xF2\x86\xED\xAA\xC1\xDA\x5E\xEB\xAA\x41\x65\xF2\xDE\x3F\x95\xF0\xD0\x46\x76\xDE\x19\xD5\x7E\xBA\x65\xE3\x49\x5C\xD8\x49\x4F\x7B\xDF\xA0\xB6\xF1\x20\xA3\xAC\xDD\xD9\x73\xEF\x31\x51\x93\xDF\xC2\x5A\x8D\xB2\xED\x52\xCB\xEB\x6A\xE9\x14\xFE\xBE\x8F\xEB\x99\x09\xFC\xA1\x9D\xEB\xDE\x91\xDC\x93\xD1\xA1\xF0\xDE\xD4\xAD\x4B\xC1\xCC\xDE\xAF\xB6\xE8\x46\xD3\x41\x1A\xD4\xC5\x9B\xA2\x5D\xCB\xFE\xDE\xC6\xDC\x30\xF4\xAB\xC2\xDF\x62\xD8\xF1\xD4\x66\xC6\xEB\x11\xEE\xC8\xCA\xCC\xC0\xD9\x6B\xF2\x91\xED\x0E\xAF\xF1\x6F\xD8\xB4\xE8\x68\xD6\xD1\xFB\xEB\x36\x96\x2E\xCC\x3F\xA3\x32\x21\x3C\xB8\xF9\xE0\x1C\xCC\xC1\xEC\xAD\xCE\xE0\x07\xED\xE4\x60\xAE\xE3\xEC\x0C\xEF\x1D\xC6\x6E\xC0\xAD\x73\xB1\x1A\xDE\xC4\xC3\x90\x15\xED\xC6\xE8\x3D\xB0\xA4\xEB\xE8\x5A\x59\xB4\x6E\xEB\x87\xC0\xA0\x93\xB2\xEE\xED\x2E\x3D\x0A\xE4\xB2\xD8\xC9\xB2\xB3\xC9\xE5\x37\x29\xEC\x04\xF0\x08\x9F\xC8\x05\xED\x8F\x32\xCE\x54\x0B\x23\x9C\x8F\x31\x6C\xBF\xC8\x10\xEF\x1B\xF1\xFF\x23\xB9\xF7\x05\xA4\xED\xEF\xE5\x91\xFF\xEE\xD9\xED\xCF\xE6\x41\x70\xED\xE5\x21\x93\xD9\x28\x88\x96\x2D\xF7\xD7\xE4\xD3\xF4\xED\xAE\x09\x50\xFD\xD9\xAF\xF4\x66\xEE\x31\xCF\xBE\x35\x88\x75\xEC\xFF\xE4\xB5\xF9\xF4\x1C\xF5\x06\xAD\xBD\xE5\x23\x58\xDB\xDD\xB6\xD2\xC9\xEF\x47\x8D\x87\x55\x6D\xCD\x9E\x46\xF4\xD1\xB8\xD4\xF9\xED\x4A\xF4\x60\x02\xBD\x8D\xF5\x95\xEF\x4D\xFE\xBF\xD0\xF5\x06\xE7\xD5\xE0\x1F\x62\xF5\xA0\xEF\x2A\xCD\xD5\xC9\x91\x5F\xF5\xE4\xE1\xD6\xD1\x04\x3E\xF4\x59\xF3\xEF\x69\xE2\xFD\xEF\xFA\xEF\xBF\xCB\xBD\xC2\xEF\xFB\xE2\x12\xF4\xF5\x54\xBD\xE2\xE8\xD5\xCA\xEE\xA8\x63\x3F\xFD\x78\xB6\xEE\x76\xF4\x58\xF5\xBE\xD3\x3A\x68\xEF\xF3\xE7\xD7\xD7\xEF\x97\xEE\x22\x91\xB8\xEF\xED\xDD\xEE\xE7\xE5\xCE\xF4\xEE\xA1\xEF\xD8\xE1\x78\x70\xF4\x8B\x5A\xEE\xE5\xBF\xCE\xF5\xD8\xEE\x64\xFD\xBE\xFB\xF4\x53\xF5\xE1\xE0\xBE\xC8\xF6\xAE\x09\x4D\xF4\xBE\xD1\xEF\xBC\x2C\xEA\xE7\x8E\xE0\xF6\x91\xF7\x45\xB6\xB5\xDC\xEF\x7E\xF6\x0A\x1E\x14\x0A\xB0\xC7\xED\x6A\xF9\x88\xE2\xED\xF7\xE6\x02\xF7\x89\x92\x95\x5E\xED\x55\x90\x42\x93\xE2\xC3\xF4\xF3\x36\xC8\x0C\xEF\x0C\xF2\x66\xF6\xBF\xD0\xE4\x53\x3C\x40\xE6\xB3\xC1\xBE\x65\xF7\xDA\xE0\x94\xAC\xEF\xB3\xF5\x00\xF8\x90\xCE\x6A\xF3\xEE\x72\xFF\x90\xF8\xE1\x53\x3C\x3B\xEF\xDC\xFD\xE2\xD1\xF7\xEA\xE3\xDD\xFB\xF5\x5A\xE3\x41\xE2\x19\x47\xE3\xEE\x49\xDA\xE2\xBE\xDB\xF7\xA6\xEC\xA7\x3F\xDD\xD2\xE3\xE1\xF6\xFA\xEC\xBA\xE8\xF5\xA3\xF4\x0A\xED\xBD\xDC\xE4\x58\xD8\x29\xF9\x73\xC0\xF2\x3C\xDF\x23\x37\x76\xC4\xF2\x7E\xF3\xE9\xD5\x9D\xF9\xE8\x1E\xF1\x3B\xF7\x7F\xF9\xE6\x01\xA5\xC4\xDA\xC3\xC7\xF1\xC7\x80\x3B\x87\x71\xFA\xDD\x2B\xF1\xDF\xDD\x4E\xDF\xDC\x94\xA4\xB3\x39\x9E\xE6\xE7\x8F\xAC\x0D\xFD\x9E\xE0\x3E\xEF\xE5\x89\xED\xC7\xFC\xDB\x11\xF2\x29\xF7\x56\x1D\x58\x98\x33\x56\xFC\xDF\xC2\xF8\x72\xD7\x1C\xFB\x4E\xE2\xF1\xCC\x04\x9F\xD9\x68\xFE\xD9\x04\xF8\x2C\xFC\x3A\xF0\xEA\x3D\xE9\xB1\xDD",
"\xC6\xC0\xDD\x70\xF2\x86\xE4\x6F\xF3\xD5\x21\xDE\x3C\xF3\xA4\xE0\xE8\x89\xDA\x88\xE2\x96\x38\xF1\x9F\xEB\x89\xF7\xA2\xE2\xF8\x55\xA6\x21\x35\xC6\x3F\xE9\xF1\xE6\x21\xF4\x5D\xC2\xDD\x5B\xEA\x24\xD1\x6B\xC2\xE6\x41\xA3\x68\xBF\x2D\xF7\xDA\x8D\xE8\x08\xF8\xE0\xF4\xF1\x96\xF2\xB1\x58\x71\xC9\x5B\x96\xEA\xD5\xD0\xC6\xE2\xDC\x59\xDC\x26\xF0\xE6\xDD\xEA\xA2\xF0\xF4\x5A\xDF\xFF\xF1\x4D\xF8\xBE\x4D\x61\x69\xDE\x00\xF8\x88\xFE\xE4\xE5\x77\xAF\xF3\xF0\xB8\xCD\xFA\xEA\xA3\x7F\x36\xF6\x51\xDD\xF3\x57\xD9\xAE\xE2\x9D\x7B\xDE\x1C\xD4\x31\xFA\xCD\xE7\xF3\xB7\xF1\x3A\xF4\xAC\xFF\xF2\x48\xC1\x96\xF8\xAE\xEF\xF3\xCC\xDD\xA4\xED\xCC\xD3\xB0\xEF\xAE\x3D\xFE\xC6\xE7\xDE\xF9\xF3\xAF\xCB\xC5\x87\x5F\x8F\x32\x61\xFB\x83\xF7\xC2\x72\x99\x2E\xCF\xAD\xD4\xEC\x08\xF7\xD4\x35\x81\xCB\xF4\x20\xCE\xC5\xE0\xBC\x54\xEC\xD5\xAE\xC5\xE8\x40\x95\xF4\x51\x47\x45\xF0\xCD\xA4\xE0\x89\xC3\x46\xF3\xD9\xDD\xF4\xF4\xEB\x2F\xA0\x09\xF3\xB2\x28\xED\xB8\xE2\xF5\x38\xBD\x27\xF7\x55\xFB\x17\x66\xF8\xCF\x07\x5B\xF4\x2A\x31\xF5\xA5\xEF\x32\x2B\x68\x4B\xF5\x75\xF6\x6E\xF1\xDF\xF9\xF5\xF3\xF6\x68\xF5\xDD\xEE\xEF\xD6\x75\x4F\xFD\xD6\xD2\x95\xC2\xF9\xB0\xFC\xDE\xC6\xFB\x31\xF4\xFC\x23\xD3\xE4\xED\xB0\xF4\x4E\xFE\xEC\xEE\xE2\x6A\xF5\xD4\xBA\xED\xF9\xF6\x49\x07\x23\x35\x52\xA9\xF4\xA2\xE7\x33\x3F\x88\xDC\xF5\x50\xE6\x91\x2F\x1C\x18\x32\x45\xEC\x26\x3A\x73\x72\x03\xD7\x98\x26\x31\xDB\x98\x32\x30\xF6\xBC\x3B\xA8\x3C\x81\xD6\xFB\xB2\xFF\xD4\xDF\xFB\xD8\xE0\x69\xF5\xDB\xF8\x31\xC8\xE2\x54\x96\xEF\xEE\xC1\xF8\xF9\x52\xF0\x26\xA3\x29\xFC\xF9\x51\xFD\xED\xE7\xF5\x00\xFC\x00\xF0\xED\xD2\xC5\x03\x11\xC1\xFD\x78\x87\xFC\x9D\xB5\xC2\xFA\xD8\xC4\x8B\x61\x28\xD4\xE4\xEC\xF6\xF4\xD2\xF7\x2F\x14\xDD\xE0\xFB\xB4\xF6\x75\x7B\x2A\x11\x06\x16\xFC\xA9\x08\xF1\xF8\xC6\xC3\xF8\x51\xF9\x14\x2B\xFC\x49\x92\xC6\xF2\xD7\xE0\x89\x6C\x2A\xC7\xFF\xF0\xFA\xF5\xF4\xF7\xB3\xF2\xF0\xD6\x77\x78\x29\x35\xCB\xCC\x70\xFC\x2A\xFF\xB5\xF6\x0C\xE1\x29\x0D\xFD\xB9\xF7\xF3\xCD\xFB\xB2\xF4\xC9\xF6\xDD\xD2\x46\x9D\x29\xCA\xFF\xEE\xDA\xF6\x32\xFD\xB1\xF6\x0C\xEC\x29\x45\xFF\x5D\x0F\xF1\xEB\x6B\xBE\xEC\xC4\xF9\xF4\xC1\xFC\xF6\xF5\x6D\xFC\xE4\x1E\xE3\x20\x90\xBC\xF1\xF6\xC6\xF7\x00\x02\x38\x05\xEF\xD0\xFD\x42\xFF\xC2\xF9\xB4\xB0\xF5\x47\xFF\x78\xF9\xF3\xEE\xEE\xE6\xF4\x06\x95\xF1\xE9\xF7\x4F\xFF\xBD\xF9\xF6\xC4\x8B\xFB\xFB\xB6\xF7\x34\xBE\xFB\xA1\xF7\xD6\xF3\x38\x8C\xBD\x82\xEC\xC7\xB3\x11\x20\xEF\x40\xFF\xD3\xF9\xEF\xD3\x3A\x1D\xFE\x57\xFD\xF6\xE2\xFC\xE4\xF6\x67\xCB\xF2\x9D\xEF\x27\xFF\xB4\xF7\xF1\xE8\xFD\x87\xFC\xEF\x25\xF3\xCA\xFE\x7C\xFD\x6C\xFD\xF8\xB4\xE3\x71\xFE\xBC\x3D\xF3\xC4\xFE\x94\xFE\xC2\xFC\xF1\xEB\xFD\x2D\xFD\xE6\xFE\xED\xFE\xFD\x7C\xF7\xE3\xF5\xDB\xCD\xFD\x74\xFE\xAB\x05\xF8\xEE\xFE\x77\xFF\xD4\x34\xF5\xFA\xFD\x57\xFC\xDA\xB1\xF2\xEC\xE2\x99\xED\xF0\xEA\xFA\xFC\xFC\x36\x04\xB9\xF3\xD4\xC5\xED\x84\xF5\x6E\x83\x72\xA8\xF6\x49\x06\x6A\xF7\xBF\xE0\x89\xA8\xEF\x7B\xF1\xB5\xCF\xF6\x7E\xEC\xCE\xF1\xF1\xDE\xC4\x9D\xFF\xA4\x31\xBB\xF8\xF6\xAD\xFD\xF1\xFA\xD9\xC6\xFF\xCC\xF7\x62\x97\x11\x8E\xF6\x38\xED\xF3\xF8\xF4\xDB\xFE\x4A\xFF\xC4\xF4\x0B\x9E\x0C\x73\xED\xED\xE7\xFD\xF1\xFE\xF2\x38\x01\xAA\xFC\xFC\xEE\x58\xFE\x59\xFE\xFC\xE8\xFE\xE5\xF5\xB8\xF8\xBD\x45\xEF\x9F\x4B\x9A\xF1\xE2\xDF\xF8\x6A\xDD\x80\xEF\xC8\x25\x31\x26\xF9\x9B\xF9\x6D\x3F\xAF\x3C\x7C\x4E\x7A\xF0\x42\xCF\x6D\xE2\x76\xD1\x65\xF1\x0F\x74\x31\x7C\x3B\x7C\xA9\x7A\x27\x4D\xE3\x76\xB8\x56\xE8\x38\x7C\x19\x75\xE1\x57\x87\x71\x00\x8C\xE5\x6A\xD3\x7F\xF8\x7B\x78\xF4\x78\x21\x7C\x57\x10\x29\x1C\xEB\x78\xEA\x68\xFB\x7D\x18\xC0\x7C\x87\x7E\x4B\x78\xFD\x73\xE9\x08\xF6\x5B\xFF\x4A\x7D\xCC\x7F\xAC\x7F\xFB\x78\xFC\x7C\xF5\x61\xFC\x6B\xF5\x00\x7B\xE0\x77\x6A\x7E\xC3\x7D\xF2\x74\x12\x03\xF7\x68\xA0\x56\x7F\xA6\x7E\xAD\x7C\x0B\x82\xE2\x7B\xF3\x6F\x01\x99\xB7\x78\x5E\x62\x7F\x67\x4E\xBC\x78\x15\x36\xF6\x76\x3B\x6F\xFE\x2F\x7E\xB1\x7E\x1F\x64\xE9\x7D\xDF\x79\x02\x8E\xFF\x5F\xFF\x43\x71\x3C\x81\xAE\x7E\x75\x3B\x22\x03\xF7\x76\x43\x6B\xC2\x47\x80\x77\x03\xA8\x7E\xD1\x23\x14\x7B\x68\x33\xFD\x76\xFC\x39\x80\x2B\x80\x28\x80\xF4\x7A\xFE\x73\xF5\x1F\xFA\x55\xFF\x59\x80\xA1\x7F\x8D\x7C\xEA\x49\xEF\x7F\x05\x8D\x02\xB7\xFE\x72\x71\xDA\x77\x31\x81\xC9\x7B\xFC\x33\xF8\x67\x03\x9E\x04",
"\x58\x80\x77\x81\x24\x82\xEC\x7C\xF6\x7B\xF8\x78\xFD\x71\x01\xF1\x7F\x73\x80\xE3\x27\xE7\x7E\x0E\x8E\x7A\x36\xFB\x5C\xF6\x53\x1E\x89\x7E\xB6\x7C\x18\x87\x09\x89\xFB\x71\x02\xAE\x00\xC6\x27\x91\x7E\xD0\x7E\x21\x82\xF4\x78\x7A\x44\xFA\x7C\x01\x8B\x81\x6E\x7F\xE7\x7C\x20\x83\xE9\x73\xF5\x0C\xFD\x7B\xFA\x63\x7E\x25\x4B\x21\x80\x02\x78\x42\x6E\xDB\x67\x78\x70\xFE\x11\x71\x20\x49\x51\x19\xD1\x73\x94\x1A\x73\x24\xE2\x4D\x9E\x23\x19\xB1\x5B\x51\x18\x0D\x82\x81\x1E\x7A\x61\xFA\x58\x02\x8C\x7F\x6F\x7F\x16\x80\x65\x7D\xB6\x78\xA1\x15\xF3\x56\xC2\x08\x4B\xB0\x80\xA1\x79\x1E\x86\xAA\x7F\x6C\x4A\x05\xA9\x02\xE4\x7E\x27\x73\xE7\x01\x30\x85\xB3\x52\x0B\x94\x04\xB2\x3B\x34\x81\xC9\x7C\x24\x83\x2D\x86\x0F\x89\xFD\x5B\xFD\x53\x42\x3D\x81\xB5\x81\x95\x14\x10\x80\xAB\x73\x04\x9D\x63\x05\x01\x86\x7E\x69\x81\x99\x7C\xDE\x79\x69\x5A\xFC\x75\xFD\x78\xF5\x7F\x7D\xF0\x7E\xB0\x5B\xEB\x71\x96\x45\x07\x96\x02\xA0\x03\x93\x81\x6A\x81\x45\x74\x4C\x70\xF3\x7E\x06\x82\xEF\x78\x02\x9A\x81\xEA\x81\xE8\x7F\x0F\x39\x2D\x32\x09\x88\xF8\x64\x00\x96\x7F\xE4\x80\x7A\x81\xF7\x7A\x05\x8C\x08\x9F\x03\xB9\x03\xE4\x80\x9E\x7F\xDE\x7C\x21\x80\x0F\x8E\x7A\x34\x01\x89\xFE\x65\x81\x7D\x80\x38\x82\x4E\x7A\x0A\x83\x09\x31\x04\x8B\x04\xE1\x81\x52\x7E\x30\x46\x25\x83\x94\x2C\x04\x83\x08\x8E\x01\x99\x81\xE9\x80\x87\x57\x3A\x85\x13\x8A\x10\x8E\x07\x93\xFE\x70\x81\xE2\x81\x3D\x80\x47\x83\x06\x85\x0F\x92\xEF\x60\x04\xBB\x80\x72\x80\x4E\x81\x42\x80\xE5\x75\xD2\x65\x06\x98\xF5\x2C\x81\x34\x65\x91\x4F\x32\x84\xE8\x5D\x0C\x8A\x03\x8B\x5A\x50\x81\x7A\x7E\x2D\x81\xFB\x7F\x0D\x83\xF2\x7A\x05\xB4\xFA\x3C\x81\x50\x04\xDF\x7E\x47\x03\x94\x15\x52\x58\x09\xA3\x02\xB1\x6E\xA5\x80\xA9\x49\x30\x82\xB8\x7F\x6C\x4E\x65\x05\xED\x2E\x19\xAD\x81\x91\x4E\x2B\x19\xB6\x5E\xCA\x14\x01\x95\x30\x50\x76\x3D\x83\x77\x70\x41\x87\x25\x82\x06\x9B\x04\xA2\xFF\x26\x52\x73\x76\xBA\x63\x56\x82\x18\x80\x00\x03\x65\x04\x03\xA4\x05\x56\x82\x10\x48\x56\x81\xF0\x29\x0C\x8E\x15\x2B\x05\x9D\x5B\x5D\x82\x67\x81\x4D\x4F\x99\x10\x16\x91\x08\x85\x05\xFF\x7E\x7D\x7A\x67\x3C\x5F\x85\x26\x84\x2A\x06\x06\xB6\x04\xA6\x72\x3A\x82\xCD\x79\x58\x81\x23\x84\x2C\x40\x0A\xAB\x04\xD2\x81\x2D\x82\x66\x7C\x59\x85\x11\x81\x13\x87\x0B\x93\x3D\x58\x81\x3E\x7A\x6D\x80\x08\x4B\x97\x15\xB4\x7B\x65\x1B\xBD\x23\x4E\xBB\x19\xD8\x5B\x2E\x1C\x06\x85\xE7\x6F\x0E\x39\x05\x9E\x82\x44\x83\xC6\x7E\x48\x82\x1F\x80\x19\x7E\xF9\x48\x96\x21\x83\x6C\x82\x57\x1B\x5B\x87\x39\x0C\x19\x9B\x0C\xA4\xFD\x2F\x76\xB4\x82\xCD\x7B\x68\x82\x2F\x8E\x7E\x71\x06\xB7\x05\x27\x83\x62\x83\x8F\x83\x3D\x81\x24\x8D\x4F\x00\xFC\x7B\x02\xD6\x3B\x65\x06\xA5\x81\x0A\x5F\x2A\x8B\x5F\x55\x0B\x89\x05\x77\x82\x44\x5E\xE0\x80\x63\x80\xF5\x4F\x15\x9C\x09\xBE\x05\xAA\x83\x02\x70\xD6\x82\xC0\x2B\x6E\x78\xF7\x4E\x65\x25\x94\x73\x82\x4F\x83\xA7\x4B\xBA\x78\x2E\x8D\xEE\x78\x7B\x75\x06\xCF\x4D\x9E\x82\x54\x30\x6E\x86\x55\x00\x1B\x9D\x6C\x7B\x06\xBE\x82\x14\x76\xDF\x82\x47\x02\x3A\x80\xF2\x76\x07\x94\x03\xD1\x7A\xA1\x16\xB8\x75\x72\x84\x30\x89\x1B\x85\x29\x69\x07\xE1\x83\xEA\x7D\x99\x6E\x54\x48\x36\x84\x15\x84\x15\x05\x33\x45\x76\xC5\x19\xBD\x22\x6F\x06\xEE\x45\xCC\x1B\xC4\x6C\x07\xAE\x7E\x77\x03\x06\x86\x1B\x65\x98\x14\x03\x85\x55\x3B\x5E\x49\x48\xEF\x83\xE0\x81\x6A\x81\x17\x8E\x08\x87\x0E\x93\x42\x50\x4B\xA6\x57\x83\x09\x44\x01\x3C\x00\xF6\x6F\x36\x47\x08\xA0\x48\x09\x85\xA3\x46\xC6\x66\x40\x8A\xD9\x74\x10\xBC\x06\xC5\x45\x17\x84\x52\x05\x86\x86\x7A\x7E\xFD\x73\x0C\x86\x04\xB8\x0D\xC6\x83\xA3\x83\x73\x4B\xA8\x13\x21\x02\x11\xAE\x05\x4A\x83\x71\x83\xAA\x81\xCF\x3E\x39\x8F\x1B\x9A\xEC\x74\x07\xAB\x7B\xA2\x7D\xC1\x82\xF2\x7B\x31\x85\x1F\x8E\x09\x83\x07\xB0\x82\x66\x83\x1E\x83\xF8\x7F\x7C\x3C\x1F\x8F\x10\x9D\x06\xBD\x3E\xEB\x83\xA4\x01\x7B\x84\xE8\x53\x23\x9B\x02\x84\xBE\x2D\x75\xCA\x7E\xFA\x83\x50\x86\x3E\x82\x11\x98\x0F\xA0\xA0\x46\x27\xFB\x82\xA9\x1D\x41\x41\xF0\x55\xC6\x17\xB9\x2C\x09\xFC\x79\x00\x01\xB4\x16\xDD\x4D\x8E\x4D\x22\x8E\x00\x86\x92\x00\x6A\x9A\x6F\x18\x87\x44\x77\xAC\x4E\x2D\x74\xD4\x5F\xF2\x32\x2D\x7B\x85\x4E\x7B\xA5\x70\xBD\x60\xB6\x40\x86\x48\x96\x74\x84\x0E\x85\xA4\x01\x31\x1E\x1B\x4F\x86\x7C\x2F\x6E\x09\xBD\x71\x02\x5E\x39\x19\xBB\x53\x0E\x7C\x5F\x51\x6D\x6E\x08\xE6\x57\x77\x85",
"\x1E\x0F\xA2\x2A\x4F\x8B\xBF\x7C\x13\xB6\x5A\x7E\x84\x6D\x75\x24\x55\xA0\x80\x23\x3E\xC9\x61\x15\x9D\xDD\x48\x3A\xB4\x12\xBC\x5F\x89\x86\x44\x8D\xF3\x2B\x11\x8F\x07\x12\x84\x9D\x5B\x4B\x85\x4A\x83\x53\x85\x2C\x50\xDA\x5D\x09\xE3\x84\x4E\x85\xFB\x83\xAC\x7A\xAA\x75\xDB\x60\x11\xBA\xD3\x3E\x84\x24\x85\x2A\x86\xA2\x83\xB7\x7F\x2A\x8C\x7E\x00\x08\x85\x5E\x02\x85\xC6\x4E\x84\x81\x12\x3B\x26\x90\x14\xA0\x4A\x2B\x76\x02\x5F\x63\x86\xC7\x03\xFB\x64\x29\x9E\x2A\x4C\x0B\x8D\x85\x6D\x84\x6C\x84\xD9\x7B\x52\x80\xB3\x75\x14\x93\x08\xF6\x84\xCF\x18\x3C\x87\x51\x64\x53\x8F\x26\x81\xA5\x53\xDD\x42\x73\x8D\x79\x80\x72\xA7\x82\x6C\x45\x2A\x89\xB6\x4B\xDB\x28\x85\x6D\x35\x66\x86\x34\x71\x5B\x80\x2D\x9D\x00\x64\x2E\x73\x84\xDE\x85\x58\x84\xB8\x86\xC2\x02\x2E\x9A\xBD\x3A\xFD\x74\x84\xE6\x84\x36\x76\xBB\x80\x51\x73\x2A\x89\xA5\x56\xDD\x04\x85\xA1\x78\x78\x85\xB8\x52\x5E\x87\x95\x6F\x14\x92\xE3\x70\x70\x01\x06\x7C\x85\xCC\x73\x2F\x61\x28\x94\x8B\x72\x31\x13\x86\xDD\x85\x75\x87\x74\x83\x51\x70\xB5\x77\x18\x97\x07\x9C\x84\x95\x82\x29\x87\xE9\x3E\x54\x0E\x1B\x1C\x6A\x7A\x3F\x0C\x86\x1E\x86\x87\x87\x55\x77\x14\x35\xB0\x5F\x7B\x58\x0C\x85\x86\xF0\x82\x8E\x85\x40\x75\x7A\x7D\x24\x92\x0C\x8F\x09\xE5\x82\x07\x83\x40\x83\xC8\x87\x30\x05\x32\x9F\x94\x28\x0C\x8E\x85\xDA\x85\x53\x30\xB7\x81\x50\x86\x29\x9B\x17\x9E\x0C\x7D\x85\x0C\x27\x13\x81\xB9\x85\x4F\x8F\x6B\x7F\x13\x8C\x59\x30\x86\xEC\x85\x41\x85\xA5\x75\x50\x81\x8E\x0C\x11\x88\x08\xE4\x7E\xAE\x84\x57\x04\xAC\x84\xE8\x52\x2B\x9B\x18\x93\x3A\x16\x84\x4A\x87\xBB\x03\xAD\x86\xF6\x74\x26\x9F\x0B\xA1\x0C\x94\x82\xC6\x26\x5F\x87\x15\x08\x58\x8A\xFF\x4B\x59\x3F\x0C\xF4\x85\x19\x86\xB6\x53\xBD\x87\xEF\x52\x80\x45\x16\xB7\x92\x19\x85\xCC\x6E\x72\x86\xB3\x81\x60\x86\xE6\x74\xB6\x37\x81\x4A\x7F\x00\x86\x83\x85\x70\x76\x54\x85\xA7\x6A\x18\xBD\x8D\x3F\x86\x72\x19\xEB\x6F\xFE\x73\x11\x73\xE0\x29\xE0\x54\x0B\xDD\x85\x74\x5F\x6B\x87\xCA\x72\x8E\x1A\x32\x9E\x18\xBA\x5C\x2D\x86\x94\x85\x97\x85\xA7\x87\x1F\x8B\x04\x8B\x1C\x9F\x0C\xF8\x81\x38\x85\xC0\x83\x5F\x52\x92\x0D\x33\x87\x7C\x10\x17\x40\x64\x12\x78\x74\x34\x6D\x13\x2F\x2B\xF7\x2B\xBD\x50\x11\x09\x85\xBD\x71\x4E\x71\xE7\x13\x22\x74\x39\x8D\x14\xBC\xBD\x06\x19\x98\x86\xC8\x86\x66\x79\x70\x81\x0F\x93\x74\x33\x03\xE8\x77\x34\x86\x5C\x86\xCD\x82\x57\x85\xDF\x6F\x04\xBB\x0C\xD2\x03\xA5\x86\x1F\x21\x0E\x7C\x8A\x7C\xE0\x74\x4A\x51\x0A\x3E\x78\x37\x78\x20\x79\x83\x7D\x2A\x5D\xC7\x0E\x05\xB5\xDD\x4C\x87\x14\x6E\x24\x7A\xC8\x55\x41\x4A\xFA\x17\xC0\x66\xE9\x4B\x4B\xB2\x2D\x81\x68\xA4\x7E\x3D\x76\xC4\x73\x1F\x08\x81\x37\x72\x4B\x41\x9B\x73\xF1\x2A\x35\x57\x9A\x51\x02\x5D\xE9\x33\x7C\xB0\x53\xED\x6A\x0A\x64\x4B\x25\x9B\x52\xE4\x59\xC1\x21\x87\xC0\x6A\x8B\x3F\x73\x60\xD3\x28\xE4\x6F\x1E\xBD\x0F\xA8\x58\x42\x30\x3F\x75\x9C\x79\xFF\x73\xE7\x65\x7F\x1A\xE9\x30\x42\x84\x74\x45\x79\x1A\x79\x78\x63\x98\x64\x9E\x50\xF2\x4A\x56\x1F\x78\x74\x76\x13\x78\xAB\x33\xE6\x72\xE7\x5E\xF9\x68\x6B\xC2\x6D\x4D\x79\x05\x84\xCC\x7F\x08\x42\x18\x99\xF2\x20\x79\xAF\x69\xB0\x57\x9D\x77\x7F\x83\x1C\x09\x1D\x81\xF8\x25\x75\x64\x30\x0B\x7B\x00\x8C\xF5\x62\x1E\x3C\xE0\x77\xF0\x36\x73\xEC\x74\xD8\x6A\x63\x3F\xE1\x6A\x61\x6B\xF0\x59\x0F\xD3\x87\xB3\x3E\x43\x6E\x78\x72\x38\x74\x9E\x65\xB1\x58\xF8\x7F\x6E\x4F\x79\x62\x6E\x0C\x78\x24\x1A\xE1\x7C\x53\x76\xF0\x40\x74\xA2\x6E\x12\x8B\x42\x06\x84\x82\xE7\x6E\xF3\x74\x7A\x65\x18\xA0\x56\x6A\x78\x35\x6A\xC7\x63\x21\x10\x21\x96\xF4\x55\x38\x3F\x6C\x77\x08\x05\x8D\x01\x8D\x66\x6E\xD6\x46\xD9\x20\x6F\x08\x6B\x24\x88\xFE\x7C\xF4\x6A\x44\x9F\x8F\x46\x32\x06\x19\xA8\x74\x23\x7C\xBE\x25\xF5\x6E\xD3\x69\x35\x77\xF9\x7F\x7C\x83\x7C\x60\x75\x98\x6D\xE5\x5E\xCD\x79\x6E\x79\xDE\x70\x88\xBC\x78\x5E\x77\x3A\x7F\xCB\x64\xE8\x62\xE6\x46\xFA\x02\x7D\xEC\x79\xDB\x71\xFF\x5F\x7C\x53\xD6\x4E\xCC\x06\x89\x62\x87\x6E\x6D\x48\x7D\x34\x7B\xFA\x6D\xB3\x47\x1D\x92\xF4\x4B\x16\x40\x65\xDE\x78\x69\x76\x75\x83\x6F\x08\x91\x5B\x10\x39\x4E\x21\x39\xC4\x50\x59\x00\x93\x8A\x16\x61\xCD\x72\x31\x0F\x02\x04\x29\xB4\x60\x0F\x6D\xFB\x6C\x2C\x51\x21\xA9\xD1\x6D\x2F\x8E\x73\x86\x79\xF1\x5D\x33\x42\xA2\x71\xDD\x52\x6C\x70\x62\x50\x05\xC1\x67\x25\x8A\x94\x88\xE9\x3B\x24\xB4\x12\xA1\x73\x8F\x18\x50\x89\x4B\x21",
"\x2E\x63\x4A\x91\x14\x3B\xA1\x2D\x7D\x55\x39\xD1\x41\x6C\x52\xD1\x7A\xB1\x6C\x25\x8A\x57\x2E\x89\x6B\x75\x98\x4F\xFF\x3D\x18\x44\x44\x22\xC9\x4E\xC7\x37\x72\x21\x72\x7D\x0E\x4D\x75\x7D\x8B\x92\x75\xB8\x5D\x58\x27\x72\x1F\x72\x83\x38\x4B\x70\x33\x6B\x00\x9B\x03\x6A\x12\x8A\x5B\x34\x72\xB8\x21\x36\x8A\xC5\x34\x2C\x95\x98\x7B\xF3\x28\x46\x85\x27\x6B\x65\x6F\x67\xFC\x32\x1A\x62\x24\xA4\xC5\x06\x33\x95\x7D\x49\x49\xB5\x77\x68\x43\xCA\x1F\x42\x6A\x13\xC2\x63\x02\x7A\x57\x63\x8B\x81\x35\x61\x41\x9A\xD8\x42\x0F\xA8\x4F\xAF\x63\x82\x83\x44\x86\x78\x82\xD5\x52\x1B\x1D\xB4\x26\x82\x9B\x7C\xF1\x20\x3F\x8E\xC0\x79\x4B\x6F\x5E\x07\x05\x35\x02\xB8\x30\x40\x4D\x64\x61\x45\x2C\x35\x14\x8D\x46\x9A\x4E\x4D\x3B\x71\x7E\x75\xF4\x4E\xBF\x70\x00\x16\x36\x77\x13\xDA\x75\xF2\x1D\x6D\x4C\xDC\x66\x42\x5D\x51\x57\x94\x7C\xC9\x36\x65\x91\x64\x5C\x67\xA4\x66\x0B\x76\x27\x4C\x94\x63\xCA\x62\x4D\xAC\x64\x48\x65\x57\x62\x52\x60\x2B\x7F\xE4\x12\xF4\x77\x4D\x57\x38\xD4\x4C\xCB\x3C\xA1\x8A\x5F\x6D\x7F\x0D\xC5\x23\x3F\xB4\x65\x4B\x38\x4A\x88\x68\x7C\x86\x14\x29\xAA\x8F\x77\x88\x87\x49\x0F\x51\x50\x8F\xDD\x45\x37\x77\x17\x01\x73\x5A\x64\x47\x8A\x5D\x67\x6C\x68\xCD\x2B\x2F\x72\x6D\x5A\x14\xBD\x59\x8F\x18\x4C\x1A\x06\x06\xA4\x50\x1A\x63\x86\x77\xBE\x46\x63\x51\x7C\xFB\x6D\x2E\x68\x27\x49\x3A\x45\x95\x77\x14\x8C\x67\xFD\x6F\x77\x77\x0E\x49\x15\x6F\x6A\x4B\x85\x4A\xC7\x5E\x8A\xC6\x4E\x4E\x60\x02\x8C\x98\x8A\x98\x5D\x39\x7B\x7F\x66\x8A\xFD\x89\xBA\x8A\x4D\x55\x63\x73\x52\x38\x26\x0A\x97\x4D\x4F\xE1\x6E\x7E\x77\x39\x8E\xF5\x25\xC6\x01\x98\x70\xB6\x2C\x5F\x89\x33\x8F\x67\xF0\x5A\xD5\x7A\x78\x2B\x93\x67\x15\xE5\x4E\x05\x55\x53\x60\xC4\x64\x60\x64\x47\x09\x99\x40\x16\x99\x8A\x83\x8A\x4C\x1A\x21\x1A\x6E\x4F\x51\x83\xD8\x4E\x69\x59\x61\x89\x74\xAA\x4D\x58\x8C\x03\x74\x56\x98\xD8\x79\x15\xB4\x58\x85\x47\x8D\x45\xF2\x58\x1D\x6E\x5F\x22\x50\x79\xDA\x0D\x66\x62\x67\xEF\x61\xDA\x4E\x6C\x4C\x76\x48\x1B\x6D\x15\x80\x7A\x14\x61\x79\x48\x68\x8E\x09\x70\x28\x39\x9B\x5E\x8E\x3C\x8A\x67\x6C\x1A\x4B\x5D\x88\x29\x67\x5A\x88\x2B\x86\xC2\x7C\x8A\x13\x33\xB3\x60\xD8\x47\xF8\x45\x1C\x6D\x87\x4F\x8E\x6F\x61\xDC\x27\xDA\x8B\xE6\x48\xA3\x89\xDA\x41\x2C\x8C\x95\x23\x19\x65\x18\x8F\x88\x6E\x88\x13\x6C\x7B\x63\x94\x63\x14\xAC\x62\xA3\x3E\x93\x89\xAD\x65\xA9\x84\x13\x7C\x94\x51\x15\xB1\x65\x5E\x64\x70\x4C\xBB\x4F\x90\x38\x29\x72\x29\xA3\x57\x2F\x65\xE7\x8A\x9B\x89\x71\x8B\x2A\x2D\x28\x6E\x2C\xB3\x17\xCB\x62\x47\x03\x6E\x4D\xAA\x60\xA8\x8B\x27\x63\x2F\xA7\xC1\x65\x8B\x14\x4E\x99\x58\x56\x67\xA7\x4B\x54\x91\x89\x67\xC1\x12\x4E\x46\x8B\x32\x6E\xA0\x64\xAA\x84\x5D\x86\x27\x96\x17\xC5\x49\xA3\x19\x3E\x18\xB6\x75\xB3\x8A\x83\x70\x2B\x9E\x1E\x5E\x75\x10\x71\x83\x78\x00\x71\x42\x76\xEA\x74\x29\x66\xEB\x77\x8B\x14\x63\x40\x62\x7D\x88\xB8\x8F\x3D\x98\xE8\x48\x17\xDB\x47\x1B\x8C\x33\x86\x47\x7D\x5E\x73\x12\x78\x97\x61\xFA\x1F\x48\x0F\x8C\x79\x88\xB0\x65\x2D\x89\x3B\x60\x00\x04\x03\x5C\x8A\xD8\x65\x7C\x88\x2E\x65\x5B\x77\xC6\x4C\x7E\x1A\x18\x8E\x61\x56\x88\x60\x8A\x76\x76\xB4\x4F\x61\x84\x31\x8E\xEA\x17\x76\x91\x31\x0F\x72\x91\x8A\xCB\x76\x62\x9A\x61\x58\x4E\x20\x76\x2A\x8D\x5A\x7F\xF8\x43\xEA\x16\xAF\x6F\x10\x26\x8F\x62\x65\x2F\x8C\x45\x5B\x76\x8A\x18\x64\xD7\x46\xD8\x58\x18\x88\x76\x11\x71\x0D\x8D\x90\x88\xEE\x61\x56\x74\xBF\x68\xFA\x5F\x89\x12\x76\xE3\x35\x59\x8C\xB8\x8B\x64\x92\x20\x88\x19\xAB\x54\x1B\x63\xF7\x6D\x94\x8B\x64\x7C\x62\x97\xD7\x6E\x18\xE2\x8C\x1E\x5A\xCC\x89\x8C\x88\xE0\x33\xCA\x18\x64\x1A\xFA\x07\x8B\xAA\x5D\x82\x77\xAE\x21\x9C\x59\x61\x80\xF5\x78\x19\xF2\x1D\xA3\x7D\x57\x75\xE5\x38\xCD\x82\x32\x73\x20\x96\xA9\x04\x48\x74\x8B\xE9\x44\x45\x7B\xC4\x8E\x4E\x8D\x34\xAF\x19\xFE\x6F\xB1\x7D\x14\x8F\xAE\x81\x3F\x82\x65\x8B\xC1\x77\xFA\x22\x7A\x62\x36\x5D\x7C\x2E\x5B\x9F\x77\x55\x94\x36\x6E\x32\x65\x18\xEA\x00\x1C\x8F\x3A\x8A\xC7\x8D\xE9\x7C\x31\x90\xB2\x3E\x8C\x86\x8C\x20\x8D\x92\x82\xA1\x7A\x68\x8D\xB7\x31\xDF\x57\x88\x43\x8C\x3E\x63\x99\x8E\x7B\x87\x64\x8A\x33\xA6\x16\xED\x8C\x4D\x79\x4B\x8E\x5A\x88\x36\x62\x67\x9B\x34\x8A\xEC\x04\x70\xB6\x7C\xA2\x89\x0B\x74\x96\x5F\x82\x67\x34\x9A\x19\x9B\x66\xB9\x8B\x1D\x72\xA7\x7D\xD0\x80\x4D\x59\x32\xB6\xC1\x06\x73\x87\x75\xC5\x8B\x63\x8C\xD3\x64\xB7\x45",
"\x32\x95\x1A\x87\x7C\xD9\x47\xE1\x8B\x4E\x8F\xDB\x89\x4B\x78\xBF\x6A\x16\x9E\x76\xA1\x16\x28\x8E\xB1\x8B\xC5\x89\x6C\x80\xE9\x4B\x1B\xB9\x7D\x59\x8D\x95\x17\xF2\x81\x7A\x8B\xC3\x78\x21\xBD\xF0\x75\x07\x36\x88\xF0\x71\x68\x76\x90\x16\x3D\x85\xE1\x75\x1B\xCE\x87\x5E\x6A\xEE\x85\x44\x14\xD7\x8A\xE5\x7F\xE8\x2E\xCE\x02\x80\x31\x6A\x7A\x7B\x14\x7C\xDE\x81\x91\x07\x1F\x94\x13\xF4\x2C\x03\x3F\xDE\x55\x85\x02\x6E\x23\xF0\x26\x17\x4A\x10\xBB\x74\xB3\x6D\x61\x89\x68\x8C\x36\x59\x51\x2C\x34\x87\xF8\x62\x6A\x95\x2D\xFD\x84\x8F\x3C\x89\x63\x46\x8B\xCD\x5C\xD6\x27\x6D\x7D\x18\x4C\x18\x93\x7F\xE4\x8F\xA2\x6F\xA4\x48\xF2\x09\x88\xB5\x80\x2A\x7F\xEB\x60\x69\x58\xE5\x62\x2B\xBD\x14\xF2\x6E\x01\x58\x1F\x77\x05\x8D\x52\x79\x41\x8A\x04\x48\x1C\x8E\x41\xED\x85\x0F\x88\x9A\x7A\x84\x83\xCA\x65\x23\xB4\x2B\x46\x8E\xA7\x31\x51\x1B\x05\x7A\x8D\x8F\xFF\x6D\x21\x92\xDC\x63\x8C\x32\x73\x5C\x8C\x25\x7B\xEF\x45\x43\x98\x1E\xBA\x1B\xA7\x78\x83\x6A\xF7\x69\xA8\x85\x87\x82\x03\x43\x22\xA0\xDC\x3F\x8E\x5F\x67\x1F\x8B\x7A\x75\x88\x8F\x73\x44\x1F\x90\xE7\x62\x88\x4C\x8F\xB3\x08\x13\x8C\x80\x8E\x44\x9D\x63\x2E\x32\x51\x88\x18\x79\x13\x8B\x1A\x8A\x3C\x24\x45\x8B\x88\x77\x1A\xC2\x8C\x58\x4F\x2C\x8A\xC3\x68\x27\x5C\x45\x89\x38\x90\xDF\x2C\x25\x47\x6C\x66\x54\x1F\x79\xED\x82\x26\x0B\x3B\x80\xDD\x1D\x2C\xC5\x19\x34\x8A\xFF\x7D\x87\x6C\xAA\x75\x05\xAE\x11\x8B\x80\xB3\x79\x38\x88\x74\x05\x56\x74\x47\x9D\xF3\x60\xF3\x00\x7D\xE3\x79\x5E\x76\xE4\x8E\x79\x55\xE8\x72\x77\x3F\x48\x07\x7D\x97\x7A\x33\x65\xA4\x88\x85\x7A\x7C\x65\x24\x9A\xDE\x25\x63\x7D\x8F\xE7\x6E\x5D\x5A\x91\x87\x24\x0C\x24\xB2\xAE\x33\x89\xBC\x89\x5A\x8B\x5F\x01\xF6\x81\x9A\x7D\x63\x3A\x12\xCE\x1D\xB4\x8E\xD4\x73\x57\x6E\x94\x85\xFC\x42\x26\xA6\xA7\x76\x87\x08\x6D\x3A\x44\x08\x8B\x8D\x4F\x16\x63\x2B\x0A\x05\x32\x89\xB3\x8F\x94\x4D\x62\x53\x87\x0C\x49\x9D\x25\xA8\xB0\x52\x85\x47\x02\x11\x66\x0A\x09\xF7\x8A\x3D\x8D\xF7\x5E\xE4\x35\x4D\x24\x73\x8A\x6C\x24\x53\x9C\x81\xD1\x21\xCD\x50\x1F\xAC\x16\xC9\x84\x94\x72\xAF\x4A\xF7\x81\x89\x31\x27\xA7\xCB\x33\x8C\x7D\x19\x46\x4E\xAA\x88\x9F\x8B\x1C\x6D\x38\x02\x74\x58\x8F\xD0\x88\x0F\x6C\x77\x62\x25\x74\x12\x0B\x33\x95\x53\x5C\x8F\x31\x64\x7B\x8D\xA6\x4A\x0A\x44\x7F\x98\xE8\x3A\xBF\x10\x76\xE4\x8D\x9B\x8F\x76\x72\xBD\x4D\x70\x14\x1C\x5B\x19\xD9\x4D\xBC\x16\xE6\x60\xFE\x89\x47\x62\x7F\x9C\x3F\x80\x54\x7A\x3F\x35\x49\xF7\x8F\x8A\x61\xFE\x88\x75\x81\x36\x4F\x1C\xFE\x8F\x80\x7D\xBB\x8C\x99\x8A\x86\x83\x80\x95\xC9\x6D\x0A\x17\x8B\xD5\x8B\x79\x88\x26\x1D\x8F\x1A\x5D\x90\x36\x9C\x17\x88\x65\x82\x38\xF0\x8A\x4B\x89\xA7\x86\x25\x6E\x2F\xBB\x03\xC5\x8A\x2A\x8B\x9A\x89\x24\x3D\xA5\x85\x52\x8B\x2F\x95\x72\x6D\x8B\x43\x8B\xF7\x89\x82\x89\x90\x8C\x7B\x8A\x6C\x6A\xC9\x26\x39\xC7\x78\xD5\x87\x78\x66\x4D\x62\x04\x30\x93\x44\x18\xFD\x8B\x42\x8A\xF2\x89\x96\x66\xBC\x8E\xE7\x69\x2A\xAF\x71\x2B\x65\x38\x91\xA6\x88\x82\x89\x06\x91\x5F\x9F\x4C\x7A\xAB\x5E\x8B\x55\x8B\xA7\x4D\xA9\x8E\x68\x48\xC9\x1F\x65\x54\x18\x81\x7A\xD2\x8D\xE6\x8A\xB2\x73\xAE\x86\x73\x81\x2E\xB6\x8C\x01\x47\x41\x90\x2A\x3B\x0C\x48\x8A\x59\xD1\x61\xDC\x2C\x15\x94\x66\xE7\x4F\x2D\x90\x53\x48\x93\x10\x30\x62\xD8\x7A\xE0\x5B\x60\x89\x8A\xA3\x6A\xB6\x88\xC4\x8B\xB1\x69\xEB\x29\x21\xDB\x38\x58\x4E\xD8\x8B\xE9\x8B\xA4\x21\x31\x6A\xCC\x0D\xBF\x20\x90\x0E\x8D\x79\x8B\x28\x1A\x8E\x19\x34\x47\x40\x87\xCA\x51\x4E\x8E\x78\x07\x88\x94\x6D\x1B\x65\x86\x9B\xBF\x74\x90\x68\x90\xC0\x8F\x72\x63\xAB\x7C\x63\x4C\x5A\x8C\xE0\x0C\x17\x90\x8B\x38\x3C\x77\x62\x15\x93\xED\x4F\x91\x2D\x30\xB1\x21\x83\x8B\xA3\x18\x57\x1B\x8D\x8F\x0B\x91\x6D\x96\x30\x9C\x8A\x60\x8C\x3F\x8D\x85\x75\x81\x79\x00\x91\x82\x67\xF5\x50\x93\x29\x7D\xDB\x8D\x10\x8E\x07\x74\x44\x59\x89\x86\x65\x66\xC2\x30\x7D\xC4\x8C\x59\x7D\xF1\x84\xB2\x74\x67\x8D\x37\xA2\xC4\x76\x8C\x58\x8C\x67\x8C\x66\x7E\xAD\x8D\x55\x9D\x32\x83\x1A\x8F\x70\xB0\x91\x58\x8E\x2C\x90\x3B\x78\x6B\x85\x33\x84\x19\xBB\x8D\x67\x65\x1E\x91\x9A\x8B\xD2\x83\xCA\x59\x45\x9B\xEC\x23\x70\x26\x66\x75\x8F\x30\x94\xD6\x75\x8C\x93\x32\x84\xEE\x48\x91\xCD\x8C\x59\x8C\x8C\x8A\xCF\x8A\x88\x96\xC1\x40\x00\x29\x8D\xAC\x90\x4C\x62\x2B\x94\xD0\x81\x8D\x95\x36\x8E\x1B\xD7\x8D\x8B\x78\x5B\x8E\xC7\x8D\xDC\x83\xB1\x77\x45\x8E\xB4\x7C",
"\x90\xE6\x8D\xEA\x46\x37\x91\x20\x90\x67\x90\xD7\x5D\x8F\x6B\x8D\x9D\x8D\xC4\x24\x0B\x70\xD7\x73\xD2\x62\x35\x8B\x23\x8E\x91\x78\x4F\x79\x90\x34\x96\xA0\x72\x8D\x89\x1E\x49\xF4\x58\x8D\x0F\x76\x86\x60\xB0\x8B\x92\x7D\xC9\x58\x46\xA3\x1E\x85\x61\xEA\x74\x3F\x91\x2F\x92\x17\x91\x0C\x58\x34\x81\x23\x9A\x8D\xE3\x90\xA9\x79\x39\x96\xD3\x8A\x6C\x8C\x48\xA1\x1A\xF1\x8D\x6E\x14\xD3\x50\x76\x61\x24\x09\x21\x11\x38\xA9\xFB\x16\x0C\x4D\x73\x3D\x2F\x73\x66\x92\x84\x6A\x83\x2C\xBB\xFF\x00\x00\x9C\x00\x3B\x90\x18\x91\x01\x9E\x7E\x99\xEC\x30\x1F\x8F\x8E\x21\x55\x04\x6E\x42\x29\xFF\x62\x7E\x99\x3E\x95\x1F\xC6\x69\xFD\x8E\xD6\x39\x38\x7B\x16\x9A\x8D\x96\x34\xB8\x1C\xC3\x64\x05\x90\x53\x91\x42\x5A\x0E\x95\x4C\x58\x64\x32\x31\x41\x92\xF1\x90\x98\x48\x51\x96\x56\x02\x81\x93\x26\xB3\x24\xD5\x89\x4F\x93\xE0\x8F\x4D\x74\x29\x9B\x80\x88\x4B\xBA\x1F\xD2\x63\x0E\x91\xA5\x92\x54\x91\x03\x9F\x8F\x9B\x48\xB7\x0F\xF4\x56\x26\x66\xF3\x63\x20\x4D\x9B\x08\x8C\x41\x18\x03\x0A\x7B\x07\xAA\x07\xBE\x92\x6F\x07\x2F\x93\x23\x1F\x90\x49\x3B\x0A\x02\x64\x02\x66\x1C\x16\x32\x30\x9B\x77\x13\x11\x2C\x29\x7C\x92\x7A\x0E\xC2\x91\x5B\x03\x89\x01\x99\x92\x1C\x08\x3B\x6B\x02\x38\x10\x80\x0C\xB3\x19\x4C\x1C\x98\x92\x4C\x8F\x08\x6C\x14\x00\x0E\xC6\x90\xA6\x3C\x32\x90\xDF\x09\x17\x1E\x12\xA9\x02\x72\x26\xD1\x93\x36\x8B\x81\x8F\x18\x68\x9A\x4C\x26\xF7\x28\x98\x3D\xE1\x32\x6A\x92\xF7\x8F\x33\x2C\xBC\x18\xA3\x6A\x0E\xFF\x05\xD2\x93\x0E\x1F\x31\x42\x3F\x19\x40\x31\x26\xBE\x7B\x9D\x92\xC9\x04\x52\x09\x38\x9B\x3F\x1B\x8B\x32\x02\x5B\x2A\xC4\x92\xC7\x91\x0C\x23\x36\x99\x96\x8E\x04\x55\xDC\x23\x02\xA9\x46\xE6\x93\x5B\x93\x3B\x63\x37\x0F\x4E\xBD\x41\x37\x93\x09\x1D\xDC\x93\x11\x0E\x33\x9F\x15\x0C\x8D\x09\x27\xED\x02\x89\x20\xE9\x90\xC0\x8B\xFF\x8E\x77\x15\x3E\x90\x20\xC7\x51\x7A\x0F\x10\x55\x79\x93\x3A\x9C\xB1\x78\x4E\xAF\xA2\x5F\x93\x0F\x05\xD0\x91\x7A\x91\x31\x5D\x1F\x02\x4F\x91\xC7\x7F\x63\xDF\x8F\x01\x66\x21\x26\x3E\x9D\x74\x91\xC4\x10\x26\xBA\x93\xDC\x92\xA8\x4A\x40\x00\x3E\x9F\x15\x1D\xED\x41\xE5\x7B\x93\x95\x93\xFD\x04\x8A\x67\x3F\x97\x44\x0A\x46\x74\x43\x43\x93\x7A\x0E\x07\x97\x23\x23\x2F\x2B\xD2\x69\x4D\x91\x28\x95\x0F\x9C\x22\x28\x39\x79\x26\xE0\x14\xA0\x9D\x93\x18\x1E\x5F\x02\xD0\x92\xC2\x24\x3E\x5C\x43\x99\xA0\x93\x11\x0D\x3D\x1F\x94\x1C\x76\x4F\x6C\xE8\x1E\x35\x97\xA1\x8B\x46\x7C\x87\x0C\x93\x12\x94\xC0\x01\x86\x92\xEF\x05\xEF\x1D\x50\xA7\x28\x92\x07\xE7\x93\xE8\x5C\x89\x90\x40\x92\x39\x17\x51\xBB\x0F\x1A\x32\xBC\x68\xEF\x75\x76\x91\x63\x0A\x9B\x91\x51\x91\x04\x0C\x94\x06\x65\xCA\x0C\x84\x95\x48\x95\x79\x02\x1A\x88\x27\xAD\x94\xF4\x21\x19\x96\x6E\x95\x46\x95\xA2\x8D\x0B\x3E\x28\xB3\x04\xA2\x3B\x11\x95\xE8\x16\x46\x91\x03\x28\x51\x80\x29\xAE\x30\x40\x66\x22\x95\x83\x95\xF2\x00\xE4\x23\x50\x90\x29\x8F\x21\x4B\x95\x31\x96\x8B\x95\xC3\x25\xA1\x88\x50\x8C\x29\xAE\x94\x52\x95\x23\x08\x95\x94\x47\x9B\x3F\x17\x52\xAD\x05\x59\x94\x8F\x67\x2D\x95\x95\x97\x41\x06\xA7\x99\x3C\x11\x70\x41\x94\x2C\x95\x37\x94\x3D\x26\x3B\x97\xA6\x92\x51\x9B\x88\x34\x94\xF7\x26\x2E\x95\xC6\x1E\x4B\x92\xA2\x8C\xB2\x0A\x2A\x86\x1E\x8C\x94\x1F\x28\xA0\x91\x4C\x99\x77\x02\x54\x8F\x42\x48\x94\x93\x0E\x23\x96\x80\x91\x20\x00\xA3\x8D\x52\xB7\x24\x9E\x06\x07\x94\xCE\x91\xA1\x91\x22\x09\x33\x76\x59\x48\xCD\x22\x51\x85\x24\xA4\x65\x87\x28\x11\x0B\xCA\x7F\xBB\x08\xCD\x2C\x51\x99\x21\x5E\x53\x8E\x6F\x03\x52\xAB\x98\xBE\x06\x23\xC2\x94\xAF\x50\x99\x5A\x2E\x57\x08\x75\x20\x55\x55\xAF\xB2\x56\x3B\xC1\x50\x11\x51\xA0\x61\x39\x59\x54\x31\x4E\xA3\x2A\x85\x43\x2E\x95\x46\x2B\x40\x51\x2A\x2E\x35\x6A\xCE\x47\xA4\x57\x93\x96\x36\xDC\x91\x48\x01\xB5\x6F\xAA\x86\xA0\x11\x50\x3E\x95\x8F\x38\x5E\x50\xA5\x97\xA3\x7C\xBB\x08\x9A\x7A\x2A\xA9\x02\xC2\x51\xAC\x34\xB6\x94\x5B\x99\x9B\x19\x08\x21\x2B\xAA\x52\xC4\x94\x74\x40\x7A\x96\x52\x94\x13\x24\xE8\x4F\x42\x4A\x95\x5D\x67\x82\x50\x3C\x57\x59\x99\x13\x2E\x4F\x84\x1E\x18\x95\x86\x62\x17\x95\x60\x97\x58\x96\x98\x98\x4C\x8B\x04\x09\x93\x06\x1F\xC5\x93\xB1\x97\x31\x96\xA6\x8C\x57\x91\x04\x24\x93\x6A\x94\x7A\x23\x65\x96\x3E\x09\x99\x82\x08\x1B\x26\xB9\x13\x06\x96\xEC\x25\x07\x82\xDA\x48\xEE\x6F\x0A\x87\x26\xBE\x7B\x8A\x92\x6A\x7E\xC4\x97\xAA\x75\x4C\x16\xF6\x4B\x2C\xB9\x05\xD9\x2C\x87",
"\x96\xC1\x1C\xDD\x71\xED\x15\x17\xA8\x94\x74\x84\xFD\x94\x86\x95\x1C\x11\x20\x09\xB1\x95\x16\x98\x4F\x6F\x86\x79\x73\xB8\x87\xC7\x97\x43\x0A\x10\x0B\x76\x23\x2C\xF1\x86\x6C\x14\xF3\x83\xF0\x28\x3D\x86\x2C\x8D\x1C\xBE\xC5\x2A\x96\x35\x96\x91\x94\xAF\x1B\x40\x8B\xB1\x9C\x59\x9D\x2C\x8F\x84\x33\x96\x1C\x2C\x7A\x17\x61\x99\x1B\x8C\x53\x0B\xA5\x51\x52\xC5\x40\x4C\x3C\xEF\x12\x2D\x55\xA0\x43\x9C\x64\xCE\x16\x96\xFE\x94\x85\x01\xEB\x85\x65\x9E\x5A\x85\x4B\x51\x2D\xAC\x72\x4F\x96\xD4\x67\xD7\x95\xE2\x69\xB8\x14\x5A\xB8\x78\x56\x96\xA1\x73\x8B\x94\xDB\x14\x65\x97\xB3\x91\x9D\x41\x80\x55\x8F\x6C\x15\x79\x8D\xE5\x52\x7A\x83\x9E\x8B\x08\x2B\x2D\xD7\x87\x0C\x8F\x1B\x89\xDD\x90\x3F\x9E\xB3\x90\x2F\x38\x20\x04\x07\x5C\x96\x7F\x8D\xF3\x87\x3E\x98\x3D\x32\x5B\xAD\xD0\x74\x96\x84\x96\x4B\x52\xE0\x92\x6F\x94\xB8\x89\x5A\xB8\x20\x14\x16\x0F\x97\xC5\x97\xD5\x88\x6E\x91\x93\x9A\xCB\x78\xE5\x50\x0B\x56\x72\xAC\x94\xD0\x97\x59\x87\x3F\x38\xC2\x1A\xE5\x46\x72\x78\x72\xB2\x02\x55\x77\x62\x9B\x41\x0F\x58\x9F\x2E\xB2\x92\xC7\x69\x8B\x00\x74\x0E\x26\x9A\xB9\x80\x59\x9C\x2E\xDC\x96\x15\x8F\xCA\x95\x4A\x70\xA0\x24\x16\x16\x49\xA4\x2E\xC2\x96\x08\x2B\x9D\x93\xA6\x94\xF0\x81\x29\x0F\x99\x6C\x1C\xBC\x6E\xAD\x96\x9A\x97\xC4\x10\x77\x9A\x9F\x7F\xB7\x68\xF8\x76\x7F\xD0\x2E\xC2\x07\xE2\x8D\x2A\x57\xB1\x9D\x0F\x0F\x2C\xCB\x97\xBE\x89\x36\x54\xEC\x53\x52\x0F\x72\x61\x5E\xB8\x58\x3A\x1D\x01\x97\x39\x54\xEC\x55\x64\x9B\x41\x98\x0A\x08\x15\x2F\x6E\x17\x96\x9B\x95\xE8\x11\x4C\x16\x0F\x5B\x06\x92\x9B\x22\x81\x7D\x97\xF0\x94\xF1\x97\x1D\x8E\xEE\x70\xFD\x47\x2D\xC8\x80\x8E\x97\x85\x03\xD2\x97\x66\x95\xF7\x6D\x5F\x83\x0B\xD2\x4D\x29\x84\xEB\x94\x0E\x12\x7C\x9F\xDB\x6A\x16\x85\x2D\xAC\x84\xEF\x97\x08\x84\xF3\x1F\x62\x93\xBF\x83\x5F\xAC\x08\xB9\x96\xC7\x80\x69\x4E\x53\x81\x7D\x99\xB5\x98\x58\x99\x2F\xAF\x81\xFF\x96\x65\x80\x9D\x2A\x82\x91\xBF\x81\x59\xAC\x2D\x86\x98\x12\x98\x04\x9A\x90\x82\xDA\x40\x1E\x8C\x60\x9B\x2E\xFC\x97\xA6\x81\xE7\x81\x04\x9E\x2E\x83\xC1\x84\x61\x95\x30\xB2\x97\x4C\x96\x12\x98\xF7\x94\x76\x8C\xC5\x4C\x61\xA9\x2C\xAE\x97\xD8\x97\xA1\x95\xE6\x87\x65\x96\x3B\x91\x59\xAE\x30\xFE\x96\xCA\x1C\xDC\x97\x0C\x9C\x4D\x1B\x32\x65\x8B\x2D\xCC\x2D\x87\x30\x66\xA5\x08\x3A\x5D\x3D\x6A\xBF\x8B\x08\x16\xA2\x5C\x96\x41\x98\x59\x1F\x10\x98\x7B\x2D\xC3\x9E\x88\x03\xA2\x48\x28\x3B\x16\x9B\x55\xCB\x67\x84\x90\xB8\x97\x59\x89\x31\xC9\x1E\xC6\x2B\xB8\x96\xCD\x50\x8A\x07\xB7\x91\x24\xB0\xDC\x17\x96\x55\x98\x19\x99\x25\x90\x39\x0A\xC5\x83\x23\x90\x11\x16\x51\x5E\x99\x8B\x94\xE4\x96\x8A\x92\xD1\x6C\x53\x28\xCD\x3C\x33\x72\x0D\x98\x2F\x0B\x9A\x78\x9A\x99\x8F\x60\x9D\x2D\xA6\x3C\xB2\x96\x85\x2C\x91\x4A\x8E\x98\xC3\x8E\x48\x3A\x30\xF7\x98\x35\x3D\x26\x9B\xE9\x1E\x3B\x10\xC4\x83\xF1\x35\xE5\x3D\x0C\x73\x98\x1C\x2F\x11\x9E\x8E\x91\x8D\x49\xA1\x60\x52\x29\x64\x63\x88\xEF\x13\x7C\x71\x12\x5C\xE3\x34\x62\xBF\x31\x8D\x99\x33\x2E\xC7\x3F\xCE\x91\x0B\x38\x34\x68\x63\xA9\x2A\xDB\x95\x89\x98\x1C\x12\xEA\x00\x89\x9F\xC9\x92\x56\xBA\x51\x3A\x66\xA9\x51\x6D\x96\xE1\x8A\x55\x9D\xC7\x82\x57\x17\x32\xA5\x99\x43\x95\x53\x9A\xA9\x93\x5B\x98\xAA\x87\x9A\x60\x32\xA8\x31\xAC\x95\x9F\x6D\xB5\x90\xBA\x27\xAD\x9B\x56\xA3\x7E\x63\x95\x05\x70\x6F\x96\x2E\x7A\xDE\x1B\xAB\x8D\x89\x40\x33\xB7\x95\xC1\x95\xD9\x76\x99\x66\x61\x73\x6B\x71\x58\x6B\x2B\x89\x96\x91\x24\x77\x94\x60\x00\x5E\x91\xF1\x2D\x56\xBB\x12\x0E\x99\xA6\x0E\x68\x97\x8A\x93\x5B\x94\xAD\x9B\x56\xB0\x2A\xD3\x1E\xE3\x95\x5F\x9B\xB6\x91\x98\x9E\xCB\x83\x66\x93\x3A\x45\x99\xE2\x98\x53\x98\xB9\x91\x99\x9D\xA1\x4C\x66\x93\xE8\x4E\x99\x3B\x94\x68\x99\xBB\x96\x60\x7F\xAE\x9D\x83\x0B\x2B\xF5\x22\xD6\x98\xB0\x67\x1A\x55\x3D\x91\xAD\x91\x65\x9B\x32\xBF\x66\xEA\x99\x5A\x99\xE8\x24\x95\x9D\xC7\x07\x45\x6B\xDE\x3B\x99\x2D\x5B\x70\x9A\xB8\x93\x9C\x97\xAB\x82\x66\x9F\xB9\x19\x21\xE8\x99\x85\x9A\x3A\x9D\x00\x7C\xCE\x83\x46\x4B\xF4\x48\x55\xEB\x1F\x4E\x96\x8B\x94\x89\x45\xCF\x99\x89\x37\x33\xE5\x22\xF9\x98\x7A\x96\x45\x26\x5E\x91\x76\x12\x4F\xBA\x26\x98\x3D\x84\x06\xFE\x93\x88\x7F\x8B\x9D\xC0\x90\x2E\x1C\x2D\xAA\x9A\xDD\x6E\x93\x9B\x11\x08\xD3\x3B\xAF\x87\x69\xA9\x2D\x8D\x98\x36\x07\x87\x94\x4C\x99\x7A\x9B\x34\x78\x9A\x68\x3F\x2A\x07\x43\x72\x31\x31\x11\x98\x31",
"\x9B\xBE\x94\x9A\x4A\xA4\x56\x66\xBE\x7B\xA0\x9B\xB9\x62\xA9\x93\xC0\x8D\x60\xB5\x31\x86\x98\x4C\x9B\x15\x98\x5D\x3A\xA6\x36\x12\x43\x6A\xB4\x59\x5C\x96\x5C\x2F\xEA\x6D\xAF\x0D\x24\x4C\xBC\x8D\x60\xBC\x2F\x8B\x42\xDD\x6F\xC3\x77\x26\x9D\xA9\x71\xCA\x99\x61\x97\x30\xFD\x97\x62\x76\x0D\x9A\xD8\x71\x80\x9C\xED\x67\x61\x85\x30\xC0\x7B\xD8\x26\xCA\x5F\x76\x4F\xD7\x0E\x71\x15\x7C\x6C\x97\x65\x9A\x7E\x99\xB3\x9A\xE7\x5E\xAE\x9F\x6B\x0C\x53\x32\x35\xB8\x4B\x3A\x04\x80\x0E\x6E\x64\x2A\x07\xC2\x88\x2A\x0F\x2C\x83\x9B\x71\x9B\x6F\x0D\xBE\x58\x42\x06\x33\x13\x8F\x78\x35\xBB\x7B\x5C\x97\xF9\x62\x5F\x9A\xB1\x9F\xF4\x50\x10\x00\x1C\x0E\x9B\xAD\x98\xC3\x9B\xCD\x92\xB2\x9C\xB9\x9B\x8F\x78\xC7\x7E\x63\x20\x16\x09\x4F\x76\x44\xC2\x40\xDA\x8F\x6C\xAE\x34\xF6\x98\x9E\x9A\xD2\x98\xC9\x23\xB5\x66\x1F\x65\x90\x59\x2A\xA0\x9B\x56\x0C\xD7\x9A\x61\x63\xB5\x9F\x1F\x77\x58\xB9\x34\xED\x96\xF7\x62\xD5\x9B\x10\x24\x4D\x16\x68\x17\x90\x48\x99\x14\x16\x1B\x65\x12\x67\x82\x66\x43\x6C\xD2\x9B\x5C\xB7\x36\xE2\x98\xC1\x9A\xD1\x00\x85\x65\xB7\x97\xAB\x62\x6E\xAA\x27\x76\x05\x71\x98\xDF\x9A\x89\x65\xA9\x9B\xB9\x99\x10\x0F\x2C\xC9\x9B\x47\x4D\xE9\x98\x6F\x98\x88\x59\x68\x1E\x99\x52\x61\x56\x9A\xC7\x9A\xB4\x98\x66\x44\x36\x47\x78\x2E\x24\x97\x60\x27\x98\xD6\x9A\x36\x98\x8E\x40\xF6\x8A\x7C\x95\xB8\x54\x2C\x4D\x8F\x57\x96\x0F\x9A\xEB\x91\xBC\x98\xE0\x37\x25\xBA\x1E\xEC\x9B\x3A\x4F\xC4\x50\x74\x08\xBE\x97\xD3\x95\x6E\xBF\x31\xFC\x9B\xBA\x8F\x14\x4F\x70\x9E\x5E\x09\x21\x0E\x90\x45\x37\xAE\x97\x9A\x9A\x31\x98\x85\x62\xC0\x9F\xDC\x81\x18\x1B\x10\x06\x9C\x17\x97\x18\x99\x11\x7B\xC0\x93\x63\x50\x64\x8D\x25\x94\x90\xD5\x8F\xD6\x85\x5B\x96\xF9\x82\xC4\x67\x70\x82\x2F\x8B\x99\x62\x99\x0D\x9E\x8E\x67\xFA\x83\x81\x88\x4A\x89\xA6\x13\x99\x22\x9D\xFE\x9A\xEB\x91\x8C\x96\x23\x67\x4A\xA7\x25\x9C\x9C\xAB\x6A\xF3\x8F\xF0\x93\xCF\x8D\xB3\x98\xFB\x2D\x32\xF4\x9B\x10\x93\x95\x26\x8C\x98\xBA\x03\x63\x97\x58\xA9\x37\x98\x98\x4E\x64\xBC\x5D\x19\x1A\xDA\x41\x2D\x92\x6F\x82\x2F\xA0\x98\x62\x4B\x11\x98\x0E\x54\xAD\x9C\x5F\x4E\x6B\xBF\x31\x88\x5E\x88\x70\x69\x4C\xE3\x86\xC6\x9A\xBE\x9A\x6B\x90\xE2\x76\x97\xBD\x70\x26\x9C\xDF\x5C\x80\x9F\xE4\x9B\xDF\x6A\x35\xC8\x77\xD2\x4D\x03\x7A\x91\x98\xC7\x28\xE4\x8D\x3C\x5F\xE2\x5F\x71\x4C\x9C\x71\x70\x97\x9F\xAC\x96\xE6\x94\x61\xAF\x14\x49\x1F\x8D\x2A\x03\x54\x00\x03\x80\x2D\x12\x3C\x76\x16\x2B\x97\x2B\xE5\x21\xD1\x3F\x21\x50\xBB\x29\x59\x2F\x68\x9A\xD9\x0D\x1E\xA3\x2A\x65\x3F\x9E\x9C\xAF\x50\xE8\x9E\xAE\x3B\xBF\x18\x52\x1A\x8E\x98\x44\x6F\x2D\x22\x2A\x64\x94\x62\x67\x50\x14\x22\x31\x28\xE6\x36\x9D\x57\x8A\x99\x1A\x06\xAE\x3B\x50\x5C\x50\x6C\x22\xD9\x89\x5F\x89\x25\x23\x40\x73\xDE\x38\x2B\xFE\x92\xC2\x93\x82\x97\x76\x96\x32\x94\xEB\x28\x71\x2E\x29\xA3\x9D\x0A\x95\xE5\x93\x7C\x95\x02\x96\x7C\x56\x4E\xB2\x41\x3B\x9A\xF7\x3F\x56\x9E\x79\x92\x9B\x9C\x3B\x3B\x56\x9D\x28\xE5\x94\x9C\x95\x63\x95\x9A\x91\x49\x9B\xA6\x87\x1A\x5C\x0B\x9A\x9A\x51\x95\x43\x97\x94\x91\x9E\x97\x78\x01\x50\xBD\x29\xA0\x94\x8D\x94\x53\x27\xA3\x91\x74\x11\xA9\x9F\x8E\x53\x2A\xEA\x99\xC0\x9D\x47\x20\x45\x19\x6C\x92\x38\x68\x4C\x55\xDC\x21\x67\xD5\x9D\xD1\x64\x2E\x8E\xC3\x28\x95\x59\x76\xA9\xCE\x34\x93\xAC\x92\x08\x69\x24\x90\x93\x69\x38\x3D\x19\x67\x2D\xE2\x3D\x14\x1A\xC3\x96\x0E\x6F\xDF\x84\xB8\x90\x1E\xB3\x2D\xEC\x9D\xA7\x78\x4C\x19\xBF\x8D\x7C\x83\xB9\x8C\x4F\x9F\x96\x1A\x88\x1D\x8C\x66\x64\x0C\x7D\xD8\x6E\xCC\x7E\xCB\x0B\x1C\xEF\x9D\x11\x13\xA8\x72\x5C\x73\x3B\x51\xB3\x96\xCA\x66\xDD\x58\x72\x41\x2D\xA7\x70\x60\x70\x23\x9D\xCC\x96\xEF\x33\x0F\x85\x73\x62\x73\xB3\x70\x59\x74\xE1\x9A\x0C\x70\xAB\x36\x80\x69\x72\xB2\x2D\xB5\x71\xD7\x3A\x32\x7E\x96\x7D\x52\x75\xF0\x1E\x44\x7B\x73\xB3\x64\xEA\x94\xFE\x89\x3E\x8F\x38\x84\x91\x6C\x87\x2F\x9C\x8B\x8D\xCC\x8B\x01\x89\xE8\x8F\x78\x89\x4E\x75\x87\x1F\x92\x6E\x8C\x7F\x6B\xB9\x6A\x5C\x3C\x4D\x47\x32\xDA\x88\xD2\x96\xCD\x51\x38\x40\x76\x5D\x61\x32\x53\x64\x2F\xDB\x97\xF7\x40\xBA\x6C\xF4\x91\xD6\x93\xCF\x67\xBD\x62\x22\xC1\x6B\x9A\x52\x3F\x6A\x20\x9A\x0B\x51\x33\x78\x74\x89\x51\x52\x98\x4F\x98\xDC\x1D\x87\x2E\x9E\x8B\x7A\x78\x99\x4E\x1D\xE3\x1B\x75\x50\x40\x99\x9F\x22\x9F\x93\x8D\x42\x44\x4D\x3D\x84\x51\x1D\x4B\x41\x9D\x21\x58\xEB\x9B\xA0\x5C\xDA",
"\x55\x3D\xD1\x9E\xFF\x4B\xDD\x8C\x41\x55\xD3\x9A\xB1\x7C\x7A\x8F\x19\x07\x69\x5F\x9E\x28\x99\xD8\x9A\x28\x28\xFF\x51\x5E\x55\xC3\x6F\x98\x3D\x0C\x4D\x40\x1F\x9E\x63\x8D\x36\x6B\x4B\x6F\xCD\x0A\x65\xE1\x9D\x88\x43\xDC\x63\x6F\x62\xA1\x56\x9B\x79\xA5\x66\x99\x7B\x53\x02\x44\xDD\x67\x0C\x60\x98\x44\xB8\x02\xA6\x38\x41\xC3\x63\xB6\x3E\xB5\x9D\x39\x9D\x9C\x47\x9C\x43\x9F\x6E\x96\xBC\x40\xF6\x90\x6A\x8B\x31\x59\x43\x49\x7E\x79\x8C\x6F\x5D\xCF\x41\x96\x18\x8C\x51\x71\x22\xA3\x56\xE4\x7D\x3B\x97\x67\x6C\x69\xCC\x64\x68\x51\x29\x5C\xF6\x9D\x44\x73\x32\x81\x9A\xAF\x9E\x7F\x9A\xCE\x2E\xA0\x91\x77\x96\x1F\x08\x34\xCE\x5A\x0A\x9B\x8E\x4B\x31\x9E\x1C\x93\xE9\x0E\x68\x96\xC5\x53\x1E\x11\x9A\xDD\x9C\x43\x9C\xF7\x9C\xBB\x15\x68\xB8\x71\x69\x95\xAD\x8B\x68\x9F\x3C\x9F\x19\x94\x0F\x34\x66\x94\x32\xAD\x9F\xD4\x51\x4C\x9A\x3B\x0F\x1A\x5D\xCF\x8F\x45\x47\x4B\x39\x9D\x36\x9B\x8A\x6C\xC2\x97\xF0\x04\x3A\x7D\x63\x19\x04\x16\x94\xD9\x9E\xCA\x95\x6D\x90\x4C\x90\xED\x9A\x3B\x1C\x0C\x3C\x93\xB9\x04\x91\x05\x62\x52\x36\x9B\xEA\x82\x7F\x81\x3E\xD1\x39\xD5\x9E\xC2\x0F\x6B\x91\xFE\x0F\x9B\x9D\x69\xAD\x51\x68\x1F\xDF\x50\x9D\x70\xFA\x1D\xB7\x33\x35\x68\x3C\x3A\x3F\xFB\x51\x4D\x47\x9E\x73\x3F\x55\x9B\x80\x71\x71\x57\x90\x3F\xAB\x6C\x37\x9F\x6C\x9B\xD8\x66\x6C\x42\x00\xA0\x3D\x23\x1C\xB3\x87\x24\x43\x91\x42\x49\x43\x97\x14\x9C\x54\xEB\x2B\x84\x11\x05\xF9\x91\xFE\x47\x19\x6E\xD1\x95\xF9\x82\x31\x9D\x23\xBA\x46\x6C\x63\x13\x8D\xFE\x87\xD3\x65\x9D\x4F\x80\xBF\x35\xBC\x4B\x3A\x04\xDD\x48\x5F\x9D\xB7\x44\xEB\x34\x7D\x8D\x20\x73\x9A\xA0\x5F\x87\x47\xD6\x55\x3C\x6B\x02\xBF\x2B\xBA\xFC\x6B\x1F\xF0\x4A\x79\x1C\x88\x82\xCC\x7B\x06\x7D\x8E\x08\x36\x80\x80\x85\x68\x02\x90\x0C\xA6\x06\xA1\xFE\x76\xA0\x39\x40\x93\x1D\xE2\x4B\x5B\x53\x70\x37\x07\xA8\x5E\x56\xC2\x5A\x97\x00\x9B\xDD\x4B\x1B\xA2\x1C\x27\x08\xA6\xF8\x8B\xC3\x54\x34\x68\x63\x8B\x9B\x51\x04\x7E\x4D\xBE\x40\x21\x08\x27\xB2\x4D\x1C\x9B\x19\x1F\x00\x4F\x44\x03\xC0\x40\x99\x78\x31\x54\x82\x69\x63\xD7\x49\x79\x63\x8B\x0A\xB6\x9B\x61\x54\x6D\x9C\xB1\x29\x9B\x63\x94\x37\xA1\xB0\x63\xAB\x20\x07\xA9\x52\xAE\x41\xCF\x4C\x23\x16\xA2\x15\x64\x07\xCA\x41\xEF\x49\xA6\x2C\x41\xD0\x5C\x64\x62\xE6\x99\x1D\x8F\x67\x9D\xE0\x83\x32\x56\xC8\x4D\x9B\xCA\x9B\xE9\x9B\x29\x32\xC9\x48\x61\x52\x6E\x94\x38\xA7\x64\x1E\x4C\x12\x1A\x94\x4D\xC6\x4C\xDE\x05\x83\x8F\xE1\x58\x9B\x1F\x90\xAC\x34\x7E\x99\x93\x85\x71\x76\x25\x94\x1F\xEC\x93\x1D\x2D\xDB\x8F\xF4\x8D\xBD\x9E\xFE\x91\x79\xB7\x4E\x33\x41\x2D\x9E\x3E\x92\x31\x8F\x90\x65\x7C\x8A\x26\x83\xCE\x09\x64\xDE\x07\x47\xA2\xEC\x96\xC0\x9D\xC7\x10\x31\x61\x29\x14\x64\x19\x1E\x4A\xA0\x1B\x1E\x12\xAD\x07\xBD\x90\x7B\x98\x1E\x63\x24\x9C\xB3\x91\xEA\x90\xC6\x9A\x10\x0E\x91\x6E\x38\xC3\xA1\x35\x69\xB4\x32\xDC\x21\xC5\x90\xEE\x98\x38\xAF\x33\xA4\x7F\x1C\x71\x70\x88\xE8\x1B\xC3\x94\xD1\x11\x9F\x3E\x77\x24\x02\x19\x04\x05\x2D\x02\xA2\x41\x0F\xA0\x0C\x5A\x22\x3A\xC5\x9D\x92\x06\xBB\x0E\xAD\x9B\x4F\x9F\x15\x06\x50\x28\x00\x2A\x14\xD7\x15\x6F\xA3\x6B\x9E\x45\x92\x0E\xA5\x7F\x91\x2C\x86\x14\x33\x00\x74\xA0\x4B\x05\x03\x8C\xE4\x83\x1C\x46\x28\x35\x00\xF2\xA1\x95\x00\xCC\x95\x1E\xA5\x35\x46\x50\x37\x00\x79\xA1\xFF\x00\x9D\x94\x3F\xA7\x7A\x46\xA0\x19\x01\x00\x44\xD4\x9D\x55\x97\xC9\x9C\x7B\x94\x4C\x5E\xED\x85\x06\x46\x28\x3B\x00\x00\xA2\x75\x9F\x37\x6D\xDE\x9B\xB7\x94\xB3\x12\x2E\xA1\x02\x06\x15\x1E\x00\x40\xA0\x74\x91\x3E\x75\x09\x2A\x20\x4F\x72\xDE\x12\x03\x17\x0F\x03\x23\xA3\xF2\x80\xA8\x12\x27\x22\x8E\xAD\x9E\x03\x15\x10\x00\x20\xA8\xBC\x98\x97\x18\x2B\x74\x3D\x06\x14\x1C\x70\xB9\x12\x93\x0A\x99\x4F\x89\xBD\xAC\x06\x14\x45\x00\x80\xA3\x36\x83\x20\xA8\x6C\x46\x50\x07\x01\x3A\xA2\x28\x85\x12\x98\x6D\x16\x40\x19\x04\x00\x8A\xB6\x04\xBC\xA2\xB8\x0C\x03\x17\x12\x06\x28\xA4\x1E\x88\x8A\xBD\x13\x06\x14\x4D\x00\x80\xA0\xE2\x82\x28\xAD\xA6\x26\x50\x0F\x01\x00\xA2\x4B\x9F\x00\x2E\x10\x9E\xB8\x25\xEC\x08\x7B\xA3\x0A\x06\x14\x51\x01\x88\xA3\x16\x9C\x34\x10\x42\x56\x87\xA3\x0F\x24\xA2\x66\x96\xDE\x32\x95\x0C\xF5\x9B\x0D\xA8\x0E\x06\x28\x55\x00\x58\xA2\x9B\x56\x77\x12\xB1\x0C\xE3\x26\x50\x17\x01\x00\xA2\xA8\x99\xA3\x1C\xD2\x61\xED\x0E\xCF\x86\x50\x19\x01\x00\xA2\x32\x9A\xEE\x9D\x62\x52\x75\x01\xA8\x93\x69\x89\xA6\x06\x14",
"\x5D\x00\x80\xA2\xFD\x9A\x8E\x22\x0F\x3B\x3C\x07\x35\xAC\x0F\x75\xA2\x81\x03\x17\x02\x2A\xAC\xD5\x94\x4A\x15\x46\xC1\x0B\x29\xA2\xDD\x08\x53\xA5\xA9\x7E\x14\xAD\x1B\x06\x28\x63\x00\x00\xA3\x13\xA1\xC9\x5C\x2A\x05\xD7\x83\x82\x91\x41\x83\x49\x06\x15\x32\x01\x68\xA4\xB2\x9C\x6E\x43\x15\x0D\x36\xDC\xA0\xA7\x5A\xD4\xA1\x0C\x10\x30\xA2\xDA\x8D\x30\x7A\x36\xE9\x11\x71\x99\x3F\xA2\x3E\x3E\x40\x19\x06\x00\x88\x82\x42\xC6\x4C\x84\xA0\xF2\x21\xC0\x01\xBF\x03\x08\xBB\x8D\xAA\x15\x3E\xA3\xDC\x9B\x14\x0A\x42\x0C\x88\x06\xA0\x0D\x03\x08\x47\xC7\x03\x9F\xA1\x8A\xA2\xEA\x00\x99\x82\xC4\x0E\x85\xA2\x7B\x06\x14\x6F\x00\x80\xA0\x83\x9A\x38\xAE\x1B\x05\x70\x93\x37\xD0\x08\x06\x15\x38\x01\x5C\xA2\x9A\x8F\x4C\x86\x71\x95\xDC\x14\x0E\xC7\xA0\xFA\x8E\x81\x13\x0E\x0F\x1C\xBB\xC1\x5D\x46\xF3\x04\x06\x15\x3A\x03\x66\xA6\xB1\x4F\x1E\xBC\x86\x82\x04\x77\x00\xF3\xA3\xC0\x5D\x7D\xA6\x2D\xA2\x10\x19\x03\x39\x47\x8E\x72\xFB\xA2\xA7\x02\x81\x13\x0F\x00\x10\xA4\x07\x19\x02\x08\x14\x31\x14\x09\x15\x40\x01\x46\x1D\x0D\xAD\x90\x8E\x48\x8F\xA4\x10\xA5\x08\xA6\x84\xA3\x42\xA4\x21\xB5\x90\x95\x48\xFF\x01\x09\xA4\xD8\x14\xC4\x15\x1B\xA1\xA3\x0A\x28\x06\x28\x5C\x0A\x2D\x0B\x2D\xA0\x6A\x2B\xEF\x17\x0D\xB7\x23\x56\x48\xA7\xA4\x10\xA4\x0C\xA4\x83\x17\x2A\x55\xA2\x1C\x90\x82\x04\x1E\xA4\x2F\xA4\xB5\x09\x57\x0D\x44\xAD\xB9\x12\x7B\x28\x48\xB7\xA4\x38\xA5\x1C\xA7\x89\xA2\x45\xA8\xA0\x1E\x72\x01\x04\x11\x11\x2E\xA5\x05\xA7\x83\x10\xE9\x06\xA0\x14\x91\xBA\x48\x88\xA4\x0C\x15\xFE\x00\x8C\xA3\x42\xAC\x23\xAA\x09\x10\xA2\x78\x0A\x47\xA5\x28\xA6\x94\xA2\x47\xAD\x24\xBF\x07\x3B\x10\x5D\x09\xDD\xA1\x12\x14\x5E\x0B\x49\xA7\xA0\x06\x92\x8F\x28\x19\x04\x91\x44\xFB\x4D\xAC\x27\x7C\x28\x11\xA2\x08\x24\x37\xC2\x2F\xDD\xA1\x2A\xA5\xEB\x85\x98\x01\x24\xBD\x5C\x1C\x49\xC5\xA4\x71\x9C\x95\x01\x82\xA5\x72\x11\x10\x1F\x27\x1D\x43\x91\x11\x5B\xA5\x07\xA4\x8D\xA4\x4B\xA8\x74\x0A\x28\x31\x8B\x26\x02\xF0\x63\xE4\xA3\xB3\x05\x1B\xA2\xBA\x82\x10\x52\x88\x3F\x08\x06\x15\x33\xA5\x40\x35\x4A\xA1\xBA\x15\x93\x8F\x48\xF8\xA4\x31\xA4\x07\xA7\x9E\xA3\x48\xAC\xDF\x18\x2A\x42\x8C\x0D\x5B\x8A\xA4\x3E\x24\xA1\xA5\x7B\x62\x82\x0E\xB7\x64\x49\x97\x02\x89\xA4\x41\xA7\xEE\x01\x43\xA2\x10\x16\x93\x8F\x28\x10\xA5\x01\x03\x37\xA6\x40\x03\x52\xAB\xA0\x08\x3A\x22\x48\x88\x44\xA7\x21\x4C\xA4\xA2\xA7\x41\x15\x28\xAD\x11\x75\x87\x4C\xA3\x66\xA4\x51\xA4\xA0\x01\x41\xA3\xB5\x98\x2A\x77\x49\xAB\xA5\x91\xA5\x06\xA4\xAB\xA7\x40\x18\x74\x11\x44\x04\x3E\x32\xA5\xB8\xA5\x05\x15\xAD\xA3\x5F\x4E\x29\xB5\x14\x60\x4A\xB9\xA5\x63\x88\x34\x0D\x82\xA6\x78\x1E\x28\xAE\x90\xA8\x4A\xC6\x14\xDD\xA1\x61\xA7\x87\xA5\x52\xAA\x50\x04\x11\x43\x07\x48\xA5\x89\x0D\x4D\xA6\x5E\x75\x53\xA3\x20\x49\x96\xBB\xF6\x42\x2A\x55\xA4\xE9\x15\xB5\xA5\x41\xA7\x2D\xAA\x95\xAC\x3A\x71\x9C\x7C\xA5\x4A\xA7\x8E\x19\xB7\x97\x2E\xB7\x9E\x22\x4B\xD1\x2A\xE4\xA5\x43\xA6\xB9\xA0\x5C\xA9\x7C\x09\x90\x83\x3A\x26\xA5\x0B\x15\x76\xA6\x9E\xA0\x5E\xA4\x29\xA3\x4A\x2A\x0D\x7F\x09\xD9\x23\xC2\x77\x84\x04\x5F\xA3\x28\xB4\x95\x9C\x4A\xEC\x69\xEB\x45\x14\x09\xA8\xA1\x5A\xAD\x6E\x09\x90\xB1\x4F\x00\xA6\x07\x14\x81\xA6\xA4\xA4\x60\xAD\x2A\xB5\x94\x9B\x47\xC7\x08\x0C\xA7\xA4\x07\xBD\xA2\x5D\x4E\x22\x41\x97\x90\x4B\xF3\x44\x55\xA5\xFF\x17\xBA\xA7\x57\xAF\x2E\xA9\x95\x83\x4C\xEF\x9C\xB2\x1D\x78\xA6\xC1\xA1\x3F\x0A\x50\x07\xB3\x20\x04\x21\xA6\x65\xA4\x65\xA7\xC3\xA6\x3F\x27\x2B\xA6\x99\x81\x04\x38\xA6\x95\x03\x04\xA4\x03\x1E\x57\xA7\x2A\xA0\x96\xAE\x4C\x9B\xA6\x30\xA6\x2A\x06\xCC\xA5\xFB\x3A\x50\x14\x11\x54\x05\x40\xA6\x0D\xA5\x65\xA5\xBE\xA1\x62\xAD\x30\xBF\x99\xBA\x4A\xC1\xA6\x0C\x15\x0B\x1A\xEC\x95\x4D\xA9\x27\xA8\x9A\xA6\x45\x17\xA4\x09\xA4\xD8\x2F\x68\x0C\x6B\xA1\x2C\xB9\x96\xB1\x49\xD3\xA4\x0C\x15\x04\xA6\x8F\xA4\x68\xA1\x30\xA6\x9A\x98\x4B\x8F\x14\x34\xA4\x06\xA5\xB0\xA1\xFF\x13\x31\xB3\x13\x5D\x43\xB4\x11\x56\x45\x32\x4A\x90\x26\x67\xA5\x2F\xB7\xC0\x28\x4D\x86\x14\x55\xA5\xBB\x94\x52\x0C\x42\xA5\x25\xBA\x90\xAD\x48\x85\xA6\x9D\x16\x28\xA4\xDC\xA1\xCE\x98\x57\x12\x02\x32\x4D\x87\x14\x59\xA3\x65\x22\x57\xA2\x29\x08\x57\x18\x02\x0F\x4E\x86\x14\x91\xA7\x22\x40\x20\x51\x31\x1B\x2D\xAC\x39\x1D\x15\x2F\xA5\x85\x9C\x79\x22\x97\xA1\x47\xA5\x25\xB0\xBD\x24\x05\x2C\xA6\x89\xA7\x97\xA6",
"\x59\x25\x71\xA7\x39\xA2\x08\x19\x4E\xAD\x66\x95\xA7\xD6\xA5\x40\x01\x73\xA1\x12\xAB\x50\x15\x49\xBB\x1A\x5C\x58\xD4\xA4\x5E\x0A\x71\xAB\xA0\x14\x91\xAC\x4E\x8E\xA4\xAF\xA7\xC9\xA4\x48\x01\x76\xA0\x3C\xB2\x8B\x91\x46\x92\xA4\x55\xA4\x16\xA7\x83\xA2\xA1\x0B\x3B\xAA\x9D\xB2\x3D\x3F\xA7\x0D\xA5\xE0\xA5\xDC\x98\xF7\x14\x3C\xB1\x9E\x86\x4F\xAD\x9F\x4B\xA7\x50\x22\xEF\xA1\xCE\x95\x25\xAD\x19\xB6\x0C\x3A\xA7\x6E\xA6\xB3\xA5\xD2\xA4\x29\x00\x3D\xBD\x86\x92\x4F\xDB\xA2\x57\x51\xEA\xA6\xF9\xA7\x7A\xAD\x16\xA9\x11\x09\x48\xC8\x49\x19\x04\xF0\xA5\xCB\xA2\x58\xAC\x38\xBE\x1C\x32\x4E\x96\x9C\x94\x9C\x92\x03\x12\x9A\x7D\xAF\xA0\x14\x9D\xBC\x78\x55\xA4\xD4\x4F\x0D\x08\xD9\xA3\x7E\xA2\x3E\xBF\x9A\x95\x49\xED\x55\x00\x0E\xF9\xA5\xE7\x15\x80\xAF\x3C\xB6\x9F\x85\x4F\xE3\x88\xB0\xA6\x81\x02\xE5\xA7\x81\xAF\xFC\x8D\x9F\xA8\x26\xE9\xA4\x09\xA5\x18\x16\x86\xA1\x45\xA6\xB0\x05\x51\x14\x2C\x06\x14\x31\x14\x69\x02\x40\x05\x44\x1F\x4F\x02\xA1\x8E\x48\xD0\xA6\x97\xA7\x61\x1A\xC8\xA2\x20\x0D\x12\xAF\x4A\x25\x28\x2A\x07\x20\xA8\x81\x02\x26\x03\x84\xA5\x2A\xB2\xA1\x8F\x48\xA8\xA8\x88\xA7\x8B\x2A\x81\x10\x21\xA7\xEE\x9A\x76\x95\xDC\x7F\x01\x25\x14\xC2\x05\x0C\xA9\x20\x07\x20\xA1\x08\x24\x50\x82\x02\x45\xA9\x06\xA4\x0E\xAB\x41\x13\x66\x1B\x57\x66\x4B\xF8\x9E\x54\x0B\x12\x15\xFC\x23\x88\xA0\x00\x12\x04\x02\x04\x11\x11\xFF\x08\x2B\xAB\x09\xAF\x6A\xA9\xAE\x1D\x98\xA0\x27\x2B\xA8\x56\xA6\x1A\x9D\x37\xA0\x33\x15\xB2\x23\x97\x76\x16\xD5\xA2\x27\xA6\xB0\x48\x10\xAA\x20\x03\xE8\x14\xA2\x84\x02\x34\xA8\xEB\xA5\x37\xAB\x16\xAC\x62\xA9\x42\x09\xA1\xB6\x26\x55\xA6\xE5\x89\xF3\x4F\x1A\xA9\x20\x0D\x46\xA2\x08\x31\x28\x02\x01\x70\xA8\xAC\x48\x20\xAB\x8E\xA3\x27\x56\xA3\x9F\x51\xB9\xA6\x79\xA9\x84\x5B\x1E\xA8\x00\x0D\x47\xA2\x92\x81\x04\x01\x01\x81\xA9\x7F\x08\x24\xAC\x90\xA2\x54\x26\xA4\x83\xBD\x75\xA6\x6A\xA9\x23\xAB\x82\x11\x46\x17\x50\x38\xA2\xBD\x47\xB7\xA8\x5C\xA9\xCB\xA7\x4A\x18\x64\x4F\x71\x75\x9B\x82\x55\x5D\xA1\x86\x0D\x91\x44\xDF\xA0\x6A\xAB\x48\xBB\x21\x14\x51\xF2\x84\x10\x17\x7F\x08\x2C\xA8\x95\xA1\x4A\xB9\xA1\xBC\x4D\x9C\xA2\x73\x73\xB6\x09\x89\x16\x12\x54\x45\xA6\x09\x06\x51\xB5\xA8\x01\x02\x5F\xAA\x12\xAC\x8B\xA7\x38\xA1\x08\x01\x1A\x29\x8B\x70\xA4\x09\xA1\xC2\x05\x44\x1D\x1F\x14\xA2\x91\x11\x9A\xA9\x8F\x6F\x61\xA8\x1D\xAF\x59\x06\x49\xBA\xA1\x82\x04\x0E\x8E\x2F\x9D\x45\xAA\xCA\xA7\x40\x11\xA3\x1E\x58\x47\x4D\xD8\x4A\xDE\xA8\x69\xA9\x21\xAE\x96\xA2\x31\xA1\x96\x97\x95\x5D\xA1\xA8\x13\x79\x5E\x73\x3A\x0C\x66\x16\xBF\xA6\x97\x95\x5C\xA4\xE8\x13\x32\x61\xBC\x0D\x26\x0F\x31\xB3\x7A\x42\x39\xAA\x02\x25\x14\x75\xA4\x37\xAA\x82\xA1\x49\xBC\xA7\x94\x52\xD7\x27\xD5\xA9\x55\xAB\x3E\x7B\x91\xAD\x2B\xB4\xA2\x88\x34\x31\xA9\x02\x03\x83\xA8\x2D\xAB\x9A\xA9\x34\x05\xA6\xBE\xF6\x38\x42\xA6\xA9\xEB\x27\x22\xAC\x5A\xAB\x4F\xA1\x08\x34\x33\x46\x14\xFF\x09\x8B\xAB\x42\xAB\x9C\xAD\x36\xBE\x9C\x88\x4A\x11\xAA\x7E\xA7\x07\x14\xCC\x08\x35\x45\x4E\xA1\xA3\xB3\x89\x5C\xA4\x3A\x0F\x5A\x47\x37\x30\x96\x28\x9E\x10\x0D\x64\x63\x15\x04\xAC\xA9\x12\x14\x45\xAC\x8A\xA0\x7B\x2A\x28\x3F\x13\x30\x2F\x1B\xAB\x4A\xA9\xD1\xA6\xA3\xA3\x71\x87\x99\xA7\x52\xA2\xAA\x37\x0F\x3E\x45\x49\xAD\x6F\xAE\x8A\x28\xA9\xB7\x47\xAA\xAA\x74\x43\x2C\x10\x7A\x12\x57\x43\x83\x37\x22\x31\x54\x82\x02\xBC\xA8\x3F\xAA\x40\x03\x97\x1F\x4B\xAB\x97\x94\x55\xE2\xA9\x42\x2A\x87\xAB\x31\xAB\x31\x59\x4C\xBB\x4F\x62\x05\x25\x14\x05\xAA\xA9\xA9\x40\x03\x68\xA0\x4D\xA3\x9A\xB9\x54\xD7\x27\x5A\xAB\xDB\x0F\xD5\x40\xA4\xAE\x8A\x2B\xA4\x8D\x4A\x95\xAA\x74\x2C\x68\xA8\x9B\xA7\x41\x10\x35\xA0\x92\xA0\x52\x8C\xAA\x80\x05\x12\x14\x9D\xA0\xAE\xA8\x9E\x10\xA6\xA8\x27\x67\xAA\x17\x31\xCB\xA7\x3C\x11\x76\x2C\x56\xA4\x0C\x4B\x52\xD0\x0B\x54\xA8\x85\x08\x34\xAE\x5D\xA4\x54\xA4\x0C\x69\x55\x84\x14\x54\x23\xA4\x06\x89\xA3\x7E\xA2\xF7\x10\x52\x0C\x28\x11\x11\x93\x99\x2C\xA6\x40\x03\xB4\x0E\x06\x17\x9F\x8B\x51\x87\x14\xD0\x0E\x96\x59\x61\xAC\x29\x45\xA1\x02\x08\x0B\x2D\x1A\xAB\x01\x02\xCE\xAA\x67\xAD\x96\xAB\xA0\x01\xAD\x90\x5F\x23\xAB\x6A\x43\xD2\xA9\x40\x00\x12\x58\x5A\xA4\x53\x0E\x16\x2B\xAB\x78\xAB\x8B\x03\xE5\xA6\xB5\xA8\x2F\x30\xAD\xA8\x88\x32\xAB\x00\x01\xBB\x95\x6D\xAA\xB5\xAF\x4F\xA1\xAC\x80\x55\xEC\x11\xAF\xAA\x9F\xAA\x44\xA9\x12\x1D",
"\x3A\x83\xAE\xB7\x56\xC5\xAB\xAE\x30\xC1\xA8\xC9\x0E\xB9\x4E\x5B\xA3\x0B\x40\x57\xE5\x96\x0D\xA5\x12\x14\x71\xA8\xAB\xA0\x50\xAF\x50\x10\x1D\x0F\x70\xD5\xAB\xAD\x43\xDF\xA3\xBC\xA4\x5E\xBF\x9B\xAA\x49\x82\x02\x66\xAB\xF2\xAA\x7A\xAC\xBC\xA5\x25\xB7\x92\x8F\x48\xDA\xA4\xD7\xA9\xBB\xAA\xDD\xA7\x4B\xA4\x42\x15\x7E\x73\x24\x46\x26\x9F\xA5\x03\x14\xD4\xA0\x83\xAC\xA0\x0B\x93\x8F\x48\xA0\x1D\xF1\xAA\xE8\xA8\x61\x42\x4E\xAC\xA0\x1B\xAB\x98\x4C\x86\x14\xD7\xA5\xBF\xA8\x5D\xAC\x8B\xAB\x34\xB9\x7F\x3E\x49\xE7\x45\x8D\xAA\xA6\x43\xC8\xA6\x50\xA4\x35\xA0\xA3\x91\x58\xB1\xAB\x09\xA5\xB7\xAB\x81\xAF\x8A\xAE\x36\xAA\xB0\x8B\x28\x50\xA6\x0D\xAD\xF8\x0F\x3F\x0F\x52\xAC\x1C\x1B\xAF\x8E\x4C\xE3\xA5\x10\xA7\x92\xA7\x50\xAC\x95\xA4\x2A\xAB\x99\xBB\x54\x9D\x17\x1E\xAC\xFD\xA8\x83\xA8\x71\xA9\xFF\x00\x9D\x84\x41\x31\xA5\x5C\xA9\x09\xAE\xAD\xA5\x5F\x4B\x62\xBC\xA2\x95\x49\xBD\xA5\x1B\xAD\x1F\xA5\x87\xAA\xBE\xA2\x54\x21\xB1\x89\x1E\x46\xA5\xFA\x02\x13\xAE\xCE\xA0\xC5\xAC\x33\xBC\xB1\xB8\x51\xAC\xAC\x0C\x14\x8A\xA9\x90\xAD\xD4\x18\x57\x11\xB1\xA1\x57\xB4\x31\x46\xAC\xB5\x05\xB7\xA6\xA9\x8B\x10\x0A\xB2\x87\x28\x52\xA6\x29\xAD\x9E\xA5\x8F\xA9\xB7\xA4\x60\xA8\x50\x3A\x53\xD3\xAC\x09\xAC\x22\xAF\xF5\x21\xCB\xA9\x1F\x13\x97\xA5\x98\x5E\xAC\x06\x14\x30\xAD\x93\xA9\xBF\xA7\x65\xA7\xBC\x15\x49\xFF\xA5\x8F\xA5\x21\xAE\x80\xAC\x29\x4C\x66\xA1\x09\x08\x4C\xEB\x43\x4E\xAB\x1C\xAF\x89\xA8\x5F\xA1\x66\xAE\xB2\x96\x58\xD0\xAC\x08\x15\x8B\xA5\x9E\xAB\x7E\xA6\x65\xAA\xAE\x97\x60\x7D\xAC\x17\x03\x8F\xA7\xE1\x08\xCE\xA2\x10\x12\xB3\xAA\x48\x62\xAC\x4F\xAC\x1F\xAD\x82\xA3\x9B\xA8\x66\xBA\xB3\x9C\x57\x8F\xAD\x34\xAD\xF8\x0D\xCD\xA7\xAF\x27\x33\xA2\xB4\x8B\x59\x84\xAD\x73\xAC\x67\xA6\x8C\xAC\xCC\xA5\x25\xA3\x9A\x9D\x5A\x8C\xAD\x6A\xAC\x50\xAE\x17\xAC\x69\xA4\x14\x14\xC2\x0F\x4D\xA6\xAD\x5F\xAD\x9D\xA7\xA5\xAE\xD0\xA8\x48\xA8\xB4\xAA\x04\x5A\xA6\x8D\xAC\x47\xA8\x8C\xA9\xD6\xAE\x8A\x20\x9B\x8C\x28\x62\xA6\xFF\xAA\x4F\xAC\x60\xAD\xD8\xA3\x5E\xB5\x92\xAB\x4D\xAF\xAD\xC3\xAD\x3D\xAE\x5A\x46\x92\xA4\x37\xAE\xB4\x8C\x5B\x8B\x14\x78\xA7\xCD\x62\xDE\xA7\x57\x95\x67\xA8\x93\xAB\x57\xDF\xAD\x47\xA4\x67\xAC\x30\xAD\x41\xA1\xA3\x14\xB6\xB1\x1F\x5D\xAD\x01\x33\x70\xAD\x82\xA6\xBD\xAE\x20\xB0\xAF\x81\x04\x73\xAA\x1F\xAC\x5C\xAE\x81\x10\x4C\xA0\x93\x12\x14\x57\xBF\x40\x12\x13\x44\x74\xAE\xA6\xA3\x42\x19\x20\xBE\xAF\x8E\x48\x80\xAC\xEF\xAC\x62\xAF\x80\xAD\x4A\xA6\x60\xAB\xB4\x9D\x2E\x70\xAD\xAB\xAD\x93\xA9\xA8\xA9\xF1\x0F\x60\xA6\x9B\x17\x58\xA8\x44\x3A\xAC\x66\xA5\xB9\xA2\xA0\xAC\x6A\xB9\xB0\xA3\x5B\x8A\xA8\x08\xAE\x7D\xAF\x0F\x08\xD2\xA6\x29\xAD\x1A\x38\x8B\x72\x04\x94\xAD\x80\x02\xA5\xAC\x5F\x44\x67\xB6\xB6\x86\x56\xAD\xAC\x6C\xA7\x8C\xA6\xDB\xA1\xE3\xA6\x72\xBC\xB3\x8B\x5C\xEA\x06\x36\xAD\x4D\x22\x3C\x21\xE4\xAB\xC9\x84\x99\x98\x5A\x87\xAD\x9A\xAC\x06\x14\x90\xAE\xE0\xA8\x57\x0C\xB9\xA6\x54\xC5\xAC\x2F\xAF\xFC\x00\x92\xAF\x5B\xA2\x6F\xB5\xB4\xBA\x5A\xA4\xAE\xAA\xAC\x8D\xAE\xB4\xA1\xCA\xA7\x71\xAF\xB1\xBD\x5C\x82\xAE\x2E\xAF\x59\xAE\x83\xAE\x4C\x97\x2C\xA5\xBA\xA2\x5C\xC7\xAE\xCD\xA5\x7C\xAD\xCB\xA8\xC3\xAC\xA0\x07\xB3\xBC\x5C\x82\x02\x3E\xAF\x87\xAF\x58\x44\xE3\xAE\x66\xA3\x6D\xA2\x5D\xE2\xAB\x83\xAC\x9B\xAC\xAF\xAF\x59\xAF\x73\xB2\xA8\xBE\x4B\xCD\xAE\x1D\xAB\x83\xAC\xD4\xAA\x2D\x4C\x71\xBF\xB3\xA1\x87\x0B\xA6\x56\xAF\x9A\xAC\x85\xAA\xC5\xA9\x69\xB5\xB8\x8C\x28\x0A\xAD\xD6\xA5\x95\xAF\xDC\xA8\x45\x45\x77\xAA\x90\x45\x42\xE7\xAE\xB4\x31\x88\xAF\xD4\xA4\xEF\xA8\x73\xBE\xBB\x88\x28\x1C\xAD\x5F\xAF\x80\xAE\xB4\xAC\xF0\xA1\x74\xA9\x28\x0E\x14\x1F\x04\x34\xAF\x91\xAD\xD6\xAB\x56\xAD\x76\xB7\xC0\x2D\x5A\xF0\xAE\x2A\xAF\xF9\xA5\xD8\xA8\xC4\xA5\x79\xB7\x08\x0D\x4D\x8D\x87\xB7\xAC\x32\xAE\xE2\xAD\xD0\xA5\x72\xBD\xBC\xAD\x55\x89\xA4\xC0\xAD\x64\xAE\xE8\xAB\xF0\xA3\x16\x46\xB6\x88\x28\x48\xAD\xFF\xAC\xC1\xAF\xE4\xAD\xF6\xAD\x6C\xAA\x9B\xA0\x5E\x88\xAC\xBA\xAF\x4F\xAD\x74\xAD\xF4\xA9\x70\xBF\xA9\x98\x5B\xAD\x11\x40\x25\x6D\xAE\x0A\x75\xF1\xA3\x5F\xA0\x9C\x99\x50\x82\x02\x5A\xA7\x36\xA5\x37\xA1\x1B\xAC\xE9\x96\xA0\x9F\x3F\xEE\xA6\x95\xAB\x04\xA5\x89\x10\x84\x10\x57\xB3\xA0\xA5\x3A\x53\xAF\x71\x9D\xDA\xA4\x65\xAB\xF9\x1F\x4F\x1E\xBE\x8C\x50\xCB\x1F\x76\xAA\x0A\xA8\x26\x9E\x08\x46\x1F\xA0\xB7\xAE",
"\x5F\xEF\xAF\xEE\xAF\xD2\xA6\xD1\xA9\xF7\xA3\x3F\xA2\xA0\xBD\x4F\xD0\x9E\xD3\xA6\x08\x04\xFC\xAB\xFF\xAC\x7F\xBC\xB7\x8C\x28\x6B\xA6\x2C\x18\x72\xAE\x58\xAC\x58\xA5\x29\xA6\x50\x0B\x46\xF8\x28\xE8\x1E\xF5\xAB\x79\xA9\x20\x04\x66\x5D\xBF\xBD\x5E\xFF\xAF\x02\x02\x18\x4D\x9B\xA6\xDC\xA9\x78\x06\x50\x10\x51\xF0\xA3\x0E\xB1\x0C\xB2\xFF\xAD\x47\xA2\xAF\x12\xBD\x9D\x51\x84\xB0\x33\xA6\x44\xA8\x36\xAB\x18\xAA\x81\xA5\xC1\x8E\x5F\x90\xB0\x02\x16\xFA\xAF\x07\xB5\x73\xAD\xFD\x3D\xAA\x8C\x55\x26\xB0\x30\xB0\x71\xAD\x40\x05\x8C\x1A\x82\xB4\xC0\xAA\x0D\x16\xB0\x77\x73\x8E\xA0\xDA\xA5\x4A\xA4\x38\x0C\xAC\x9B\x60\xCE\xA4\xE1\xA6\x18\xB1\x79\xAD\x4A\xA1\xA3\x12\x63\x2A\x60\xE0\xAF\x69\xA3\xB9\x3F\x75\xA0\xAA\xAD\x39\x7E\x5A\xAD\xA4\x09\x53\xC0\xAB\x45\xA9\x1F\x1B\x93\xA2\x23\xA2\xB2\x8E\x48\x8C\xA2\x09\xA3\xDD\x3F\x0E\xAD\x09\xB7\xED\x3E\xA1\x95\x1F\xFF\x09\x3C\x51\x06\xA4\x0F\xAA\xF2\x9E\x85\xAC\x4F\x8F\x56\xE0\x61\x4B\x2E\x1C\xB1\x12\xB1\x8A\xA2\x10\x13\xC2\xB0\x55\x8B\x84\x6F\xA7\x05\x14\x16\xB5\x87\xA2\x95\x5B\xC2\xAB\x61\x91\x2C\x0A\xA3\x8A\xA3\x3F\x08\x0E\xBD\x0D\xA3\xC3\x8A\x61\xE5\xB0\x15\xA3\x33\xB0\x44\xA9\xC0\xAA\xF5\x9C\x92\x83\x19\x31\x41\xCD\x3C\xBC\x0A\xBD\x2F\x02\xBD\x29\x05\x51\x2E\x61\xD4\xA8\x64\x4C\xC6\xAB\x1C\xB4\x0C\xB5\x87\xAC\xC2\xB7\x61\xD8\x29\x79\xB0\xC2\x97\x3F\x0D\x01\xBF\xA0\x1E\xC3\xAE\x13\x68\x96\x15\x6E\x41\xB2\x46\x42\x0D\xB5\x88\xAF\x50\x07\x62\xA7\x52\xA9\x41\x6E\x09\xE3\x98\x25\x57\x6E\x4C\xC4\xBC\x47\xC2\xB0\xB0\xB1\x1D\xA5\x82\xA0\x12\x56\xC8\x11\xC5\xB1\x60\x89\xA4\x36\x07\x47\x1A\x2D\xB3\x17\xB7\x82\xA8\x50\x36\x0C\x17\x4C\xBC\xB1\x60\xB1\xDA\xA4\x41\x14\xB1\x03\x65\x16\x48\xD5\xA4\x90\x50\x57\x1A\x0A\xB0\xAF\x02\x44\xAF\x50\x2E\x62\x82\xA4\xC2\xB1\xF5\xA8\x0F\xB3\xAA\xA7\x23\xB5\x92\x98\x57\x8C\xA1\xD1\xB1\x29\xA5\x95\xA3\xB4\x03\x65\xB7\x9F\x9B\x32\xE3\x44\x6E\xA1\x51\x07\xBE\xA1\xEF\xA9\x8D\xB2\x92\x95\x49\xB6\xAA\x1E\xB1\x6E\xA2\xF4\x04\xD4\xA7\x61\x10\x30\x62\x63\x94\xAE\xCD\xAF\x72\xB3\x2D\xB4\x41\x1A\x3A\x1D\xC6\xB2\x57\xC7\x45\xBF\x2E\x78\xB2\xF1\xAA\x1E\xBB\x7F\xA8\xC6\x82\x04\x4B\x15\xFC\xB1\x12\xB1\x95\xA3\x92\x98\x53\xA1\xC8\xB0\x5F\xED\xAB\x5B\x2B\x23\xB2\x29\xB6\xA1\x0F\x18\x43\xC7\xAA\x5E\x86\xB2\xE0\xAD\x81\xB2\x40\x02\xA3\xA0\x91\xA6\xC1\x96\x63\x82\x02\xFF\x19\x8A\xB2\x46\xB3\x23\xB3\x8D\xA1\x08\x0A\x54\xB6\xAF\x2A\x02\xEC\xA8\xE6\x2B\x23\xB1\x7F\xA9\x90\x8B\x2D\x53\xAC\x24\xB3\x21\xB3\x2C\xB4\x28\x0C\x24\xBD\xB7\xB1\x11\x29\xB2\x11\xA4\x22\xB0\xC3\x08\x79\xAA\x7D\xBA\x16\x14\x61\x89\x18\x2A\x14\x68\xA8\x1E\x00\xB7\xAB\x83\x69\xBF\x8D\x48\xF7\xA9\xDC\x07\xCB\xAB\x5F\x05\xDD\xAB\x59\xA1\x31\x3C\x64\xE0\x4A\xA2\xA8\x02\x10\xA1\x88\x93\xAB\xC5\x40\xAE\x80\x86\x4E\xAB\x01\x02\x3B\x03\x51\xB3\x8B\x57\x39\xA8\x4F\x02\x22\xD7\xAF\x26\xAA\x35\xAA\x85\x17\xBD\xA5\x94\xB1\xCA\x93\x65\xE7\x4F\x49\xB3\x80\x00\xA7\x44\x29\xBA\x47\xB1\x44\x32\xA9\x50\xB2\x14\x03\xAF\xB1\x42\x59\x2C\xB7\x61\x82\x13\x24\x65\x8A\xA9\x91\x11\xB1\x19\x76\xAD\x2B\xB9\x96\xA4\xA4\x88\x65\x8B\xA7\xEB\x08\xE6\x7B\x5B\xB2\x09\x60\x5C\xAC\x6B\x33\x65\xA9\xAB\x46\xB2\xBB\xB0\x55\xB7\xB8\xAA\xB0\x59\x36\x3B\x65\xB2\x5B\xC0\xAB\x41\x04\x51\xB0\x30\xBE\x95\xA2\xCC\xA0\x65\x8F\x14\xCF\x13\x9E\xA1\x1A\xAD\x29\xB1\x89\x1D\x22\x68\x65\xD2\xB2\x8E\xB3\xB5\xB0\x64\xB2\x25\x12\x1B\xB9\xCA\x94\x66\xB9\x18\x8B\xB2\xDB\xA9\x63\xB2\x9C\xA7\x97\xAC\xA2\x9C\x66\xFD\x46\x87\xB3\xA7\x4C\x4C\xB6\x16\xB7\x91\xBC\xA3\xAB\x66\xAD\xB2\x0C\x14\xBC\x08\xD7\x5A\x81\xAB\x4D\xBD\x86\xB7\x53\xDD\xA1\x94\x92\x90\x84\x41\xA6\x9C\xAE\x58\x5C\x92\x84\x32\x1E\x02\x36\x3E\x94\x02\x66\x4D\x96\x30\x94\xA9\x90\xBF\x13\x33\xB3\x4E\xAE\x2C\x1F\xF2\xA7\xDF\x5D\x20\xB9\xCD\xA0\x0E\xCF\xA2\xBC\xB2\x1C\x52\x6F\xB5\x37\x12\xBB\x9E\xC8\x3E\x06\x1E\x5E\xA6\xAE\xE6\xB1\x4C\xB3\xDD\xA2\x10\x09\x75\x2C\x4B\xEE\xA6\xB5\xB2\xC4\xA7\x55\x48\xAF\x0B\x93\xAE\x90\xB7\x66\x8F\x14\x14\x17\x30\xA6\xF5\x5F\xFE\x48\x6F\xA6\x8E\x9E\x66\xE7\x4F\xBD\xB0\x95\x03\x24\x9F\x2A\x54\x9B\xAB\xCE\x8F\x9B\x65\x18\xE4\xB3\xFB\xA7\x79\xB3\x41\x19\x80\x01\x34\x72\xC6\x15\x8A\x39\x0B\xDA\x63\xBC\x09\x35\xB6\x7B\x45\xB3\x80\x61\xBD\x30\xA1\xB2\xBC\x09\x78\xB3\xD6\xA3\x9E\xA2\x08\x25\x67\xBF\xB2\xDA",
"\xB3\x05\xB2\x5A\x01\x41\xBA\x9C\xA6\xCF\x8C\x67\xF9\xB3\x16\xB5\xFB\xB3\x31\xB1\x41\xAC\xA1\x01\x08\x08\x67\xF1\xAE\x0A\xB4\xFB\xB1\x72\x38\x37\xB6\xA6\x9A\xCD\x92\x66\xEE\xA9\xBD\xB3\x07\x17\x6F\xB5\xD4\x17\xAD\x25\xCE\x8C\x28\x34\xB0\x37\x06\xAF\xA5\x88\xB1\x43\xB9\xDC\x38\xD0\x90\x68\x9A\xB4\xD9\x0A\xB5\xB2\x12\x64\x4B\xA3\x58\xBB\x2B\x17\x38\x68\x34\xA2\xA3\xEA\x49\x83\xA5\x34\xA0\x05\xAE\xCF\xA2\x66\xAF\xA0\x45\xB5\x2A\xA6\x11\xB1\x46\xB4\x3F\xB3\x9F\x8B\x68\xA0\xB0\x35\xB4\x07\xB6\x7E\xB7\x42\xB1\x98\xA4\xCD\x9B\xB1\x3C\xB4\xD3\xAA\x21\x67\x72\xA0\xBB\x47\xA4\xA8\x6C\xAA\x63\x8C\x0E\xA6\xA2\x23\xB5\x90\xB6\xF2\x55\x25\xAE\xC3\xB0\x36\x4D\xB4\x9D\x17\x27\xB4\x0B\xB5\x41\xB8\x93\xB4\xD1\xAC\x69\xF5\xB2\x56\xB5\xF3\x4C\x96\xB1\x2A\xBD\xF5\x33\x97\x9B\xAD\x63\xB4\xEC\x4B\x2F\xB4\xB0\x01\x4C\xB0\x1E\xB4\xCB\x88\x36\xD5\xA4\xB5\xB1\xDC\x10\x85\xB1\x20\x0A\xA6\xB1\xCE\x8B\xBC\x36\xB4\xB6\xB3\x08\xB5\x82\xA7\xC2\x48\x4C\x55\xAD\xB3\x68\xB7\xB4\x51\xB5\x36\xB4\xA4\xB7\xAA\x45\x25\xA6\xC6\x80\x00\x26\x9D\x8E\xB5\x0A\xB7\xA4\xB6\xB1\x48\xA8\xA2\xCF\x8E\x96\x43\xB1\x08\x14\x80\xB0\x00\x01\x9C\xA3\x40\xB1\x74\x22\x68\x94\xB5\x61\xA7\xF9\xAF\x77\xB6\x49\xB7\xAA\xBC\xD4\x92\x69\xEE\xB4\xAE\xB5\xD1\xB3\x46\xAA\x8D\xA9\x20\xA6\x67\x06\x39\x5C\xB2\xAC\xB4\x58\xB4\x0E\x55\x53\xBC\xA0\xAE\x2C\x55\x49\x97\xAA\x51\x1D\xBF\xB1\x9A\xB5\x55\xBB\xAB\xAF\xD5\x9B\x6A\xB8\x50\x55\xA5\x8C\xB1\xBB\x51\x53\xB4\xA8\xA4\xD6\x87\x6A\xC6\xB5\x89\xB4\x0D\xB4\x92\xA0\x41\x1A\x14\x4B\x9B\x8C\x6B\xA6\xB5\xBA\xB5\x67\xB6\xA4\xB1\x5A\xB9\xDC\x35\x92\xB0\x04\x01\x02\xA2\x4F\x6B\xB5\xA1\xB0\x45\xB5\xAC\xBB\xD6\x9E\x6A\xB8\x50\xEA\xAC\x14\xB0\x23\xAA\x44\xBF\xA8\xBC\xD6\xAF\x69\x8F\xB4\xEE\xB4\xC7\x4A\x0D\xB1\x3F\x04\xA0\xA1\x66\x6B\x4F\x95\x11\x79\xA6\xB7\x01\xEE\x05\x4F\xBF\x9E\xAA\xA4\x89\x48\xA2\x4F\x8D\xA8\x28\xB5\xBB\xB7\x5C\xBA\xAD\xB7\x09\x13\x69\x9A\xB4\xF3\xB5\x5E\xAF\x3E\x78\x9D\xA0\xB3\x13\x28\x8C\x20\x67\x39\x03\xB5\xC9\xB2\x1E\xA9\x41\xAE\x9D\xA8\x6E\x10\x6A\x83\xB6\xBD\xB5\x72\xB6\xC1\xB1\x5B\xBE\x11\x18\xCF\x95\x69\xB3\xB5\x83\xB3\xDE\xA5\x96\xB6\xC0\x46\xA0\x0D\x6D\xA6\x5D\xF6\xA0\x43\x21\x2A\xA4\xD7\x5E\xEF\x5C\xAD\xB8\xD8\x90\x69\xEF\xB5\x07\xB7\x48\xB4\x9C\xB0\x64\xBF\x98\xA2\xD9\xB4\x69\xD4\xAB\x74\xB3\xF9\x61\x95\xA1\x9C\xA5\x23\x6D\xD9\x9A\x6A\xF1\xB5\x1A\xB6\x78\xB4\xC1\xB5\x63\xBD\xB9\x18\xCC\xB1\x69\x9A\xB3\x36\xB7\x1D\x40\xDB\xA8\xAB\x48\x64\x55\x92\x84\xF1\x5B\x1B\x17\xB7\x9F\xB7\xD0\xB4\xBF\x4C\xAB\xAF\xD9\xB1\x6A\xB3\xB6\x0B\xAC\x1A\x9E\x74\xAF\x66\xB2\x24\x75\x9B\x98\x42\xBE\xA1\x11\x86\x59\xB0\x83\x14\xDD\xA2\xAC\xB8\x2B\x29\x57\xF1\xAD\x0F\xB2\x39\xB1\x7D\xAE\x55\x27\x5F\xAC\xCB\x1A\x5D\xAE\xAF\x03\xAD\x1F\xB3\x3F\x06\xDF\xA2\x80\xB3\x9F\xA7\x6D\xC5\xAF\x6E\xAE\x06\x16\x48\xB0\x36\xB8\xA0\x05\xB8\x81\x5E\xF6\xB6\xB4\xAF\xAD\x40\xC7\xAD\xE1\xA2\x2F\x59\xBC\x98\x5D\x93\xAE\x63\xAC\x94\xA6\xC5\xAE\xC5\xA0\xA2\xA8\xAF\x81\x6E\xD8\xAC\xC4\xAF\x11\xAE\xC7\xAA\x68\x26\xB8\xAC\xB2\xBB\x5A\xAD\xAF\x88\xAE\x3B\xAC\xCA\xA8\xDA\xA6\xB6\xAF\xDC\x87\x5E\x1C\xAE\x31\xAF\x09\x29\x48\x05\x72\xB8\x6A\xB7\xDC\x89\x5D\xDB\xAE\xBF\xAA\x5E\xA7\xEF\xAC\xC3\xA0\xB8\xBB\xBD\x82\x6E\xC4\xAF\x43\xAF\x2E\xAD\xDE\xAA\xF3\xA8\xB8\xBD\xBB\x8A\x6E\xCC\xAE\x8C\xB7\xD0\xAD\xE7\x17\x6E\xBA\x74\xA9\x34\x03\x6E\xD4\xAE\x49\xAD\xD9\xB7\xE1\xB2\x5F\xAA\x8F\xB9\xDB\xA6\x59\xAB\xB7\x56\xB1\xDD\xB6\xE7\xB2\xF8\x24\x76\xB5\x8D\xB2\x08\x24\xB7\x6A\xAE\xCC\xB6\xAF\xAF\x1F\x08\x67\xBF\xDB\x8A\x6F\xAE\xB7\x90\xB6\xA9\xAE\x88\xAC\x3C\x00\x68\xB8\xBB\xA9\x6D\xB9\xAD\x96\xB6\xA4\xAF\xDB\xB1\x73\xB2\x7C\x35\x92\x80\x5E\xAB\xB5\xD7\xB6\xE1\xAC\x61\x45\xF0\xA1\x0B\xA7\xBC\x90\x6F\xFB\xAE\x37\xAE\x85\xB6\xE3\xAA\x25\x00\x79\xB6\xDE\x9D\x6E\xD8\xB7\x9F\xB6\xE2\xAF\xA8\xAF\x40\x24\xBE\xA9\xB7\xA9\x5D\xF0\xB7\x6B\xAE\xBC\xB6\xE7\xAA\x68\xA8\xBC\xB4\xB2\x8E\x6E\xF8\xB7\xCC\xB6\xFD\xB5\xAD\xA8\x97\x4F\xBE\xBB\xB1\x92\x6F\xB9\xAE\x08\x15\xD8\xAF\x32\xB7\x80\xBA\xBE\xB2\xB0\x84\x4E\xA9\xB5\x8C\xB3\xBA\xB5\xFA\xB3\xD9\xA1\xB7\xA6\xAF\xBE\x5E\xB9\xB7\xC0\xAF\xD6\xB5\x05\xBB\xDA\xA4\x7C\xBD\xDD\x83\x55\xA5\xB6\xC8\xAF\x18\x36\xBE\xB4\xDB\xA8\xBA\xBC\xBD\xAF\x66\xBB\xB0\xCF\xAE\xC8\xA8\xF2",
"\xA2\xA1\x0B\x48\xA4\xE2\x54\x51\x8E\xA7\xDF\xA9\x7F\x08\x0E\xBE\x7A\xA1\xC9\x9C\xF1\x17\x4E\xD0\x0A\xC7\xA6\xFC\xA7\xCD\x62\x78\xA1\x87\xA6\x52\x21\x42\x7F\x09\xE6\x33\x3A\x88\x55\x07\x7C\xAA\xC4\x86\xAE\x1D\x43\xDD\xA2\xF9\xAF\xAF\xA2\xEB\xA0\xFF\xA8\x3E\xAE\x7A\xB8\x53\x82\x02\xBA\x88\x2A\xAA\x0C\x01\x27\xB3\x6E\xBB\xE2\xAA\x5F\x86\x99\xD8\x98\x05\x06\x43\xAB\xF4\x0D\xFA\x93\xAC\xBF\x33\xB0\x99\xAF\x51\x45\xAB\x51\x07\x26\xBE\x31\x15\xAA\x98\x95\x6B\xB8\x3C\xB9\x0A\xA9\x18\xB8\x39\x03\xC6\xBC\x67\x0F\x2B\x86\xB0\x39\x72\x9F\x9B\x29\x23\x91\xA9\xC5\xA3\xC0\xBA\x12\xD0\xA9\x7D\xB9\x05\x16\xFF\xA5\xF5\x95\xC7\xA1\x08\x2E\x3D\x90\x38\x71\xAD\xD8\x9F\x2B\x57\x85\xB6\x91\xAB\xC9\x86\x72\x8C\xB9\x07\xB3\x04\xA4\x76\xAB\x69\xBC\xC6\xA6\xC4\xB7\x1E\x08\xB1\xA9\xB1\x38\x08\x26\xBC\x43\x5F\x8C\xB7\xA0\x99\x63\xB2\xB0\x73\x07\x41\xB5\x3A\x8D\x41\xAD\xC9\xB9\x08\x09\x6C\xCB\xB6\x9E\xB0\x3C\xB0\x20\xB4\x70\x9A\x80\xAE\xC9\x81\x04\x7C\xB0\x90\xB8\x14\xA5\x95\xA1\x17\xBB\xA1\xA9\x92\x82\x04\x51\x88\xB1\xB9\x48\xB9\x7F\xAB\x8C\x19\xCB\xA9\xD7\x88\x28\x7D\x03\xB3\xA9\x5E\xBA\x30\xBB\x1E\xB8\xA0\x04\x1C\x21\x61\xB5\xB9\x08\x15\x49\xBB\x30\xBB\x99\xBF\x20\xA0\xE5\x8A\x79\x13\xB0\xDE\xAB\x18\x12\xC4\x9C\x14\xB1\x02\x4E\x90\x95\x49\xB2\xB3\x0F\xA5\x49\x04\x5E\x0A\x17\xB4\xCA\xA5\x89\x8A\x54\x78\x0A\x54\x01\xFB\xA6\x79\x9B\x23\x98\x57\x10\x02\x37\x4F\xD3\xA2\x78\x0A\x1C\x03\x39\xBA\x5B\x88\x57\x0A\x02\x31\x6C\xC5\x85\x78\x0A\x47\x4C\xC7\xB6\x1D\x9A\x88\xAF\xE7\xA4\x30\xF8\x0A\x4C\x00\x7B\xB9\x52\x03\x94\x18\x57\x08\x02\x3A\x73\xE8\x80\x78\x0A\x1B\x03\x3F\xBE\x23\x0F\xC8\x18\x2B\x24\x01\x03\xBA\x81\x2E\xBC\x08\x1F\x00\xA1\xBD\xC7\x18\x2B\x3A\x01\x08\xBA\x4B\xB5\x05\x16\x73\xB4\x38\x8E\x19\xA6\xD4\x84\x6D\xD3\xB3\x01\x02\x50\x09\x70\xB7\x30\x08\xB8\x2E\xD1\x88\x28\x47\xB3\xD9\xB8\xB7\xA4\x37\xBD\x1B\xA3\x82\xB4\x3F\xA0\x73\xE2\xB9\x63\xA2\xDA\x11\x39\xBB\x9D\xB3\x39\x9D\x5C\x2A\x73\xDE\xA6\x81\x85\x76\xB8\x42\xBD\x98\x11\xCF\xA8\xE8\xBB\x32\x75\xB9\xF3\xB8\x57\x18\x3E\xB8\xA1\xBC\xCF\xA2\x08\x3E\x73\xF3\xB9\x98\x19\x80\xB8\x42\xBD\xA0\xBC\xCF\x08\xE8\x86\x32\x0A\xBA\x0C\xBB\xCE\x17\x43\xBB\x9E\xB1\xD1\xA7\x50\x13\x74\xD0\x84\x27\xB4\x2C\x9F\x45\xBA\x45\xB4\x9D\xA8\x4F\x16\x67\xB8\x0B\x1B\x05\xFD\xB2\x35\xBC\x3B\xB1\x10\x1E\xCE\xA4\x68\xF3\xA7\x23\xBA\x67\xB2\x37\xBB\xCE\x27\xD2\xAE\x90\xA3\x73\xB4\x91\xBE\x53\xB7\x04\x4B\xBA\x77\x89\xCE\xAB\xEB\xB1\x74\x82\x02\xEE\xB9\x79\xB8\x4D\xBF\x1F\xB6\xD3\xBD\x5C\x0E\x01\x08\xBA\x3A\xBA\x55\x04\x4F\xBD\x73\x1F\xD3\xA7\xD6\x80\x74\x82\x02\x02\xBB\x79\xB8\x51\xBE\x90\xB6\xD4\xBD\x5C\x0B\x74\xF3\xB9\x0D\xBA\x81\x03\x52\xBE\xAF\xB2\x8D\x75\xDA\xAB\x69\x9F\xB5\xE8\xB3\xB5\xB7\xF8\x23\x3D\xB3\x26\xAD\xCB\x28\x51\xFD\xB5\x4A\x61\xF8\xB3\x3F\x03\x3E\xB1\xD2\xA0\xEB\x8F\x48\xA5\xBA\x00\x2B\xB2\xB9\x83\xA7\xAC\xB5\x95\x98\x35\x2B\x74\xB0\xBA\x9E\x87\xB6\xB8\x6A\xBF\x4D\x82\xD3\xB2\xEB\x9D\x2E\x72\xB9\x8C\xBA\x7A\xB9\xCA\x00\xAF\xBD\xB9\x19\xE7\xB3\x73\xBD\xBA\x01\x03\xBE\xB8\xD0\xB7\xAF\xB1\x10\x01\xEC\xB1\x76\x83\xBB\xFD\x05\xC2\xB8\x52\xB8\xB1\xBA\xD4\xB0\xE8\x9D\x2E\x42\xB6\x19\xB7\x85\x5D\x37\xA5\x3F\xBE\xB0\xB7\xE7\x04\x9A\x79\x39\xFC\xB5\x44\xA9\x66\xBE\x1F\xB8\xA0\xB1\x9A\xA2\x74\x9F\xBB\x63\xBA\xD7\x0A\x68\xBD\x1B\xA4\xDA\xB5\x46\x83\x92\x27\xBB\x68\xB4\x16\x9A\x6A\xB9\xBC\xBB\x39\x8D\xED\xB1\x76\xF3\xBA\x01\x02\xD8\xBB\x6E\xBE\x23\x07\xD3\xB3\xED\xB9\x74\xB5\xBB\x7B\xBB\x7E\xB8\x42\xB9\xA8\xB0\xD8\xA3\xEA\x9D\x2E\x07\xBA\xF3\xB9\xA3\xBA\x40\x07\xB0\xB1\xDB\xA9\xEC\x81\x04\x0B\xBB\xEB\xBA\x54\x32\x63\xBE\xA2\xBC\x5F\x46\xD0\xB3\x6D\xF5\x07\x0E\xA4\xB2\x03\x36\xB8\xBB\xB3\x9A\x4F\x71\x9B\x77\x8F\x14\xDD\xBA\xBC\x8F\x77\xBA\xAD\xBB\xDA\xB1\x1D\xAE\x74\xEE\xBA\xE5\xBA\xB8\xBB\x4C\xBF\xB5\xB5\xD7\xB8\xE9\xB1\x76\xF9\xBA\xB4\x05\xF8\xBA\x4F\xBB\xBE\xBD\xB9\x1E\xED\x81\x78\xC0\xBB\xF8\xBB\xD8\xBA\x7E\xB9\x20\x0C\xDF\xA1\xF0\xBE\x77\x80\x00\x00\xBD\xA9\xB6\x1C\x1B\xC0\xB4\xAE\xAA\xEE\x97\x70\x8C\x14\x1D\xB5\x85\x16\x83\xA2\x9B\xB2\x10\x01\xEB\x8B\x28\x20\xBB\xDF\xB9\xFF\x04\x4A\xBE\x8C\x92\x8F\x14\xF0\xA4\x77\x81\x5F\x33\xBD\xA9\xA8\x86\xBC\xB5\xBA\xE1\xAE\xED\xB5\x74\xF3\xB9\xED\xBB\xA0\x04\x6D\xBB\xA7\xB7\xDB",
"\xBC\xEB\xA4\x78\xC2\xBA\x82\xBB\xFB\xBA\x70\xBB\xBF\xB9\xD4\xAE\xE8\x86\x77\xDF\xBA\xE5\x95\xE7\xB1\x45\xBD\xC6\xB3\xD5\xAB\x50\x2B\x68\x91\x11\x2D\xB4\xE6\xB1\x95\xA0\x46\xB7\xA6\xBA\xD3\x9D\x2E\x3E\xBC\x07\x14\x20\xBC\x59\xBA\xC8\xB6\xD6\xA9\xE9\xB1\x0B\xC6\xBC\x05\xA8\xF1\xBA\x92\xBD\xC2\xB3\x2F\x9D\x5C\x31\x75\xE7\xBB\x1C\xBC\x28\xBE\x5D\xBB\xCA\xBA\xD7\xB5\xF2\xB2\x77\xC0\xBA\x25\xBC\xFB\xBA\x41\xBB\xCB\xBC\xE2\xBD\xF2\x8A\x76\xC6\xBB\x34\xBC\xA9\xB8\xD5\xB7\x63\xB9\xB5\xBB\xC1\x73\x69\xCA\xB6\x46\x15\x63\x44\x9E\xB7\xD7\x0E\xE6\xA8\x6C\x91\x77\x9B\xBD\x13\x08\x25\xB4\xEA\x0E\x41\xA6\x33\x0B\xF0\x8E\x48\xF2\xBC\xDA\xBA\x3A\xBF\x68\xBE\xCE\xB3\xE1\xAB\x42\x0B\x79\x96\xBC\xE3\xBB\x3C\xBD\x86\xB9\x20\x0F\xE7\xA1\xF0\xA8\x77\xCC\x15\x1D\xBC\xF7\xBB\x87\xB8\xBE\xB6\xE8\xA3\xF1\x88\x7A\xD8\xBC\xBF\xBA\x2D\xBD\x7E\xBE\xB0\xBE\xE8\xBF\xEF\x90\x7A\xD0\xB5\x53\xB6\x8F\xB6\xAC\xB5\xD2\xB0\x56\x57\xF4\xB0\x62\x5B\xB4\x52\x56\x50\xBE\x8E\x05\xD3\xB5\x03\xA7\x8D\xA8\x66\xFE\xB4\xD5\xBC\x03\xBE\x99\xB7\x41\xA5\xEA\xBD\xF1\x8C\x78\xB3\x97\x41\xBC\x07\x0B\x90\xBB\x8C\x9E\x14\x00\xEF\xB2\x7A\xC8\xBC\x17\xBC\x3E\xBC\x2A\x32\xD9\xB3\x10\x1B\xF0\x8F\x79\xB1\xBB\x51\xBC\x81\x04\xA1\xB9\xC4\xBD\xEB\xB9\xED\x97\x79\xF5\xBB\x59\xBD\x45\xBF\xB0\xBB\xB8\xBD\xDF\xA5\xEE\x8C\x75\xC7\xBB\x08\xBA\x76\xBE\xD1\xB4\x66\xB9\xD0\x4E\xF6\xB5\x69\xCF\x04\x77\xB4\x30\xB5\x91\xB4\xDA\xBC\xA7\xB1\xD8\x99\x70\xFF\xB4\x09\xA5\x40\xB5\xCB\x87\x5E\xA6\xEA\xBD\xE6\x8D\x78\xC3\xA1\x0F\xBD\x05\x15\x84\xBB\x03\x97\x38\x98\xF3\xB8\x65\xEC\xBA\x7B\xBD\x23\xBE\xB3\x86\xBC\xB6\xEB\xA1\xF4\xB0\x7B\x83\xBD\xEF\xBA\x2A\xBD\x6C\xB8\xB7\xBE\xCE\x17\xF7\xBD\x76\x8A\xBD\x45\xBB\x7D\xBC\x97\xBC\xB8\xBE\xE5\xBF\xF7\x91\x7A\xB7\xB3\x55\xA4\x46\xB7\x83\xA2\xC1\xBE\xED\xA7\xF5\x99\x77\xD7\x08\x19\xBF\x03\x17\xC6\xB9\xEA\x87\xE7\xAE\xF5\xAA\x7B\x9E\x86\xB1\xBD\x8F\xBF\x5B\xBC\xD6\xBE\xEE\xB4\xEB\x82\x7A\x9E\xBC\x01\xBC\x10\xBD\xC0\x0A\xC4\xB6\xEF\xBF\xF5\xB8\x7B\xC1\xBD\xFA\xBC\x15\xBC\xB1\xBC\xE6\xBF\xE8\xB6\xF9\x88\x7B\xC9\xBB\x44\xB7\x4A\xB6\x3F\xAE\xBA\xBE\xD9\xBE\xF9\x97\x7C\xA6\xBA\xAA\xBC\xEE\xB8\xAB\xBD\xE3\xB6\xF4\xA2\xF9\x8F\x0C\xE9\xBD\x6E\xBF\x75\xBE\x9F\xBD\xE9\xB9\xDE\xB9\xF5\x92\x79\xA9\xBE\x85\xBD\x95\xBE\x95\xBE\xEA\xBF\xF2\xB9\xF7\xB1\x7C\xDA\xBE\xFC\xBC\x17\xBE\xBF\xB9\xB6\xB9\xE4\xA6\xD7\xA0\x7D\x85\xBC\xD3\xB4\x95\x02\xA8\xB4\x54\xBF\xA0\x00\x38\x15\x7C\xA4\xBA\x3F\xBE\x8D\x0D\xDA\xB8\xC2\xBB\xF6\xA3\x1C\x66\x7B\xCA\xBE\xA9\xBB\x90\xBF\xB9\xBB\xE4\xBD\xE4\xA0\xF4\xAF\x7B\x81\xBC\xF1\xBD\xBB\xB8\xDE\xBC\xDE\xBA\xF7\xA7\xF4\xB1\x76\xF4\xBB\x7D\xBE\xAC\xBF\xDF\xB9\xC0\xBB\xE2\xB2\x73\x05\x7B\xB0\xBC\xC6\xBA\xF9\xAF\xD5\xAB\xC7\xB7\xDD\xA6\xFB\xA0\x7B\xF3\xBC\xE2\xBD\x3A\xBC\x91\xBA\xA5\xBE\xF1\xA9\xDA\xBA\x79\x81\x02\x2F\xBB\xB8\xBC\x9D\x84\xE4\xB3\xB5\xB7\xF5\xAA\x77\xD3\xB6\xA1\xBF\x79\xBF\xD4\xBD\xDE\xBD\xF2\xBC\xFB\xAD\x05\xB0\xBE\x84\xBA\x99\xBD\xA3\xBC\xEB\xB6\xEC\xBE\xFA\x86\x7E\xD6\xB6\x1A\xB7\x81\xBC\xB3\xBD\x29\xB5\xAB\xA2\x08\x07\x39\x64\xBE\x6F\xBD\x6F\xBF\xC0\x39\xE8\xB6\xA0\x03\xFA\x88\xF3\x45\xBE\x79\x07\x57\xBF\xDB\xB9\xE9\xBE\xFB\xB3\xF5\xAD\x7B\xCE\xBC\x4E\xBF\x93\xBC\xD4\xBB\x6A\xB2\xF5\xB6\xED\xA5\x7E\xBE\xBD\xA7\xBF\x44\xBE\xDF\xB9\xFA\xB0\xF8\xB3\xF9\xBD\x7B\xB5\xBE\x84\xBE\x80\xBF\x3C\xBD\x8C\x1F\xAB\xA2\x08\x01\x6B\x94\xBE\x3D\xBE\x8B\xBF\xED\xB9\xD5\xB9\xFB\xAB\xF5\xBB\x7E\xE8\xBF\xE6\xB9\xA3\xBE\x80\xBA\xF3\xB8\xF9\xAC\xF2\x8C\x7D\xF0\xBF\x75\xBF\xA7\xBE\xAE\xB9\xEA\xBC\xEB\xB7\xFF\x95\x7D\xF9\xBF\xC0\xBD\x13\xBE\xB0\xBD\xFF\xB3\xFD\xBF\xFF\x9D\x7D\x81\xC0\x37\xBE\x35\xBD\x82\xA2\x59\xBB\xF3\xB5\xFD\x8A\x80\xE3\xBF\x93\xBE\x8D\xBD\xE5\xBD\x6A\x47\xF9\xAD\xFF\xA8\x7B\xEC\xBF\x5D\xA4\x76\xB9\xE7\xBD\xE4\xBF\xF9\xA8\xFE\xA8\x7C\xBB\xBD\x2A\xBF\x00\xBC\xCB\xBA\xB7\xB3\xB5\xA8\xFD\x8F\x7F\xFB\xBF\xC1\xBA\xE9\xBE\xEB\xBC\xFA\xB0\xFB\xB6\xFE\x9B\x6C\xB1\xBB\x30\xB5\x2A\xA5\xB5\xB5\x05\xC5\xF6\xAF\x01\xCF\xC7\x64\xBF\x02\x02\xF3\xBE\x10\x95\xD5\xB9\xFE\xB2\x00\xC5\x7E\xB6\x70\xEA\xBE\xB9\xBC\xF1\xBF\xF0\xB6\xFC\xB6\xFB\xB2\x7B\xA3\xBF\xCB\xBE\x0F\xC1\xF3\xB8\x04\xC7\xF5\xA2\x01\xD9\x7D\xAC\xBF\x5B\xBE\x13\xC1\xF5\xB8\x05\xCF\xF5\xB8\xFE\x8B\xBC",
"\x5E\xB5\x02\x03\x70\xB7\xA0\xAF\xF1\xB2\xD6\xA7\xFB\xA1\x76\xB1\xC0\x42\xBF\x19\xC3\xF5\x45\x06\xC9\x03\xCD\xE9\xB8\x80\xAE\xB0\xEE\xBF\x5A\xBD\xF1\xBE\xE4\xB0\xFA\xBF\x01\xDC\x80\xC1\xC0\x53\xB7\x21\xC2\xCB\xBF\x08\xCA\xFA\xBC\xFF\xB0\x81\x81\xBF\x53\xB7\x17\xBD\x8C\xBF\xF0\xBF\x05\xC8\xEE\xB6\x81\xC4\xB6\xBE\xB8\x95\x03\xDA\xA1\x60\xB3\x6F\xAE\x01\xD0\x7E\xFE\xC0\xE1\xBC\xC8\x03\xB8\xB8\x48\x64\x08\xC8\x04\xF7\x80\x94\xC0\x36\xC0\xCE\xBF\x05\xC6\xF3\xB1\xFF\xAD\x04\xF3\x7F\x87\xBF\xF5\xBE\xAA\xBF\x1A\xC1\xC0\xB6\x04\xC6\xF1\x93\x6D\xA8\xBC\x8C\xBD\x25\xC2\x1C\xC5\x09\xC4\x07\xD7\xFE\x8F\x76\xB8\x50\xA7\xB9\x84\xAC\x58\x4F\x5E\xB7\x3C\x2A\xE1\xB8\x0E\x2B\x59\xED\xA8\xE9\xB8\x62\xB7\x5F\xBC\x46\xAF\x90\x99\x08\x7C\xC0\x3F\xBD\xC8\xBD\x48\x00\x0B\xC1\x10\x1A\x02\xEA\x21\x90\xC0\x61\xC0\xA4\xBC\x2C\xC5\x10\xC1\x37\x83\x03\xDF\x82\xB5\x8C\x3D\xC1\xC3\xBD\xF2\xB8\x0D\xC6\xFF\xA2\x02\xFB\x7D\xEC\xC0\xA9\xBE\x37\xC3\xEA\xBB\x6A\xBD\xFA\xAD\xF1\x99\x82\x83\xBF\x01\xBD\x4E\xC1\xC0\xBB\x05\xB3\x37\xA7\xB7\x92\x6C\x89\x5A\x0C\xB6\x0C\x13\x2E\x0F\x61\xB4\x19\x63\x8A\xBF\x83\xFC\xB2\x14\xB6\x2B\x13\x15\xB6\x14\xCD\x07\xCB\x00\xC0\x7D\x80\xC1\xE5\xBE\x41\xC0\xB2\x4D\x15\xCE\x36\xBF\xFD\xA0\x81\x92\xC0\xEC\xBC\x45\xC0\x19\xC4\x11\xCE\x03\xD7\x05\xE7\x83\xB9\xC1\xCC\xBE\x22\xC3\xE1\xBD\x17\xC0\xFD\xA9\x02\xE4\x80\xC2\xC1\x82\xBE\x00\xC1\x3E\xC2\x00\xC0\x05\xC5\xDA\xBA\x68\xB2\x5B\x5B\xB6\x4C\xBC\x0A\xBB\x0D\xA7\xB2\xAF\x6D\xAE\x41\xAA\xB6\x30\x17\x85\xC1\x15\xC7\x14\xCE\x10\xD2\xFC\x8D\x80\xEA\xBE\x0F\xC0\x2E\xC1\x04\xC2\xF8\xB3\x01\xC0\xFE\xA1\x83\x93\xBD\xB3\xC0\x1E\xC1\x2D\xC5\x23\xCB\x01\xD4\xFF\x9D\x80\xEE\xC1\xA6\xBE\x5E\xC2\xFE\xBD\x12\xC6\x12\xD7\x04\xFE\x7F\xA9\xC2\x27\xC1\x95\xC1\x0A\xC0\x47\xB4\xE9\xA8\xDB\xBB\xE0\x31\xC2\xB0\x30\x03\x14\x16\xA5\xB2\x93\x2A\x1B\xD9\xAA\x2A\x56\xC1\x0C\xC3\x6C\xC0\x2A\xC0\xF7\xBA\x0A\xDA\xFD\xA4\x7B\xA9\x02\x14\xC3\xF9\xA6\x45\xC1\xF8\xBB\xF9\xBD\xF3\xA6\x83\xC7\xC1\x02\x99\x74\xC3\x39\xC3\x1D\xC0\x04\xD9\xFB\x90\x85\xF8\xBF\x52\xC3\x10\xC3\x2F\xC3\x04\xC6\x15\xC5\x01\xD8\x85\xF3\xC0\x5A\xC3\x3A\xC0\x5E\xC4\x68\xB9\xA3\xB9\xCC\x8A\xC1\x60\xC2\x5D\x3E\x03\x16\xA4\xAB\xF2\x0E\xB4\xB5\x1D\x3A\x84\xE1\xBF\xB6\xBE\x18\xC3\x4F\xC4\xF2\xB1\x14\xCC\xFB\x9D\x81\xC4\xC2\x5F\xC0\xBA\xC1\x05\xC2\x16\xCF\xFE\xB4\x05\xD9\x80\xF2\xBF\x4D\xC2\x5C\xC3\x53\xC1\x12\xCF\x0E\xC1\x0C\xED\x81\x83\xC3\x6F\xC0\x7A\xC1\x1C\xC7\x30\xC4\x0C\xC9\x0C\xC6\x83\x84\xBC\x02\xBF\x97\xC3\xD3\x48\x32\xC8\xB3\xA6\xA9\x9F\x6D\xC8\x4C\x1F\x15\x04\xA4\x36\xBC\xF6\xB3\x3F\xA0\xC6\x8F\x28\x2D\xA8\x67\x0A\x6E\xC2\x2B\x9D\x33\xC6\xF9\xBD\xFD\xA4\x83\xF3\xC2\x47\xC3\x8C\xC0\xDD\xB8\xD7\xBA\x01\xD7\xFB\xBD\x85\xA4\xBF\x7F\xC3\x0F\xC2\x6B\xC1\x1E\xC0\x1B\xD3\x07\xC7\x7E\xF5\xC1\xAF\xBF\x4D\xC3\x39\xC5\xA9\xB6\xA0\x0F\xEA\xB8\x0C\xC9\xA2\xB8\xC3\x22\xBB\x8A\xB3\xA3\xB3\x9C\xA3\xDF\x1E\x74\xAA\x02\x20\xBA\xE2\xC1\xE7\x16\x38\xCB\xA0\x08\x0E\xF7\x15\x10\xC2\x59\xC0\x89\xC2\x69\xBE\x39\xCE\x0A\xD0\xF5\xA3\x83\xFD\xC3\x76\xC3\x1D\xC3\x22\xC2\x2F\xCB\x18\xD2\xED\x96\x87\x8F\xC1\x7E\xC2\xD6\xC1\x54\xC5\x08\xC3\x15\xD2\x07\xD6\x82\xB2\xC3\x98\xC1\xC3\xBE\x26\xC7\xCB\xBF\xA0\x06\x0F\xD4\x06\xBB\xB3\x64\xBC\xFE\x48\x46\xB8\x26\x16\xD5\xBD\x78\x71\x6C\x5A\xBA\x0D\xA4\x84\xB1\x57\xBD\xB3\xB3\x1F\xDC\xF6\x86\x1D\xCA\xC3\xDE\xC0\x40\x92\x50\xC7\x28\xC1\x1A\xD1\x0E\xF3\x7D\x98\xC0\xD4\xC2\xD4\xC3\x81\xC6\x29\xC0\x09\xC7\xFC\x92\x82\xCE\xBF\xBE\xC1\xC3\xBC\x30\xC2\x09\xC6\x0F\xD2\x10\xF8\x83\xB2\xBC\x2C\xC3\x00\xBC\x8C\xB3\x41\x19\x9E\xB5\xB7\xA2\x49\xF8\xAB\x96\xBB\xCE\xB2\x34\xC2\x35\xB0\xAA\xB2\xCF\xA4\x10\x72\xC3\x78\x0A\xFA\xC3\x81\x16\x3E\xC1\x29\x08\x11\xFA\x87\xF9\x10\xFC\xC3\x8A\xC1\xE6\xBE\x28\xC8\x11\xCF\x11\xE6\x86\xB1\xC4\xB6\xC1\xD4\xC3\x47\xC3\x35\xC6\x23\xCD\x0D\xCC\x88\x82\xC3\x3A\xC4\xC2\xC0\x84\xC7\x2A\xC7\x0F\xCA\x09\xC0\x89\xDB\xC2\x23\xB5\x07\x14\x73\xBB\x20\xCE\xDC\xB6\x28\xA0\x0D\x0E\xBE\x4B\xC5\x02\xB4\x75\xBB\x87\x19\xE0\xAE\x9B\x92\x89\x86\x14\x54\xC4\xFD\x02\x95\xC4\x39\xC4\x03\xD9\x12\xF2\x85\xDB\xC4\x17\xC2\xA2\xC2\x74\xC0\x46\xC7\xFC\xAA\x07\xCE\x82\xB4\xC4\x09\xC5\x32\xC7\x82\xC3\x24\xCD\x20\xDD\x0E\xCF\x88\xDF\xC3\xB3\xC3",
"\x36\xC5\x56\xC7\x4D\xCA\x18\xC9\x0F\xC6\x78\xAD\x87\xE6\x1A\xF0\xBD\x94\xC6\x44\xC5\x72\x94\xBE\x78\x87\xDD\xC1\x57\xC5\xB6\x05\x5C\xC0\x02\xAF\x0A\xDC\x12\xCA\x8A\xDE\xC4\x4A\xC3\xD3\xC1\x98\xC3\x46\xCA\x1A\xD5\x11\xE7\x83\xB7\xC4\xF0\xC0\x4A\xC2\x83\xC5\x2A\xCB\x26\xC6\x0C\xDA\x8A\x88\xC3\x9C\xC5\xDB\xC1\x86\xC3\x48\xC4\x93\xB8\xF1\x92\x46\xA4\xC4\xA3\xC4\x52\xBF\x89\xC7\x54\xCB\x1C\xCF\x0B\xD9\x04\x2B\xC5\xE8\xB9\xFF\xC2\x96\xC6\x02\xC5\x1A\xD1\x15\xE0\x89\xCC\xC2\xB4\xC5\x31\xC6\xAD\xC5\x40\xC8\x2B\xDB\x0E\xFA\x8A\x96\xC5\xBC\xC4\x4C\xC5\x84\xC7\x1C\xC3\x21\xDF\xF7\xA0\x79\xA8\x5E\x46\xB5\x7B\xAB\x86\xC0\x94\x08\xE6\xB7\xD2\x2F\x87\xFF\x01\x6C\xBC\x52\xC5\x89\xC2\x59\xC5\x2A\xC4\x61\x4C\x8B\xA9\xC4\x3B\x33\x22\xBD\xDB\xBD\x2E\xC7\x95\x67\x04\xD3\x8B\xA4\xC3\x1A\xC3\x73\xC1\x19\xC5\x3A\xC7\x06\xD7\x0E\xE9\x81\xD9\xC3\xBB\xC1\x33\xC7\x6B\xC1\x4D\xC1\x1B\xC2\x17\xEC\x89\xBE\xC4\x6E\xC4\x4E\xC1\x90\xC1\xD9\xBE\x12\xCE\x0C\xF2\xB6\x06\xBE\xCE\x4B\x1F\xB5\x0D\x1A\xDA\xBF\xCC\xB3\x12\xCA\x7C\xA8\xA0\xD6\xBD\x68\xC0\xC7\xC6\xC0\xBB\xA4\xAD\xF3\x87\x87\xFE\xC4\xF2\xC5\xA1\x9C\x41\x47\x5E\xC9\x2A\xCC\xAC\x3B\x8B\xA3\xC3\xEB\xBE\x69\xC7\xA1\xC4\x5A\xC1\x30\xC5\x10\xC3\x8C\xB2\xC4\x05\xC6\x04\xC4\x76\xC2\x41\xC0\x18\xCA\x18\xDC\x87\x8C\xC6\xDE\xC3\x73\xC0\x78\xC4\x09\xC2\x1E\xC5\x10\xFA\x83\x83\xC0\x15\xC7\xA3\xB7\x8E\xB7\xE3\xBF\xEC\xA6\x4A\x31\x4E\x23\xC6\x0C\xBF\x22\xB7\xA7\xBF\x63\xC3\x1A\xBA\xF6\xA3\x7A\xC3\xB4\x28\xC6\x7A\xC4\xEF\x92\x50\xCC\x32\xC4\x14\xC3\x82\x86\xC5\xAC\xC4\xFF\xC2\xAB\xC4\x5F\xC3\xFC\xA2\x10\xDB\x84\x84\xC4\x04\xBC\xBE\xC2\xCE\xC7\x60\xCC\x33\xDA\x0E\xFE\x8C\xDF\xC5\x40\xC7\x4B\xC6\xD0\xC1\x53\xC0\x31\xDB\x14\xD2\x8C\xF0\xC4\x6F\xB4\xED\xBE\x57\xC5\xD9\xBC\x34\xC7\xF8\xAF\x18\x09\xBE\x7B\xB5\x85\xBF\xC9\xC1\x70\xC0\x32\xC2\xD3\x94\x8D\xC2\xB4\x80\xB4\x33\x95\x9F\xC5\x38\xC9\x32\xDF\x5D\xA7\xDE\x03\xC5\xCE\xC5\xCE\x17\x50\xC4\x6C\xC5\x14\xC9\x14\xD4\x8E\x8B\xC5\x5F\xC5\x46\xC7\x5E\xC7\x51\xC5\x2B\xD1\x14\xF7\x8A\xE6\xC4\x94\xC4\x34\xC7\x39\xC3\x47\xC7\x12\xDD\x11\xE4\x8B\xBF\xC4\x77\xC7\x4E\xC7\xB0\xC1\xF1\xBF\x0F\x1A\xF9\x8B\x8E\xF3\xC5\x58\xC7\x7A\xC6\xEC\x50\x72\xCC\x0A\xC0\x1B\xD1\x8B\xE3\xC6\x30\xC6\x31\xC2\xD9\xC2\x60\xCC\x11\xCE\x14\xDE\x84\x85\xC4\x20\xC2\x35\xC2\x48\xC7\x1C\xC4\x12\xC8\x02\xE9\x78\x85\xC3\x28\xC3\x5F\xC5\x6D\xC1\x58\xCF\x04\xC2\x12\xC6\x78\x96\xB5\x98\xB5\x3D\xC2\x40\x07\x4F\xCC\x42\xAB\x16\xDB\x86\xB2\xC0\x5E\xC7\x89\xC2\xED\xC5\x86\x9E\x2F\xD3\x19\xC0\x8C\xD3\xC3\x9A\xC7\x02\xC6\xDA\xC0\x52\xCB\x33\xD2\x14\xFD\x8C\xA1\xC7\x0B\xC7\xD1\xC6\x9A\xC6\x61\xCE\x2B\xD5\x1B\xC0\x8B\xA9\xC7\xC2\xC4\x49\xBF\x90\xC5\x4A\xAB\xF8\xAF\x90\x8E\x7E\xD3\xC7\x8D\xC6\xD9\x72\x15\x6C\x76\xC2\xD1\x70\x16\xDC\x8F\xB2\xC6\x61\xC7\x00\xC5\x52\xC3\x40\xCB\x14\xDE\x1D\xE2\x89\xC0\xC7\x64\xC5\xCF\xC7\xA4\xC4\x78\xC5\x29\xD1\x1B\xE1\x8B\xF3\xC6\xE3\xC5\x02\xC5\xB9\xC1\x00\xC2\xFB\xBB\x64\xA0\x79\xC9\xC5\xB1\xC7\xAD\xC7\xCA\xC7\x7A\xC1\x08\xD9\x1E\xFB\x87\xAF\xC6\xB1\xC1\x98\xC4\xEE\xC1\x84\xCA\x3B\xC3\x20\xE7\x8D\x85\xC8\x9B\xC7\xDF\xC4\x81\xB9\x78\xC8\x30\xC3\x1E\xC5\x88\xC5\xC7\x54\xC3\xE3\xC5\xAF\xC1\x79\xCE\x3E\xCB\x1E\xF0\x8F\xCD\xC7\x14\xC7\xC6\xC2\xD2\xC3\x1A\xCC\xA0\x16\xD5\x9F\x7F\x88\xC0\x01\x02\xEA\xC5\x40\x01\x50\xCB\x41\xCD\x0B\xCE\x80\x91\xC7\xFE\xC6\x43\xC0\x00\xC8\x66\x97\x17\xC4\xF0\xB7\x8C\xB3\xC5\x39\xC6\xF2\xC4\xDB\xC6\x7C\xCE\x36\xC8\x1F\xFF\x8C\xEA\xC7\x0D\xC6\x08\xCB\xC3\xC7\x74\xC1\x31\xC3\x0F\xD3\x8C\x87\xBF\x04\xC1\x04\xA4\xB0\xB4\x0A\xC0\x3B\xCE\xF3\xAA\x8C\x8B\x02\xFC\xC7\xBC\x89\x12\xC8\xE4\xB3\x42\xCF\x0E\xC9\x82\xE0\xC7\x66\xC0\xD1\xBE\xC1\xC5\x1D\xCD\x36\xC9\x18\xD6\x91\xF0\xC6\x58\xC9\xA0\xC5\x81\xC3\x68\xC3\x0C\xC5\x1A\xC4\x78\xC7\xC6\x2D\xC3\x64\xB6\x40\x03\x59\xB2\x3D\xC1\x22\xF9\x8F\xAC\x79\x8F\xC7\xAE\xC4\x12\xCB\x7B\xCA\x44\xCD\x23\xC0\x88\xA5\xC8\xD5\xC4\x02\xCA\xAC\xC0\x5B\xC1\x45\xDD\x1C\xE5\x8F\x8A\xC8\xE7\xC6\x06\xCA\xE8\xC5\x40\xC4\x3A\xC8\x1E\xE6\x8E\x92\xC8\xA8\xC6\x2F\xC8\xDE\xC0\xB2\xB2\x05\xC2\x08\x16\x6B\x85\xC9\xAE\x2E\xAD\xC7\x19\xCA\x21\x09\x46\xC4\xE7\x8C\x92\xEC\xC8\x96\xC7\xDC\xC5\xD9\xC6\x84\xCC\x3B\xC8\x1B\xD9\x88\xE3\xC7\x96\xC9\x29\xC8\x26\xCD",
"\x8A\xCA\x49\xC9\x1F\xDC\x92\xEB\xC7\x5A\xC9\xF6\xC4\x17\xCE\x6E\xC2\x4A\xCA\x1D\xF2\x8F\x86\xBC\xDF\xB5\x6D\x27\xEB\xC0\x83\xC6\x46\xCE\x1C\xD0\x5F\x2D\xC9\x68\xBA\x91\x43\x67\xC4\x72\xCD\x22\xDD\x12\xCD\x91\x99\xC4\x4F\xC8\x4A\xCA\x1C\xCB\x6D\xC4\x47\xD4\x22\xF6\x91\xBD\xC9\x57\xC9\x5F\xC9\x16\xCB\x8F\xC4\x37\xC3\x26\xEF\x8F\xC5\xC9\xF1\xC6\x10\xC6\x2C\xBF\x83\xBB\xAE\xB7\x0C\xCC\x93\x83\xC7\x1A\xC8\x34\xCA\x22\xCD\x76\xC0\x42\xCE\x23\xED\x8A\xB1\xC9\x24\xC9\x59\xC9\x24\xCF\x84\xC3\x49\xC6\x20\xD9\x8B\x88\xC8\xDB\xC4\x02\xBD\xB7\xC7\x6D\xC9\x23\xD9\x23\xF2\x8D\xE4\xC9\x11\xC8\x02\xBF\x04\xCE\x36\xC8\x43\xC0\x23\xFC\x83\xDF\xA9\xD5\xAC\xCC\xBA\x6C\x5C\x19\xCF\x23\x2E\x06\xFC\x18\x01\x70\x63\xBD\x3C\xC5\x30\x5D\x4A\xA0\xB0\xA8\x0B\xCC\x8E\xAA\xC9\xCE\xC8\x7C\x24\x34\xCD\xB4\xB8\x25\xD5\x27\xCF\x92\xE2\xC1\x8E\xC9\x7F\xC6\x00\xCB\x9F\xC5\x4B\xC8\x21\xE2\x8F\x9C\xC7\xDA\xC4\xCF\xC4\xB7\xC0\x74\xC0\x4E\xD8\x23\xE2\x93\xFA\xC8\x04\xBC\x3E\xC8\x6D\xC6\x8F\xC9\x21\xC0\x24\xCE\x8F\xC9\xC1\xF5\xB4\x79\x59\x40\xC5\x35\x86\xCF\x35\x1B\x10\x6C\x86\xC2\x12\xCB\xA7\x4D\x95\xA5\x62\xBE\x51\xC5\x23\xF0\x93\xAB\xC9\x9D\x17\x70\xBA\x5B\xC4\x9E\xC3\x4D\xD2\x25\xD5\x8E\xA2\xC3\xF9\xC8\xA4\xC0\x4B\xCE\x66\xCD\x3B\xC9\x21\xC7\x90\xAB\xC8\x09\xC9\x99\xCB\x02\xCF\x85\xCD\x40\xC6\x28\xCF\x90\x88\xCA\x5B\xC8\x50\xC9\x17\xCE\x68\xCF\x45\xC7\x07\xF9\x86\x96\xC6\xBB\xC3\xBE\xC5\x6F\xC5\xB3\x94\x2F\xA8\xD9\xA9\x23\x38\xC2\xDF\x0E\x77\xC8\xFE\xC0\xA4\xCA\x3F\xD6\xB4\x63\x94\xDE\xBB\x9E\xC3\xC9\xC6\x55\xCD\x9A\xCF\x2A\xD7\x26\xD2\x7A\xD9\xC9\xFE\xC9\x4A\xC9\x4C\xCF\x92\xC2\x56\xD9\x24\xE4\x95\x9B\xC9\x04\xBD\x4E\xCB\x0C\xCF\x93\xCA\x50\xC1\x25\xEC\x95\xA3\xC9\xD9\xBE\xDD\xC2\xED\x4C\x37\xCD\xB5\xB9\xD9\xB0\x46\xCA\x02\x66\xC3\x80\x01\xCF\xB4\xBE\xAF\x51\xD9\x20\xD0\x95\xFF\xCA\x12\xBD\xC0\xC8\x8B\xC0\xEE\xB7\x39\xD0\x15\xD2\x92\xD7\xC5\x89\xCB\x6D\xCA\x14\xCD\x9B\xCB\x4B\xDF\x26\xCF\x96\xBE\xC9\x91\xCA\x60\xC8\x5A\xCA\x98\xCA\x56\xC4\x26\xD7\x96\xC6\xC9\xF7\xA8\x1D\xC8\xC1\xBF\x31\xC2\x57\xDD\x2C\xEB\x4B\xCD\xB6\x09\xA5\xA7\xB5\x53\xCF\x9D\xC5\x1F\xD6\x1E\xC6\x91\xC0\xC2\x8B\xC8\x93\xCA\x4A\xCD\x5F\xCB\x44\xDA\x01\xF4\x92\xDC\xCA\xB6\xC8\x49\xBC\x2E\xCB\xB1\xCA\x4B\xCD\x2C\xFC\x92\xB7\xCB\xE1\xC9\xDC\xCB\x38\xC9\xA7\xC5\x4E\xDD\x2D\xE7\x93\xBF\xCB\xE9\xC8\x2A\xB7\xB2\xBB\x6F\xC1\xB2\xA4\x07\xE1\x85\xA7\xA6\xBF\xC3\xE9\x9A\x81\xB9\x46\x15\x0E\xBA\xE0\x8C\x83\xD3\x3F\xD6\xAF\x38\xBC\x17\xB0\x28\x04\xC3\xA5\x51\x01\x6C\xB1\x14\x46\xB6\xC6\xAB\x5A\xA3\x73\x69\x19\xA1\x08\x25\x72\xD8\x4A\x7A\xC6\xFD\xCB\x25\xB0\x39\x05\x95\xB8\x33\x3E\x7F\x41\xCA\xEA\x4E\xE8\xCA\xC2\x29\xBA\xB2\xE3\x8B\xA4\x9C\x5F\xD4\xA8\xDE\xAE\x9F\xB0\xE6\xA3\xBF\xCA\x39\xB2\x47\x50\x63\x86\xCC\x1C\xCD\xF2\xAF\xFD\xA7\xC0\xCA\x61\xD7\xBF\xBD\x70\xAD\x9F\x8B\xA9\x64\xC8\x15\xA9\x99\xC5\x62\xD3\x9D\x9C\x98\xE2\xAF\x79\x99\x98\x2F\x3F\x0A\xC5\xCD\x10\xCA\xB8\x27\x61\xD7\xB2\x24\x02\x08\xCE\x9C\x4D\x86\xBF\xA0\x11\x51\x1B\x10\x3C\xA7\x90\xA7\x17\xCD\x10\xBF\xC0\xCF\x4F\x16\xBF\xAA\x85\xDA\x9E\x3F\xB8\x3B\xB9\x81\xCA\x88\xB5\x85\x51\xE2\x8A\x05\x59\xA7\x5D\x0A\x06\x9C\x8F\x07\x21\x0C\xC4\xB8\x62\x97\xA1\x4F\xB8\x71\x9D\x25\x9B\x86\xC8\x82\xA4\xC4\xAC\xE6\xA0\x64\xFF\x01\xC3\xC3\x06\xA7\x35\xC2\x20\x0A\x8C\xA8\xD3\x82\x82\x78\x0A\x44\x01\xFB\xA4\x11\xCA\x9E\xCC\x41\xD1\x08\xDE\x90\xA5\xCA\x55\xCB\xAC\xC8\x61\xCD\xB5\xC6\x58\xCA\x15\x9D\x95\xAF\xCA\x2A\xC9\x0C\xC4\x0B\xCD\x8E\xCE\x42\xC4\xF0\xB0\x90\xBB\xC5\x32\xC8\xF6\xC4\x0D\xCE\x9C\xC6\x43\xDE\x22\xE7\x8B\xD8\x83\x19\xCA\x75\xC4\x55\xB9\xA3\xB7\x17\x0C\x0F\xE6\x68\x6F\xC5\xF1\xC2\x31\xCE\xDB\xA5\xCC\xC5\x40\xA7\x33\xE4\x07\x6A\xCC\xCE\xCA\xA9\xCB\x11\xCC\xAA\xC2\x58\xD2\x33\xEC\x96\xD6\xCA\x98\xC6\x6B\xC5\xF8\xC1\x6D\xC0\x53\xC0\x28\xF2\x94\x82\xCA\x34\xCA\xF0\xCA\x4D\xCA\xBC\xC8\x53\xD9\x10\xFA\x94\xCA\xC7\x3C\xCA\x49\xBC\x79\xC2\x20\x06\x21\xD7\x11\x90\x67\xAB\xC7\xEB\xC5\x46\xCC\xEF\x09\x60\x08\x9D\xA7\x26\xDB\x67\xE3\xB6\xDD\xB3\xE5\xC8\x99\xCA\x75\xA6\x69\xCF\x0F\x18\x9A\xB2\xC7\xFB\xC7\x79\xC9\xFF\xC7\x95\xC0\x1D\xD6\x26\xFB\x8E\xD8\xCB\x2E\xCA\x52\xCD\x9E\xCA\xD2\xBB\x67\xDE\x26\xFD\x99\x99\xC4\x7F\xCC\x70\xC5\xA0\xC9\x98\xC3\x68\xC6",
"\x2F\xC5\x9A\xE8\xCB\x0D\xCA\xB7\xC9\x83\xA5\x48\xC6\x5F\xBE\x49\x08\x89\xF9\x4F\xD1\xC0\x19\x9E\x66\xBC\xB3\xBA\x57\xC1\x08\x14\x9A\x9F\xBE\xC5\xCC\xFF\x03\xB1\xC9\x9E\xCC\x4A\xCA\x36\xEA\x91\xCC\xCD\x88\xC4\xAC\xCA\x3D\xCF\x7B\xCC\x28\xD1\x23\xCA\x7F\xB4\xCB\xDE\xCA\xDB\xCA\x9F\xCD\xAC\xC7\x53\xC7\x28\xE4\x97\x89\xCA\x19\xC5\x85\xC8\xF3\xC6\x13\xC5\x20\xC4\x16\xC6\x28\x73\xC4\x45\xCA\x8F\x04\x80\xB6\x6B\x07\x51\x88\x2A\xDA\x94\xC2\xCA\x8B\xA9\x7F\x01\x32\xB0\x57\xBD\xB9\x0F\x37\xC9\x6D\xF1\xCD\x69\xCC\xBE\xC8\x22\xC8\xFA\x2A\x71\xD2\xBC\x10\x89\xC3\xCD\x5E\xA6\x90\xCF\xBC\xCF\xB4\xC6\x6F\xCE\x25\xD2\x97\xDE\xC7\x22\xC8\x7C\xCB\xBE\xCB\xA5\xC5\x33\xCE\x22\xF7\x99\xD2\xCD\x5F\xCA\x3D\xCD\x58\xC8\xD5\xC3\x56\xC3\x38\xD0\x96\x99\xC4\x92\xCA\x41\xCC\x65\xC9\xE1\xC6\x59\xDF\x23\xED\x95\x8D\xCE\x06\xBD\xBB\x94\x56\xB5\x99\xBE\xCA\xB3\xD0\x8D\x67\x93\xCD\xC4\xCC\xD8\x54\x9A\xCB\xE5\xC1\x52\xD9\x36\x28\x96\x9C\xBE\xCD\xC3\x97\xCD\x00\xCC\xBA\xC9\x52\xD0\x39\xD0\x92\xB5\xCE\xD8\xC9\x9B\xCF\x2D\xCD\xD4\xC0\x56\xC1\x28\xD9\x88\x83\xCA\x77\xC9\x82\xC9\xC1\xCF\xAC\xC7\x70\xC9\x2B\xD5\x96\xEB\xCA\x46\xCE\xCC\xCA\x8D\xBC\x6F\xBA\x12\x19\xF1\x9F\x68\x87\x14\x63\xCC\x77\xCD\xD4\xCA\x33\x53\x75\xC2\x39\xC6\x2F\xCF\xC9\x2D\xCF\x68\xC9\xB9\xB8\xDF\xC7\x4F\xDA\x37\xE7\x94\xDA\xCA\x60\xCF\xC3\xCA\xD8\xCA\xBB\xC4\x76\xDA\x39\xE6\x9D\x92\xBD\x68\xCF\x9A\xCA\xDA\xCC\xD5\xC6\x70\xCE\x35\xE5\x97\xEF\xCE\xBE\xCA\xA3\xCF\xA1\xCE\x44\xB8\x1E\xD8\x35\xCB\x9A\xB0\x12\xED\xC4\x15\x1B\xBB\xC1\x5E\xCE\x16\xD8\x2B\x1E\x9C\xE4\xC1\x2A\xCE\xBF\xCF\xD8\x68\xF0\xCD\x66\xD9\x0F\xEF\x99\xAA\xC5\x84\xCE\xB1\xC6\xCC\xCF\xF0\xC1\x6A\xCF\x2D\xE3\x9A\xE3\xCE\xD3\xCD\xEE\x83\xCE\xCF\xEC\xC9\x6A\xDE\x39\xF8\x96\xC0\xCE\xBA\xCB\xB6\xCC\x6F\xC8\xF3\xC7\x5E\xD1\x3B\xC0\x97\xEA\xCB\x58\xB6\xF6\xCA\x9C\xB5\xB8\xC6\x60\x5A\x18\xC6\x6B\x50\xC6\xF0\xC8\x4F\xBC\x9E\xC3\x64\xC2\xEA\xA1\x1A\x0F\x48\xD0\x0B\xA6\xCF\xBD\xCE\x9F\x55\xEF\xC6\x5A\xD5\x3A\xC9\x87\x81\xCF\x24\xCA\xD8\xCE\xD6\xCF\x76\xC3\x7B\xD3\x2E\xFA\x93\x89\xCF\x76\xCD\xEC\xCA\xCE\x91\xF7\xC2\x17\x9B\x3D\xD0\x9E\xBD\xCF\xD8\xCC\x82\xCC\xE5\xCC\xED\xC6\x79\xC8\x38\xD2\x7A\x8A\xCE\x37\xC8\x86\xCD\x7A\xC2\xB8\xCB\xFD\xAB\x3E\xC9\x6D\xCD\xC6\x2F\x13\x68\xBF\xE1\xC6\xF2\x51\x35\xC5\x1C\xD3\x8D\x84\xC7\x55\xC7\x32\xB7\xD5\xC0\xBA\xC9\x7D\xC9\x39\xD2\x9D\x97\xCD\xAA\xCF\xE9\x72\x48\xC8\xFC\xC0\x58\xD9\x3A\xF1\x99\xB3\xCE\x5C\xCF\xF2\xCE\xD7\xCF\xFC\xC0\x47\xC4\x18\xF2\x96\xB9\xC9\x00\xCE\x9E\xCE\x63\xCE\xF7\xC1\x5E\xC0\x3E\xE3\x97\xF5\xCF\x6E\xCE\xA2\xCC\xDC\xCD\xA7\xC7\x74\xDB\x3F\xDD\x85\xCA\xC1\x57\xB4\xE6\xCD\xEC\x26\x4E\xB7\xA9\x70\x3E\xCD\x97\x88\xD0\x42\xB5\x03\xD0\x92\xB5\x70\xC9\x38\xD9\x75\xA7\x9C\xFA\xCE\x0E\xD0\xBE\xCC\x04\xD5\xFB\xCD\x57\xC9\x24\xED\x9E\xA8\xC5\xAF\xCE\x97\xC7\x05\xD7\xF0\xC3\x67\xC0\x35\xEE\x96\xFC\xC9\xB0\xCA\xAF\xCB\x3F\xCD\xEC\xC7\x6A\xDC\x3D\xFD\x9C\xF1\xCF\x3F\xCE\x49\xBD\xD0\xCC\xDB\xC3\x74\xD7\x3F\xC5\x9D\xAC\xD0\x72\xCE\x50\xC1\xCE\xBB\x3C\x1F\x83\xC9\x61\x41\xA1\xDB\xCF\x43\xD1\x66\xC9\x11\xD4\xF5\xCF\x5C\xDC\x0C\xD1\x97\xCB\xD0\xE6\xCF\xAB\xCA\x8B\xC5\xCE\xC1\x14\xAA\x3F\xF6\x06\xEC\xCF\x42\x85\xC7\xCC\xDE\x59\xF2\xCA\x6A\xD3\x3C\xE6\xA0\xAD\xCD\x92\xBD\x57\xCD\x0D\xC9\xD6\xC8\x88\x61\x43\xFC\x97\x62\xBE\x01\x03\xE8\xC6\x44\xB8\xEA\xC7\x86\xD4\x9C\x5C\x9F\xEA\xD0\x23\xCF\x09\xD3\x11\xD5\x59\xCC\x69\xCB\x2D\xDD\x8F\xDB\xCE\x1C\xD1\x7E\xCE\x07\xD7\xDF\xCA\x0B\xD7\x36\xD2\x7A\xD9\xCD\x0E\xC9\x6D\xCF\x6E\xCD\xDB\xC4\x7C\xDF\x36\xC6\x9F\xE9\xCB\xD2\xB4\xD6\xC5\xFD\xC3\x99\xC8\x72\xC6\x33\xCF\xA0\xC6\xCD\x11\xD1\x14\x76\x24\xD5\x0D\xD8\x3D\xCF\x43\xDD\x9A\x98\xD0\x28\xCA\x0D\xD0\x26\xD0\xF1\xCD\x81\xD8\x19\xDF\xA0\xDC\xCB\x21\xD0\x2B\xD3\x08\xD0\x0B\xDF\x7B\xDA\x42\xC1\x9F\xA8\xD0\xC3\xCE\x15\xD1\xE6\xCC\x05\xD5\x41\xC7\x9D\xA4\x96\x9D\xCE\xDA\xCE\x47\xD1\x1A\xD7\xA9\xCE\x7D\xD7\x0F\xD3\xA2\xF8\xC5\xFA\x39\x35\xC9\xB3\xCD\xB0\xCF\x6C\xD6\x39\xF6\xA1\xBC\x96\x78\xD0\xF2\x82\x1E\xD7\x18\x87\x85\xDF\x44\xF2\x9F\xFF\xD0\x95\xCF\x40\xD3\xE5\xCA\x19\xD5\x7C\xC0\x43\xC7\x9F\xDC\xC2\xEB\xCA\x18\xD3\xC4\xB5\x87\xCE\xFD\xA8\x16\xED\xA2\x95\xCD\xAF\xD0\x79\xCD\x2C\xD1\x54\x76\x84\xD4\x45\xDD\x90\xB6",
"\xD1\x96\xD1\xEA\xC9\xBD\x84\x0E\xDC\x2A\x9F\x46\xF2\x08\x8D\xCF\xD4\xCC\xF7\xCF\x1E\xD0\xFE\xC6\x8E\xD9\x42\xDD\x00\xA7\xD0\xEA\xD0\xFB\xCF\x37\x73\x05\xD2\x6B\xCD\x41\xEB\x8E\x85\xC0\x01\x03\x03\xC1\x85\xC4\x11\xDE\x8A\xC2\x42\xF0\xA2\xC4\xD0\x91\xD0\xAB\xCC\x05\xD1\xB5\xC6\x81\xD7\x45\xCC\xA1\x9F\xCD\x59\xCB\xDA\xCC\x14\xD7\xF6\xCC\x78\xC1\x47\xE6\x06\x8A\xD2\xE4\xD1\x61\xD1\x43\xD5\x18\xDF\x90\xC0\x44\xE2\x35\x92\xD2\xC5\x7A\x8A\xD1\x21\xD7\x1D\xDD\xAD\xAB\x01\xC3\x92\xF6\xD1\x40\xD1\x8E\xD0\x1A\xD7\x23\xD0\x89\xDF\x3B\xF3\xA2\x9A\xCD\xD0\xCB\x4A\xD2\x17\xC0\x25\xD8\x8B\xDC\x45\xDA\xA2\xBE\xD1\x9C\xD1\x90\xC3\x24\xC6\x0F\xD6\x8C\xD0\x48\xF7\xA4\xA9\xD0\x5E\xD0\x9D\xD1\xA3\x86\x10\xD1\x05\xC9\x90\x93\x81\xE5\xD0\xA7\xCF\xAE\xA9\xEA\xC8\x24\xD6\x94\xC2\x49\xD7\xA3\xAD\xC6\x69\xBB\xF1\xCF\xFF\xC5\xEB\xCB\x8B\xCA\x49\xED\x94\xFD\xC9\x52\xD0\xC5\xCA\xA9\xCC\xB1\xC2\x82\xDF\x2E\xE4\xA0\xAB\xCD\xE8\xD0\xFA\xCD\x44\xD0\x2B\xD3\x91\xCB\x46\xD5\xA4\xDC\xD2\xC8\xC9\x3C\xC0\x50\xD6\x0C\xD2\x94\xD2\x46\xC4\xA5\xD4\xD1\x6B\xD1\xA3\xD3\x2A\xC3\xD9\xCA\x96\xCD\x24\xFA\xA2\xCC\xC8\xDD\xD1\xB0\xCE\x41\xD1\x37\x8E\x92\xD7\xE7\x95\xA1\xEF\xCF\xE5\xD1\x6D\x82\x43\xD7\xAA\x76\x95\xC2\xEC\x78\xA4\xCF\x4D\xF8\xCE\x74\xC9\xB8\xC8\xE9\xC7\x3B\xB4\x35\xDC\x9C\x8D\xD0\x85\xD3\x9E\x6B\x23\xD0\x31\xD1\x92\xD3\x2D\x09\x48\x80\x43\x28\x02\x51\xB9\x58\xD6\x6D\xA2\x08\x57\x97\xA1\x1A\x69\x60\x40\x6E\x40\xC6\xD1\x8D\x4A\xA3\x11\x0C\x34\xF2\xA6\xD1\xD1\x3D\x6A\x37\xBD\xEC\x71\xB9\x69\x9B\xD5\x1E\xC8\x9B\x96\x6D\x55\xA4\x39\x56\x47\x03\x82\xB1\x94\xD8\x47\xDA\xA6\x55\xA4\x72\xB3\xB0\x42\x06\xB8\x35\xDE\x9C\xDE\x53\x55\x49\xFE\xB2\x20\x02\xE6\xD0\x61\xD5\x3A\xD4\x39\x75\x92\x8A\x66\xB9\xCC\xD3\xD3\x7B\xD0\xBC\xC8\x76\x56\xE0\xAE\x6C\x0B\x04\x5A\xD3\xB3\xD3\xF9\xA5\x6D\xD6\xC0\xB7\xA6\xB7\x0D\x28\xA7\xC0\xD3\xF1\x29\x2A\xA6\xDF\x5D\x22\x0F\x9E\xCD\x44\xC1\xA7\xD5\xA4\x35\x65\xDC\x4D\xA9\xB1\x3D\xD9\xF3\x9E\x53\x5B\x75\xEA\xB5\xA4\xC0\xE3\xD0\x34\xD6\x3E\xD1\x4F\x2B\x4D\xF7\xA0\xF4\xCD\x51\xCB\xC5\xD3\xBD\xCD\x31\xD0\x4B\xC6\x3C\xF1\xA1\xEE\xD2\xD0\xCC\xB8\xD0\x9E\xC9\xE7\xC9\x90\xC3\x47\xF6\x04\x99\xD3\x63\x7F\xCD\xD3\xB3\x4B\x0B\xD3\x8A\xDD\x42\xFD\xA5\xED\xD1\x7F\xD2\x9E\xD3\x55\x48\xA8\xC7\x10\xD3\x28\xE6\x98\xCD\xC1\xAF\x11\x6A\x38\x9E\xC5\xC2\xC4\x0D\xCE\xCD\x9A\x8D\xD4\xD3\xE3\xD2\x8F\xD2\x3E\xD4\x2C\xDB\x7A\xCA\x4C\xD3\x95\x8C\xD3\x70\xD1\x0D\xD2\x1C\xD6\xD9\xC7\x5D\xDE\x46\xD1\x9B\xB8\xCF\x14\xD4\xDD\xCE\x85\xD5\x30\x8C\x90\xDA\x4C\xF4\xA4\x9C\xD3\x36\xD2\xCF\xD0\x5F\xD1\x27\xDE\x97\xDB\x49\xE8\xA2\xC9\x3B\x24\xD5\xA4\xC9\x81\xB7\x41\x14\x36\x1E\xCF\xA9\x48\x47\xCA\x97\xBB\x8B\xCE\xFA\x4B\xA9\xCA\x10\xD9\x20\xF0\xA8\x9F\xCE\xF9\xD1\x90\xCC\x8D\xD2\x02\xD6\x96\xDE\x47\xEE\x99\x80\xD2\x4B\xD3\x4B\xD0\x64\xD5\x47\xD2\x99\xDF\x51\xED\xA4\xC1\xD4\xED\xCF\x21\xD6\x04\x98\x43\xD2\x04\x87\x47\xD5\xA5\xC9\xD4\xCF\x4C\x41\xD0\xA1\xCC\x10\xDB\x95\xC2\x51\xD7\x6D\x89\xCC\x3A\xCD\xFA\x34\x67\xCC\x64\xB2\x10\x06\xD9\xB6\x46\xF1\xA0\x29\xB7\x04\xA7\xCA\xB2\x5E\xCF\xA5\xC8\x3D\xE1\xA9\xD4\xCE\x89\xD3\x32\xD4\x52\xD6\x0D\xDA\x94\xC0\x0D\xCC\xA5\xB4\xCF\x4F\xD1\xB7\xD1\x14\xD3\x42\xD3\x85\xCE\x3C\xD7\xA6\x8B\xD2\x74\xD5\xA0\x7E\x86\xD5\xE5\x7D\x99\xD9\x53\xEB\xA3\xD9\xD2\x4D\xD5\x3E\xD7\x93\xD1\x6F\xCA\x59\xC1\x66\x43\xAA\x84\xAB\x9E\xCA\x34\xA1\x59\xC1\x41\xAC\xB3\xAC\x54\xE2\xA7\xE0\xD4\x32\xD4\x31\xD5\x51\xD5\x46\xD2\xA9\xCA\x50\xEE\x9C\xB9\xD4\xBB\xD1\x26\xD1\x4A\xD1\x53\xD1\xA1\xDB\x54\xF8\x9C\x9D\xD5\x15\xD5\x4F\xD5\x4C\xD6\x2E\xD4\x8C\xC5\x41\xF7\xA9\xE9\xD1\x57\xD3\x64\xD0\xAA\xD0\x44\xDE\xA4\xC3\x4D\xEE\xA0\xF1\xD1\x81\xD4\x13\x37\xAB\xD3\xAF\x02\x19\xC6\xBC\x9C\x47\x86\xBC\xCA\xCB\x17\xD7\xAD\xD6\x51\xD9\xAB\xD0\x54\xED\xA6\xD6\xD1\x66\xD4\xD7\xCC\x9A\xD6\x52\xDA\xA6\xD6\x2E\xDB\x95\xBE\xD4\x12\xD5\x63\xD6\x5C\xD4\x0A\xD4\x97\xC2\x46\xCC\xAB\xB3\xD2\xCE\xD5\x9A\xD0\xB4\xD2\x49\xD2\xAD\xDF\x50\xE6\xA2\xEE\xD1\xAB\xD5\x3F\xD5\xAB\xD2\x9E\x5B\xAD\xD2\xDF\xBC\xC5\x08\xA1\xD9\x9A\x59\xA3\x3A\xC8\xD8\xC6\x4C\xA7\x4D\xD4\x63\xA8\xBB\x6A\x2C\x24\xB1\xAB\x23\xB2\xBD\xB6\xB8\x7E\x4E\x64\xF1\xB1\x9A\xBA\xBA\xB5\xA9\xB7\xAA\xA2\xEB\xB1\x58\xC4\x5C\x85\xB8\xD7\xA4\x8E",
"\xD4\xE6\xBA\xCD\x2F\xBB\xA2\xA8\x0E\x5C\x8D\xB8\x12\xAE\xE2\xB5\xE2\xB0\x5D\xAB\xB8\xA9\xB9\xA1\x70\xAE\xBA\xAA\xA6\xA6\x28\xFB\xB5\xD9\x8F\x71\xB2\xDD\x9F\x6F\x89\xB9\xE1\xB7\xCD\xAF\xC5\xD4\x65\xDC\xA0\x1A\x90\x9C\x6E\x8F\xD6\xE4\xBA\x92\xD4\xF1\xA9\x74\xBB\x41\x33\xB9\x82\x6F\xB9\xD6\xB5\xB6\xE6\xAC\xCF\xD0\x41\x1B\x73\xB6\xDF\x80\xAD\x9D\xD6\x2B\x0C\xD8\xB4\x6B\xA0\x65\xDB\x78\xB1\xDF\x8B\x6D\xD3\xB7\x52\xAD\xC8\xAE\x3B\x90\x62\xD1\xB5\xDA\xDE\x8C\x5C\xC0\xB7\x44\xAF\x9B\xD6\xAA\xB1\x7A\xB7\xBA\xB0\xDB\xA4\x56\x89\xA4\x5E\xAE\xA7\xD4\xF0\xB9\x66\xD4\xD7\x2D\xDE\xB4\x84\x87\xD5\x54\xD6\xD6\xAD\xD9\xD5\x7F\xBC\x27\x37\xB3\xA0\xAC\xEE\xA6\x22\xD7\xF6\xBE\xD0\xD6\x6B\xD7\x30\xBC\xDE\xB7\x5D\xA3\xB7\x47\xD7\xD2\xB6\xF8\xB4\xF3\xA4\xB7\xDF\x21\x26\x6F\xF7\xD6\xF3\xA7\xBC\xD6\x1B\xCB\x6F\xD0\xA5\xB9\x7F\x13\x86\xF6\x05\x71\xD7\x54\xAF\xF8\xB3\x7A\xB5\xBF\xA8\xDF\xA9\x73\xEC\xD6\x8C\xD6\x16\xB3\xD4\xA8\x9E\x09\x2B\x11\x5C\xE6\x6E\x93\xD7\x10\xB8\x95\x02\xAB\xAA\x6B\xDA\xB8\xC8\x04\xD9\xAE\xFD\xC1\x5F\xD6\x4D\x0A\xAD\xAD\x70\xD6\x2E\xB8\x59\xC2\xAE\xBA\xD6\xC5\xB7\x01\xB9\xD6\xA4\x10\xBB\xB1\xD8\x5C\xEE\x65\xB7\xBC\xB7\xAE\xBA\xB1\xED\xD4\x6B\xD1\x29\x0C\xAF\xAC\x93\xBF\xD6\x6B\xD6\xDE\xD6\x7E\x01\x4A\xDC\xBA\xDC\x9B\xB3\x84\xA8\xD4\xD4\x39\xBD\xA7\xCA\xD6\x5E\xA1\x25\xB5\x92\x94\x2C\x1C\x02\x5E\xCC\x95\xB0\x83\x17\x6E\x96\x8F\xAF\x1D\xD5\x5F\x56\x42\xD5\x45\xE5\xD5\x48\xA9\x7A\xDC\x3A\xC4\xDB\x97\x6B\x85\xB2\x5E\xC3\x7D\xB1\x29\xC7\x25\x15\x6E\xD3\x14\x6D\x67\xBB\xD6\xCC\xD7\x26\xC4\x63\x15\x80\xB5\xA2\x06\xAA\x81\x04\x00\x45\xC3\x26\x41\x45\x85\x03\xA9\xA8\x54\xBE\xDE\x98\xAC\xF4\xB2\xB2\x44\x83\xD7\x4F\xAA\x42\xB1\x76\xA0\xB8\xAC\x9F\x08\xB8\xE9\xAD\x8F\xD4\x08\xBC\x75\xBD\xB9\x00\x5F\xC2\x70\xC5\xAA\x0A\xB8\x93\xD5\xE1\xB1\x70\xD4\xB6\xC0\x5D\xF3\x6F\xFF\x01\x1A\xAC\xAD\xD6\x01\xDE\x84\xBF\x2C\x13\x59\xE4\x58\xA0\xAE\x0C\xD8\x00\xBB\x03\xBF\x81\xDE\xB3\xD2\x60\xCB\x6F\x81\x32\xA0\xB6\xD6\xA2\xCC\xA9\x77\x0E\xB9\xC3\x5C\xE8\xAF\xB2\xD7\x4C\xD6\xC4\xD5\x01\xDF\x83\xDC\x27\x3C\xB8\xB1\x6E\xF9\x9A\xF7\xD7\xD9\xBF\xEB\xD1\x69\xDA\xBF\xC6\xDE\xAA\x04\x59\xD6\x6A\xD7\xFF\xD7\x08\xBC\xF2\xAC\xB7\xD4\x99\xA0\xAD\xB6\xD6\x31\xD8\xBD\xAE\x03\xBB\x6E\xD3\xBD\xA9\x5B\xD6\xAE\x82\x02\x13\xD9\x16\xBB\xEB\xB5\x87\xDB\x0D\xCE\xDE\xA2\x06\x25\xD8\xB0\xD6\xED\xD7\xEB\xAC\x41\x15\xBD\xA7\x62\xC1\x04\x49\xD8\x66\xD6\xBA\xAD\xE4\xB6\x6F\xDA\x30\xA0\x5C\xE2\xAD\xB2\xD8\x0D\xD8\xC2\xD7\xF4\xB7\x7C\xBA\x40\xB8\x62\xC5\xAF\xCA\xA3\x5B\xD9\xF6\xB7\xB7\xD0\x8A\xD4\xC3\xD7\x5A\xE1\xAE\xFF\x01\x95\xD7\x32\xD8\x0B\xDB\xE3\xA9\xC0\xD6\x10\x58\x5E\x99\xD8\x43\xD8\x07\xDB\xED\xB0\x41\x13\xBA\xD9\x61\xE6\xB1\xA4\xAF\x4C\xD9\xEC\xB2\xEA\xD4\x81\xB8\xC7\xC9\x59\xD5\x58\xB5\xD8\x28\xD9\x5F\xAC\xED\xD5\xC7\xCE\x36\xBF\x63\xE4\x63\xFC\xAB\xB9\xD7\x0C\xB9\xA9\xB6\x91\xDF\xC5\xC1\x05\xFF\x03\x4F\xAD\x1E\xD8\x00\xD8\x9F\x24\x78\xD4\x73\xB9\xB6\x89\x5F\xAB\xB8\xCB\xAE\x44\xDB\xB5\xAC\x7B\xD0\xC9\xC2\x05\xC5\x70\xE5\xAD\x25\xB8\x25\xD9\xE2\xAC\x4A\xAC\xD5\xBE\xED\x57\x6B\x94\xB2\xE1\xD7\xF4\xD4\xDE\xCA\xB2\xB9\x96\x34\xEC\xA7\x9B\xE2\xD8\xF2\xAD\x2A\xA7\x49\xB4\xE3\xCE\xBE\xD4\xBF\x04\x63\x2B\xAA\x4A\xAA\xE4\xAF\x38\x32\x07\x30\x53\xB9\xBB\xA3\x54\xC2\xAA\xB6\xB7\xFD\xD5\xD3\xCD\x7F\xDE\x36\xB0\x65\xC7\xB0\x83\xAE\x73\xA4\x15\xD8\x5E\x0E\x99\xD4\xC1\xC9\x1A\x25\xAC\x8E\x0E\x27\xD7\x42\xD9\xD5\xD1\x80\xB5\xCD\xDB\x95\x8C\x28\x11\xD8\x39\xD8\x6A\xDA\x2A\xD9\x7F\xB1\xC8\xDD\xB8\x81\x4D\x18\xA5\xDA\xD8\xB9\xD6\x1E\xDB\x69\xDA\x12\x1D\x60\xE1\xB3\xF3\xD8\x42\x13\xC6\xD5\xFC\x0C\x68\xD9\x5A\x3E\x62\xC1\xB1\xB4\xB7\x2A\xD7\x64\xDA\x0D\xDF\x1F\x0D\xB4\xD6\x62\xC2\x5E\x3B\xD8\x63\xAE\xA9\xD7\xBB\x08\x88\xD2\xBE\xC3\x5B\xDA\xB0\xC4\xD8\x6F\xD8\x1C\xDA\x3F\xDA\x9C\xD9\xC5\xDC\x61\xF2\xB3\xA9\xD7\x8F\x17\xE0\xB5\x25\xD8\x9F\xD7\xC8\xCE\x63\xCF\xB0\xC6\xD8\x0A\xA8\x86\xDB\x19\xDD\x82\xD4\x7C\xA5\xBB\xB0\xAD\xE9\xD9\x92\xD6\x5C\xDB\x03\xDD\x8A\xD9\xD1\xD0\x67\xFE\x6E\xE9\xD8\x58\x09\xBF\xD4\xD6\x08\xA4\xDF\xB9\xC2\x69\xFB\xB1\xAA\x02\x64\xD9\xE4\xB2\x45\xAE\xA4\xD8\xC6\xC5\x67\xCF\xAE\x8E\x9C\x2C\xDA\x13\xD9\xEC\xD3\x8A\xDF\x78\xB2\x66\xD3\x64\xB4\xDA\x1C\xDB\x72\xDB\xFE\xB5\x73",
"\xD9\xD3\xD1\x62\xFA\xB3\x89\xD9\xFF\x01\x3E\xDB\x42\xD8\xA8\xD6\xCD\xD5\x63\xCE\x4D\x9B\xDA\x16\xAC\xD7\xD5\x18\xDF\x84\xDC\xD3\xCA\x64\xE0\x98\xDA\xD3\x1A\xDA\x9A\xAD\x88\xC0\x83\xB7\xA4\xA5\xD5\x99\xB5\x8F\xD9\x38\xA4\x50\xB8\xF0\xD7\x9F\xDC\xC1\xAC\x0A\x5C\xB2\xF9\xAE\x9E\xD8\x8B\xC8\x2E\x13\xA7\xDD\xC1\xAA\x5F\xDA\x50\xCC\xA4\x1D\xA8\x81\x03\x07\xAB\x00\xB6\x42\xA8\xA8\x81\x04\x75\xDA\x65\xDA\x12\xBB\xAC\xAE\x9A\xA3\x44\xDB\x4D\xEF\x50\x8C\xD9\x01\x03\x19\xAA\x1B\xBF\x9F\x02\xD8\xC0\x68\xDB\x85\x01\xAA\x43\xAB\x54\xB8\x26\xB3\x95\xBE\x42\xA2\x08\x0D\x63\xC2\xAD\x49\xA8\x68\xA9\x12\xA9\xAF\xD8\x22\x57\x9C\x8D\x51\xB0\x55\x0B\x41\xA1\xAB\x81\xCB\x91\xA3\x45\xA3\xC0\x9A\x51\xA5\x1D\x59\xA8\xA6\xD9\x48\x00\xB1\xD6\xBB\xAB\x06\xCF\x28\x64\xA8\x99\x4E\x33\xAB\x74\x8E\xE2\xC5\x61\xDE\x2F\xC0\xB6\x80\x00\x72\xA8\xBB\xD8\x6C\xDA\xB4\xDA\x5B\xA4\xA7\xA5\xB6\xCD\xB2\xAE\xDA\x36\xBB\x20\xAA\xB6\xDB\xDB\xD4\x6C\xE3\x85\x24\xDB\xCC\xAF\x4C\xA9\x35\xC4\x8D\xB3\x49\xB2\x6D\xC5\xB7\xBE\xDB\x87\xDA\xDB\xD9\x70\xD8\xB7\xD0\x7A\xBC\xA4\x84\xB0\xFF\x09\x07\x2A\xE4\xD8\x2D\x34\x2D\xBA\x24\x4F\x66\xD6\x70\xDE\xC2\xFC\x3A\xB6\xD8\x69\xAD\x44\x1E\x4A\xA3\xC0\xB0\x52\xD0\xA9\xC1\xB9\x58\xDA\x71\xAB\xAF\xD7\x4B\xB9\xC1\xB9\x52\xD7\xB8\x01\x03\xA8\xAA\xB0\xAA\x98\xA0\x4D\xA2\xA6\x92\xB7\x87\x2F\xA2\xB1\xB5\xAA\x96\xC2\xCD\x2B\x48\xAD\xA6\x83\x60\xCF\xA9\xE3\xAC\x5C\xB9\xA5\xBA\xA7\xA4\xDE\xDA\x6C\xDA\x83\x95\x03\x25\x15\x27\xB5\x37\xA9\x58\xAF\x4F\x0C\xFC\xA2\xB7\xC3\xAF\xFD\xDA\x3C\xAA\x3A\xC9\x20\x09\x4E\xA0\x83\x41\xC1\x16\xCE\x8A\xCD\x23\xCE\x3C\xA9\x60\x04\x4F\xBE\x56\xC8\x07\x3E\x03\x40\xB3\x7C\xAB\x6B\xDE\xD4\x90\x4D\xAA\x44\xD6\xB7\xFA\xDA\x50\xB4\xBE\xDA\x96\xD3\xC7\xC0\x56\xAF\x6D\xC7\x54\xD0\xA9\x1F\xB3\x03\xDE\x63\xAB\x21\xB1\x10\x03\xC4\x8D\xB4\xD6\xAB\x32\xAB\xD7\xDB\x45\xA8\x1D\xB3\xD3\xDA\x64\xFF\x10\x17\xA7\x91\x11\xF6\x2D\x37\xDC\x92\xB8\xBF\xD1\xBF\x14\xB5\xEB\xB7\x0F\x15\x94\xAB\x5C\x45\x35\x45\x13\x0D\xA9\x85\x8A\x31\x43\xC5\xD8\x56\xAD\x8C\xDC\x8D\xB5\x53\xA3\xB7\x94\xB2\x9C\xAA\xBA\xB6\x1D\xDF\x38\xDE\xDB\xAD\x5A\xA1\xAA\x8E\x4A\x47\xDA\x08\xD9\x05\x16\x90\xDF\x97\xD9\x54\xB7\x31\x34\xAF\xF3\x42\xF6\xD6\x74\xA7\x2E\xAF\xB5\xD7\x55\xB0\xA6\xA5\xAE\xD3\xDC\x01\x33\xF8\xD9\x28\x66\x74\xDB\x4C\xA2\x08\x21\x55\xC2\xAD\x64\xAB\x71\xAC\xEF\xB0\xCD\xDC\x27\x2A\x73\xC8\x53\xF4\xDC\x86\xD7\x12\x17\x5B\xAC\x8A\xA5\x4C\x12\xAB\xB4\xB6\xDF\xAF\x7F\xDD\x45\xAB\x5E\xAC\x8A\xAD\x57\xA3\xB7\x81\x5B\xD0\xDA\xA3\xDA\x19\xD0\xB7\xD0\xCF\xD8\x66\x05\x51\x08\x56\x83\xB0\x8A\xAB\x71\xAC\x63\xA8\x6A\xA7\x86\xAB\x74\x82\x43\x5D\xAA\x95\xAB\x7F\x08\x70\xA9\xB3\xAF\x79\xDB\xAE\xAF\xB7\xC2\x2F\xBB\xAB\x6C\x11\x6F\xAC\xD1\xDD\x6E\x11\x44\x27\x56\x9D\xDD\xCF\xAA\xC3\xDB\x74\xDC\x30\xB0\x4A\x47\x4F\xE4\xBA\xC9\x0F\x91\x10\xDA\xA8\xAA\xDD\x9E\x0C\x93\xBC\x6F\xE0\x56\xA2\xDD\x86\xB3\x57\xDF\xDD\x01\x12\x12\x5C\xB3\x75\xD8\x04\x35\xDD\xDD\xAB\x2A\xDC\x72\xAB\xD4\xDF\xE2\xDB\x0A\x40\x57\xCD\xAB\xBE\xDD\xCE\xAA\x8D\xDC\x88\x05\xB0\xD6\x68\xE8\x4C\x91\x11\xD8\xAA\xB4\xB2\xB2\xDA\xD5\xD7\x78\x2C\xCB\xA3\x65\xBA\xDD\x51\xDA\x52\xD9\x58\xDD\x95\xD8\x25\xBF\x3C\xF8\x15\x29\xDC\x1F\xDC\x88\xAF\x33\xD2\x3D\xB5\xB1\xC7\x5F\xDA\xB7\xEA\x42\xA5\xD9\x03\xBE\xE4\xA9\x3C\xDE\x91\xBF\x73\xC6\x78\xFE\xB6\xFE\xD8\x70\xDF\x8E\xDD\x88\xBD\x27\xA3\x4F\x19\xB3\x93\xDA\xC3\xB7\x8A\xD9\xB8\xDE\xBA\xAD\xB2\xC3\x6B\xF2\xBB\xD8\xDD\x96\xAE\x9B\xD8\xCC\x17\x9C\xD5\x62\xA5\x6A\xED\xB1\xFB\xDD\xC6\xDD\xCD\xB6\xD6\xD7\xDF\xD5\xEC\xD9\xDE\x8F\xB4\xB0\xAE\x22\xD8\xD1\xB7\x4A\xD8\xDF\xD8\xB4\xD9\x67\xCA\xAD\xFB\xD9\xFD\xD8\x05\xA8\xC3\xD8\xD1\xD2\xC8\xCF\x78\xC2\x5D\xD3\xD6\x06\xDE\x8B\xDE\x28\xDF\xE4\xA8\xBB\xAE\x59\xC4\xB0\xDF\xDD\x7F\xDD\x6B\xDA\xB7\xA4\xA0\xD2\xCB\xD2\x6A\xC7\xB4\xEB\xD9\xFB\xD8\x8C\xDA\x4C\xDD\x58\x4B\xEC\xC7\x69\xE5\xB3\x9E\xDA\xCF\xB7\x90\xDE\xBE\xDB\xDE\xD6\xB7\xC3\x60\xC9\x6F\xA8\xDE\x35\xDF\x9A\xDA\xC7\xDE\xCF\xAC\xC5\xD4\xFF\x61\xB9\xAD\xDE\x06\xDB\x3C\xDA\x4B\xDC\x9D\xDF\x0F\x11\x69\xCD\x6E\xED\xDD\x41\xDF\xA0\xDB\xD0\xD9\xD2\xA6\xE1\xD3\xB4\xBA\xBC\x8C\xAF\x23\xDF\xB3\xD4\x83\x11\x8E\xD3\xF3\xDB\x78\xC0\xB2\xD3\xDE\x46\x14\x9B\xA4\xC7\xD8\xFC\xB3\xD5\xC7\x77",
"\xE9\x6E\x8C\x14\x4A\xDA\x8D\xDD\xCA\xDE\xA9\xD8\x7A\xA3\x7B\xEB\x5E\xA1\xDA\x3F\xDC\xAD\xDD\x04\xBB\x91\xDC\xC6\xA0\x7A\xD4\xBB\xD4\xDC\xC5\xC5\x48\xD9\x57\xDF\xB5\xD6\xF7\xDF\x74\xFE\x6F\x9E\xB8\xEA\xB4\x7F\xDF\x9F\xDF\xAC\xD5\xC9\xC9\x6B\xE9\xA8\xCA\xD7\x58\xDD\xB6\xDB\xB6\xDE\x96\xB1\x10\x11\x6E\xDA\xBB\x9A\xBB\x61\xCD\x0B\xCB\x4B\xB3\x87\xCF\x74\x57\x3A\xC4\x7D\xAB\xC4\x69\xD4\x81\xD1\x39\xC1\x32\xDA\x78\xD3\x4C\xCF\x08\x95\xD3\x22\x98\x39\xD6\xAB\x04\x0F\xD7\x97\xD4\x4A\xFA\xAB\xFA\xD2\xD1\xD4\x52\xD0\x3B\xD7\x5F\xD5\x91\xDB\x3C\xE2\x79\x98\xB0\x9E\xCE\x33\xBD\x55\xBE\x0A\x12\x9C\xAF\x34\xEA\x80\x8C\x14\x91\xCC\xC9\xDF\xA3\x12\xBE\xA0\x56\x56\x7C\xE7\x7F\x98\xDF\xEC\xD4\xCD\xDF\xD2\xBF\x5D\xDD\xA6\xD1\x57\xC0\xA9\xC8\xD5\x42\xD4\x65\xD7\x85\xD2\x26\xD6\xA4\xD9\x57\xC8\xA9\xFB\xD5\xA6\xD5\xCF\xD1\xDA\x72\x2B\xDB\xB2\x6E\x7D\xD4\x74\xB0\xDF\xC7\xC9\x5C\xCC\x70\xB3\xD7\xC7\x9D\xBF\x10\xDA\x67\xA9\xA4\xAD\xD8\xAF\xBB\x46\xD3\x7E\xAA\x14\x43\x2E\xF2\xB6\x3E\xDF\x5B\xC0\xD5\xC9\xE6\xDC\x2D\xDB\xA6\xC4\x7E\xDD\xBE\xEE\xD4\xEB\xCE\x38\xD5\x1E\xD2\xF9\xD4\xA4\xC1\x55\xCF\xFD\x23\xD5\xD6\x7D\x52\xD6\xD8\x72\xFA\xD8\xBC\x74\x7E\xDD\x0B\x80\xD3\xDD\xA0\x72\xCC\xDB\xB6\xDC\xCE\xB6\xA6\xD2\xAA\x9B\xEA\xD7\xEC\xCD\xA7\xCC\xF9\xDC\xF7\xDB\xC5\x48\x7F\xDF\x83\xC0\xDF\xD4\xC9\x4B\xD7\x83\xD4\x58\xD0\xAF\xC6\x56\xC7\xBF\xF3\xD5\x9E\xD5\x7A\xD4\x66\xD4\xF9\xD9\xA1\xC7\x52\xDB\xA8\xC7\xD1\x7B\xD3\x7E\xD4\x93\xD4\x5A\xDA\xAA\xD6\x56\xEB\x8E\xCB\xBB\x0D\xB6\x3A\xC5\xDD\x03\xE2\xC5\x68\x57\x13\xEC\xB6\x8B\xB6\x7B\xC4\xEA\x4C\x10\xC8\xF9\x24\xF9\xD6\x3D\x4E\xC0\xAA\xC4\xEA\xDF\xE0\xDC\xFB\xDE\x5D\xD8\x7E\xD5\x43\xF0\xBF\xF7\xD0\xF2\xDE\x71\xD0\xFD\xDB\x4E\xDC\x01\xF5\x53\xF8\xBF\x8E\x7E\xFA\xDF\xA6\x78\xFF\xDF\xB3\x7E\xFF\xD3\xC8\x40\xC0\x92\xB4\xA1\xC5\x19\xE1\xF9\xDD\xFF\xC9\xD0\x57\x81\xF9\x8B\xBC\xBF\x0C\xD5\x6D\xD0\x9D\xCC\xF3\xD9\x7E\xDF\x81\xE0\xA3\xC1\xE0\x2F\xD2\xD1\xDF\x3E\xBD\x48\xDD\x01\xEE\x7E\xDF\xC0\xC9\xE0\xBA\x7B\x25\xE0\xD8\x75\x09\xEB\xBF\x60\x4C\xED\x66\xED\xC9\xF6\xCA\x78\xC9\x3C\x67\x8C\xAA\x24\xC7\x80\xF9\xBD\xF5\xCE\xC7\xC5\x32\xD3\x14\xE2\xF9\xC5\x05\xE3\x49\xD8\x9D\x85\xC5\x59\xE1\x7C\xCF\x1C\xD4\x0B\xEE\x03\xE6\x7E\xEF\xA9\xC8\xDF\x71\xD5\x21\xE3\xE8\xDC\x0C\xE6\x04\xFE\x80\xE4\xAA\xF8\xD4\xFB\xDF\x25\xD4\x68\xD7\x0B\xDD\xFA\xC3\x7F\xE1\x79\xD7\xDF\xED\xAF\xEC\xDF\xE7\xCC\x5D\xC8\x7A\x02\x3D\xF7\xBE\x88\x14\xA4\xCE\x2F\xD7\xE4\xDE\xFC\xD5\xF9\xDE\x83\xD7\xBE\xB9\xE0\x11\xE1\x76\xD7\x40\xD4\x10\xE5\x90\xDE\x82\xC7\xA4\xA0\xDF\x45\x84\x31\xE3\x5D\x04\xF4\xDD\xAC\xD8\x4B\xCF\xAB\xA8\xDF\xFC\xD4\xD5\xDF\xB4\xD4\xF5\xD5\xAD\xDA\x3F\xEB\x8E\xFC\xCF\x7C\xE1\xA5\xC7\xFF\xCD\xEB\x3E\x7C\xD9\x26\x36\xA0\x9E\xC6\x38\xD0\xCB\x5E\x0E\xD0\xE2\xBC\xA0\x05\x19\xF6\xAA\xBB\xDF\x70\xCA\x1B\xE2\x29\xE7\xF7\xD8\x0A\xE3\x2C\xD2\xC0\xBA\xD4\x10\xD5\x0A\xE0\x4B\xD1\xFE\xD8\x08\xF3\x7F\xDA\xC0\xA0\xD5\x45\xE0\x51\xD6\x23\xE1\xFF\xD0\x09\xEA\x82\xD2\xC2\xD3\xDF\xA9\xD5\x95\x74\x60\xD0\x18\xE2\x8F\xC5\xF8\x8A\xBA\x81\xDE\x23\x75\xBD\x0B\x31\xE2\x37\xD9\x0C\xEC\x2F\x4B\xC3\xD9\xBD\x0A\xD0\xEB\xCE\xB8\xD0\x1A\xE5\x03\xE1\x66\x56\xC1\xD9\xD1\xB1\xCF\x98\xCE\x83\xD0\x1B\xE4\x01\xE5\x7E\xD6\xC0\x87\xE1\x18\xE1\x64\xD7\x37\xE3\x59\xD2\x70\xD5\x85\xE6\xBE\xCF\xDF\xB8\xE1\xE8\xDF\x39\xE5\xFF\xD9\x0E\xFF\x7F\xFE\xA9\x99\xCB\xD1\xE1\x60\x58\xC6\xC2\x48\x64\x83\xD6\xBA\x73\xC3\x82\xD4\xD2\xCE\x8B\xCC\xF5\xC9\xE2\xBA\x38\xC2\x15\xE3\xC2\xD4\xE0\x4A\x61\x7F\xE3\xC8\x09\x10\xE5\x78\xC3\x84\xEC\xA9\xEF\xDF\x86\xE0\x6E\xE1\x42\xE1\xF9\xDB\x10\xEB\x7E\xF7\xAB\xCD\xDF\xB6\xE1\xD3\xDE\x28\xD2\xF8\xCA\x0B\xFE\x57\xFC\xA9\xEA\xE1\x17\xE2\xE5\xBB\x18\xD2\xA0\x2C\x8A\xDC\x87\xE4\xC2\xD2\xE1\x67\xD3\x24\xD1\x5A\xD0\x58\xD4\x7E\xC3\x88\xED\xA5\x85\xE2\x30\xE3\x83\xE2\x4C\xE7\x17\xD3\x97\xDD\x2E\xF5\xA5\x8D\xE2\xF8\xD5\x9C\xE0\x44\xE3\x27\xE8\x8C\xDD\x89\xE3\xC0\xBC\xE1\x25\xE0\x5F\xE3\x31\xC8\x11\xD7\xA9\xA4\x23\xF8\x15\x7B\xE0\xED\xE1\x94\xE3\x34\xE1\xFD\xD5\x92\xC1\x48\xFB\xC0\xAB\xE1\x2F\xE3\x2E\xE1\x4C\xE0\x08\xED\x0D\xE2\x82\xF5\xC4\xF5\xDF\xE1\xE1\xFB\xDF\x38\xE0\x09\xE5\x0E\xE9\x83\xD3\xC4\xCC\xE0\x15\xE2\x27\xE1\x50\xE0\x14\xCA\x8A\xC2\x08\x06\xB8\x87\x14",
"\xF7\xC6\xA3\xE0\x4A\xE7\xFC\xDB\x16\xEF\x80\xD5\xC3\x9E\xCD\xAA\xE1\xCD\xDD\x5C\xE5\x10\xE2\x15\xF4\x8B\xF3\xC4\x89\xE1\x77\xE2\x22\xE3\x4D\xE5\x0C\xEA\x15\xE7\x83\xFD\xC5\xD6\x7F\x6A\xE0\x87\x70\x1B\xE1\xF0\x5D\x8C\xC3\x4C\xE8\xC5\xD9\xD5\x2C\x36\x95\xE2\xBE\xC4\x29\xEB\x96\xCF\x4C\xFC\xC0\xBD\xD1\x50\xC8\xAA\xE0\xBD\xD6\x2A\xE6\xAF\xD8\x8A\xF8\xC4\x8F\xE2\x9E\xE2\xE8\xDD\x24\xE2\x04\xE3\x09\xE3\x8D\xFD\xE2\x6B\xE1\x2F\xD0\xD4\xE1\xCC\x35\x4A\xAE\x43\xC6\x8B\xE7\xC4\xC1\xE1\x8C\xE3\xA4\xE3\xBA\xD1\x15\xE2\xFC\xCF\x23\xCF\xA5\xB1\xE3\x51\xD2\xE1\xC7\x54\xD5\x24\xCC\x15\xE1\x81\xDE\xC5\xBD\xE3\x81\xE3\x36\xE3\x60\xE7\x10\xD2\x46\xC6\x00\xC6\xC7\x8A\xE3\xC8\xE3\x52\xE2\x72\xE5\x52\xDC\x1C\xEF\x8B\xD2\xC6\xEE\xDF\x72\xE3\xCA\xE3\x17\xE5\x2E\xE1\x06\xEA\x84\xE3\xC1\xF6\xDF\xB0\x7F\x23\xE2\xD1\x78\x0D\xE0\x1A\xFF\x8B\xEB\xC1\xD9\xE3\x81\x5E\x37\xE2\x4F\xD1\x20\x04\x48\xC7\xB5\xA7\xC5\x8C\xE0\xE7\x4E\xD5\xE0\x16\xE4\x35\xEE\x98\xCE\x8A\xED\xBF\xBD\xE0\xAD\xE1\xB9\xE3\x7A\xE7\x32\xEE\x0D\xF4\x8D\xDB\xC0\x9B\xE3\x8D\xE0\x33\xE3\x23\xE2\x37\xE6\x0E\xFC\x8D\xE8\xC3\xA4\xE0\x40\xE3\x80\xD4\xBA\xB6\xC0\xBF\x95\xC6\x89\xE0\xC7\xE9\xE2\xC9\xE3\x74\xD4\x12\xD3\x39\xE6\x0D\xF1\x8C\xC3\xBF\x88\xE4\x2C\x84\xCF\xDE\x96\x80\x21\xD4\x13\xEE\x90\xE0\xC3\x90\xE4\xE2\xE0\x09\xE4\x39\xE4\x42\xEE\x17\xF6\x90\xD4\xC4\x98\xE4\x16\xE2\x0D\xE7\x1D\xC1\x41\xA9\x4C\xDA\x03\xFE\xC7\xC7\xE3\x20\xE4\xF1\xE2\x88\xE4\x12\xD8\xA3\xC6\x49\xF1\xA1\xC2\xD5\x4D\xD3\x6C\xE2\x41\xE3\x1B\xE6\x19\xF2\x8D\xD9\xC0\xAE\xE4\x0C\xE2\x4F\xD3\x6D\xE4\x3A\xE1\x0C\xDE\x50\xDF\xC5\xBF\xE2\x39\xE4\x13\xE2\xAF\xCC\x95\xD0\xA0\xC2\x36\xDF\xC8\xC2\xE3\x88\x36\x01\xE4\x38\xC3\xFD\xDE\x1A\xF0\x8B\xE8\xC7\x94\xE3\x4C\xE5\x05\xE6\x93\xE2\x21\xE0\x25\xF6\x89\xF6\xC6\x9C\xE3\xB8\xE3\x09\xE5\x44\xE3\x37\xE7\x1D\xF7\x90\xE0\xC5\x99\xE4\x5A\xE5\x7B\xA8\xE1\xDB\x07\x74\x51\xD9\xD7\x8F\x83\x98\xCA\xD8\xDE\x16\xD4\x83\x15\xA3\xCD\x6E\xD4\x81\xC7\xC5\xFE\xE1\x8D\xE2\x1C\xE1\x5B\xE4\x4C\xE6\x20\xEF\x8D\xCF\xC7\xDA\xC9\xD1\xE3\x16\xCB\x74\xE6\x78\xC5\x25\xE1\x0F\xC7\x7B\xBA\xE4\x44\xB7\x3D\xE6\x69\xDB\x41\x15\xA5\xCD\xEE\x86\x95\x85\xC2\x59\xD4\x41\xE4\x82\x14\xA9\xC5\x28\xE7\x8D\xE5\xA8\xC2\xE4\x93\xD5\x5A\xD0\x79\xE5\x44\xED\x1C\xF4\x19\xF0\xC6\x90\xE5\xEC\xC1\x4E\xD3\xA4\xE1\x86\xC5\x29\xE4\x1A\xD7\xCA\xF9\xE4\xC8\xCE\x40\xD7\xA9\xE3\xB3\xCF\x0E\xEB\xDA\x86\xAA\x85\x63\x6D\xA1\x44\xD4\x83\x13\x51\xD5\x2A\xE0\x90\xFD\xC1\xE3\xE3\x45\xE4\xB7\xE1\x99\xE7\x3C\xE8\x22\xF0\xE7\xAE\xC2\x94\xD3\x60\xE0\xCB\xD1\x66\xE3\x11\xE0\x1F\xE8\x02\xB2\xC7\xD6\x7E\x20\xE1\xD4\xDE\x95\xE0\x3B\xE8\x23\xE2\x8C\xD8\xCA\xDA\xCA\xBA\xE4\x29\xD6\xAB\xD5\x57\xE7\xEB\xC3\x68\xE4\x85\xA0\xCB\xB4\xD5\xB3\xC1\xB1\xE1\x23\xE2\xCF\x42\x93\xD0\xC0\xAC\xE5\xE6\xE3\x13\xE7\xAB\xE1\xB6\xC1\x29\xFC\x33\xF3\xCA\x80\xCD\xB5\xE5\x3E\xCB\xAD\xE2\x2C\xE1\x5C\xC1\x8E\xFB\xCA\xE3\xE5\xC3\xE1\xB9\xCB\x4D\xDE\x37\x05\x19\xD8\xD7\xAB\xCB\xFD\xE1\xED\xE5\x44\xE7\x15\xE3\x4C\xEA\x03\xEB\x96\xF2\xCB\x8F\xE5\xF4\xE5\x58\xE6\x54\xD0\x47\xC4\x25\xFC\x11\xD6\xCA\xCE\xC0\xFC\xE5\x5C\xE7\xC0\xD2\xFD\x4D\xEC\xC9\xB8\xB1\x97\x8A\xD6\xE6\xB1\x04\xA7\xDD\x91\x40\xD2\x6C\xAE\xF3\xB3\xC1\xAB\xDB\xA1\xE5\x85\xB4\x0C\xBF\xD8\xAA\xAA\xA5\xD5\xB4\x98\xE1\xE3\x53\xD5\x72\xB1\x95\xA6\x12\x5F\xE1\x0F\x7C\xE1\xCC\xBB\xB9\x01\x02\x8F\x3E\xCD\xE7\x0E\xEF\x0F\x16\x44\x62\x39\x0A\xB2\x6A\xB7\xA1\x0E\x15\xBC\xC2\xCA\x32\xFB\x99\xE2\x88\xD4\x1E\x40\xE6\xA7\xB8\x43\xB7\x17\x64\x34\xE2\xA3\xBB\xCC\xFF\xD3\x08\x15\x49\x9A\x1F\x04\x97\xDB\x09\xF7\x0B\x38\x15\x67\x0D\x06\x8B\x11\xDD\xFD\x32\x62\xD4\x3C\x89\x99\xCE\xCD\xCF\xE6\x96\xD9\x1C\xBC\x20\x02\x6C\xB8\xA0\x1C\xE6\xBF\x01\x1C\xCE\x63\xA9\x69\x12\x00\x67\xC1\xDE\x35\xF6\xF4\xB6\x52\xC6\x08\x25\x15\x73\x0E\x1D\xE0\x6C\xEA\xD9\xA5\x33\xC7\xB7\xAF\xDB\x60\xBC\x08\x62\x5C\x61\xDD\xC5\x34\xF4\x9B\xC8\x28\x35\x14\x8C\xA1\xDE\xDB\xE7\xCB\xA8\xCF\xE9\x55\x81\x6F\xC0\xB4\x9C\x4B\xA7\x0A\x37\x3F\x0C\xDB\x5A\xC5\x5A\xA3\x8C\x42\x83\x01\x7E\xE6\xDC\xD6\x4A\x07\xAA\xA1\xDB\xD5\xAD\x84\xCE\xA8\x4B\x65\x71\xC3\xE6\xDB\xE2\xC2\xDD\x84\x4B\x6C\xB5\x04\x0A\x0A\x44\x4A\x7E\x5E\xD6\xE6\x44\x31\x39\xEE\xC0\xB2\x64\x81\x02\x85\x00\x26\xA5",
"\x7F\xCA\x20\x01\xDE\x34\xA2\x8B\x76\xD0\xA9\x58\xE5\xAB\x49\x8B\xCE\x8B\xCB\x48\xA8\x04\x2F\xB6\xC0\x01\xFD\xA9\x80\x00\xEE\xE0\x69\xCC\x96\xBF\x27\xAC\x95\x8B\xA9\x86\x01\xD7\xD8\xD7\x58\x9A\xA7\x77\xC8\x3A\xE1\xBA\x8C\xCD\x2B\x51\x67\x18\x69\xD5\x44\x11\x3C\xEC\xE3\x9B\x53\xD0\xA9\xE3\xB5\x63\xCA\x65\xDF\x34\xB1\x0D\xCB\x70\xCF\xBE\xA7\xE7\x00\x01\x44\x00\xDD\xCB\x91\xAA\x08\x0F\x6D\xC6\x6D\xD0\xA9\xE1\xE5\x2E\xB5\xB6\xBB\x76\xE0\x26\xF5\xE5\x11\xCE\xD8\xE7\x8B\x01\x74\xB0\x3C\xCB\x3E\x6A\x83\xDA\xD9\xB5\x64\x81\x02\xDD\xE6\x36\xBA\xD1\xB3\x76\xEF\x1A\xB2\x55\xD1\xC0\x57\xBD\x19\xB9\xF9\x63\x3F\x09\x7C\xE3\x16\xCD\x8D\x8A\x05\x64\xE7\xFF\xE4\xA1\xCA\xDF\xE0\x7B\xE8\x42\x49\x9A\xE7\xA9\xF5\xA0\xEC\xA9\x7E\xA1\xA1\xD6\x89\xDF\xD9\x97\x09\xEF\xCF\x80\x00\xF1\xE6\xB8\xAB\xFC\xE7\xFA\xCC\x40\xF2\x74\x56\x9C\xBF\xE5\xFC\x63\x91\x27\x10\x23\x7F\xE7\x3F\xB8\xA0\xCD\xD0\xC3\x20\x00\xE8\x71\xE6\x00\xEC\x6E\xE8\x3D\xED\x04\x2A\xCF\xC1\xE6\x60\xB6\x40\xA1\x54\xBB\x60\xE6\xE0\xA5\x51\x11\xD0\xD4\xA8\x13\xE9\xCB\xC0\x92\x49\xBA\xBC\x42\xFC\xA0\xCE\x48\xAC\xE8\x21\xE9\xD1\xE4\xCB\x37\x7C\xE1\xC3\xA0\x00\x24\x83\x06\xE8\x02\x02\xE2\xA0\x70\xA6\x00\xE7\x08\xA5\x8E\x88\x97\x8C\x14\x2E\xE8\xEF\xE6\x8A\x13\x76\xE2\x44\xFC\x90\x4D\xCD\x87\xD6\x46\xE9\xE9\x9A\x0D\xEA\x9C\xAF\x31\xE7\xBC\xB9\xD0\xF3\xE6\x3C\xE9\xD8\xB1\x1E\xE2\x01\xED\xB9\x11\x82\xCB\xC6\xA8\xE5\xBE\xD4\xC1\xCC\x5C\xC1\x20\xE9\x81\xCD\x94\xE6\xC9\xCD\xE5\x5A\x87\xC5\xCF\x54\xE5\x5E\xE6\x6D\xD7\x97\xDA\x9B\xF9\xE5\x3B\xCA\x0A\xC7\x22\xD1\xD7\x9C\x79\xD7\x35\xDA\xC2\xB2\xDF\xC8\xE6\xD9\x94\xCF\x5E\xFB\xDA\xA1\xB5\x92\xB9\xBE\x96\xE1\xA1\x1C\x63\xE6\x5A\xE0\x59\xEB\xA0\xC4\x90\xCD\xA8\xAE\xE2\x67\xE5\x04\xE6\x7A\xE7\x15\xE1\x2D\xE1\x7D\xEE\xC7\xB3\xE1\x8C\xE1\x18\xE5\x67\xE2\x4E\xE5\x1D\xFA\x96\xD7\xCC\x81\xC0\xD6\xDE\xA8\xB9\xE7\xCF\x8E\xE7\xA0\x0B\x0F\xDC\xBF\xD8\xBA\xF0\xE1\x73\xA8\xF8\xDC\x61\xDD\xE6\x05\x43\xDE\xD1\xB0\xE6\x88\xE4\x42\xEB\xAF\xD6\x48\xEA\xA3\xC8\x92\xD8\xAA\x84\xD2\x29\xE5\x67\xE7\xE7\xDD\x91\xE1\x0B\xEF\xA4\xCB\x05\x91\xE9\x7A\xE2\x19\xE4\x5F\xE4\x46\xE5\x1F\xF6\x91\xC0\xC6\xDD\xE5\xDA\xE3\x6F\xE6\xC3\xCA\xAE\xD4\xCB\xD6\xB7\xAC\x67\x93\x73\x9A\xE7\x4D\xE6\x81\xB9\x01\xEA\xFB\xCE\x3A\xC7\xCA\x89\xE6\xAA\xE8\x31\xEB\xB3\xC4\x8C\xE9\x8B\xC6\xA3\xCC\xCB\xF3\xE5\x71\xD3\x35\xE5\x8B\xE1\x18\xDF\x20\xEF\x93\xD1\xC8\x93\xE9\x33\xE5\x39\xE5\x85\xE5\x4E\xE7\x23\xF7\x93\xD9\xC9\x99\xE6\xA9\xD0\xFE\xB1\x0A\xE1\xE2\xCB\x35\x18\xE7\x02\x68\xC9\xE9\x5B\x58\x03\xBE\xEF\x95\x28\xEE\x4C\xFF\xA2\xC8\xC5\xC3\xE4\xD8\xD1\x95\xE2\x21\xEA\x0B\xEE\x84\xD0\xA5\xCE\xCB\x8A\xE4\x8C\xE8\xF6\xE2\xB4\xE5\x4D\xE8\x17\xF0\x91\xF9\xD2\xE0\xE9\xBB\xE8\x71\xE9\x8D\xE4\x9C\xEF\x4B\xE6\xA7\xDE\xCB\xB8\xE5\xD2\xB4\x28\xE3\x77\xE5\x9E\xE8\x4A\xF0\xA6\xF8\xD3\xE8\xD2\xD2\xC8\x56\xE9\xB0\xD7\x1A\xEF\x14\xFE\xA7\xE9\xD1\xAA\xE4\x62\x86\x16\xE4\x66\xE4\xA0\xEA\x19\xFE\xA6\xD2\xD2\xF1\xE4\xE1\xE9\x4A\xE9\x2E\xE3\x5B\xE6\x27\xF1\x9D\xC1\xD3\x90\xEA\x71\xC5\xED\xE6\xDD\xCB\x30\xD7\x4A\xE1\x92\xF7\xD3\xA9\xE5\xFF\xD1\x55\xE4\x64\xE5\x55\xEC\x6F\xD9\x1C\xFE\x9B\x92\xE6\xD2\xE2\x8A\xE4\xA5\xE6\x62\xE6\x2B\xE6\x17\xD6\xC2\xE8\xC5\xD1\xBB\x08\xDD\x27\xEC\x3A\xB1\x7A\xCB\x08\x23\x9E\x8B\xD0\xF0\xC9\x40\xE8\xBB\xE2\xFD\x4E\x2E\xEF\x8C\xCD\xA5\xAE\xE9\x13\xE0\x8F\xEB\xB0\x80\xA4\xEC\xDE\xA2\xA9\xCD\xC8\xDC\xE9\x2F\xE4\x93\xEB\x41\xE8\xA5\xE9\x50\xEA\xA9\xD2\xC4\xBE\xE9\xF7\xE2\x60\xE9\x7E\xE3\x3B\xEF\x56\xC8\x98\xEA\x9F\x1B\xE2\xCD\xCE\xD4\x0F\xC6\xC3\x00\xD9\xA7\xB1\x3E\xD9\x7B\xF7\xE1\x61\xB5\xEA\xCC\x93\xB6\xCD\xB2\x55\xEE\xAB\xF2\x99\x55\xEA\x8B\xE5\x86\xE6\x35\xEF\x61\xEE\x53\xFB\x44\xC0\xD5\x92\xE5\x42\xEA\x5A\xE4\x51\xEA\x5F\xE8\x31\xFB\x07\xEC\xC3\xE5\xE7\xEE\xC2\x72\xE4\xB4\xBF\x69\xC4\x57\xFC\xF4\xB6\xD5\x8D\xBE\x22\xE3\xCA\xE9\xA8\xB9\x41\xAB\xED\xBB\x87\xD4\xD4\xB6\xEA\xA9\xE9\x8B\xEA\x52\xE1\xA3\xEA\x2C\xE3\xAC\xCE\xC7\x85\xEB\x50\xD3\xC3\xEA\xBD\xE1\xB1\xE8\x2F\xEB\xAC\xF1\xD1\x8D\xEB\x48\xC7\xC7\xE9\x00\xEF\xAD\xE4\x2E\xFD\x88\xF3\x0F\x1F\xE2\x7D\xDB\x7A\xE3\xAF\x08\xAF\xE9\xA4\xA4\x89\xFE\xA0\x9E\xE4\x9F\xEA\xC8\xE8\xCE\x28\xB0\xE0\x08\xFB\xA7\xC2\xC2\xBC\xD4\x89\xE9\x58\xE8\x40\xE8\x5A\xE2",
"\x50\xEE\xA4\xD3\xCB\xEF\xE3\x79\xE3\xF8\xE3\x5E\xE3\x3E\xEF\x19\xE3\xEA\x61\xC6\x8C\x72\xBE\xE3\xC6\xB8\x5B\xEC\x75\xCE\x3A\xC0\xAE\xF5\xD4\xC2\xEB\x1B\x04\xE2\xEB\xD7\xC4\x25\xE2\x7B\xC6\xAD\xEE\xCA\x90\xE6\xD9\xE8\x36\xE9\x6D\xCA\x4A\xE0\x27\xF5\x98\xE5\x8E\x97\xE9\x0C\xCA\x74\xE9\x4F\xD4\x41\x10\x3D\xD3\xA8\xDF\xD7\xB3\xEB\x7F\xEA\x85\xE4\x40\xE4\xBC\xE2\x10\xE8\xA4\xE8\xD1\xDB\xEA\xB2\xE9\x15\xE4\x2C\xE3\x3E\x80\x93\xCE\x93\xEC\xD7\xDF\xE9\x64\xEA\xEA\xE8\x2F\xEE\xBA\xE6\x1F\xE2\x8D\xF8\xC7\xBF\xE3\xDB\xEA\xF5\xD7\x2A\xD5\x41\xA9\x18\xE1\xAE\xF8\xD7\xF5\x37\xE2\xEA\xED\xC4\x7F\xED\x8C\xEE\x5F\xF8\xA6\xDC\xAA\x8C\xE4\x76\xE2\x92\xE8\xB5\xE1\xBA\xE6\x2D\xF3\xAE\xD8\xCB\xF4\xE3\x0C\xEC\xB4\xEA\x83\xEA\xAD\xED\x8B\x65\x8D\xE6\xD2\x82\xE9\x21\xE4\x9C\xEB\x99\xD2\xA7\xE7\x55\xFC\xA8\xC7\xC8\x9E\xEC\xF2\xD4\x6D\xEB\x48\xE8\xAC\xE1\x25\xEE\xA3\xE1\xA2\xF0\xE8\xB0\xCD\x7D\xE6\x63\xEE\x5F\xE2\x42\xFB\x52\xDD\x7F\x81\x02\x3F\xC8\x54\xCB\x7D\xED\xC8\xE9\x5F\xF1\xA6\xE1\x9F\xCA\xD0\x1A\xEB\xA6\xE1\x87\xE8\xBD\xEF\x61\xFA\xB1\xDF\xD5\xB2\xE5\xAC\xEB\x37\xEA\x6B\xE9\xC8\xE0\x5B\xE1\x24\xDD\xC7\x99\xD2\xF6\xEA\x18\xEC\x18\xEF\x46\xD5\x48\xF1\xB2\xED\xC6\xE6\xEB\x3D\xEA\x51\xCF\x4F\xEB\x8E\xC8\x65\xF9\x15\xC9\xD8\xA7\xEC\xD5\xEA\x6E\x7F\x75\xEC\xD6\x39\x5D\xF5\x1C\xF2\xD7\xA8\xB5\x0C\x14\x16\xC0\x3D\xEB\xC9\xEA\x43\xF1\xD9\x19\xD8\x9F\xC8\xC6\xEB\x96\xE0\x72\xEF\xBF\xE9\x17\xC1\xB0\xE1\xD4\x83\xEC\x29\x58\x59\xE3\x2D\xED\x5A\xEC\xDB\xA8\xA8\xCA\xD8\x8A\xEA\xBD\xE8\x86\xE9\x5A\xEE\xA1\xEF\x52\xF7\xB3\xE4\x92\xDE\xD2\xA6\xC9\x30\xEF\x54\xED\xC9\xE2\x5A\xE4\x91\xFB\xD4\xF1\xE5\xA7\xEA\x35\xEE\x61\xEC\xCD\xE3\x31\xEE\xB3\xEE\xD7\x9E\xC9\xF0\xEB\x85\xCF\x3E\xC0\x0F\xC0\xAE\xBA\xB4\xFE\xD5\x98\xEC\xFA\xEA\x7D\xEA\x99\xED\x40\xE3\x65\xE8\xAD\xD0\xC7\xAA\xEB\x6D\xE9\x2C\xEF\x8F\xEB\xCB\xE3\x88\xC2\xB2\xC8\x8D\x96\xD9\xA3\xC0\x2F\xE6\x85\xEC\xC9\xE0\x6B\xEE\xB2\xD5\xA0\xC5\xEB\xB3\xED\x43\xEB\xA0\xE8\xC7\xE7\x01\xF6\xB2\xE1\xD8\xBC\xEC\x06\xEC\x1F\xEE\x59\xCE\xAC\xE4\x27\xEC\xA9\xE5\xD3\xAE\xEA\x6B\xEA\x61\xEB\x43\xCE\x48\x11\x51\xDD\xB3\xC8\x6E\x7D\xE4\xDA\xAC\x50\xD8\x11\xEC\xC6\x9C\x51\xC3\x6E\xD2\x9A\xF3\xA7\x7C\xEC\x19\x9F\x9F\xE8\xCE\xC9\x6C\xFC\xA7\xC3\xAB\xDA\xEA\x85\xED\xE5\xEB\x2C\xED\xB9\xE5\x4B\xEF\xAE\xD0\xD2\x8C\xED\x79\x81\x6B\xE4\x41\xB9\x5B\xEB\x52\xE9\xB5\xF9\x9F\xFB\xC1\x9A\xE5\x78\xE8\x95\xD3\x9D\xE2\x68\x58\x52\xF5\xC1\x83\xAA\x09\xC2\x9D\x3D\xA1\xE1\xDD\xEB\xCF\x6B\xB7\xE2\x9F\x81\xED\xE5\xEB\x5A\xEE\xA8\xE9\xB5\xE4\x6A\xE1\xAA\xE6\xDA\xC3\xEA\xEF\xEB\xA2\xE9\x31\xC0\xA6\xEC\xAA\xDB\xB4\xC2\xAA\xE4\xE5\xC7\xD6\x04\xEB\x6C\x9A\x58\xE8\xA0\x04\x96\xE7\xDB\xDD\xE8\x62\xED\x9B\xE9\x18\xEF\xC9\xEB\x14\xED\xB7\xC7\xD7\xDC\xD1\x93\xE2\x45\xE9\x9A\xE1\xA0\xE0\x62\xED\x8F\xF6\xDB\x8B\xED\x24\xED\x46\xEF\x9B\xEB\xDF\xE8\x62\xF2\xB3\xCD\xD8\xD8\xEB\x0F\xEC\xED\xEA\xB6\xEA\xB6\xE4\x6C\xFA\x56\xE0\xDC\xB1\xD5\x59\xA0\x74\xE4\x83\x15\x56\xDB\x70\xE9\xB9\xE1\xD6\xB2\xEC\xEA\xD4\x1A\xEF\x49\xD6\x44\xE1\x6A\xF6\x3D\xEB\xD9\xDC\xC9\x6D\xEC\x6F\xC7\xCE\xEF\x68\x4D\x73\xE9\xE8\xBF\xDC\xF4\xEC\x41\xEE\x3B\xEF\x90\xE8\x5B\xD7\x61\xE6\xBA\xC1\xCC\xC6\xCB\x4C\xB7\xE9\x99\xC1\xE3\x75\x0D\x74\xFE\xB8\xE6\x68\x0E\xEE\x50\xED\xD2\xEA\xC4\xEE\xEA\xE3\x6A\xF8\xBA\xE5\xDA\xDA\xEE\xA7\xED\xC9\xCA\xBF\xEA\x34\xD6\x69\xF8\x88\xEF\xDA\xE6\xEE\xEE\xCB\xC8\xC0\x7C\xCC\x44\x69\x08\xA0\x99\xEA\xAF\x91\xDF\x80\xE9\x27\xC7\xDF\xE9\x35\xE1\x6B\xEB\x8D\xEE\xDC\x82\xED\x30\xEF\xE4\xEB\x3F\xEB\x91\xEC\x5C\xF5\xB9\xC3\xD4\xD0\xED\x05\xEA\xB1\xEA\x74\xEA\x97\xEF\x68\xF4\xB6\xE3\xD3\xD6\xED\x0D\xEA\x6C\xED\x2F\x71\x93\xE7\x1E\xD6\xA3\xCA\xD5\x86\x14\x9E\xE8\x9D\x3D\xED\xDC\x65\x30\x69\xDB\xA2\xCD\xD3\xF4\xB3\xF6\xE9\xA7\xEF\xCA\xEF\xD8\xE3\x5E\xF0\xB8\xFD\xD7\xCB\xED\x54\xED\x1C\xEE\x7A\xE9\xE0\xC7\x60\xE7\xA9\xF9\xDD\xC2\xCE\x7B\xEE\xB6\xC8\xE9\xEF\x42\xC1\xD5\xA7\xBD\xC1\x52\x9A\xBA\x9F\xE9\x5E\xCE\xF5\xE1\x38\xC4\x4A\xE2\x7F\xF3\xD1\xD1\xCA\x4E\xEE\x8B\xE8\xD4\xEB\x44\xE2\x75\xE7\x92\xF6\xD8\x8E\xE5\xB6\xEC\x58\xE5\xC5\xE8\xB1\xE7\x71\xEA\xAC\xD9\xDC\x8C\xEB\x1B\xEF\xBE\xEF\xDC\xCF\x40\x12\x00\xF4\x58\xC4\xC0\xD8\x5F\x4F\xE8\x65\xEA\x44\xB7\x25\x15\x86\xD0\xBD\xD5",
"\xD4\xD4\xEA\x8D\xEF\x01\xE7\xE3\xE9\xE2\xE8\x7B\xF9\xBE\xD1\xCC\xDB\xEF\xAB\xEB\xEE\xED\x6B\xEF\xFB\xEF\x5A\xE1\xBF\xFB\x83\xA8\xE0\x02\xC2\x76\xEB\x6C\x61\x40\xB5\x71\xCD\x9B\xCB\x83\xB1\xE0\x13\xEA\xF7\xEC\x68\xEA\xFA\xE3\x7B\xE4\x49\xC8\xDB\xF2\xEE\xF5\xEF\x89\xEF\xAD\xE8\xFF\xE9\x6B\xFA\xBF\xDA\xD9\xFC\xEF\x5C\xEC\xFF\xEF\xAF\xEA\xA2\xE4\x4F\xEA\xC0\xE0\xD7\xCD\xD8\xC6\xEC\x07\xF1\xED\xEB\xFE\xE7\x7B\xF1\xBC\xC4\xDA\x9E\x02\x88\xCB\xF4\xE8\xAE\xEB\xBD\xE2\x6D\xEB\x3B\xDE\xDE\x8B\xEA\xA0\xEF\x49\xEE\xE8\xEA\xE8\xEC\x71\xF0\xEC\xB2\xD4\xAE\xEF\x89\xEE\xF6\xEF\xE2\xEE\xCF\xE1\x7F\xEC\x98\xE5\xC7\x8E\xE6\x55\xEF\x95\xD3\xD5\xEB\xB6\xC9\x75\xE4\x28\xFF\xDE\xDC\xD0\xC1\xEE\xCD\xCF\x51\xE8\xD1\xC8\xFD\xC6\xBE\xEE\x71\x9C\xE1\xD6\xCE\x4F\xE1\x1F\xE9\x41\xA1\x0A\xFC\xAB\xCA\xDE\xCF\xE9\xF0\xEF\x10\xF3\x1F\xE3\x04\xF0\x81\xE6\xC1\xCC\xDB\x88\xE2\xCE\xEC\x9B\xEE\x88\xE8\xBA\xE6\x50\xFB\xBC\xCE\xDA\xF0\xEC\x0B\xEC\x9F\xEE\x8A\xE8\xE8\xEC\x62\xF4\xC1\xE2\xDF\x8C\xC3\x44\xEC\x6F\xEC\x71\xB2\xB2\xE2\x57\xEF\x3E\xDA\xD6\xD3\xBD\x97\xEA\xA9\xC7\xF4\xCF\x0E\xF4\x15\x1A\xAB\xE6\x8C\x87\xD4\xE0\xB9\xE8\xED\x16\xF5\xD3\xE5\x7D\xED\xA5\xD7\xDF\xE7\xE8\x5F\xF1\x35\xEB\x0A\xF4\xF7\xED\x82\xF3\x3F\xEF\xE0\x91\xED\x31\xF1\x15\xEC\xA5\xE9\xDB\xE5\x83\xFE\xBB\xD8\xE1\xF2\x4C\x70\xEB\xD8\x27\x64\xEA\x1E\xEC\x87\xF9\x20\xE1\xC4\xD9\xD4\x23\xE2\x06\x15\x67\xEA\x14\xEA\x83\xF7\xC4\xC5\xDB\x84\xF1\xC9\xE4\x46\xE7\xDC\xEA\x08\xF5\x77\xE4\xC2\xF7\xDD\xC6\xF0\x18\xEE\x54\xEE\xC6\xE9\xBE\xE3\x76\xE9\x3E\xCB\xE0\xB4\xEB\x67\xEE\x03\x4E\x6D\xEB\x95\x08\x5B\xFB\x5D\x9F\xE2\xCA\xC4\xA1\xF0\x04\x16\xC4\xB9\x01\xF2\x88\xFC\xB4\xD3\xDF\xC4\xE4\x65\xED\x2E\xF3\x16\xE1\xE6\xEA\x5C\xF4\xBC\xF3\xDB\x96\xEF\xCE\xEB\x31\xF3\xBD\xE9\xE7\xE9\x6F\xE6\xB1\xFC\xDC\xF1\xEC\x5E\xEF\x35\xF0\xD8\xED\x0D\xF2\x76\xFB\xC0\xCB\x6A\xE4\xD0\xC0\xEA\x0F\xF1\xD9\xEC\xF1\xEA\x85\xE7\x85\xC1\xD6\xBF\xF0\x68\xEC\x9A\xCD\x22\xF5\x49\xEB\x7B\xF7\x8A\xFD\xDE\xE3\xEA\x47\xF1\x0E\xD5\x12\xF0\x60\xD5\x89\xFB\x91\xF4\xD7\xE3\xBE\x33\xE0\x71\xF1\xD1\xEC\x1C\xF8\x8A\xE9\xC6\xEA\xE2\x91\xF0\x74\xEE\x8A\xEE\xDD\xEE\xE2\xE8\x77\xF1\xC5\xFA\xDD\xB3\xF1\xAA\xED\x5F\xED\x61\xE1\x20\x07\x18\xE7\x5E\xC1\xE2\xEE\xEE\xFC\xF1\x63\xF1\x3E\xEE\xF1\xEA\x8C\xFD\xA7\xEC\xC2\xCD\xF1\x33\xEF\xCA\xED\x18\xF7\xF2\xE5\x84\xE9\x3B\xF1\xE3\xBC\xE2\x91\xF0\x36\xF3\x24\xF5\xC5\xEC\xD5\xCE\x46\xCF\xDF\x8F\xF2\x3B\xF1\x30\xE5\x0F\xF7\x5D\xEF\x69\xE0\xC2\xE7\xD7\xF6\xEF\x2A\xF0\x0A\xF0\x0B\xF2\xD7\xE3\x6D\xE0\xB2\xFD\xDA\xDD\xEC\xCE\xC6\xA2\xEE\x1C\xF3\x7C\x34\x1C\xF5\x47\xDD\xE0\xC5\xF1\xA7\xF0\x89\xF0\x46\xEB\xF0\xCB\x61\xF5\xA6\xEB\xE2\x9A\xD5\x19\xF3\x67\xF3\x46\xF1\x1A\xF8\x79\xE5\xA9\xEF\xE3\xE6\xF0\x5B\xEE\x0E\xD4\x48\xF3\x1E\xF1\xA2\xDA\xB6\xD8\xA4\x88\x1D\x3F\xF2\x88\xF0\x0F\xF5\x1C\xF4\x0D\xE7\xC7\xF0\xCB\xAE\xF2\x69\xED\x80\xF3\x04\xF3\x20\xFC\x7D\xE5\xC8\xDE\xDF\xB2\xF1\xE0\xEE\x5A\xF0\xD2\xC2\x90\xCC\x1F\xE4\xC6\xDA\xE5\xAA\xF2\x5C\xF2\xB6\xE3\x03\xF7\x1F\xFE\x85\xF9\xBD\xCD\xDB\xED\xF1\xB5\xE3\xA7\xF1\x89\xEC\xF3\xE8\x86\xF0\xB4\xE9\xD8\x92\xED\x92\xF1\x19\xF1\x37\xF5\x25\xCC\x3A\xDD\x90\xF9\xE3\xC0\xF2\x6F\xEF\x95\xF2\x55\xEB\xEA\xEC\x53\xEA\xC7\xF6\xE5\xE0\xF0\x78\xF3\x6E\xEA\x5E\xF2\xE7\xEF\x91\xFD\x8A\xE1\xE4\xDB\xF1\x23\xF2\x37\xF3\xAA\xEC\x47\xE2\x98\xD9\xCA\xE9\xE4\xB5\x39\x70\xEF\x96\xED\x45\xF7\xDD\xE7\x91\xF3\xBC\xC9\xE5\x82\xEC\xB4\xE8\x02\xEE\xA2\xEC\xC6\x88\x6F\xEE\xBD\x3A\xDB\xDC\xEE\xD8\xF0\x3D\xD6\xB7\xCA\x30\xFE\x53\xD4\x18\xC0\xDB\xE6\xED\x12\xD6\x94\xF2\x29\xF1\x31\xF1\x97\xEE\x8C\xDE\xE5\xAD\xF2\xE9\xF1\xAF\xCF\x3A\xF2\x4D\xE1\x99\xE1\xAB\xD3\xE6\xD5\xF1\x7C\xF3\x6B\xF1\x1A\xF1\x1B\xF0\x98\xE2\xC9\xF4\xE6\x96\xD2\xD2\xE7\x54\xDB\x3E\xF1\x66\x30\x6E\xFF\x64\xFF\xC9\xE3\xED\x3B\x71\x72\xEE\x8B\xD7\xE4\xEA\x9B\xF1\xBD\xCC\xE0\xE4\xEC\xAB\xE9\xD1\xF1\x92\xE0\x2A\xE9\x1E\xE7\xCD\xC7\xDA\xA9\xF3\x89\xEC\x5B\xE8\x6B\xF4\x1A\xFE\x9A\xF6\xC6\xF0\xE6\xCB\xF3\xB2\xF3\x52\xD3\x73\xF0\x30\xD1\x70\xF0\xCF\x83\xDC\x81\xF0\x05\xEE\x50\xE7\xC1\xEC\xDC\xE9\x70\xF4\x3C\x05\xCA\xFA\xF1\x3B\xF3\xE1\xEA\x62\xF7\x37\xF5\x63\xF4\xBA\xEF\xE4\x92\xF0\xDA\xEE\xB2\xF1\xFE\xEE\x2C\xFB\x7F\xE8\xCB\xFD\xDF\xEA\xF2\x2D",
"\xC2\x9D\xF2\x8C\x9D\x63\xE1\x72\xF5\x2B\xF6\x84\xA4\xEE\x2A\x02\x93\xED\x6E\xF7\x0A\xFE\x9D\xE3\xC4\xC2\xE5\xA3\xEB\x44\xF2\xDB\xEC\x87\xE8\x20\xFC\x8A\xE2\xC8\xEE\xE2\x84\xF2\xB0\xF1\xB3\xF3\x41\xF1\x2D\xF9\x90\xF1\xD0\xF1\xE1\x93\xF4\x47\xEF\xFC\xE7\x67\xCF\x35\x09\x2E\xE2\x2D\xC2\xDB\x80\xF4\xEA\xED\x01\xF7\x5C\xF2\xB0\xE7\x94\xE5\x56\xE6\xE7\xDD\xEA\x88\xED\x6A\xCF\x4C\xF6\x02\xFB\x6B\xF8\xC0\xF7\xE4\x9A\xF0\x2E\xF4\xB2\xEF\x74\xF0\x71\x34\xA1\xE3\xB7\x87\xD1\x88\x14\xE1\xD4\xEE\xF0\x87\xF7\xFD\xE6\x8C\xED\xC0\xDB\xE1\x9A\xEC\x22\xF4\xA3\xF0\x89\xF0\x29\xF3\x84\xE0\x41\xDD\xE4\x92\xCF\x95\xF2\xEB\xE3\x65\xF1\x34\xD0\x6E\xCF\xC3\xE0\xCB\x9B\xE6\x72\x4D\x26\xF6\x6F\xC4\xF0\xE9\xB0\xC7\xBC\x8F\xCD\xA0\xB9\x8F\x00\x87\xD7\x6F\xEB\x37\xFC\xB2\x24\x5E\xC1\x43\xE5\xA3\x2F\x9C\x4C\x3C\xE0\xD9\x6A\xE2\x10\x10\x04\x1E\x60\xDC\xA4\x83\x10\x1B\x90\x4C\x89\x0A\x95\x13\x0F\x95\xB0\x17\x81\xF4\x1B\x04\xF5\xD5\xEB\x86\x4F\xFA\x82\xA0\xD4\xCD\x33\x02\xF5\x8E\x65\x24\x91\xA1\xF7\x24\x37\xA8\xF8\xA2\xDC\x64\xC2\xC3\x38\xF0\x14\xE8\x5E\x0A\x06\xED\xA1\xFC\xB4\xF0\x01\x3C\xB2\x00\x9D\xEA\x8D\x68\xF4\xB4\xE4\x97\xEB\xC6\xD2\xDE\x9F\xEA\x86\xEC\x20\xF4\x7A\xF2\x48\xFC\x88\xF4\xC9\xEE\xE0\xB6\xF2\x7B\xD4\x39\xEA\xD2\xE4\x8E\xEF\xFA\xD9\x84\xCE\xE1\x90\x16\xC8\xEE\xD5\xEC\x47\xBB\x0E\xF3\x85\xF8\x7D\xD9\xEA\xB3\xD9\xF3\xA6\x4E\xF4\x95\xF7\x14\xFF\xA9\xE4\xA4\xA1\xEA\xEC\x93\xA3\xF5\x10\xF4\x09\xF3\x44\xF5\x97\xF0\xC9\xD5\xD9\xC5\xF3\x3D\xEC\x57\xF6\x23\xF0\x56\xF3\x9B\xF2\xD5\xE5\x87\xA5\xB4\xB5\xF5\x57\xB0\x27\xE8\xF5\xE3\xFB\xD6\x3E\xD1\xA0\x1D\xBA\xDF\xDE\xA6\xCD\xF3\xEA\xD8\xE2\xAC\xF7\xC5\xDE\xEA\xA0\xF5\xF6\x9A\x51\xF6\x8E\xF4\x0B\xF5\xAA\xF6\xC8\xCC\xE3\xA6\xF3\x5D\xF4\x60\xD3\x97\xF5\x0F\xD1\xA6\xF6\xA4\xC8\xE4\xFF\xED\x0A\xF2\x22\xC5\x31\xEF\x48\xC5\x00\xE9\xBF\xC2\xDC\xAC\xC7\xCC\xE9\x67\xD3\xA6\xF0\x31\xFC\x8F\xE5\xD6\xE2\x53\xC7\xF5\x15\xA3\x64\xF7\x18\xED\x28\xFB\xA3\xCD\xD6\xC8\xE8\xF7\xEF\x0A\xF5\x0A\xF0\x83\xF7\x02\xFE\xA0\xF9\xC0\xD0\xE8\xCE\xC7\x00\xF0\xA2\xCA\xA0\x4C\x05\xE0\xDD\xAB\x51\xF0\xC0\x8E\xB9\x7C\xC4\x2E\xEB\xC0\xF7\x2D\xF0\x9A\xE4\x40\x28\xEB\xD1\xA3\x84\x96\x85\xF7\x34\xEC\x61\xF8\x55\xE4\x88\xF0\xDB\xA8\xF0\x6A\xE8\x76\xF3\x22\xF6\x1D\xFD\x88\xF9\x4B\xCF\xE2\xFF\xF2\x63\xF4\x4A\xE1\x2F\xE3\x33\xF3\xBD\xD8\xCD\xF8\xCD\xF7\xF3\xB6\x7B\xA0\x4D\x75\xA2\x94\x8E\xAF\xF3\x47\xC8\x28\x20\xC5\x83\xD3\x72\xF7\x07\xF0\xEE\x06\xB2\xE6\xD6\xE9\xEB\xC8\xF5\xEB\xF4\x2C\xF7\xB2\xF2\x4B\xFE\xB0\xE2\xCB\xC9\xE8\xA7\xF4\x65\xF3\x14\xF5\x83\xF3\x45\xFF\xA0\xED\xD1\xD8\xEC\x92\xE7\xFF\x01\x99\xE9\xA1\xE2\x69\xF3\x8E\xFB\xCA\xDD\x04\x27\xF6\xA4\xA0\xA8\xF5\x6F\xF2\x51\xEB\xA3\xE8\xC7\xFD\xE8\xDA\xE1\xF1\xF5\xAA\xE1\x53\xF3\xC4\xE5\x86\xFB\xCB\xE7\xE1\xCA\xF3\x7E\xF2\x35\xF1\x73\xF0\x33\xFF\x9C\xE3\xBE\xF6\x9A\x89\xCD\xCC\xB2\xED\xDC\x8B\xB6\x5D\xCF\x09\xEA\x09\x15\xE1\xEE\xD0\x23\xF7\xCF\xF3\xF8\x31\xEE\x08\xB6\xF9\x6F\x95\xDC\x2A\xF6\x92\xC6\xF1\xF3\x2B\xED\x34\xF8\xAA\xF2\xB7\xE8\xE6\xF4\xED\xAA\xF2\xF5\xF0\x2D\xE1\x2B\xE1\x95\xFC\xB7\xE7\xD5\xFB\xF6\x64\xF5\x53\xD1\x3D\xF0\x0E\xFA\xA4\xE8\xD4\xF0\xC3\xDD\xAA\x00\xD1\x67\x5D\x2F\xF4\x48\xB6\x80\xDB\xC3\xFA\xD6\x9B\xEB\xCD\xE0\xA8\xE9\x2D\xD1\x71\xF4\xA7\xE6\xDB\xC6\xEC\x9B\xAA\x08\xF7\x94\xF5\xD4\xF0\xD0\xE3\xB5\xED\xD8\xE6\xEA\xA7\xF0\xE8\xC1\x54\xF6\x81\xC0\x1A\xF5\x6F\xF2\xC6\xF8\xDC\xF5\xF6\x94\xF2\x83\xF0\xF0\xEF\x5E\xFC\x77\xF5\xC5\xE1\xCF\xB2\x9C\x99\xF0\x1F\xB6\xD3\xC4\x13\xFF\xBA\xF8\xC3\xC7\xA8\xBF\xF1\xF8\xE6\xF1\xE5\x5E\xEC\xB3\xE2\xBB\xFF\x47\xF4\xEE\x9D\xF5\xC4\xF5\xC6\xF4\x27\xA2\x5D\xFB\xB6\xEB\x98\xEC\xE4\x85\xF4\x8D\xF2\xE1\xF3\x63\xF2\x11\xF2\x93\xED\xD5\xC4\xE9\xB5\xF2\xBC\xED\x58\xF4\x4E\xF1\x87\xCF\xA2\xFB\xE7\x51\xEF\xA0\xF0\x8A\x0E\xC0\xC7\x0E\xD5\x6A\xC5\x80\xD5\x1A\xFC\xD6\xBC\xD0\xBE\xEA\x41\xB6\xC8\xF6\xE4\xCA\xB8\xE2\xD0\xE2\x65\xE2\xF7\x9D\x89\xC7\xF7\xEE\xF4\xDD\xE2\xB9\xF9\xAA\xD4\xEE\x80\xEC\x96\xF7\xF3\xF0\xE6\xF1\x3D\xF7\x73\xEB\xCF\xC8\xEF\xC8\xF3\x77\xF7\xF7\xF1\xDE\xF4\x39\xF9\xB3\xF5\xB3\xF5\xE6\x8E\xCA\x06\xBD\xEE\xE9\x33\xEC\x6C\xFB\xA4\xE5\xD9\xC7\xF0\xCE\xF6\x28\xF7\x5E\xD4\x78\xF2\x9A\xE1\xB9\xED\xD7\xE4\xE6\xEF\xF5\x95\xF6\x67\xF3\xE5",
"\xF4\x78\xF9\xB9\xF5\xE0\xDB\xEE\xD3\xE4\xCA\xF6\x24\xF0\xF3\xF5\x4C\xFC\xB3\xE8\x50\x35\xD7\xE5\xD0\x24\xF8\xD3\xF4\xD3\xF7\x84\xF7\xB0\xEF\xDA\xC9\xEC\x8B\xF8\x0F\xEF\xDE\xF5\xCB\xF5\xA3\xEF\xC0\xF1\xB7\xF2\xF0\x92\xF8\x34\xF8\x0A\xFA\xF1\xF6\x82\xFA\x79\xF6\xDB\xDD\xEE\xDD\xEE\xF1\xF3\xD5\xDF\x7C\xF1\xC2\xEB\x90\xE3\xD5\x93\xD4\xC1\xF8\x39\xF4\x22\xF8\xEE\xF6\x88\xFA\xBB\xE5\xDF\xFB\xD7\xD9\xF4\xBE\xF6\x77\xF7\xA9\xF0\x82\xFF\xC4\xEA\xD5\xD3\xF0\xAC\xF5\x34\xF6\x69\xF6\xCD\xF4\x5A\xF2\x9F\xF1\xFD\xA5\xE4\xE4\xF5\x04\xF6\xDB\xF4\x02\xFC\x18\xA9\xA0\xCB\xE1\xEC\xDC\xA4\xF5\x3C\xF5\x2D\xF6\x8F\xF1\x6E\xF3\x1B\xF3\xDB\xE4\xE1\xD5\xF8\xC9\xF6\x15\xF7\xF2\xF4\x45\xF8\xAF\xE9\xD2\xF6\xE2\xCB\xF6\x06\xBD\xE2\xE0\x10\xF9\x8F\xF0\x97\xE7\xDB\xE8\xF0\xE9\xF6\x47\xF8\x33\xFA\xAC\xED\x81\xFE\xB2\xED\xE2\xF0\xEC\xDC\xEA\xC3\xF7\xA5\xF1\xF1\xF6\x90\xF3\x8D\xF7\xE0\xED\xE7\xC9\xF3\x1A\xF9\x9B\xF6\xDE\xF5\x83\xF1\x76\xFF\xE0\xE2\x9B\xD7\xF2\x1A\xD3\x93\xF0\x01\xFD\x76\xF5\xC9\xF7\xDD\xD5\x7A\xB9\xF7\x2A\xF9\x4D\xCD\x2A\xF1\x90\xF5\xB5\xE5\xD1\xE3\xE5\xD8\xF6\x0B\xF4\xAD\xF4\xC5\xF4\x6B\xF6\xB1\xFE\xDA\xD4\x8C\xEC\xF2\x73\x87\x11\xF8\x25\xFE\x84\xF6\xC9\xE5\xE2\xE9\xF0\xDF\xCF\x9A\xF8\x8A\xF2\x0B\xFB\x3C\xFF\xB2\xE1\xDE\xD1\xF0\xEE\xF8\x51\xF8\x38\xF9\x5E\xF5\x66\xF7\x0B\xEA\xE5\xDC\xF0\xD4\xF2\x3B\xF6\x85\xF1\x29\xC9\x20\x07\x4A\xD2\xE5\xD5\x77\xB4\xF9\xCC\xF8\x5B\xFA\x57\xC0\x97\xF0\xCD\xFD\xC7\xE1\xE7\xD3\xF9\x93\xF6\x18\xF8\x1B\xFF\x47\xF1\xCA\xF0\xD6\xD1\xDB\xF2\xF8\xDD\xF8\x3A\xFA\x16\xFE\xD7\xEE\x65\xEC\x50\x3D\xC8\xC9\xF6\xCB\xF9\xC5\xF5\xD3\xF6\x99\xF8\xC9\xE5\xE3\xEE\xF3\xAC\xF8\xDA\xD1\x97\xEF\xEF\xF3\x38\xF4\x73\xE2\xE5\xF5\xF0\xD3\xF8\x37\xF9\xF6\xE9\x0E\xFA\x1E\xFB\xC3\xE2\xDD\xE6\xE9\xC3\xE9\x64\xE6\x53\xDB\x76\xF6\x0A\xF7\xCE\xE0\xDF\xFC\xE6\xCD\xF9\x63\xF9\x67\xF8\xBA\xD7\x43\xFE\x69\xE8\xDF\xE0\xDA\x87\xF4\x56\xF6\x88\xF4\x30\xFA\x62\xF2\xCC\xE5\xD2\xD5\xEC\xC7\xF4\x17\xF6\x8A\xC5\x7D\xF0\x20\xC7\xA2\xD5\x28\xC7\xBE\xD0\xC1\x0A\xE9\x12\xF8\x4F\xF5\x45\xD0\x07\xFC\xE8\xE1\xEC\xE8\xF9\x02\xFA\x31\xFB\x2D\xFC\x8C\xF9\xCB\xE9\x4A\xFB\xF2\xEE\xF6\x82\xF8\xB8\xF5\x2B\xF6\x4B\xFF\x8A\xFE\xC8\xD3\xF4\xD3\xF2\x15\xFA\x7A\xF3\x45\xFB\xDB\xE4\x24\xA5\xDB\xDF\xDB\xC0\xF6\xB1\x63\x2B\xD6\x7E\xF1\x7B\xF2\x2A\xEA\x09\x24\xCA\xA4\xF1\x3F\xFA\x8F\xF9\xC1\xF3\x8F\xF8\xE9\x30\xDC\xC9\xF4\x90\xEF\x0B\xFB\xF5\xF6\xCC\xF5\x7D\xF1\xC7\xEF\xDF\xEF\xEA\xF1\xF7\xD5\xF5\xF9\xF6\x43\xCA\x42\xFB\xCF\x6A\xD3\xF4\x95\xBA\xA3\x10\x4C\xBC\xCB\xFF\x0E\xB3\xE0\xC6\xED\xB8\xC3\xF4\xA1\xFA\x05\xFB\xA2\xF8\xA5\xD7\xA8\xFF\x95\xE1\xCE\xD9\xA2\xCE\xF5\xBA\xEF\x99\xF7\x36\xF8\x9F\xFA\x13\xFA\xE7\xFB\xC2\xDB\xF8\x43\xEF\xFA\xF6\xD6\xB1\x46\xF7\xA4\xAE\x9F\xCB\xDD\xEA\xE5\x60\xFB\xBE\xF8\x8D\x9C\x71\xF7\xC9\xEE\xDC\xE4\xEF\x87\xFA\x7F\xF8\x65\xF4\x27\xFC\x89\xF2\xCF\xEE\xE2\xF4\xF3\xDB\xCB\x72\xF7\x79\xF5\xE9\xDD\x5E\xFD\x6F\xF1\xEA\xD5\xE5\xA3\xF7\x67\xF4\x92\xF7\xF8\x36\xAE\xFC\x42\xEB\xBB\xD0\x6D\xBE\xFA\x9A\xFB\x1D\x70\x67\xFC\xA0\xFE\xD9\xEA\xDB\xE0\xF6\xB4\xEF\x52\xF7\xD1\xFB\x8D\xEA\xAD\xF4\x9C\xEA\xEC\xD2\xE6\xDC\xF9\x8D\xFA\xB8\xF9\x1D\xFA\xAE\xF2\x6E\xD4\xEB\xD3\xF6\xB9\xF1\xB0\xD5\x35\xF6\x23\xA6\x4D\xF9\xD1\xF6\x92\x82\x04\x5D\xDD\x78\xE9\xCE\x16\x87\xD8\x92\xF2\xB1\xC4\x77\xE7\xDF\xE6\xDD\x52\xD8\xC5\xDE\xA2\xF0\xEC\xAE\x81\xB5\x9C\x81\xF4\xB8\x2E\xEF\xDC\x9F\xD9\x22\xD7\xBC\xF9\xD5\xB5\x63\xFF\x49\x9C\x5F\x57\xDE\xAB\xD4\xC2\xDC\x16\x3C\x28\xAA\xEF\xE5\xC5\xB2\xFB\x38\x2E\x0B\xDB\xE4\xB0\x9D\xD4\xF1\xD3\x61\xE2\xBC\xCE\xDD\x4C\xDE\x77\xDA\x3F\xDB\xBB\xF6\xD5\xFC\xD5\xE0\xBD\xF4\xD9\x7B\x1E\x36\xDB\x7F\xFB\xBE\xFA\xB9\xBA\xB9\xB6\xF7\x84\xFC\x3A\xFB\xFC\xFA\x40\xDC\xCB\xA0\xC3\xC5\x68\xE0\xB1\xAF\xDE\x4B\xDF\x7D\xDA\x42\xDA\x81\xA0\xE1\xE2\xE2\xF4\xBB\xDC\xA5\x3F\xD9\x0A\xFC\xD2\xDF\xC2\xFA\xF4\xD1\x7B\xDC\x5D\xC7\xB7\x3E\xDE\x03\xBB\x7A\xF8\xBF\xFD\xDE\xF7\x79\xD5\xD0\xEE\xDE\xFF\xB7\x12\xFE\xD9\xDC\xDF\xD4\xC5\xCF\xF0\xEC\xF7\xA7\xF7\xA8\xD7\xBE\xD7\xBB\x12\xA5\xD0\xE3\xE7\xB5\xA5\xBD\xE1\xFB\x72\xDE\x98\xDA\x8D\xFC\xC5\xF8\xE3\xF0\x28\xDB\x6F\xEA\xD8\x20\xA7\xF8\xF8\x37\xD8\xE0\xD8\x35\xBD\x69\xE9\xF8\xD7\xA5\x1D\xFC\xE8\xF5\x1D\xDA\xEC\xDA\xE0",
"\xFB\x79\xCC\xF9\x86\xBC\x69\xDF\x99\xDD\x94\xFE\x7E\xFC\xF6\xCB\x5D\xD5\xF9\xD8\xDE\x00\xFD\x7D\xDA\x04\xBC\xDD\xD7\xDF\xE5\xE0\xC9\xEA\xE0\xF6\xB8\xAE\x32\xFF\x96\xFF\x6B\xEB\x32\xFC\xC0\x8F\xF9\xEE\xA6\x6B\xFD\xAF\xC2\x74\xF5\xC7\xF8\x18\xE9\xE1\xB7\xF4\xA1\xD9\x61\xFD\xED\xD7\x03\xB7\x68\xF2\x10\x11\x04\x27\xD0\xE0\xB7\xF7\x80\x74\xCD\x4E\xFE\xC3\xF5\x3A\xF2\xD0\x9F\xB6\xA5\xE7\xA3\xE8\x3E\xFD\x40\x03\x12\x0F\xE7\xE6\x50\x0B\x2D\x02\x3B\xB1\x4E\x8F\xF4\x9B\xF8\x6C\xE2\xA1\xB4\x04\x08\xFA\xBC\xE6\xAD\x87\x4A\x01\xA3\xF8\x8E\x0F\xAE\x1E\x98\x64\x9F\x03\x09\xF0\xE8\xFB\xF3\xA5\xFF\x93\xBC\x4E\xC4\x99\xDF\x60\xB3\xFA\x99\xBB\xAD\xDA\x16\xEE\x43\xBA\xB5\xC5\x9E\xDE\x8A\xCB\xF0\x75\xE8\xC0\xF6\x86\xB2\x70\xFE\x68\xCC\xBD\xC5\xEE\x96\xAB\xAC\xFD\x1C\xDA\xAB\xFF\x04\xE0\xEB\xF9\xD6\xDF\x98\xDB\xF5\xC7\xEE\x5D\xCE\xB7\xF4\xD7\xCC\x47\xF1\xA9\xD0\xCD\xAA\x02\x3B\x08\xE7\xEE\xEE\xB0\xF1\xE3\xD7\xFC\xE2\xFA\xEB\xE4\xD7\x03\xE0\xF3\xD4\x32\xEE\x00\xFF\xAF\xEB\xA6\xD3\xE9\xCB\xFD\xBF\xF4\xA4\xCC\x00\xE2\x4E\xC4\x70\xFF\xCF\xAE\xD3\x85\xF0\xFB\xF2\x3E\xE4\x02\xF2\x94\xBB\xEB\xE7\x26\xCF\xC1\xCD\xCE\x7C\xEC\x77\xAE\x8E\xBE\x91\xF3\xD5\xFF\x32\xE2\xED\xFE\xD9\xE5\xFC\xEB\xE5\xAD\xC9\x5D\xC1\xB8\xF5\x9A\xDE\x04\x4D\xEA\x5F\x13\x5B\xFF\xE1\xF1\x69\xBC\xEC\xED\xEE\xDB\xD7\xCE\xFB\x9B\xE7\xC0\xED\xC6\xC5\x0E\xF6\x0C\xFD\xC4\xFD\xEF\xB9\xD0\xAE\xF7\xFD\xF4\xE2\xC1\x41\xAE\x0C\xF2\xD1\x99\xFB\xD7\xD5\xB0\xFB\xB6\xE8\x50\xFA\xC2\xF0\xDD\xF2\xDE\xC1\xA0\x94\xEB\xD5\xF7\x8E\xC4\x3D\xE2\xE1\xFA\x0C\xE9\xF8\xCC\xC3\x88\x14\xA3\xF1\x02\xA9\xBF\xFA\xDB\xFF\xEF\xF2\xEC\xC1\xFC\xA8\xF7\x7E\xC7\xFC\xF5\x0D\xD6\xE0\xF9\x87\xED\xDD\xD9\xD6\x99\xFE\x06\xBD\x61\xF0\xB9\xFE\x59\xB4\xBA\xF1\xF8\xDC\xD7\xE0\xF1\xD7\xB5\x78\xFC\xF2\xCB\xAA\xF4\x16\xFD\xF0\xEA\xFB\xBA\xFE\xF0\xD0\x9B\xFE\x84\xEE\x30\xE5\xDE\xEF\xF8\xD7\xA4\xF7\xF8\xBA\xFC\x9A\xFE\x56\xCB\xAA\xF0\xF0\xF4\xD5\xB4\xA3\xC8\xEC\x72\xF5\x75\xFD\x4E\xF3\xBB\xE0\xCB\xF1\xFA\xC0\xFD\xB2\xB6\x3C\xFF\xFD\xE1\x32\xFE\xDB\xD6\xF4\xE6\xF7\xDC\xF1\xE3\xF9\x63\x1D\x99\xFD\x6C\xEC\xEA\xFC\x99\xED\xB5\xE2\xFD\xEC\xFD\xFF\xEE\x2E\xE6\x9B\xFD\xA7\xF8\x38\xA3\xF9\xD0\xFC\xD3\xFA\xA8\xFC\x13\xD6\x20\xBE\xCE\xF9\xBC\xD8\xE9\xD8\x88\x9E\xFC\xDA\xF2\xB6\xFF\xAC\xAE\xED\xFF\x0B\xFB\xAE\xF1\xFD\xCC\xC4\x9C\xE5\x6E\xFE\x56\xF9\xF1\x05\xB4\xFE\xD7\x8C\x28\x5F\xFA\x3E\xB7\x5C\xFC\xDA\xFB\xEC\xF5\xBA\xF0\xD1\xD5\xFC\x88\xA9\x1E\xE9\xDB\xA1\x93\x02\x51\xD9\x13\xD1\xDA\x8A\xFE\xD3\xFE\x91\xFB\xC6\xFD\x5D\xFC\xB2\xFD\x3F\xF1\x37\x33\xAA\x97\xFB\x36\xF4\x1A\xB4\xDF\xFE\xEB\xF9\xF9\xEF\xE4\xC5\xF8\xB3\xFB\x94\xFB\xDA\xF9\x72\xCE\x32\xC6\xF9\xF2\xFA\xF4\xEF\xA5\xFF\xCF\xF7\xCD\xFF\xE3\xFE\xD9\xD5\x45\xFF\x56\xCB\xAC\x88\x14\xDE\xD6\xAE\xFC\x43\xF2\xE9\xF8\xD1\xE0\x00\x34\x5B\xE5\xD7\xF7\xAD\x25\xFD\xC3\xDF\xF0\x29\xEE\xDA\x58\xFC\xBD\xC4\xFE\xDE\xF1\x02\xAE\x7D\xFD\x21\xF9\x1E\xD7\x66\xEF\xF7\x81\xA5\xFD\xFB\x1F\xFD\xE2\xD9\xC8\xF0\xC1\xCB\xFE\xFC\xFE\x9F\xFC\x21\xB0\xAA\xDE\xFA\x09\x4E\x84\xB9\xAA\xF2\xDB\xB0\xAF\xDA\xFF\x00\x01\xFE\x02\xAC\xF9\xF1\xFB\xC7\xF0\xD1\xBC\xC5\xD6\x24\xD8\xEF\xFC\x42\xDF\x81\xD9\xF1\xD3\x79\xE4\xFF\xC0\xFD\x46\xFD\x23\xAC\xC8\xD9\xFA\xF8\xE1\xE6\xF1\xE7\xBD\x88\x14\x1B\xFC\xF7\xFF\xF5\xFA\xE5\xD4\xE1\xF4\xF3\xEE\xBC\xB2\xFC\x40\x7E\x27\x7E\x2A\x01\x32\x6F\x4F\x6F\x5E\x7C\x48\x63\x6E\x6B\x93\x11\x66\x57\x5F\x7E\xF2\x7D\x3C\x6F\x6F\x57\x6F\x7E\xF3\x53\xEF\x7F\xB7\x7A\x48\x07\x76\x57\x5D\x6C\x13\x6F\xF7\x6C\xF9\x6E\x60\x7E\x0C\x7E\xE5\x5B\x16\x53\xD6\x7F\x07\x80\x28\x6D\x48\x26\x0B\x80\xC2\x7F\x63\x6F\x29\x53\x1D\x80\x2D\x61\xD7\x6C\x54\x7E\xEA\x7F\x30\x6F\x48\x6D\x59\x7E\x05\x80\x11\x80\xF5\x7E\x42\x6D\x0B\x5C\x11\x12\x21\x80\xDF\x7F\x4C\x6F\x63\x7E\xA5\x5A\x2E\x80\xE9\x74\x3C\x73\x69\x7E\x37\x80\xD7\x7F\xBE\x6B\x81\x6F\x5A\x6B\x38\x80\x50\x6A\x73\x7E\x9D\x6C\x74\x7F\x9C\x31\x19\x7E\x7A\x7E\xAC\x63\x31\x0A\x96\x00\xDB\x73\xEA\x7E\x54\x54\x78\x05\xD0\x54\x40\x66\x5B\x66\x59\x18\x2D\x33\x0E\x55\xA3\x05\x23\x11\xBD\x0F\x98\x6E\xCB\x0F\xA3\x7E\x24\x74\x3D\x74\x97\x00\x9B\x7E\xEB\x52\x48\x33\xAE\x6B\x00\x4D\x7D\x51\x7B\x7A\xED\x6C\x81\x54\x0A\x54\x81\x5C\x80\x7E\x63\x80\xAF\x28\xFC\x53\x73\x7F\x27\x66\xF9",
"\x65\x50\x66\x21\x52\xE7\x7F\xF5\x6C\x43\x7C\x5F\x53\x6A\x7F\x2A\x01\xA6\x53\x51\x7F\x69\x80\x62\x80\x68\x5C\x84\x07\x6D\x80\x41\x66\x6F\x80\x73\x5C\xBF\x7E\xEA\x6B\xB8\x53\x93\x02\xD7\x5A\x7B\x80\xAA\x5A\x6B\x80\x7E\x80\x12\x54\xF7\x53\x83\x5C\xF9\x65\x60\x7B\xCA\x53\x39\x6C\x88\x80\x32\x6C\x8A\x80\x61\x07\x7F\x80\x52\x80\xEB\x57\x9B\x53\xAE\x07\x88\x53\xDA\x53\xF5\x53\xE3\x53\x24\x01\xDD\x53\x02\x6A\x87\x80\x64\x64\x95\x80\x0F\x61\x89\x68\x8D\x80\xEC\x53\x82\x80\x7C\x01\xEF\x53\x41\x74\x7A\x80\xA4\x80\x7D\x80\x96\x80\x8C\x80\x5F\x5C\x3B\x1E\x99\x51\x07\x54\x0B\x74\xA2\x5C\x93\x80\x67\x5C\xB6\x4C\xEA\x4C\x97\x80\x53\x5C\x81\x80\xD2\x4F\xD8\x6F\x3E\x80\x08\x0A\x77\x4B\x98\x00\xD5\x7D\x86\x53\x5A\x6B\x70\x5C\xDD\x50\x07\x58\xFE\x28\x75\x80\xE6\x57\x27\x6A\x99\x80\x1E\x66\xAD\x09\x2C\x58\xA1\x10\x08\x7E\xE8\x0F\xA3\x53\x8B\x6F\x7A\x6F\x26\x79\x4B\x75\xF3\x53\xC9\x80\x2C\x6E\xFE\x4F\x7A\x5C\xA2\x53\xB2\x80\x71\x5C\xD0\x80\x61\x33\x9E\x5C\x9A\x5D\x85\x80\x51\x7F\xDD\x80\x0B\x0A\xCB\x80\x4D\x33\xBD\x80\x2E\x66\xBF\x80\xEC\x57\xDA\x7A\x89\x7E\x2A\x01\x91\x80\xFE\x6C\xEA\x80\x07\x0A\xEC\x80\x47\x1E\xEE\x80\x4C\x66\x8D\x28\x70\x80\x9C\x80\x33\x52\x9E\x80\x66\x11\xA1\x80\xB9\x75\x65\x5B\x76\x5C\x0E\x52\xF9\x80\xD6\x80\xE2\x80\xCC\x60\xE4\x80\xFB\x4C\x55\x52\xF0\x53\xE9\x80\x0F\x52\x08\x81\xA7\x10\xFB\x80\x8E\x80\xAA\x80\xD7\x57\xB6\x80\x01\x01\x09\x54\xBA\x7F\x6D\x5C\x0D\x52\x12\x81\xE1\x80\xA7\x80\xB3\x80\xFD\x80\x16\x81\x65\x80\x82\x09\x44\x54\x5B\x80\xE2\x7A\xBF\x5C\x36\x54\x27\x81\xC8\x5C\x21\x59\xFD\x06\x8D\x7A\xDE\x80\x8B\x4F\x76\x5D\xE4\x1F\x07\x66\xF2\x58\xA0\x5C\x85\x02\xA2\x5C\xB0\x5C\x47\x66\x0A\x17\xC4\x6B\x8A\x6D\x9E\x33\x63\x4B\xD5\x47\x96\x6C\xB9\x7F\xD9\x7D\x78\x05\xFA\x6D\x47\x66\x03\x1F\xDD\x7D\x46\x62\xB6\x6C\x05\x70\xF6\x7F\x2E\x5C\xCC\x77\x8A\x7E\x74\x16\xA5\x5A\x45\x81\x0A\x66\x3D\x61\x18\x51\x02\x6C\x26\x6F\x3F\x6F\xB7\x5C\xE2\x5F\xCF\x31\xCE\x7F\x10\x56\x33\x80\xEB\x7F\xE0\x7F\xE0\x6C\xFE\x6C\x52\x81\xA4\x58\x03\x1F\xFA\x7D\x04\x6F\x18\x6C\xF4\x7F\x00\x80\xD3\x7F\x02\x80\xE1\x7F\xF6\x7D\x63\x81\x84\x58\x65\x81\x43\x6B\x73\x80\x09\x7E\x29\x80\x47\x80\x55\x6D\xFC\x6C\x6E\x81\x5A\x81\x37\x39\x2E\x6C\xF3\x7F\x17\x80\x15\x6F\x56\x7E\xC3\x7F\x1B\x80\x25\x6F\x63\x6D\x6F\x81\x57\x6D\x54\x81\x1D\x6F\x9A\x6B\xA2\x56\x21\x7E\xFE\x7F\x49\x6F\x86\x6C\x19\x80\x0D\x80\x5D\x57\x79\x81\x99\x61\x5B\x81\x1D\x6D\x2F\x7E\x5E\x81\x2A\x80\x77\x81\x24\x6D\x33\x6F\x85\x81\xB2\x4B\x71\x81\x02\x6F\x3B\x7E\x15\x80\x8C\x81\x24\x7E\x8E\x81\x0C\x80\x57\x7E\x87\x6B\x0F\x80\x9D\x0B\x9C\x81\xA8\x5E\x6B\x07\x1F\x80\xD3\x4D\x97\x81\x76\x81\x24\x6F\x4E\x7E\x57\x81\x2A\x7E\xD1\x54\x3C\x61\x9E\x81\x60\x6F\x43\x6D\x77\x6C\x69\x81\xA4\x81\x22\x80\xD3\x5B\x2C\x80\xD8\x7E\x01\x01\xAA\x81\xFF\x6D\xD8\x7F\xB4\x56\x83\x6C\x32\x80\x75\x81\x4C\x81\x09\x6F\xB3\x6B\x86\x81\x51\x81\x7A\x81\x0F\x47\x5F\x66\x3B\x80\xC7\x7F\xC1\x81\xCE\x81\x2F\x4E\xC2\x80\x1A\x7D\xB3\x81\xD7\x52\xC2\x81\x6B\x61\xAE\x05\x7B\x72\x16\x7E\x9C\x4B\x36\x7D\x75\x7F\x78\x7E\x1A\x80\x7F\x6F\xD8\x80\xC8\x7E\xD7\x7D\x51\x7F\xEE\x6D\x23\x6B\xB7\x6B\x28\x74\xDE\x7D\xD2\x7E\x34\x80\x23\x7E\x9F\x62\xE4\x7D\xDA\x69\xE9\x81\x7A\x6B\x09\x03\x92\x5C\x02\x01\xD8\x58\x28\x81\x2A\x01\xF0\x6E\x0A\x54\xF4\x81\x8B\x6B\x5D\x6B\xB8\x81\xF6\x6E\x0B\x6C\xBB\x81\xDB\x6C\xEF\x81\x48\x6D\x61\x81\xFD\x81\xB6\x6B\x35\x06\x9F\x81\x34\x6B\xDD\x7F\x04\x82\xEA\x6C\xB0\x81\xD4\x7F\xE2\x7F\x33\x6F\xFE\x81\x6C\x6E\x0B\x82\xE6\x7F\xE6\x72\x37\x56\x46\x6B\x0F\x82\x70\x6F\x33\x7E\xCA\x81\x29\x6C\xA8\x81\x78\x05\x15\x82\xF3\x6D\x00\x82\x89\x81\xF2\x7F\x19\x82\xAF\x81\xC9\x81\xF4\x7D\xD3\x52\xF6\x7D\x23\x82\x87\x62\xA7\x6B\xF1\x7F\x5A\x56\x8B\x81\x29\x82\x1E\x82\x2B\x82\x91\x81\x21\x82\xBC\x5C\x41\x6B\x25\x82\x39\x7E\x6D\x56\x96\x81\xC8\x81\x35\x82\x0D\x7E\x08\x0A\x9A\x81\x05\x80\x2E\x82\x10\x50\x30\x82\xDC\x76\x47\x7E\x29\x6D\xA1\x81\x34\x82\x01\x80\xF7\x7F\x42\x7E\x38\x82\xC1\x54\x0A\x82\x8D\x07\xAD\x81\xB2\x50\x4C\x82\x6B\x81\x4E\x82\x70\x6C\x2D\x82\x52\x82\xC8\x06\x53\x7E\xEC\x58\x56\x82\x17\x6F\x2B\x80\x5A\x82\xC2\x6B\x5C\x82\x30\x80\xC6\x81\x3A\x02\x5F\x82\x59\x6F\x6C\x81\x36\x80\xD2\x81\x31\x01\x63\x82\xAE\x6E\xDB",
"\x73\xD1\x81\x75\x6F\x39\x82\x50\x6B\xBD\x6B\x7B\x7E\xD7\x81\x63\x6D\x45\x82\x5A\x4D\xC3\x01\xDD\x81\xF0\x81\x86\x6F\xE1\x81\x11\x82\xE8\x6E\x77\x80\xD6\x7D\x0D\x6B\xA2\x5C\xE1\x6D\x53\x81\xD5\x5C\xE3\x6E\x49\x81\xE5\x6E\xBD\x81\x79\x57\xFC\x6B\x45\x7F\x01\x01\x86\x82\xD4\x5C\x4F\x39\xE9\x7D\x50\x82\xDC\x7F\xB6\x5F\x21\x20\x5C\x81\xF7\x6E\x7E\x81\xFE\x7D\x80\x81\x23\x80\xFD\x6E\x5A\x6B\x91\x82\x84\x58\x98\x82\x28\x6D\x17\x6C\x2C\x6F\x48\x80\x8D\x81\x05\x82\x5F\x81\x01\x7E\xF6\x7D\xA1\x82\x86\x81\xA3\x82\xE5\x6C\xD5\x80\x38\x56\x1C\x82\x2D\x6D\x2A\x82\x41\x82\x2A\x01\xED\x7F\x05\x80\xAD\x82\x7A\x74\x4F\x39\x7C\x81\x28\x82\x3F\x82\x4D\x82\x34\x7E\xF8\x7F\xAC\x82\xDF\x5E\xAF\x82\x01\x82\xB9\x4E\x55\x57\xB3\x82\x3A\x6D\xC0\x82\x1F\x82\x03\x80\xC3\x82\x97\x82\xBC\x82\x95\x81\x6F\x6B\x39\x6F\xC9\x82\x46\x6D\x60\x82\x99\x81\xCE\x82\x0A\x60\xC5\x82\x26\x82\x3A\x7E\x4A\x82\x46\x6F\xF6\x6C\xDE\x81\x14\x6D\x8F\x81\xA6\x81\x1C\x80\x95\x82\xBA\x82\xB8\x54\x04\x4F\x33\x6B\x20\x80\xBF\x82\x57\x82\xC1\x82\xF4\x5B\xD8\x82\x3C\x61\xDA\x82\x3C\x82\xF0\x70\x28\x80\xD4\x82\x07\x6F\x90\x81\x7C\x6C\xEF\x82\x0D\x61\xF1\x82\x31\x82\x3E\x6C\x66\x82\xA9\x57\x9B\x82\xD2\x7F\xD6\x82\xB1\x81\x56\x6D\x5B\x53\x6C\x82\xE6\x82\xE6\x6D\x04\x4F\xD0\x81\xBA\x6B\x06\x83\xC4\x82\x93\x82\x76\x82\x97\x6C\xF9\x82\x47\x66\x21\x20\x7C\x82\xA7\x82\x19\x81\x45\x80\xCA\x57\x80\x82\xE2\x6E\x03\x74\xEC\x64\x37\x81\x05\x81\x9E\x53\xB6\x5F\x3B\x81\x73\x7E\x3D\x81\x4E\x58\x33\x29\x87\x51\x96\x6C\xFD\x01\x60\x49\x3C\x73\x84\x03\x9D\x00\xD5\x7D\x77\x4B\x3F\x1F\x2B\x81\xB1\x5C\xD8\x73\xA5\x00\x5F\x80\x9B\x4C\x82\x20\x48\x09\x62\x69\xB0\x2B\xB2\x02\x48\x74\x02\x01\x9F\x00\xAF\x6D\x62\x6A\xB3\x73\xCA\x04\xB0\x2B\x37\x83\xB4\x69\xB0\x2B\x08\x53\x6B\x5D\x82\x20\x39\x74\x6B\x66\x5F\x55\x02\x01\xA1\x00\xAF\x6D\x5B\x45\xC9\x5B\xB6\x69\x42\x83\x30\x51\x44\x83\x9A\x29\xFF\x04\x4F\x83\xA9\x69\xF1\x14\x97\x53\xFD\x09\x37\x51\x02\x6A\x50\x65\x8B\x54\x4D\x83\x6C\x5C\x19\x00\x4B\x74\x64\x64\x36\x83\x53\x83\xEA\x69\x45\x83\x02\x01\x62\x83\x04\x6A\x69\x01\x5A\x83\x06\x09\x5C\x83\x04\x81\x5E\x83\x25\x0A\xA2\x00\xAF\x6D\x17\x00\x63\x83\xAF\x63\x65\x83\x6F\x83\xFD\x69\x94\x33\xFF\x04\x75\x83\x6B\x83\x58\x01\xD3\x73\xE2\x08\xA0\x42\xEE\x42\x1B\x7F\x71\x83\x02\x01\x22\x27\x6C\x5C\x15\x00\x76\x83\xE0\x5F\x78\x83\xB2\x2B\x38\x83\x55\x83\x05\x01\x47\x83\xB0\x2B\x6D\x83\x7D\x09\x79\x83\x12\x51\x9F\x39\x8C\x4B\x8D\x6D\x01\x01\xA3\x00\xAF\x6D\xE3\x28\x50\x83\x83\x56\x8C\x83\x56\x34\x8E\x83\x7E\x2A\xFF\x04\x9D\x83\x58\x83\x6C\x83\x83\x56\x37\x3E\x43\x83\x70\x83\xD5\x68\x26\x03\x25\x0A\xD5\x36\x54\x54\xD0\x00\x04\x6C\x51\x83\x49\x4F\x66\x83\x7A\x83\x3D\x35\xFF\x04\xB1\x83\x7E\x83\xDB\x76\x1C\x09\x62\x47\x33\x3C\xC2\x39\x84\x83\xAC\x83\x4D\x02\x25\x0A\x60\x83\x70\x55\xBB\x00\xB2\x83\x9F\x83\x52\x83\x79\x83\x2C\x37\x8F\x83\x01\x01\xC6\x83\xBA\x83\x49\x66\xEB\x04\x41\x47\xD4\x06\xC0\x83\x91\x6A\xB3\x05\xC3\x83\xAF\x6D\xB9\x00\xC7\x83\xA7\x56\xA0\x83\x96\x36\xA2\x83\x7B\x83\x02\x01\xD9\x83\xCF\x83\xCF\x68\x17\x40\x44\x3E\xA1\x83\x5D\x83\xC1\x83\xEE\x02\x25\x0A\xA0\x00\xAF\x6D\xB9\x27\x40\x83\x6F\x2A\x7E\x2A\xAA\x83\xB6\x83\xF1\x14\xFF\x04\xFA\x69\x31\x6A\x7E\x2A\x97\x53\x65\x09\x04\x2C\x35\x3A\x64\x3C\x8D\x83\xE7\x83\xD5\x83\x6D\x6E\xBD\x5D\x74\x83\xDA\x83\x80\x7E\xDC\x83\xA7\x37\xDE\x83\xB7\x83\x8E\x6D\xF0\x69\xA7\x83\xEB\x80\x6E\x83\xFD\x83\x86\x81\x0A\x17\x30\x83\xBF\x66\x08\x0A\x14\x0B\xC4\x83\x6F\x7A\x98\x7A\x97\x7F\x39\x78\x77\x01\xFB\x68\xA4\x3A\x36\x6A\xBA\x7C\xFE\x78\xBC\x7C\x69\x7D\x88\x7D\x77\x79\xC6\x7D\xC6\x79\xC8\x7D\x5B\x71\x8E\x7D\x3E\x71\xD6\x7A\xA6\x69\xB4\x7A\x98\x70\xDA\x7A\xB7\x7A\xA9\x77\x1A\x74\xED\x61\x14\x7F\xF3\x75\x1F\x5D\x5D\x7F\x3C\x5E\x62\x59\x87\x64\x65\x69\xED\x7C\x24\x7D\x85\x78\x1B\x75\x06\x7A\x61\x79\xBE\x7C\x57\x7B\x4C\x7D\x28\x7A\x4E\x7D\x8A\x7C\x3A\x7C\x8C\x7C\x86\x66\xBD\x7E\x2D\x84\xBF\x7E\x2F\x84\xDD\x7A\x37\x03\xDF\x7A\x06\x7E\xA2\x74\xFA\x81\x83\x82\xA5\x74\x03\x7C\x38\x84\x1B\x84\x13\x3C\x1D\x84\x46\x7D\x1F\x84\x48\x7D\xBD\x7C\x5C\x7A\x4B\x7D\xF2\x7A\x4D\x7D\x60\x7A\x4F\x7D\x96\x79\xE0\x7C\x61\x71\x69\x7F\xCF\x7E\x13\x6B\xB5\x6C\x8B\x82\x36\x09\xA1\x7E\x00\x61\xCE",
"\x6B\x4C\x83\x34\x83\xBD\x08\x98\x6D\x29\x01\xF1\x83\x4A\x83\x08\x70\xD7\x7E\xD7\x7A\xF3\x53\xCB\x69\x63\x6A\xB2\x68\x82\x7D\xAA\x72\x84\x7D\xC0\x79\x6F\x7B\x4B\x72\x84\x7C\x4F\x72\xA4\x7C\xC7\x7B\x88\x7C\x18\x7C\x57\x7C\xB1\x79\xA7\x6A\x29\x84\xCC\x7D\x48\x67\x19\x7B\x59\x7D\x0C\x08\x1C\x7B\xEF\x74\xD4\x7E\xF0\x59\xE3\x7E\xC0\x75\x7C\x84\xBB\x6A\x64\x6A\x3B\x84\x56\x7A\xE6\x78\x6D\x7B\x85\x7D\x83\x84\x51\x71\xA7\x7D\x5E\x75\xCF\x76\xAA\x7D\x0E\x71\xAC\x7D\x9F\x7B\xAC\x7C\xDC\x78\xAE\x7C\x90\x84\x1C\x78\x99\x84\x39\x84\xBC\x6A\x9D\x84\x7E\x7C\xC0\x7D\xBC\x7B\xC2\x7D\xD8\x77\x0F\x7B\x31\x79\x11\x7B\x43\x7A\x13\x7B\x2E\x7D\xC4\x7C\x30\x7D\xC6\x7C\x20\x7C\x60\x7B\xEF\x7E\xCD\x74\x9A\x84\xAC\x69\x3A\x84\x23\x7D\x9E\x84\x5D\x79\xA0\x84\x82\x84\x49\x7D\x84\x84\x60\x84\xA9\x7D\x62\x84\xF4\x7A\x64\x84\x62\x7A\x66\x84\xD5\x6F\x4A\x84\x9A\x74\xA6\x77\x2F\x80\xDB\x80\xA0\x67\x9D\x70\x4E\x75\xFA\x7E\xDD\x7B\x1B\x7F\x71\x07\xB1\x84\x9C\x84\xC9\x84\xB4\x84\x22\x78\xC1\x7D\xF0\x7C\x0E\x7C\xA5\x7D\x9F\x7C\xC2\x7B\xA8\x7D\x85\x7C\xA7\x84\x9C\x7B\xA9\x84\xD5\x76\xD6\x84\xE7\x74\xCE\x7B\x68\x7A\xF5\x1B\xF7\x7B\x1D\x6F\x9A\x5E\x2C\x7F\xD7\x7B\x77\x75\x1E\x7F\xF8\x70\x0C\x7F\xE1\x84\x02\x6A\xE3\x84\x58\x84\x85\x3C\x5A\x84\x83\x7D\x5C\x84\xA1\x84\xCE\x84\xA3\x84\x85\x84\x6C\x72\x87\x84\x54\x7C\xC7\x79\xA7\x7C\x19\x7C\x52\x79\x65\x84\xAE\x7D\xE1\x7C\x8E\x7C\xB1\x7F\x88\x73\x74\x78\x17\x7F\xD4\x7B\x1C\x7F\x75\x75\xFE\x84\x98\x75\xA0\x78\x9D\x78\xF9\x70\x7B\x75\x51\x75\x4A\x59\x06\x85\x72\x47\x7F\x84\x39\x75\x81\x84\x26\x7D\x60\x79\x8E\x79\x22\x84\x90\x79\x24\x84\xD1\x7A\x6E\x7D\xD3\x7A\xCA\x7D\xFB\x7C\x8F\x84\x10\x7F\x1A\x85\x27\x7F\x6E\x53\xB0\x18\xBB\x78\x21\x01\xAB\x7B\x9D\x78\xFF\x7B\x09\x68\x01\x7C\x13\x5F\xA8\x64\xC6\x84\x07\x6A\x2C\x67\xD1\x7C\xF2\x77\xB7\x84\x88\x78\xC4\x7D\x0D\x7D\xF6\x7C\x99\x77\x12\x85\xA0\x68\xF0\x7B\x46\x7A\xF2\x7B\x48\x7A\x18\x7B\x43\x71\x0E\x07\xF4\x74\x48\x85\xC8\x70\x08\x6A\x66\x7D\xD4\x74\x69\x7C\x2F\x7C\x6B\x7C\xA6\x7D\x0E\x85\xDB\x74\xF1\x84\x38\x7C\x46\x84\x14\x7D\x48\x84\x3C\x7C\x6B\x79\x09\x52\x3F\x7C\xB0\x84\x29\x85\x4D\x44\x2B\x85\x33\x76\x2D\x85\x8C\x79\x27\x7D\x40\x84\x5F\x84\x26\x7A\x43\x84\x59\x7B\x45\x84\x5B\x7B\x8B\x7C\x5D\x7B\x8D\x7C\x5F\x7B\x06\x5E\x13\x76\x77\x53\x6E\x53\x5D\x85\xD4\x83\xE7\x6A\x55\x62\x48\x7C\x71\x77\xEA\x84\x9D\x7C\xEC\x84\xD6\x7C\x6D\x7C\xF5\x7C\x33\x85\xF7\x7C\x35\x85\x73\x7C\x37\x85\x8F\x7D\x76\x7C\x2C\x73\x32\x6C\xC5\x84\xE4\x84\x7E\x84\xB3\x84\x1E\x84\xEF\x7C\x20\x84\x6A\x7C\xC0\x7B\x29\x78\xCF\x7A\x94\x85\x52\x85\x26\x84\xB9\x71\x1B\x7C\x59\x7C\x99\x85\x39\x85\x7D\x7F\x9A\x7F\xFC\x79\x4F\x7F\xB7\x5A\x5C\x85\x9E\x85\xFC\x68\x6C\x68\x3C\x84\x76\x85\xD6\x77\x3F\x84\x30\x85\xB9\x84\xA7\x85\x6C\x7D\x8B\x7D\x96\x85\xF9\x7C\x98\x85\x8E\x84\x58\x85\xC7\x7C\x5F\x76\x58\x79\x71\x85\x7D\x84\xB7\x85\x08\x85\x80\x84\x0A\x85\xCD\x84\x5E\x84\x83\x7C\xD0\x84\xF0\x84\xD2\x84\xAB\x7D\xD4\x84\xF6\x7A\x6C\x85\x16\x7D\x3D\x7C\x2A\x01\x7A\x76\xCA\x85\x9B\x84\x9F\x85\xE6\x84\xA1\x85\x08\x7D\x61\x85\x4B\x7C\xC3\x7D\x31\x85\xEC\x7B\xBB\x84\xEE\x7B\xBD\x84\x55\x85\x2F\x7D\x57\x85\x31\x7D\xC2\x84\x60\x7F\xE5\x7C\x80\x7E\x05\x85\xCB\x85\x1C\x84\x74\x85\x51\x77\xBA\x85\x86\x78\xBC\x85\xEA\x7B\xE7\x85\x6B\x7D\xE9\x85\x6D\x7D\xEB\x85\x6F\x7D\x56\x85\x71\x7D\xC6\x85\x0E\x65\xAC\x76\xCA\x64\xDE\x85\xC7\x84\xB2\x84\xE1\x85\x5B\x84\xA2\x85\x5D\x84\x21\x84\xBE\x85\x89\x7D\xC0\x85\xC7\x7D\x8C\x7D\x27\x84\xC4\x85\x57\x72\xFC\x7C\x83\x85\xE5\x81\x10\x83\x1B\x7D\x02\x7B\x28\x85\xF5\x85\x59\x84\xF7\x85\xD4\x77\xF9\x85\x3E\x84\xE9\x7B\x87\x7D\x11\x86\x23\x84\x13\x86\x25\x84\x15\x86\xAB\x85\xDE\x7C\xAD\x85\xC5\x85\xEF\x85\xE2\x66\x7F\x7F\x31\x73\x80\x80\xC8\x6B\x46\x80\x85\x7F\x08\x61\x83\x72\x3E\x7B\x9A\x7A\x1F\x86\xDF\x85\xCC\x85\x22\x86\xC8\x78\x0E\x86\x0B\x85\xD1\x85\x4A\x7D\x7B\x85\x61\x84\x44\x84\x63\x84\x6A\x85\x50\x7D\xD9\x85\x52\x7D\x00\x77\x43\x80\x7D\x73\x06\x0A\x9D\x72\x2A\x70\x1B\x08\x84\x7F\x92\x7E\xD9\x79\xFD\x79\x16\x5B\x1B\x7A\x57\x84\x20\x86\x07\x85\x40\x86\x13\x79\x4C\x85\x8E\x85\xA4\x7D\x64\x85\xED\x84\xD7\x7C\x93\x85\x2A\x86\x34\x85\x01\x86\x36\x85\x03\x86\xCB\x7D\x05\x86\xFE\x7E\xB1\x85\x72",
"\x7E\xB3\x7F\x75\x7E\xD2\x82\x19\x74\x79\x7D\x94\x7F\x79\x65\x52\x7A\x5B\x86\x3E\x86\xF6\x85\xA0\x85\x0D\x86\xE3\x85\x2C\x7B\x87\x78\xD7\x74\x4F\x85\x1A\x79\x51\x85\x4E\x79\xAA\x85\x94\x74\x28\x84\x18\x86\xAF\x85\xA4\x7F\xA6\x7F\x11\x7E\x1B\x02\x76\x7D\x9D\x7F\x97\x08\x34\x7A\xA0\x7F\xCA\x50\x78\x86\x1A\x84\x5C\x86\x2A\x85\x7C\x86\x09\x85\x42\x86\xD0\x85\x10\x86\x29\x7D\xBA\x84\x2B\x7D\xBC\x84\x2D\x7D\xEC\x85\xBF\x84\xEE\x85\xC1\x84\x6E\x86\x8C\x86\x1E\x7E\xB4\x7D\x55\x6F\x94\x61\xAB\x7F\x06\x73\x95\x86\x88\x85\xFE\x83\x8A\x85\x5C\x63\x4B\x85\x3E\x78\x43\x86\x9D\x86\x41\x84\x2A\x7D\x7C\x85\xC1\x7C\x7E\x85\xC3\x7C\x80\x85\xC5\x7C\x82\x85\xAF\x7F\xA8\x86\x8E\x7F\x02\x7F\x68\x77\xBF\x51\x1C\x32\xC0\x61\x90\x6F\x36\x84\x6E\x53\xD2\x69\x7A\x86\x21\x86\x99\x86\xCE\x85\x9B\x86\x2E\x85\x86\x7D\x4E\x69\xFD\x85\xC5\x7D\x67\x86\x95\x85\x69\x86\x97\x85\x6B\x86\x38\x85\x98\x74\xD8\x84\xA5\x77\xB2\x7E\xC9\x1D\xB4\x7E\xB4\x6F\xBB\x7A\x91\x75\xBD\x7A\x35\x84\x18\x84\xE6\x7C\x00\x00\xCC\x86\x0A\x86\xE5\x84\x8B\x85\xB4\x86\xE7\x7B\x77\x85\x2F\x85\xFC\x85\x28\x86\x32\x85\xD7\x86\xA9\x85\x2C\x86\x87\x86\x17\x86\xDC\x72\x99\x79\xA8\x18\x7E\x7B\xF4\x7E\xB3\x7E\xF6\x7E\xD5\x59\x1E\x62\xE0\x7A\x39\x80\xAA\x7E\xB8\x7F\xC1\x66\x65\x68\xEB\x86\x49\x85\xE8\x83\x6C\x66\xBF\x7D\xE8\x84\xB6\x84\x61\x86\xE6\x85\xF4\x86\xE8\x85\xA0\x86\xEA\x85\xA2\x86\x02\x86\xED\x85\x04\x86\x31\x86\x90\x84\x91\x5D\xD0\x7E\xE6\x77\xEE\x81\x49\x62\x5C\x7D\x7D\x73\xEB\x77\xDC\x4E\xCD\x74\x0A\x87\x5E\x85\x4A\x85\x0E\x87\x57\x7A\x10\x87\xA3\x85\x63\x85\xA5\x85\x31\x7B\xD6\x86\xFF\x85\xC1\x85\xD9\x86\xC3\x85\xDB\x86\xAE\x85\x6D\x86\x1C\x87\xEA\x74\xF8\x79\xDE\x7E\xCF\x5D\x95\x84\xE1\x7E\x07\x78\x20\x7B\x41\x7C\x3C\x5F\x01\x01\x27\x87\x89\x85\xC8\x84\xEE\x86\x2A\x87\x9F\x84\xEC\x7A\x2D\x87\xD4\x7C\x9E\x7C\x91\x85\xA4\x84\x41\x7A\x05\x76\xF7\x86\xC2\x85\xC9\x7D\x36\x87\x30\x86\xA6\x86\xAE\x84\xE8\x7E\x13\x75\x45\x87\xB1\x86\x47\x87\xB3\x86\x49\x87\xCB\x84\x4B\x87\x0F\x86\xA4\x85\x0C\x7D\x83\x86\xA8\x85\x85\x86\xF8\x86\x29\x75\x88\x86\xFB\x86\x90\x7D\x42\x7F\xC3\x84\xCA\x86\xF3\x53\x5C\x87\xAB\x83\xFF\x83\x48\x87\xB9\x85\xCF\x85\xD2\x86\xA2\x84\xE5\x79\x66\x85\x3B\x76\x68\x85\x12\x7D\x4A\x86\x16\x85\x4C\x86\x95\x70\xCF\x77\x48\x75\x78\x62\x4D\x84\x79\x74\xF8\x7E\x63\x71\x54\x78\x03\x85\x04\x81\x78\x05\x72\x87\xBB\x4B\x29\x87\x76\x87\xD1\x86\xF1\x86\xD3\x86\x4A\x72\x0D\x85\xD3\x85\x86\x84\x7D\x87\x08\x76\xF3\x84\x9F\x77\xF5\x84\x0F\x75\x4C\x7F\x26\x7F\x7C\x63\x71\x86\xC5\x70\x3A\x02\x41\x85\x30\x7F\x43\x85\x0B\x7F\xB1\x7B\xFA\x70\x60\x7D\x8E\x87\x77\x84\x60\x85\x7F\x86\xFB\x85\x27\x86\x9E\x86\xBF\x85\x32\x87\x14\x86\x54\x87\x16\x86\x56\x87\x89\x86\x38\x87\x3A\x85\xF8\x84\xB6\x6F\xA2\x87\xD3\x7B\x40\x85\xFD\x84\x5E\x85\xD8\x7B\x22\x63\x24\x85\xDC\x7B\xAA\x87\x3E\x7D\xAC\x87\x99\x66\xCA\x84\x72\x79\x62\x87\xB6\x86\x64\x87\x82\x86\x4A\x79\x84\x86\x74\x7B\x89\x84\x13\x85\x8B\x84\xF0\x79\x8D\x84\xB9\x87\x1B\x87\xBB\x87\x44\x7E\x88\x81\x3D\x85\x29\x7F\x3B\x50\xB7\x75\xC1\x87\x1B\x7F\xC3\x87\x83\x7E\xC1\x78\x2A\x01\x32\x7F\xC0\x75\xC9\x87\xC7\x69\xFD\x68\x91\x87\x7E\x86\x68\x7C\xE5\x85\xB8\x84\xB2\x87\x12\x86\xB4\x87\x2B\x86\xB6\x87\x2D\x86\x6B\x87\x2D\x75\x19\x86\xB6\x79\x5A\x85\x8D\x5A\xA8\x64\xEA\x87\x5F\x85\x8C\x85\xA2\x79\x11\x87\xF1\x87\xB8\x86\x9F\x86\xBA\x86\x2C\x7D\xBC\x86\xBE\x84\xBE\x86\xC0\x84\xC0\x86\x06\x86\x6F\x85\xF8\x78\xFE\x87\xB6\x85\x7B\x86\x0C\x86\x9A\x86\xEE\x87\x4A\x7C\x80\x86\x84\x75\x13\x87\xFE\x85\x15\x87\x00\x86\x17\x87\x6A\x86\x19\x87\x6C\x86\xDA\x87\xBC\x7E\x84\x85\xC8\x7F\x14\x76\xCB\x86\x12\x88\xCE\x86\x14\x88\xD0\x86\x16\x88\x4D\x85\x81\x86\xD5\x86\x50\x85\x67\x87\xD3\x87\x53\x85\x76\x6A\x55\x87\x20\x88\xDC\x86\x2B\x61\x2E\x76\x56\x84\xEA\x86\x28\x88\x5D\x86\xCF\x86\x2C\x85\x77\x87\x93\x87\x79\x87\x68\x72\x7B\x87\x57\x76\xD5\x85\xA8\x84\xD7\x85\xAD\x7D\x81\x87\x18\x85\x98\x7F\xC2\x86\x08\x77\xB3\x85\x49\x76\x3F\x72\x44\x87\x3C\x88\x98\x86\x2A\x88\x3F\x88\x92\x87\xBB\x85\x26\x86\xD4\x86\x1A\x88\x31\x87\x1C\x88\x33\x87\x1E\x88\xDA\x86\x36\x88\x37\x87\x22\x88\x89\x87\x0C\x0A\x63\x64\xF4\x74\xFF\x87\x90\x87\xCB\x87\xBE\x79\xCC\x84\x78\x87\x0C\x85\x7A\x87\x97",
"\x87\x0F\x85\x99\x87\xBE\x77\x48\x88\xAA\x84\x9D\x87\x95\x76\xDB\x85\xFF\x00\xDD\x85\x33\x70\x68\x88\x0C\x87\xF5\x66\xEF\x86\x8B\x79\x58\x88\x78\x85\xBD\x85\xF2\x87\x29\x86\xF4\x87\x68\x86\x5F\x88\x35\x87\x61\x88\x57\x87\x0D\x88\xE2\x66\x85\x79\x99\x76\x67\x88\x53\x88\x73\x85\x3E\x88\x75\x85\x40\x88\x81\x88\xF2\x86\xB1\x87\x05\x88\xB3\x87\x5D\x88\xB5\x87\x34\x87\x35\x88\xA4\x86\x1A\x87\x58\x87\xE9\x61\x07\x86\x3E\x72\xF3\x85\x02\x01\x7C\x88\x74\x87\x5F\x87\xED\x87\xA1\x7D\x0B\x7B\xEF\x87\x18\x88\x41\x78\x7A\x85\xBF\x7C\x07\x88\xA1\x86\x09\x88\xA3\x86\x0B\x88\xA5\x86\x8C\x88\x39\x87\x1B\x86\xC1\x76\x85\x72\xA7\x88\xB2\x86\x45\x64\xAA\x88\xB5\x84\x0C\x7C\x03\x88\x4E\x85\x2F\x88\x66\x87\xF6\x86\x68\x87\xF6\x87\xF9\x86\xB8\x87\x6C\x87\xFA\x87\x0E\x65\x33\x86\xF6\x5A\x35\x7D\x7E\x72\x17\x65\xD8\x79\x4E\x7F\x08\x0A\x84\x72\x95\x86\xBD\x88\x5E\x87\xBF\x88\x6A\x88\x6C\x7B\xCD\x87\x9C\x86\xCF\x87\xC5\x88\xD1\x87\x31\x88\x87\x7C\x33\x88\xAF\x79\x15\x85\xD5\x84\x17\x85\x67\x84\xBC\x73\x4F\x86\x93\x7E\x9C\x7E\x1A\x7B\xB2\x31\x06\x77\x22\x87\xB2\x85\xA3\x72\x5D\x6A\x5A\x86\x3B\x88\x72\x85\x6C\x47\x5E\x86\x43\x79\xAC\x88\x17\x88\xB0\x87\x5A\x88\x84\x88\xF5\x86\x86\x88\xD8\x86\x88\x88\x9E\x88\xB6\x88\xA0\x88\xB8\x88\xDB\x87\x66\x7E\x89\x6E\x71\x86\x15\x7A\x78\x7D\xA0\x4D\x7A\x7D\x2C\x5B\x1E\x86\x52\x88\xF8\x88\x40\x37\xAE\x87\xAD\x88\xFE\x88\x95\x87\x6F\x88\x46\x86\xD1\x84\x48\x86\xD3\x84\x7F\x87\xE8\x88\x4A\x88\xEA\x88\x19\x85\xBC\x87\x75\x7A\x9C\x7F\x11\x6F\xFA\x25\xA1\x65\x94\x86\xF6\x88\xD9\x88\x0B\x86\x75\x87\xDC\x88\xE6\x7B\x80\x88\xFA\x85\x59\x88\x19\x89\x43\x88\x70\x88\x67\x85\x46\x88\xF2\x84\x74\x88\xF4\x84\xE9\x88\x78\x72\x9F\x87\x6F\x86\xA5\x59\xC4\x86\x84\x6A\xC7\x65\x6A\x77\xAD\x86\x6C\x77\xD8\x88\x91\x88\xF9\x88\x93\x88\xF8\x85\x95\x88\x32\x89\x82\x88\xF3\x86\x00\x89\x14\x87\xB2\x88\x16\x87\xB4\x88\x18\x87\x9F\x88\x21\x88\xA1\x88\xB0\x85\x4D\x88\xCF\x7D\x41\x89\xD1\x7D\xBB\x3D\xB5\x7F\x47\x04\x4E\x81\x2A\x01\xA3\x7F\x37\x84\x4A\x01\x14\x89\x2B\x37\x01\x88\x80\x7C\x63\x87\x2E\x87\x65\x87\xE2\x88\xC7\x88\x32\x88\x86\x86\x6A\x87\xFA\x86\xF9\x87\x46\x75\x83\x87\x4C\x78\xB6\x7A\xDB\x84\xDC\x7A\x79\x74\xB5\x7E\xC5\x7E\x78\x76\xE7\x86\xAE\x7F\xE9\x86\xD9\x69\x97\x86\x92\x88\x55\x88\x94\x88\x57\x88\x4D\x89\x97\x88\xFF\x88\x99\x88\xF3\x87\x9B\x88\xF5\x87\x9D\x88\xB7\x87\x8A\x88\xD9\x87\x40\x62\xFE\x86\x49\x75\x78\x89\xC1\x7E\xDB\x6F\xC3\x7E\xDD\x6F\x04\x87\xC6\x7E\x06\x87\xE6\x81\x23\x62\x65\x68\x81\x89\xCD\x86\x3D\x88\x84\x89\x4B\x89\x86\x89\x25\x86\x4E\x89\x98\x88\xB0\x88\x42\x84\x47\x86\x7D\x85\x49\x86\x7F\x85\x47\x84\x81\x85\xCD\x7B\xF9\x7A\xE4\x77\xFB\x7A\x4A\x81\xE8\x77\x56\x86\x40\x87\xC4\x58\x71\x84\x40\x74\x01\x01\x68\x08\x6E\x34\x77\x08\x6D\x08\x9C\x2A\xB5\x83\x77\x84\x00\x7B\x79\x84\x2B\x84\x9D\x0B\xA0\x89\xEC\x86\xE0\x85\x2E\x89\xE7\x84\x2B\x87\xC2\x88\x4C\x87\xF1\x7C\x63\x86\x4F\x87\x44\x88\xA6\x84\x38\x89\x69\x85\xAE\x89\x6B\x85\xB0\x89\x6D\x85\x84\x79\xDC\x7E\x3B\x87\x14\x45\xDF\x7E\x2E\x70\x96\x84\x6F\x84\x41\x87\x13\x75\xC8\x89\x0B\x87\xA8\x88\xDB\x88\xCC\x89\x4A\x87\xE9\x84\xCF\x89\xEB\x84\xD1\x89\xA6\x85\x8B\x89\x52\x89\x1D\x88\x54\x89\x1F\x88\x56\x89\x37\x88\x58\x89\xBE\x66\xAF\x84\x33\x70\xE5\x89\x28\x87\x7D\x88\x7D\x7C\xE2\x85\xAB\x88\x2B\x7B\x17\x89\x33\x89\xE4\x79\x35\x89\x1B\x89\xD4\x85\x1D\x89\xD6\x85\x1F\x89\xD8\x85\xD9\x89\xDA\x85\xB2\x89\x12\x84\x78\x70\xE8\x86\xB3\x7A\xC7\x89\x48\x89\x15\x89\x68\x89\xA2\x7D\xC3\x88\x2E\x88\x5B\x88\x30\x88\x6E\x89\xE4\x88\x70\x89\x65\x75\xF8\x87\xD7\x76\x2A\x84\x01\x01\xF3\x7E\x94\x89\x00\x87\xD9\x7D\x50\x78\x82\x2E\x4F\x75\xC7\x87\x27\x85\x01\x01\xFB\x89\x46\x87\x2D\x89\xA9\x88\x2F\x89\x67\x7C\xFD\x88\x03\x8A\xD5\x7C\xEF\x89\x85\x88\x8C\x89\x87\x88\xF3\x89\x60\x88\xF5\x89\x62\x88\xF7\x89\xFD\x72\x3F\x89\x31\x68\xBE\x87\xD6\x67\x73\x75\x30\x7F\x07\x7F\x1D\x7F\x2F\x7F\x1F\x85\xBF\x06\x7E\x78\xCF\x70\x65\x89\x82\x89\x49\x89\xA3\x89\x23\x86\x4C\x89\xA6\x89\x88\x89\x34\x89\x32\x77\xD3\x89\x62\x78\x10\x85\x11\x7D\x9A\x87\x3A\x89\x9C\x87\x3C\x89\xF6\x84\x8C\x7F\x5A\x89\x3C\x85\xF3\x53\xA9\x7B\x49\x50\x17\x01\xA5\x87\x4A\x8A\x22\x07\x00\x85\xDB\x7B\xA2\x78\x8B\x87\xBB\x4B\x6F",
"\x0C\x14\x8A\x67\x89\x7F\x88\x04\x7A\x41\x88\x6E\x88\x05\x8A\xB1\x88\xAB\x89\xBB\x86\xAD\x89\xBD\x86\xAF\x89\xBF\x86\xB1\x89\x23\x89\xDC\x87\x45\x5C\x3D\x5A\xF8\x7B\xE0\x87\xBC\x78\xE2\x87\x20\x71\xFF\x84\x49\x8A\x1F\x7F\xE7\x87\x25\x71\xFA\x89\x71\x8A\xA6\x62\x73\x8A\x6C\x88\x75\x8A\x44\x86\xCF\x84\x06\x8A\x98\x87\xD5\x89\x7E\x87\xD7\x89\x4B\x86\x0C\x8A\x4D\x86\xC9\x7F\x08\x0A\x22\x7C\xA8\x64\x2E\x8A\x5D\x87\x30\x8A\xE8\x89\xFF\x89\xC1\x88\x49\x7C\x2D\x88\x19\x88\x50\x89\x1B\x88\xF1\x89\x5E\x88\x3B\x8A\x89\x88\x3D\x8A\x8B\x88\x7F\x8A\xCE\x63\x3D\x7F\xE4\x89\x8F\x8A\xF6\x62\x91\x8A\xDE\x88\x6D\x88\x94\x8A\x96\x87\x96\x8A\x71\x88\x98\x8A\x5C\x8A\x0A\x8A\x49\x88\x9C\x8A\xAF\x7D\xED\x7E\x5D\x7C\xEF\x7F\x15\x76\xA2\x8A\x73\x87\xBE\x88\x0D\x87\xC0\x88\x0F\x87\xCE\x89\x6A\x89\x4D\x87\x90\x85\x37\x8A\x01\x89\x39\x8A\x03\x89\xAF\x8A\x05\x89\x7D\x8A\x0C\x88\xB4\x73\x48\x7F\x3A\x88\xCA\x8A\x8F\x87\xFD\x89\x16\x89\x34\x8A\xA7\x89\x89\x89\xA9\x89\xB9\x86\x79\x8A\x08\x88\x7B\x8A\x0A\x88\xDA\x8A\xB7\x88\xB3\x8A\xC1\x86\x3B\x85\xD5\x88\x2A\x01\x92\x7C\xC0\x75\xDF\x8A\xAD\x87\x16\x8A\xFC\x88\xA9\x8A\xAF\x88\xD2\x85\xBE\x8A\x37\x89\x08\x8A\x47\x88\xC2\x8A\x75\x88\x5F\x8A\x9E\x87\x78\x88\x66\x88\xF4\x8A\xB7\x8A\xB3\x63\xF7\x8A\x01\x8A\xE3\x8A\x55\x8A\x04\x8A\x57\x8A\x36\x89\x7C\x87\xC0\x8A\x73\x88\x00\x8B\x3B\x89\x21\x89\x3D\x89\x78\x88\x7A\x88\xA1\x8A\x07\x8B\xC9\x66\xB9\x8A\xEB\x89\xD1\x8A\xD0\x89\x2F\x87\xA0\x7C\xEF\x84\x97\x8A\xFE\x8A\x39\x89\x13\x8B\x5E\x8A\x15\x8B\x60\x8A\xDB\x89\xF1\x85\xB6\x8A\x66\x89\x90\x8A\x60\x87\xCC\x87\x1D\x8B\xCE\x87\x6B\x89\xD0\x87\x33\x7C\x0E\x7D\x52\x7C\x5A\x8A\xB8\x74\x50\x79\x9B\x87\x30\x78\x76\x88\x94\x78\x59\x7F\xFE\x7C\x9D\x79\x06\x8B\x2D\x8B\xB8\x8A\x2F\x8B\x6B\x88\xBA\x8A\x93\x8A\xB7\x86\xE6\x8A\x06\x88\xE8\x8A\xB3\x88\xEA\x8A\xB5\x88\xEC\x8A\x07\x89\xEE\x8A\xC2\x84\xA4\x53\xA5\x7E\xC2\x76\xF5\x8A\xCA\x87\xE9\x89\x61\x87\x31\x8B\xDF\x88\x33\x8B\xE1\x88\x35\x8B\xD2\x87\x1D\x8A\x69\x87\x1F\x8A\x72\x89\x21\x8A\x8A\x86\x7A\x72\xEC\x88\x7C\x72\xD1\x88\xE1\x76\xD7\x79\x38\x86\x3C\x64\xD6\x88\x3B\x86\xC0\x7A\x13\x8A\x43\x8B\x08\x8B\x1C\x8B\x2C\x87\x1E\x8B\xED\x89\x20\x8B\xEE\x84\xA5\x84\x59\x8A\x72\x88\xF0\x78\x5D\x8A\x3C\x8B\x02\x8B\x77\x88\xEB\x88\xE5\x6C\xDC\x7D\x58\x7D\x56\x6A\x04\x61\x55\x86\x6E\x84\x39\x86\xF4\x88\x0A\x77\x95\x86\x57\x8B\xEB\x87\xB8\x85\x32\x8A\x9B\x7C\x18\x8A\xAA\x8A\x8A\x89\x38\x8A\xAD\x8A\x9C\x88\x04\x89\x8F\x89\xB1\x8A\x91\x89\x08\x89\x59\x89\xF0\x8A\xED\x65\x28\x7F\x73\x65\x91\x7F\x88\x6A\x77\x65\x76\x86\x7B\x7D\x8E\x8B\x1A\x8B\x7E\x65\x09\x8B\x2D\x7C\xEC\x89\x8F\x85\xEE\x89\x30\x87\x1B\x8A\x02\x89\x53\x87\x8E\x89\xF7\x87\x64\x8B\xA1\x77\xCD\x88\xA7\x86\xA0\x8B\x35\x5B\x5C\x89\x8B\x6E\x32\x7A\xF6\x73\x92\x86\x08\x0A\x4C\x77\xA9\x8B\x73\x8B\x1B\x8B\x45\x8B\xDD\x88\x5B\x8B\xBB\x8A\x49\x8B\xFB\x8A\x78\x8A\x1C\x89\xAC\x89\x1E\x89\x9A\x8A\x80\x87\xC4\x8A\x4B\x88\xEF\x8A\x24\x89\x31\x1B\xAA\x86\x48\x7E\x87\x07\xB6\x7D\x56\x8B\xAA\x8B\xEC\x87\x92\x8B\xD2\x7C\xAE\x8B\x62\x86\x79\x8B\x65\x86\x22\x8B\xBF\x8A\x24\x8B\xD6\x89\x7C\x8A\xD8\x89\x7E\x8A\xDA\x89\x4C\x88\xBB\x8B\x48\x5B\xBD\x8B\x06\x6B\x5F\x89\x87\x07\x6D\x7E\x2A\x01\xAD\x43\xA6\x00\x11\x84\x72\x5B\xAD\x43\xA7\x00\xF8\x8B\xB6\x53\x4D\x67\xA8\x00\xFC\x8B\x61\x89\xEA\x6E\x00\x00\xA9\x00\x00\x8C\xAC\x63\x1B\x67\xDA\x69\xF5\x83\xE6\x89\xCC\x8A\x0A\x01\x30\x59\xD8\x73\x70\x2D\x71\x70\x28\x74\x3E\x21\xC0\x80\x99\x70\x7A\x82\x6F\x01\x0F\x74\x17\x66\x03\x58\x19\x66\x4D\x65\x12\x8C\xF1\x80\xBF\x7E\x15\x8C\x0A\x01\x22\x66\x6E\x82\x0A\x01\x39\x74\x15\x81\x13\x8C\xF2\x80\x05\x8C\x06\x5E\x42\x81\xDC\x84\x78\x05\x8E\x6F\x2A\x6E\xD7\x6D\x71\x8B\xED\x81\xC1\x7F\x06\x82\xA3\x6C\x19\x6B\xF2\x81\x64\x7E\x2D\x8C\xE3\x81\x9A\x52\x56\x81\x63\x6D\x38\x8C\xF3\x6E\x99\x82\x03\x82\x00\x83\xF5\x7F\x40\x82\x82\x81\x08\x0A\x08\x82\x33\x6F\x3D\x8C\x57\x7E\x66\x81\xDC\x7F\xFC\x7D\x41\x8C\x6A\x81\x02\x83\x12\x82\xF6\x7D\x48\x8C\x81\x81\x20\x6C\x72\x81\x19\x82\x23\x6C\xDF\x82\xF0\x81\xE1\x82\xA5\x81\x53\x8C\x75\x6B\xAA\x5B\x95\x82\x52\x8C\x63\x6F\xBD\x82\xFD\x7F\x68\x82\x79\x7E\x77\x81\xF9\x7F\x05\x80\x60\x8C\x5F\x6F\xDB\x82\xFD\x82\x11\x6D\x61\x6B\x4D\x8C\xBC",
"\x81\x33\x8C\x03\x83\xFF\x00\x04\x80\xC0\x81\x3D\x55\x7E\x6F\x2D\x6C\xD1\x82\x09\x80\x1F\x6D\xF5\x82\x0B\x7E\xF7\x82\x2A\x01\x43\x82\x75\x8C\x69\x8C\x33\x56\x0C\x82\x09\x53\xDE\x82\x16\x80\xE0\x82\x18\x80\x5B\x8C\x9E\x82\x7F\x57\x51\x8C\x6B\x6F\x0C\x82\xEA\x82\x7C\x8C\x9D\x82\x94\x6B\x8D\x8C\x51\x6F\x4D\x6D\x65\x82\x76\x6C\x4A\x01\x64\x8C\x39\x8C\x86\x6B\x04\x5C\x5F\x8C\x8E\x8C\xC6\x82\x3C\x31\xC7\x81\x91\x8C\xE2\x82\x5C\x8C\x9C\x8C\xCB\x81\x05\x83\x72\x82\x8D\x6F\xEE\x6E\x68\x7E\x0B\x83\xA9\x8C\x76\x8C\xFB\x6D\xF0\x81\x82\x82\x98\x6C\x39\x6C\x82\x8C\x64\x56\x14\x83\x34\x8C\xB7\x80\x36\x86\x18\x83\xB5\x82\x78\x6F\x06\x59\x55\x52\x07\x55\xAB\x00\xBB\x58\xD7\x5C\x70\x87\x9D\x0B\x3A\x73\x62\x7D\x66\x7B\xCE\x8A\xCD\x89\xA8\x8A\x94\x8B\xFA\x8A\x45\x86\xCD\x8B\x07\x8A\xCF\x8B\x09\x8A\xD1\x8B\x20\x89\xD3\x8B\x8D\x42\x93\x89\x85\x87\x95\x89\x4F\x78\xC2\x7E\x31\x84\xBD\x87\x34\x84\xF0\x61\xC4\x8C\x78\x05\xC6\x8C\xC3\x7A\x1F\x7D\xC9\x8C\xEA\x89\x76\x8B\x32\x8B\xD2\x8A\xB0\x8B\x21\x8B\x7B\x8B\x1C\x79\x11\x8B\x7E\x8B\x26\x8B\x80\x8B\x28\x8B\x13\x39\xD7\x8C\x10\x6E\xD9\x8C\xB8\x7A\xDB\x8C\x57\x5D\xCA\x77\xE1\x7A\xC7\x7E\x54\x84\xCA\x7E\x7A\x84\xC5\x8C\x37\x7E\x75\x80\xE5\x8C\x5A\x8B\xE7\x8C\x5C\x8B\xE9\x8C\xE3\x8B\x92\x85\xE5\x8B\xFD\x8A\xD1\x8C\xFF\x8A\xD3\x8C\x0B\x8A\xEB\x8B\x0D\x8A\xDB\x89\x69\x84\x31\x8C\xC7\x74\x6D\x84\xE1\x89\xA9\x7E\xC4\x89\xA5\x78\x19\x84\xE2\x8C\xE6\x7A\x41\x79\xDF\x8B\x60\x86\xE1\x8B\x12\x87\xAB\x8A\x5C\x88\x98\x8B\x8D\x89\x9A\x8B\xB6\x8B\xCB\x88\x73\x89\xBA\x87\x23\x88\x07\x0A\x10\x67\x1B\x7B\xDF\x89\xD4\x88\xF1\x74\x98\x84\x33\x70\x1C\x8D\x90\x7C\xE2\x8A\xF9\x8A\x28\x7D\x96\x8B\xD5\x8A\x25\x8D\x3A\x8A\x4E\x8B\x55\x89\x06\x89\x57\x89\x9E\x8B\xF8\x89\x5A\x87\xF4\x74\x35\x8D\xA7\x7F\x06\x7C\xC7\x8B\x30\x89\x74\x8A\x96\x88\x94\x87\x0D\x8B\x18\x79\x58\x8A\xED\x8C\xE7\x8B\x99\x8A\xE9\x8B\x9B\x8A\x10\x8D\x9D\x8A\xFD\x7C\xC9\x5C\x70\x8B\x54\x54\xF7\x52\x7E\x45\x21\x63\x83\x7E\x96\x7A\xFC\x8C\xC4\x84\x1B\x8D\x01\x8D\xFE\x89\x7D\x86\x00\x8A\xAD\x8B\x77\x8B\xAF\x8B\x08\x8D\x50\x87\xAB\x7A\x52\x87\xC8\x88\xB5\x8B\xCA\x88\x90\x89\xCC\x88\x74\x89\x12\x8A\x84\x87\xF5\x8C\x26\x8A\xDC\x84\x28\x8A\x69\x5E\xE6\x86\x86\x7B\x6E\x8A\xDD\x5E\x39\x73\x64\x8D\x37\x8D\xCC\x8C\x39\x8D\x4A\x8B\x9A\x88\x3C\x8D\xD7\x8A\x3E\x8D\xF4\x89\x40\x8D\xF6\x89\x42\x8D\x40\x8A\x62\x8A\xA1\x87\xF0\x8B\xFB\x84\x40\x5A\x87\x8A\x04\x81\xE4\x87\x77\x7F\xE6\x87\xFF\x00\x0D\x7F\x60\x7D\x46\x8D\x8D\x86\xF8\x7B\x03\x8D\x30\x8B\x05\x8D\xCA\x8B\xE0\x88\x1A\x8A\xC6\x88\xB3\x8B\x6F\x8D\x27\x8D\x71\x8D\x9C\x8B\x73\x8D\x2B\x8D\x8B\x86\xEE\x8B\xC2\x70\x91\x8D\x46\x0A\x66\x8A\xDA\x7B\x82\x63\x21\x85\x7A\x78\x8A\x8A\x01\x85\x6D\x8A\x2B\x8A\x80\x78\x02\x01\x9C\x8D\x1E\x7E\x82\x8D\x21\x8D\x04\x88\x85\x8D\xF0\x89\x4C\x8B\x53\x89\x89\x8D\x3C\x8A\x8B\x8D\x3E\x8A\x8D\x8D\x1A\x73\x81\x8A\xFA\x84\x9D\x0B\x85\x8A\xC0\x87\x46\x8A\x2D\x7F\xFE\x7B\x6B\x8A\xBD\x75\x0C\x0A\xE8\x87\x34\x8D\x81\x8D\xAC\x8B\x67\x7D\xF4\x77\xBC\x8A\x1A\x89\xCF\x8C\x23\x8B\x0C\x8D\x25\x8B\x0E\x8D\xC3\x8A\x56\x8D\xC5\x8A\xFF\x77\xFC\x87\x13\x75\xBD\x8D\x61\x7C\x49\x8D\x33\x8A\x38\x8D\x79\x85\xCC\x8B\xAA\x89\xCE\x8B\x7A\x8A\xD0\x8B\x54\x8D\xD2\x8B\xE5\x8D\xD4\x8B\x0E\x88\xF7\x78\x2B\x7E\xC0\x75\xEA\x8D\x7E\x7D\x75\x8B\xD0\x8A\xE8\x8C\x1F\x8B\x6C\x89\x5F\x8B\xE3\x88\xA5\x7C\xD4\x87\x54\x85\x3F\x8D\x50\x8B\x41\x8D\x52\x8B\x8D\x88\xC7\x8A\xF6\x63\x6E\x53\xFD\x8D\x9B\x7D\xDA\x8D\xE4\x85\xAE\x88\x84\x8D\xF0\x8D\xE7\x8A\xF2\x8D\xE9\x8A\xF4\x8D\xEB\x8A\xEA\x8B\xDB\x8A\xBF\x73\xDD\x8A\xCD\x74\x11\x8E\xBA\x7D\x13\x8E\xAF\x87\x35\x8A\x4E\x87\xD4\x8A\x51\x89\xC4\x8D\xF2\x89\xC6\x8D\xB0\x8A\xC8\x8D\xB2\x8A\xEC\x8B\xD5\x8B\x81\x8A\x3D\x79\x50\x7F\x45\x8D\xD9\x8D\xFF\x8D\xCB\x8C\xC0\x8D\xC4\x88\xA4\x8D\x6D\x89\xA6\x8D\x6F\x89\x62\x8B\x9D\x77\x20\x8A\xB8\x8B\x66\x8B\xB7\x7E\x05\x8B\xD8\x8D\x81\x8A\xBF\x8D\x69\x8D\xE2\x8B\x03\x8E\x50\x7C\x36\x8B\xDA\x7C\x99\x8B\xD8\x8A\x9B\x8B\x2E\x8E\x9D\x8B\x0C\x8E\xA4\x69\x5A\x7F\xFD\x71\xA5\x88\x80\x8D\x47\x8E\x24\x8E\x02\x8A\xE4\x8A\x56\x8A\x4F\x8D\x0F\x8B\x45\x88\x52\x8D\xC1\x8A\xE3\x8D\x01\x8B\xF2\x8C\x82\x8B\x2A\x8B\x98\x76\xE4\x7C\xE9\x8D\x36\x8E\xEC\x8D\x93\x8B\x39\x8E\x19",
"\x8A\x23\x8D\xB2\x8B\xD6\x8A\xB4\x8B\xA8\x8D\x71\x89\x29\x8D\x65\x8B\xAC\x8D\xEF\x62\xFF\x7C\x35\x8E\x5A\x8E\x37\x8E\x8D\x85\x6F\x8E\x95\x8B\xC2\x8D\x97\x8B\x2A\x8E\xAE\x8A\x2C\x8E\xD9\x8A\x1D\x8E\xED\x8A\x30\x8E\x53\x8B\xBA\x88\x5A\x8D\xAD\x80\xF3\x53\x22\x8E\xBD\x6F\x5B\x8E\x0B\x8B\x4D\x8D\x36\x8A\xB1\x8B\xA5\x8D\x73\x8E\xA7\x8D\x50\x8E\x28\x8D\x72\x8D\x2A\x8D\x63\x88\x67\x8B\x84\x8B\x47\x8D\x67\x7E\x6E\x80\xBA\x8C\xE2\x76\x6D\x8B\x4A\x65\x3C\x7D\xA6\x7E\x79\x67\x2A\x2C\x0A\x89\x02\x8D\x1F\x8D\xB5\x86\x06\x8D\x02\x8E\x34\x8B\x4C\x8E\x60\x8B\x06\x8E\xE5\x88\xEE\x79\xE7\x88\x0F\x8D\x1E\x8E\x11\x8D\x3F\x65\x68\x8B\xCA\x74\x51\x86\x82\x7F\x88\x8B\x6A\x03\xA6\x8E\xB6\x27\x5C\x6A\x8D\x8B\xF6\x88\x90\x8E\x0D\x70\x92\x8E\xEE\x8D\x83\x88\x3A\x8D\x29\x8E\x19\x8E\x4D\x8B\x1B\x8E\x4F\x8B\x88\x8E\x51\x8B\x8A\x8E\xBA\x8B\xD6\x8B\x4C\x7A\x94\x7D\xA4\x8B\x76\x65\x93\x7F\xC3\x72\x95\x7F\xC7\x8E\x6C\x8E\x9F\x8D\x46\x8B\xC9\x8B\x48\x8B\xA3\x8D\x71\x8E\x97\x8E\x87\x8D\x74\x8E\x9A\x8E\xA9\x8D\x52\x8E\xAB\x8D\x9E\x8E\xCB\x8D\xAC\x8E\xDB\x76\x83\x8A\x4B\x5B\x90\x86\x28\x89\x35\x7A\x2A\x89\x12\x89\xAB\x8E\x13\x7F\xE1\x75\xCA\x8E\x83\x8D\xEF\x8D\xCE\x8C\xF1\x8D\xD0\x8C\xF3\x8D\xD2\x8C\xF5\x8D\xD4\x8C\xF7\x8D\x22\x89\xED\x8B\xD7\x8E\xB5\x1C\xD8\x8B\x29\x74\xE0\x6A\xAC\x7F\xDF\x8E\x7D\x8E\x6D\x8E\xE0\x8B\x49\x8E\x22\x8D\xCD\x8E\xAC\x8A\x84\x8E\x4F\x8E\x86\x8E\x51\x8E\x0A\x8E\x8C\x8D\x54\x8E\x09\x89\xFA\x8E\x0B\x89\xB0\x8D\x5E\x5B\x6C\x7A\xC1\x51\x60\x89\x46\x73\x55\x8B\x35\x58\xBD\x8E\xD5\x7E\x94\x7E\x27\x8F\x1A\x5C\xCF\x88\x23\x74\x72\x5B\x63\x89\x6E\x53\x53\x73\x10\x8F\xE1\x8E\xC8\x8B\xA1\x8D\xE4\x8E\x5D\x8B\x3B\x8E\x04\x8E\x1C\x8A\xB5\x8E\x1E\x8A\x40\x8E\xB7\x8B\x32\x78\x22\x8A\x5C\x2C\x76\x8D\x59\x6A\x86\x87\x1C\x62\xE3\x86\x32\x84\x2D\x7E\xDE\x8C\xB8\x7E\x7F\x89\x12\x8A\x78\x05\x33\x8F\xF0\x8E\x48\x8E\x01\x8E\x78\x8B\x4B\x8E\xD8\x7C\x4D\x8E\x6E\x8D\x3E\x8E\xC9\x88\x76\x8E\x9C\x8E\x78\x8E\x2B\x61\xF4\x8C\x45\x8F\xF6\x8C\x30\x84\xF9\x8C\x7C\x89\x36\x78\xFC\x8C\xC9\x7E\x83\x69\x50\x8F\x1F\x8F\xAD\x8E\x59\x8B\xA0\x8D\x00\x8E\xB0\x8E\x54\x8F\xB2\x8E\x56\x8F\xB4\x8E\x88\x84\xB6\x8E\xA8\x7C\xB8\x8E\xE4\x8D\xBA\x8E\x57\x8D\x1A\x86\x06\x0A\xE5\x77\x6B\x84\xDF\x7D\xD3\x7E\x3F\x87\xD5\x7E\x24\x87\x00\x7A\x64\x89\x69\x8F\xC7\x8C\x95\x7C\x35\x8F\x4A\x8D\x92\x8A\x4C\x8D\x42\x88\x0E\x8B\xFC\x8A\x10\x8B\x62\x8E\x12\x8B\x64\x8E\x14\x8B\xD5\x8C\x16\x8B\x0E\x8A\x09\x84\xDD\x89\x93\x84\x30\x8D\xC3\x8E\xF6\x5A\x33\x8D\xA8\x64\x86\x8F\xE3\x8C\x11\x79\xAE\x8E\xF0\x86\x8C\x8F\x76\x8A\x8E\x8F\xDF\x8D\xE6\x8B\xE1\x8D\xE8\x8B\x1C\x8E\x55\x8D\x79\x8F\xE6\x8D\x9E\x8A\xF5\x8B\x08\x5E\xC0\x75\xA0\x8F\x1D\x8D\xE4\x8C\xA3\x8F\x31\x89\x54\x8A\x94\x8E\x27\x8E\x96\x8E\x3C\x8E\x98\x8E\x59\x8F\x70\x8D\x5B\x8F\xAA\x8D\x9D\x8E\x3F\x8A\xFB\x8C\x0F\x8A\x61\x7B\xE0\x8C\x02\x01\xB4\x8F\x36\x8D\xFC\x8E\x80\x8E\xCD\x8C\x95\x8A\xA8\x8F\x0B\x8D\x02\x8F\x0D\x8D\x04\x8F\xB9\x8E\x89\x8E\x4A\x78\x75\x89\xB1\x7E\x4D\x78\x61\x8F\x4C\x75\xDE\x84\xF9\x7E\x7C\x8D\xF0\x62\x7E\x8D\x32\x8F\xE0\x8E\xB7\x8F\x4B\x8D\x87\x89\xBA\x8F\xD3\x8A\xBC\x8F\x3B\x8F\x3D\x8E\x61\x8B\x5A\x8F\x63\x8B\x77\x8E\x42\x8E\x79\x8E\xEF\x8E\x6A\x8F\x82\x8A\x23\x5B\x9A\x78\x04\x7F\xA4\x87\x94\x8D\xBE\x78\x89\x8A\x23\x85\x30\x7F\x4C\x8A\x9E\x75\xCA\x8F\xA1\x8E\x9E\x8D\xE4\x8F\x8B\x8F\xE6\x8F\x8D\x8F\x5F\x8E\x8F\x8F\x61\x8E\xAA\x8F\x53\x8D\xAC\x8F\xF6\x8D\xAE\x8F\xF8\x8D\xD6\x8E\xCC\x8D\x1C\x85\xF1\x70\xD0\x8D\x69\x8A\xD6\x7B\xC2\x87\xFB\x8F\xC0\x78\xC5\x87\xB9\x8D\x26\x85\xBB\x8D\x01\x01\x00\x90\x9D\x8D\x6B\x8F\xA6\x8A\xCF\x8A\x38\x8E\x13\x8F\xC1\x8D\x17\x8E\x4B\x8B\xCF\x8E\xC5\x8D\xD1\x8E\x09\x8E\xD3\x8E\x0B\x8E\xD5\x8E\x24\x7F\x41\x8A\xFE\x67\xB0\x8D\x3F\x85\x67\x8A\xF9\x8F\xAC\x7B\xD3\x8D\xB7\x8D\x6C\x8A\xC2\x78\x8D\x8A\x9F\x8F\xE3\x8F\x6C\x8F\xE2\x8E\x37\x8F\xA5\x8F\xDD\x8D\x77\x8A\x00\x8F\xE0\x8D\xD2\x8F\xE2\x8D\xD4\x8F\x78\x8F\xD6\x8F\x7A\x8F\xFB\x87\xDF\x78\x44\x71\xB3\x8F\x3E\x90\x22\x90\xCA\x8C\x7F\x8E\x25\x90\x3A\x8E\xE6\x8E\xBD\x8F\xE8\x8E\x99\x8E\x19\x8F\x9B\x8E\xC2\x8F\x5D\x8F\xC4\x8F\xDF\x8F\x70\x85\x33\x70\x1F\x90\xBE\x8D\xCC\x8F\x55\x90\x70\x8E\x15\x8F\x24\x8D\x17\x8F\x26\x8D\xEA\x8E\xC1\x8F\xEC\x8E\xC3\x8F\xCA",
"\x8D\xE9\x74\xF4\x63\x25\x88\x86\x85\xF3\x53\x63\x90\xEB\x8D\x89\x8F\xED\x8D\xFD\x8E\xCC\x8E\x82\x8E\x3B\x8D\x6A\x90\x3D\x8D\x2B\x90\x8A\x8D\x1B\x8F\xC9\x8D\xDC\x8A\x9B\x85\x16\x64\x19\x84\x76\x90\xFE\x8D\x11\x8F\x20\x8D\x66\x90\x81\x8E\x27\x90\x86\x8D\x7E\x90\x88\x8D\x80\x90\xC7\x8D\x82\x90\x2F\x8E\xBB\x8E\x31\x8E\xF0\x8E\x33\x8E\xB4\x85\x50\x90\x34\x8F\x03\x90\x47\x8B\x42\x90\xCB\x8B\xFF\x8E\x18\x8E\x01\x8F\x1A\x8E\x03\x8F\x0C\x90\x05\x8F\x0E\x90\x07\x8F\xC7\x85\x65\x88\xDE\x71\xF4\x74\x88\x90\x12\x8E\x7E\x8E\x02\x88\xCD\x8F\x16\x8E\xA1\x90\x28\x90\xA3\x90\xD0\x8E\xA5\x90\xD2\x8E\xAD\x8F\x4B\x90\xAF\x8F\x58\x8D\xDC\x85\x3F\x69\xAD\x90\x51\x90\x66\x8D\xA7\x8A\x54\x90\x53\x8F\x6A\x8D\x55\x8F\x66\x86\xEB\x8F\x3D\x8F\x3F\x8E\x7D\x79\x2E\x86\xD8\x87\xED\x8E\x5F\x90\x71\x62\x2B\x8B\xC0\x90\x9C\x90\x3F\x90\x36\x8F\x6E\x8F\xA2\x8D\x39\x8F\x57\x90\xEA\x8F\xBE\x8F\xEC\x8F\xC0\x8F\xEE\x8F\x5C\x8F\xF0\x8F\xEE\x8E\xDF\x8F\x7B\x8E\x9B\x90\x51\x8F\x65\x90\xC5\x90\x4A\x8E\x71\x8F\xC8\x90\xDC\x90\xCA\x90\xED\x8F\x3F\x8F\xEF\x8F\x41\x8F\x43\x8E\x05\x87\xB7\x7F\xD7\x81\xA9\x8E\xE2\x8F\xD4\x90\x52\x90\xE6\x8C\xD7\x90\x38\x8F\x07\x8D\xC7\x90\x0A\x8D\x90\x8F\x0A\x90\x63\x8E\x49\x90\x65\x8E\x95\x8F\x29\x8B\xBC\x8E\xA0\x8E\x20\x90\x71\x5C\xE0\x81\x37\x86\xB7\x89\xDC\x5F\x3A\x86\x1D\x86\x3C\x86\x1E\x90\xC1\x90\x15\x88\x67\x8D\xDB\x8D\x25\x78\xA0\x90\xCF\x8F\x45\x90\xA9\x8F\x47\x90\xAB\x8F\xB9\x90\x0D\x90\xBB\x90\x0F\x90\xC6\x73\x29\x8F\xA2\x7E\x07\x0A\x52\x86\x02\x78\xF1\x88\x7C\x73\xF3\x88\x5E\x7D\xF5\x88\xF8\x8E\xAE\x90\x23\x8E\xB0\x90\x69\x89\xE8\x90\x14\x8F\x7C\x90\xCE\x8E\xB6\x90\x2A\x90\xB8\x90\x2C\x90\xBA\x90\xD4\x8E\x96\x90\xCD\x7E\x31\x90\xEF\x8B\xA2\x8B\x68\x77\xDA\x8E\x17\x7A\xA6\x8B\xDD\x8E\x77\x86\xF6\x88\x2E\x91\x91\x8E\x30\x91\x17\x8A\xB2\x90\xFE\x8E\x19\x91\xA2\x90\x46\x90\xA4\x90\xD3\x8F\xA6\x90\xD5\x8F\x3B\x91\x4C\x90\x3D\x91\x8F\x8D\xA1\x8B\xDE\x87\x73\x65\xF4\x8E\x34\x08\xF6\x8E\xA3\x65\x11\x91\x00\x00\x48\x91\xC9\x8E\x4A\x91\xF8\x8A\x7A\x90\x4F\x89\x68\x90\x72\x8E\x59\x90\xBF\x8F\x75\x8E\xDF\x90\x5D\x90\xE1\x90\xD0\x90\x1D\x77\xF0\x8E\x0B\x8F\x4F\x7A\x2A\x01\x51\x7A\x47\x91\x13\x91\x2B\x88\x15\x91\x14\x8E\x18\x89\x4E\x8D\xF0\x7A\x60\x8E\xD4\x89\x91\x8F\xEF\x8C\x93\x8F\x27\x8B\x05\x91\x03\x8B\x61\x8A\xAE\x8D\x30\x61\x94\x7D\xC6\x86\xCE\x4D\xB6\x7F\xC9\x86\x11\x8A\xFF\x8C\x78\x05\x67\x73\xF8\x90\xC2\x90\x23\x90\xC4\x90\x6F\x8F\xC6\x90\xEA\x90\xFF\x90\x09\x90\x1C\x91\x0B\x90\x1E\x91\xA7\x90\x20\x91\xD6\x8C\xDE\x86\xC4\x77\x9B\x74\x46\x8F\xB9\x7A\xDC\x8C\xB6\x7E\xDF\x8F\x7F\x74\xE9\x86\x92\x91\xE6\x90\x64\x91\x0A\x8B\xCB\x8E\x67\x91\x34\x91\x16\x8F\x29\x90\x2B\x8E\x92\x90\x2D\x8E\x94\x90\x53\x8E\xC2\x77\xA2\x91\x7F\x7B\xDA\x8F\x78\x8D\x79\x89\x47\x8F\x98\x89\xA0\x74\x1D\x6F\x52\x84\x66\x8F\x08\x87\x3A\x88\xAC\x91\xF3\x8F\x52\x8F\x97\x91\xE9\x90\x5E\x8B\xB3\x8E\x05\x8E\x74\x8F\x3E\x8F\xCC\x90\x41\x8E\xF1\x90\xF1\x8F\xF3\x90\x01\x01\x7D\x8F\xC6\x74\x95\x5D\x82\x7E\x77\x7F\x73\x73\x83\x8F\x83\x69\xC8\x91\x87\x8F\xCC\x7C\x78\x90\x6E\x8E\x8C\x90\xCE\x8F\xBD\x8A\xD0\x8F\x00\x91\x9C\x91\x02\x91\x53\x91\x4A\x90\x55\x91\xBC\x90\x7B\x8F\x98\x8F\xEF\x88\xDE\x89\x3D\x87\xE0\x7E\xF2\x88\xE2\x7E\xE3\x89\xF4\x74\xE0\x91\xA1\x8F\xC8\x8C\x9D\x90\xE3\x8E\x9F\x90\xE5\x8E\x68\x91\xE7\x8E\x90\x90\xE9\x8E\x5B\x90\xEB\x8E\xB8\x91\xCF\x90\x70\x90\x23\x5A\xF9\x89\xA8\x64\xFA\x91\xB5\x8F\xA2\x8F\xD5\x90\x8A\x8F\x9E\x90\x05\x90\xA6\x8F\x07\x90\xE8\x91\x9B\x91\x51\x91\x48\x90\xEC\x91\x04\x91\x06\x8F\x96\x8F\x12\x8D\x3C\x73\x62\x8D\xAB\x91\x78\x91\x56\x88\x2C\x88\x66\x91\xA8\x89\x8E\x90\xC3\x8D\xB4\x91\x85\x8E\xB6\x91\x87\x8E\x3A\x91\x2E\x90\xD7\x8F\x75\x8D\x76\x89\x2E\x84\xDB\x8F\x87\x87\xDD\x8F\x64\x88\xA0\x70\xE1\x8F\xF3\x53\x0D\x92\xCB\x8F\xAE\x91\x68\x8D\x32\x91\x26\x90\xB4\x90\x8F\x90\x29\x92\x18\x8F\x2B\x92\x1A\x8F\x2D\x90\x1C\x8F\x2F\x90\x1E\x8F\xE1\x91\xE5\x86\xB0\x8D\xA3\x87\x54\x01\x68\x8A\x96\x8D\x51\x5D\x98\x8D\x9A\x8D\x3E\x7D\x3A\x92\x01\x90\x21\x90\x94\x91\x53\x90\xB1\x90\xE5\x91\xB3\x90\x4E\x91\xB5\x90\x50\x91\xB7\x90\x52\x91\x9E\x91\x54\x91\x2E\x92\x56\x91\x10\x90\xF0\x8E\xCD\x8D\x9B\x78\x14\x90\x5E\x5A\xD2\x8D\x08\x7F\x39\x90\xD5\x8D\x20",
"\x7F\x38\x92\x9D\x0B\x55\x92\x09\x91\xCA\x91\xD8\x90\xFD\x90\x99\x91\xEC\x8C\x4C\x79\x7D\x8B\x3A\x8B\x7F\x8B\x90\x78\x3D\x8B\x10\x76\xB0\x7F\x09\x8F\x4B\x92\x40\x91\xBA\x78\x08\x5F\x2B\x7F\xD1\x8D\xB5\x8D\x2E\x7F\xFC\x8F\x15\x90\x7D\x78\x45\x85\x13\x75\x73\x92\x64\x90\x3C\x92\x16\x91\xCC\x7A\x18\x91\xE7\x91\x1A\x91\xD1\x8F\x18\x92\x1D\x91\x39\x91\x1F\x91\xEE\x91\x21\x91\x9E\x62\xE8\x8D\xF9\x91\x22\x92\x85\x89\x24\x92\x4C\x91\x7B\x90\x27\x92\x83\x8E\x42\x92\x6B\x90\x05\x92\x6D\x90\x07\x92\x6F\x90\x1D\x8F\x47\x7F\xFA\x8D\x65\x7E\x33\x70\x90\x92\x77\x90\xFD\x91\x41\x90\x13\x92\x43\x90\xA7\x8F\x97\x92\xE9\x91\x99\x92\x9D\x91\x9B\x92\x9F\x91\x9D\x92\xA9\x90\x53\x8B\x72\x90\xBB\x7F\x0E\x52\x15\x76\xB4\x92\x89\x90\xE3\x91\x12\x8F\x3E\x92\x56\x90\x01\x92\x58\x90\x03\x92\x5A\x90\x44\x92\x5C\x90\x6E\x90\x5E\x90\x12\x63\x39\x88\xCD\x74\xC8\x92\xAF\x90\x8A\x90\xAF\x8E\x76\x92\xB1\x8E\xCD\x91\x72\x8F\xCF\x91\x11\x85\xD1\x91\x78\x7B\xCD\x90\x73\x76\xA1\x7B\x65\x92\x30\x90\x58\x91\x46\x7B\xF2\x8A\x3E\x79\xC0\x75\xD9\x92\x2F\x91\xDB\x92\xA4\x8F\xB8\x92\x95\x92\xDE\x8D\xBB\x92\x17\x92\x60\x92\x19\x92\x62\x92\xED\x91\x64\x92\xEF\x91\xAA\x90\x08\x0A\x45\x8E\x0C\x92\xA2\x92\xA4\x89\xA4\x92\x5B\x92\x4D\x91\x96\x92\x4F\x91\x1B\x91\xBD\x92\xEB\x91\xFA\x92\x1B\x92\xA8\x90\x1D\x92\xB4\x8A\x56\x8E\x8F\x92\x02\x93\x52\x8A\xA5\x89\x52\x76\x14\x92\x7E\x91\x08\x90\x80\x91\x01\x91\x92\x8F\x03\x91\x94\x8F\x1C\x92\x06\x91\xB6\x79\x1C\x72\x8F\x88\xEE\x92\x13\x93\x41\x86\x04\x93\xCC\x92\x67\x90\xB2\x91\x69\x90\xA9\x92\x7F\x90\x38\x91\x81\x90\x46\x92\x83\x90\x48\x92\xB0\x92\x08\x0A\xE4\x90\xB3\x92\x25\x93\x5F\x86\xDC\x92\xFC\x90\xDE\x92\x3A\x8F\xCE\x91\x3C\x8F\xD0\x91\xCB\x90\xE4\x92\xD3\x91\x81\x79\xB9\x8B\xB9\x88\xD5\x58\x2C\x8F\xF6\x88\xEF\x92\x49\x91\xF1\x92\xB8\x8F\x16\x93\xB9\x92\x15\x92\xF6\x92\x1A\x93\xEA\x91\x1C\x93\x1A\x92\x1E\x93\x0E\x93\x20\x93\xCE\x88\x23\x91\x34\x7D\xA3\x8E\x0B\x91\x18\x83\x9C\x8F\xF2\x2C\x79\x7F\xF6\x90\x39\x92\x37\x93\xFB\x88\xAF\x91\x25\x92\xE5\x8A\xA7\x92\x7D\x90\x2C\x93\x91\x90\x2E\x93\x93\x90\x30\x93\x95\x90\xE8\x92\xE9\x61\x2E\x8F\x11\x66\x86\x8B\x9E\x72\x54\x86\xC2\x8E\x0D\x91\xEB\x92\xFF\x00\x88\x7F\xF8\x8E\x49\x93\x63\x91\x4B\x93\xE5\x8F\xB9\x8F\x06\x90\x18\x93\x16\x92\x51\x93\x0A\x93\x53\x93\x0C\x93\x55\x93\xA0\x91\x0F\x93\x97\x90\xF3\x8F\x76\x7D\x42\x91\x23\x77\x44\x91\x25\x77\xDE\x8E\x7C\x93\x63\x93\x20\x7A\x65\x91\xA5\x92\xB1\x91\x68\x93\x35\x91\x5F\x92\x37\x91\x61\x92\xBF\x92\x63\x92\x47\x92\x3C\x91\x66\x92\x8D\x93\x26\x89\x56\x8C\x91\x86\x06\x5E\xC3\x8B\x48\x93\x95\x93\x25\x7D\x3A\x93\x70\x8F\xDF\x92\xEB\x90\x6A\x91\xDD\x90\x6C\x91\xEF\x90\xE0\x90\xD4\x91\xE2\x90\x32\x5B\x88\x91\x71\x65\x0C\x89\x4E\x7A\x44\x89\x0C\x0A\x76\x91\x94\x93\x93\x91\x14\x91\xC3\x90\x5A\x92\x28\x93\x8D\x90\x40\x92\x28\x92\x36\x91\xB5\x91\x6C\x93\xB7\x91\x6E\x93\xB9\x91\xA2\x93\xE9\x92\xB9\x93\xBC\x72\xBB\x93\xD2\x7D\x08\x6B\x24\x8F\xF3\x8B\xB0\x58\x55\x52\x66\x73\x68\x73\xA7\x6D\x6A\x73\x01\x2E\x51\x38\x81\x8F\x32\x90\x2C\x58\x15\x1A\x8A\x58\xF9\x2F\x19\x01\x60\x8D\xD1\x58\x47\x73\xD8\x7D\x2B\x8C\x02\x01\x77\x73\xFB\x91\x57\x7D\xEC\x81\x8A\x82\x7F\x8F\x71\x8C\x2F\x8C\x35\x8C\xEB\x6E\xA5\x5A\xED\x93\x0E\x92\xD4\x79\x3B\x8C\x5A\x6B\xF8\x93\x90\x7C\x3F\x8C\x80\x52\xA2\x81\x42\x6C\x70\x8C\xAA\x82\xFB\x6C\x46\x8C\x05\x80\xFD\x93\x56\x92\xC4\x81\x8E\x6B\x03\x6F\x4B\x8C\x05\x6F\xA3\x8C\x8A\x8C\xD3\x5B\x13\x82\x07\x94\x64\x8D\x21\x6C\xA6\x93\xE8\x7F\x58\x8C\x15\x83\x02\x94\xA9\x82\x98\x81\x72\x8C\xB8\x82\x75\x8C\x08\x94\x09\x91\x62\x8C\xC8\x82\x6F\x8C\x1B\x94\x19\x83\xED\x82\xFF\x00\x67\x8C\x1F\x94\x14\x94\x75\x6C\x2B\x6F\x22\x7E\x19\x94\x5A\x8C\x8C\x82\x17\x6D\xF6\x7D\x20\x94\x1E\x7E\x08\x80\x70\x50\x9A\x8C\x7E\x8C\xD4\x5B\x33\x94\x2B\x94\x84\x8C\xDD\x5B\x18\x94\xB8\x8C\xA3\x81\x25\x94\xBC\x8C\x8B\x52\xE4\x82\xD8\x81\x6E\x53\x34\x94\x52\x7E\x8F\x8C\xAE\x81\xEB\x82\x4F\x8C\x6C\x81\x5C\x6F\x13\x94\x11\x90\x97\x8C\xF4\x82\x24\x94\x10\x82\x43\x94\x5D\x8C\x68\x6F\x3B\x94\x51\x94\xA0\x8C\x4F\x6D\x38\x94\xE3\x82\xA7\x8C\x87\x6E\xFE\x6B\x48\x94\x50\x86\xF3\x80\xFF\x00\x71\x82\x70\x55\x78\x05\x62\x94\xED\x88\xCD\x6B\xBF\x6B\xFC\x93\x64\x8D\xB7\x8C\xE2",
"\x7D\x16\x83\xF8\x5A\x6B\x8B\xD3\x88\x56\x94\x84\x6B\x46\x93\xA4\x74\xEA\x93\xBF\x91\x78\x05\x82\x73\xEE\x93\xE6\x73\x89\x82\xC0\x7F\x15\x8D\x04\x94\x19\x94\x8E\x82\xDA\x69\x7C\x94\xF9\x93\xDF\x76\xFB\x93\x39\x6C\x86\x94\xFE\x93\xEE\x7D\x5D\x81\x4C\x94\x69\x82\x58\x82\x06\x94\x75\x8C\x8B\x94\x09\x94\x4A\x8C\x35\x6B\x2E\x94\x40\x94\x1A\x94\x55\x94\x43\x8C\x44\x94\x3D\x6B\xF6\x7D\x94\x94\x21\x94\x55\x8C\xFD\x7F\x57\x8C\x87\x8C\x59\x8C\x89\x8C\x31\x94\xE0\x7F\x1E\x94\x2F\x6B\x7B\x94\x3C\x94\x60\x6F\x2F\x6C\x01\x94\x30\x94\xF3\x93\x6C\x81\x29\x94\xAB\x94\x02\x01\xA0\x94\x35\x94\x2C\x94\x63\x8C\x8F\x94\x65\x8C\x72\x8C\x74\x8C\xB5\x94\x01\x01\xB7\x94\x49\x94\x60\x6F\x38\x6F\x4F\x6C\xBB\x94\x9B\x8C\x4B\x57\x42\x82\x9F\x94\xAD\x94\x6B\x8C\x44\x6F\xA0\x81\x86\x8C\xB0\x94\xA7\x94\xB2\x94\x58\x82\x4E\x6F\x93\x94\xCB\x94\xF2\x82\xDA\x7F\x0C\x8F\x5D\x94\xA5\x8C\xC8\x94\xEE\x82\x95\x82\xC1\x94\x5C\x7E\x52\x94\x5E\x82\xC6\x94\x39\x94\xBF\x81\xBF\x94\x52\x34\xD6\x94\xFC\x82\xF0\x70\x5C\x94\xE3\x94\x5E\x94\x73\x6F\xCC\x81\x6C\x82\xDF\x94\x6A\x94\xFC\x8C\x66\x94\x4E\x80\xB6\x94\x64\x8D\xD6\x81\x1C\x86\x46\x94\xF3\x53\xF1\x94\x70\x86\x60\x6F\xF3\x6E\x74\x90\xA4\x8E\xD7\x79\x75\x94\xAD\x6B\x02\x59\x35\x0A\x39\x5E\xAC\x00\x4C\x52\x39\x5E\xB7\x94\x0E\x55\xBF\x8E\x8E\x09\x20\x2E\x2D\x30\x5E\x93\xB8\x78\x21\x6E\xE3\x08\x5B\x50\xA4\x2E\x8D\x73\x86\x7F\x37\x92\x10\x91\xDC\x84\x89\x73\xE3\x08\x8B\x73\x03\x1A\x35\x0C\xE7\x93\x0D\x6E\x64\x38\x86\x73\x17\x8D\x72\x7F\x15\x59\xE9\x93\x51\x7F\x95\x73\x4A\x92\xE8\x7D\x7F\x94\xD1\x7E\x32\x8C\x82\x94\x99\x94\x84\x94\x64\x7E\x2A\x95\x7D\x94\xE3\x1B\x94\x82\xFA\x94\x9D\x0B\x34\x95\x87\x94\x06\x7E\xCC\x94\x1D\x6F\xCF\x7F\xD0\x94\x7F\x81\xA4\x8C\x8B\x8C\x45\x8C\xF6\x7D\x3A\x95\x8C\x94\x0C\x82\xA5\x82\x98\x94\x70\x94\x9A\x94\x1D\x82\xCB\x82\x36\x82\x08\x0A\x12\x94\x75\x8C\x46\x95\x95\x94\xA2\x94\x1A\x14\x74\x80\x40\x95\x9C\x82\x42\x95\xD3\x5B\xAA\x94\x27\x6F\x02\x01\x53\x95\xA1\x94\xE5\x6C\xAF\x94\xDA\x94\x43\x95\x37\x6C\x45\x95\xE8\x94\x48\x82\x10\x6D\x2D\x94\x58\x95\x01\x83\x90\x94\x27\x94\xBE\x94\x5D\x95\x01\x01\x5F\x95\xB8\x94\x2E\x7E\x73\x86\xA6\x82\x99\x94\xB1\x94\x30\x95\x72\x8C\x80\x8C\xE6\x94\x72\x95\xC2\x94\x3D\x95\x58\x25\x85\x8C\x73\x16\x63\x95\x63\x6C\x66\x95\x5A\x94\x7F\x95\x2C\x74\x83\x95\x6F\x6C\x4F\x94\x52\x95\x67\x95\xF5\x6E\x9C\x6B\xBA\x81\x54\x94\x4D\x95\xEC\x82\xCC\x82\x49\x6D\x85\x95\x67\x92\x5D\x7E\x84\x6C\x0F\x94\xA8\x94\x35\x80\x74\x6F\x67\x94\x5E\x95\xF7\x94\xAC\x8C\x92\x6C\x6C\x82\x7D\x95\x63\x94\x6B\x94\x3F\x80\x39\x6C\xA4\x95\x5B\x89\x7F\x95\xFF\x94\x8D\x5F\x17\x83\xE2\x76\x03\x95\xC6\x6B\x97\x7E\xD8\x73\xA9\x73\x33\x5C\x3B\x83\x01\x01\xAD\x73\x03\x58\xAF\x73\xE3\x56\x82\x79\x65\x0C\x39\x74\x88\x38\xB5\x73\xB7\x73\xB9\x73\x00\x00\xBB\x73\x2D\x61\xBD\x73\x64\x43\x1C\x81\xCC\x68\xCC\x73\xC2\x73\xC2\x95\x57\x7F\x23\x6A\x84\x59\x1A\x28\xDD\x80\x19\x6E\x02\x01\xCD\x73\x70\x55\xCF\x73\xE3\x56\xD1\x73\x9F\x8E\x07\x0A\x91\x59\xA4\x91\xC5\x8F\x26\x8F\x4D\x62\xAE\x00\x4C\x52\x35\x0A\x25\x0A\x68\x37\x54\x54\xFC\x5D\xD0\x54\x97\x79\x72\x0C\xBE\x95\xC5\x3D\x8B\x54\xB0\x00\xAF\x6D\xCF\x00\xC2\x95\xEF\x95\xFF\x5E\xC6\x95\xE7\x40\xA0\x64\x55\x52\x91\x08\xAD\x00\x1C\x67\xA3\x05\xCF\x79\x31\x61\x48\x42\xBA\x91\x2B\x8F\xDF\x95\xDB\x93\x28\x74\x5D\x73\x4A\x62\x88\x38\x82\x7B\x5B\x59\x49\x01\xBF\x95\xE2\x95\x02\x01\xE4\x95\x03\x58\xFC\x5D\x92\x58\xA2\x04\x31\x92\x4C\x84\x8D\x42\x06\x96\x20\x24\x88\x38\xFF\x04\xE8\x95\x80\x6E\xC4\x5D\xEC\x95\xEE\x95\x65\x53\xCF\x68\x03\x96\xD9\x7B\x05\x96\x01\x87\x07\x96\x77\x01\x16\x96\x02\x01\xF1\x95\x01\x60\xF3\x95\x53\x3B\xF5\x95\x09\x52\xF7\x95\x22\x5A\x5C\x73\x65\x42\xD8\x8C\x2B\x3B\x14\x96\xCF\x26\x88\x38\xFA\x95\xC6\x5D\xFC\x95\xC7\x3F\x0C\x8C\x2F\x92\x28\x8C\xBD\x5C\xD8\x73\x9D\x0D\xC6\x8F\x25\x0A\x74\x26\x54\x54\x0F\x5A\x3A\x59\x82\x92\x38\x17\xEA\x95\x7D\x74\x75\x0A\x91\x08\xB8\x53\x97\x59\x46\x96\x8E\x86\xD1\x5C\x38\x84\xE0\x55\x09\x94\x4E\x59\xF9\x95\xA0\x87\x59\x91\x86\x81\x38\x66\x90\x7C\xC0\x55\xBD\x69\xC2\x5A\xA3\x05\xD1\x93\x00\x73\x07\x0A\xDF\x55\xEB\x37\x5A\x96\x66\x59\x55\x96\x3E\x91\xC4\x65\x0B\x0A\x62\x96\x18\x46\x64\x96\x02\x01\x72\x59\x4D\x96\x81",
"\x8A\x38\x96\x7A\x59\x53\x96\x91\x08\x7E\x59\x6F\x96\x72\x91\xAC\x6E\xB8\x17\xFA\x01\x6C\x96\x9A\x06\xA1\x59\x5E\x96\x4E\x96\x20\x8F\x06\x0A\xDB\x95\x76\x74\x15\x66\x95\x59\x66\x96\xEA\x92\x3F\x91\x36\x8C\x4E\x3C\x7B\x96\x91\x0C\x7D\x96\x56\x96\xBC\x8B\x81\x96\xD4\x73\x5F\x8D\xA5\x95\x3C\x96\x94\x96\x95\x96\x96\x96\x1A\x58\xB3\x5C\x02\x01\xB1\x00\xA3\x7E\xC3\x8C\x8F\x91\xC6\x89\x78\x05\x8C\x7A\xAD\x91\x7F\x93\x04\x90\x81\x93\x17\x93\x31\x7C\x6C\x8D\x6F\x7C\x58\x8F\xB2\x93\x6C\x90\x6D\x91\xD4\x92\x6F\x91\x12\x63\x5F\x8F\x04\x96\x33\x92\xC0\x91\xA7\x91\x64\x8F\xC8\x5A\xC6\x59\xC8\x8F\x01\x01\xA1\x96\xC9\x91\xE7\x90\xCB\x91\x33\x91\x9A\x93\xB3\x91\xC9\x93\x2A\x92\xCB\x93\x2C\x92\x9C\x92\xFC\x92\x88\x38\xB1\x96\x20\x96\xB3\x96\xA6\x91\x63\x8F\x9A\x89\xC4\x91\x9C\x89\xFD\x8C\x83\x69\xBB\x96\x2B\x95\xFB\x8E\x92\x92\x7B\x91\x26\x8E\xE8\x8F\xEB\x8C\x51\x87\xAB\x79\x5B\x8A\x87\x93\x9F\x93\xFB\x92\xA1\x93\x70\x93\x2C\x8D\x7C\x8F\xB4\x89\x6C\x84\x21\x87\x29\x91\x69\x8B\x19\x8D\x25\x87\x19\x84\xD3\x96\x35\x95\x48\x8D\xCA\x92\x8B\x90\xC5\x93\xE6\x91\xF5\x92\x08\x93\x98\x92\xF8\x92\x9A\x92\x2F\x93\x2D\x92\xE1\x96\xFD\x92\x8B\x8E\x0F\x67\xC0\x8E\x75\x62\x04\x78\xE0\x89\xE0\x93\xE2\x89\x0C\x0A\xF3\x74\xC0\x75\xED\x96\x3B\x95\x41\x7D\xA3\x96\x12\x92\xA5\x96\x4E\x93\x83\x93\x50\x93\x7C\x8B\xEE\x8C\x7C\x92\xF0\x8C\x7E\x92\x81\x8B\x3E\x8B\xE7\x8D\x44\x8D\x07\x97\xAB\x93\x3D\x84\x4D\x93\xF4\x92\x44\x90\xF5\x96\xBC\x92\xF7\x96\xBE\x92\xF9\x96\xC6\x96\xFB\x96\x9E\x92\xE3\x96\x64\x94\x20\x92\x4E\x8F\x7D\x7A\x1B\x97\x24\x86\x1D\x97\x00\x92\x2A\x93\x69\x91\xD0\x92\x6B\x91\xAC\x96\xB4\x93\x6E\x91\xB6\x93\x92\x89\xBB\x91\xFF\x86\xE1\x86\x22\x96\x35\x92\x2A\x8A\x1C\x90\x5E\x85\xA0\x96\x2D\x97\x53\x8A\x2F\x97\xD9\x90\xCE\x92\xDB\x90\xB1\x93\xED\x90\xDE\x90\x36\x97\xAE\x96\x38\x97\x09\x92\x71\x91\xF3\x8F\x68\x92\xF7\x8F\x4E\x92\x36\x90\x42\x85\xD4\x8D\x00\x7C\xA9\x87\x40\x97\xE2\x84\x2C\x97\xC1\x93\x79\x91\xC3\x93\x31\x91\xBE\x96\x3F\x92\x5D\x92\x41\x92\xC2\x96\x43\x92\xC4\x96\x45\x92\xFA\x96\x31\x93\xCF\x93\x49\x92\xEE\x96\x4A\x8F\x84\x92\xF6\x8F\x1D\x85\x6A\x92\xD9\x5E\x47\x8A\xF6\x70\x57\x97\x44\x85\x1B\x90\x7F\x78\x41\x97\x5C\x97\xA2\x96\xF0\x96\x39\x93\xFF\x91\x46\x97\x31\x97\x02\x92\x6A\x93\x04\x92\xD2\x92\x06\x92\xCD\x93\x08\x92\xAF\x92\xAD\x8D\x7F\x96\xDD\x87\x64\x8A\xDF\x87\x1D\x44\x35\x90\x88\x92\x17\x90\x22\x85\x19\x90\xFD\x8F\x8E\x92\xF4\x74\x08\x97\x3B\x92\x0B\x97\xFE\x91\xF3\x92\x30\x97\xC0\x96\x2B\x93\x65\x97\xAA\x92\x85\x97\xAC\x92\x87\x97\xAE\x92\x32\x93\x43\x8D\x0C\x0A\xA0\x8A\x51\x88\x00\x00\x98\x97\x09\x94\x75\x92\xAD\x93\x98\x91\xAF\x93\x9A\x91\x85\x93\x22\x97\x0B\x93\xDF\x96\x0D\x93\x8A\x93\x57\x93\xAF\x7C\x0F\x88\xFB\x8D\x33\x70\xAC\x97\x74\x92\xBD\x96\xDD\x92\xAE\x93\x3C\x93\xE0\x92\x3E\x93\xE2\x92\x40\x93\xA9\x7C\x42\x93\xCE\x79\x44\x93\xAF\x7E\x24\x88\xC5\x92\x26\x88\xF3\x53\xBE\x97\x91\x92\x9A\x97\xB7\x92\x0D\x97\x1E\x97\xBA\x92\x20\x97\xF7\x92\x9D\x93\xF9\x92\xB6\x97\x89\x93\xC1\x92\x2B\x3B\xD7\x92\xEC\x96\x43\x97\x15\x93\x67\x76\x82\x93\xA7\x96\x50\x8D\x7A\x92\x12\x97\x56\x7C\x3B\x8B\x15\x97\x66\x8E\x17\x97\x87\x91\x8B\x97\x91\x7C\xED\x92\xBD\x97\xE2\x97\x27\x93\x61\x97\xCD\x92\x81\x97\xCF\x92\x83\x97\xD1\x92\x67\x97\xD3\x92\xAD\x92\xD5\x92\x89\x97\xEF\x62\x00\x93\xAA\x97\xD1\x97\xB5\x92\x10\x92\x79\x90\x98\x93\x26\x92\xC7\x93\xA8\x92\xA0\x97\x2D\x93\x9E\x93\x24\x97\xC0\x92\xC7\x96\xC2\x92\xBA\x97\x79\x76\xBF\x90\x1A\x97\x5D\x97\x23\x92\x7A\x91\x25\x8E\x5D\x8E\x7D\x91\xE6\x97\x7F\x91\x11\x97\x81\x91\x13\x97\x83\x91\xF1\x8C\x85\x91\x67\x8E\x5F\x7B\xD2\x90\x16\x98\x7C\x97\xB6\x92\xFB\x90\x7F\x97\x77\x92\xB1\x97\x79\x92\xA3\x7C\x7B\x92\xEA\x97\x7D\x92\x38\x7B\x7F\x92\x9A\x79\x6E\x85\x40\x8B\x66\x7F\x28\x98\xBC\x96\xD6\x96\x1A\x98\x0C\x8B\x95\x8E\xDA\x96\x6D\x8D\xDC\x96\x39\x8B\x32\x98\x14\x97\x34\x98\x16\x97\x80\x92\x6E\x87\x54\x8B\x5D\x72\x85\x72\x04\x98\xC9\x92\x2A\x98\x24\x90\xF2\x96\x5C\x92\x07\x93\x5E\x92\x09\x93\xB4\x97\xDE\x96\x0F\x98\xA0\x93\x6A\x97\xE2\x96\xD1\x79\x08\x91\x84\x7E\x6A\x8B\xD6\x79\xD3\x88\x11\x95\x3B\x66\xA8\x8E\xC2\x76\x4D\x98\xDA\x92\x7D\x97\xF2\x92\xD5\x97\x9D\x97\x0A\x98\x69\x93\x0C\x98\x6B\x93\x0E",
"\x98\x6D\x93\x69\x97\x6F\x93\xFC\x96\x32\x86\x59\x93\x18\x8D\x25\x91\xFF\x96\x9F\x72\x89\x8B\x25\x95\xA7\x8E\x87\x7F\x2C\x91\x60\x91\x66\x98\xF0\x92\x68\x98\x4C\x93\xE4\x97\xA6\x96\xF3\x7C\xE7\x97\x30\x98\xE9\x97\x89\x7C\x22\x98\xEC\x97\x24\x98\xEE\x97\x80\x8A\x77\x96\xD3\x93\x77\x7D\x35\x61\x90\x93\xDC\x8E\x92\x93\x46\x91\xF8\x8E\x81\x98\x4A\x93\x83\x98\x80\x93\x45\x97\x2D\x98\xC3\x97\xB0\x93\x33\x97\xAB\x96\xAB\x92\xAD\x96\xFE\x97\xAF\x96\x00\x98\xF2\x8F\xD4\x96\x80\x96\x5A\x91\x68\x77\x5C\x91\x9F\x7F\xC2\x8B\x98\x7D\xF6\x88\x9A\x98\x7E\x93\x9C\x98\xA4\x96\x9E\x98\x3B\x93\xDA\x90\x3D\x93\xC9\x90\x3F\x93\xEE\x90\xD2\x91\x40\x8F\x43\x93\xF2\x90\xB8\x93\xF0\x97\x73\x91\xBD\x93\x50\x7A\x0E\x8F\x99\x98\xF4\x97\x19\x98\x5C\x8E\x3E\x98\xBB\x8F\x40\x98\xA9\x96\x42\x98\xAD\x79\x08\x8E\x58\x98\xE0\x96\x5A\x98\x74\x98\xD0\x93\xC3\x98\x8A\x91\x45\x74\x43\x74\xC8\x86\x87\x77\xB9\x96\x00\x00\x7E\x7E\x17\x98\xA3\x92\xCA\x98\x93\x8E\xE5\x97\x87\x98\x1E\x98\x51\x8D\x1B\x93\x82\x91\x1D\x93\x84\x91\x1F\x93\xF3\x8C\x3A\x97\x25\x8A\x3C\x97\x27\x8A\xDB\x8C\x7B\x74\xCE\x96\xBE\x5A\xB8\x96\x9E\x96\x23\x8A\x6E\x53\xE0\x98\x29\x98\x06\x98\xE4\x91\x51\x98\x06\x93\xF4\x96\x54\x98\xF6\x96\xDA\x97\xF8\x96\x71\x98\x25\x97\xD5\x98\xC8\x96\xEF\x98\x31\x96\xF1\x98\x79\x8D\xF8\x8C\x03\x87\x51\x84\x65\x8F\xD0\x96\x67\x8F\x65\x68\xFB\x98\x3B\x98\xD3\x97\x2B\x98\x9C\x97\x80\x97\x9E\x97\x32\x97\xFA\x97\x34\x97\xA4\x98\x4C\x97\xA6\x98\x4E\x97\xA8\x98\xD6\x91\x33\x4E\x6A\x84\xD9\x91\xB7\x6C\x62\x98\x5B\x73\x78\x84\x1A\x8D\xE9\x86\x15\x99\xAA\x98\x57\x92\xC2\x93\x95\x91\xC4\x93\xF6\x97\x29\x93\x1B\x99\x82\x97\x6E\x98\x84\x97\xFC\x97\x86\x97\x72\x98\xCE\x93\x5B\x98\xD6\x73\x2E\x8D\x3C\x87\x76\x62\x31\x8D\x97\x84\xF8\x91\xC0\x75\x2E\x99\x6D\x97\x02\x90\xFD\x98\xCB\x92\x34\x99\xC6\x93\x63\x97\xC8\x93\x9C\x93\xCA\x93\x70\x98\xCC\x93\x3C\x99\x88\x97\xA6\x97\x38\x5F\x19\x97\x33\x70\x47\x99\x09\x97\xEF\x96\x4F\x98\x96\x91\xC1\x97\xB0\x97\xA0\x98\xB2\x97\x1F\x98\xE9\x98\x21\x98\xEB\x98\x23\x98\xED\x98\x25\x98\x21\x93\x37\x78\xF8\x98\x5C\x2C\x78\x05\x5A\x99\x99\x97\xB5\x98\x0C\x97\xB7\x98\xC2\x97\xB9\x98\xC4\x97\xBB\x98\xC6\x97\xBD\x98\x41\x93\xBF\x98\xCA\x97\x74\x8D\xFF\x8C\x44\x8F\xB2\x96\xBE\x91\x96\x89\x83\x7B\x52\x78\x4B\x8F\xFB\x7E\x7A\x97\x01\x01\x6F\x99\xAD\x97\xC0\x97\xAF\x97\xCC\x91\x61\x99\x2F\x98\x0F\x7D\x38\x8B\xD1\x98\x34\x88\x68\x97\x07\x99\x73\x98\x27\x97\x8A\x97\x86\x95\xAC\x98\x71\x75\x44\x8A\x76\x78\x91\x97\xE3\x87\x18\x90\xD9\x7B\x52\x92\x71\x92\x6E\x99\xC9\x98\x5F\x97\x4B\x91\x05\x93\xA6\x92\x6C\x98\x9B\x93\x55\x98\x04\x99\x23\x97\x06\x99\x10\x98\x26\x97\x12\x98\xD7\x98\x99\x99\x8D\x97\x03\x7F\x71\x97\x90\x97\x8C\x92\x9E\x78\xA0\x99\xC4\x87\x95\x97\x78\x97\x4D\x8A\x89\x99\xBF\x97\x3C\x98\xCB\x98\xE7\x8F\xEA\x8C\x7A\x8B\xDB\x96\x9A\x7B\x43\x98\x8B\x98\x66\x99\x8D\x98\x68\x99\x8F\x98\x08\x8F\xB4\x99\x45\x5B\x8E\x97\xFA\x7B\x6B\x92\x89\x92\x38\x90\x8B\x92\x8B\x8A\xFF\x00\xD7\x8D\xA8\x64\xC0\x99\xD2\x97\x71\x99\x9B\x97\x6A\x98\x1A\x99\xAA\x99\xC1\x96\x50\x99\xC3\x96\x52\x99\xC5\x96\xB0\x99\x08\x99\xB2\x99\x9F\x92\x4E\x90\x5B\x85\x46\x99\xA5\x99\x32\x99\x60\x97\x5F\x99\x8D\x99\x75\x99\xA1\x98\x1D\x99\xA3\x98\xA2\x97\xA5\x98\xA4\x97\xFF\x97\x56\x99\xB7\x7E\x61\x90\xDB\x99\xEF\x99\x59\x92\xF1\x99\x8C\x99\xBF\x96\xE2\x99\x9F\x97\xE4\x99\x66\x97\xE6\x99\x94\x99\xE8\x99\x96\x99\xEA\x99\x23\x88\xC4\x92\x06\x80\xCF\x97\x9D\x0B\xDC\x99\x05\x98\xF9\x90\x04\x8D\x18\x99\xE0\x99\x9F\x98\xF4\x99\x62\x99\xE8\x98\x52\x93\xEA\x98\x54\x93\xEC\x98\x56\x93\x13\x39\xE0\x97\x2D\x99\x00\x9A\xFA\x90\x50\x98\x4C\x99\xF3\x96\x1F\x97\x02\x99\x21\x97\xAD\x99\xB5\x97\xD3\x98\xB7\x97\xDE\x97\xB9\x97\xB3\x99\x98\x90\x47\x76\x9A\x90\x59\x99\x25\x9A\x16\x9A\x27\x9A\xF2\x99\x04\x9A\x4E\x99\x0B\x98\x07\x9A\xA1\x97\x3A\x99\xA3\x97\x54\x99\xA5\x97\x6B\x97\x33\x93\x2A\x01\x02\x98\x58\x8E\xDF\x98\x38\x9A\x6D\x8F\x3A\x9A\x03\x9A\x62\x97\x53\x98\x64\x97\x3F\x9A\x0D\x98\xDB\x97\x2F\x9A\xDD\x97\x11\x98\x8B\x93\xF9\x8D\x08\x0A\x18\x8B\xAA\x97\x13\x9A\x4E\x98\x4A\x99\xF1\x96\x28\x9A\x52\x98\x01\x99\x51\x9A\xAC\x99\x51\x99\x54\x9A\xAF\x99\x59\x98\x0C\x9A\x58\x9A\x0D\x8E\x27\x98\x37\x9A\xE1\x98\x03",
"\x93\xE3\x98\xB0\x91\x09\x98\x3D\x9A\x6D\x98\x52\x9A\x6F\x98\x67\x9A\x53\x99\x95\x99\x3D\x99\xD6\x98\xA2\x88\x65\x7F\x08\x86\x6E\x9A\xFC\x98\x15\x9A\x4C\x9A\x5E\x99\x4E\x9A\xF7\x97\x36\x99\xF9\x97\x38\x99\xFB\x97\x09\x9A\xFD\x97\xFA\x99\xA7\x98\xFC\x99\x24\x99\x5F\x66\xBB\x88\x95\x86\x5D\x9A\x67\x98\x5D\x99\x33\x99\x3B\x9A\x4F\x9A\x63\x9A\x4F\x99\x65\x9A\xE5\x99\x78\x9A\xE7\x99\x69\x9A\x7B\x9A\x97\x99\xD9\x95\xAB\x95\x09\x94\xD5\x79\x6A\x6D\x2A\x6A\x8A\x8B\x6E\x8B\x2A\x01\xD7\x88\xF6\x88\x94\x9A\x82\x98\x96\x9A\x02\x9A\x2C\x98\xB8\x98\x47\x97\xBA\x98\xEC\x90\xBC\x98\x4B\x97\xBE\x98\xF0\x90\xC0\x98\xD5\x91\x42\x80\x5D\x98\x21\x95\x79\x98\x76\x93\xF9\x01\x29\x99\x26\x1A\xC5\x8E\xFE\x79\x93\x9A\x4B\x9A\x40\x90\x17\x9A\x73\x99\x60\x99\x1A\x9A\x8F\x99\x37\x8B\x31\x98\xCA\x99\x1F\x9A\x67\x99\x21\x9A\x69\x99\x57\x91\x5F\x96\x04\x6B\xD9\x8E\x2F\x7E\xDB\x8E\xEE\x02\xA7\x8B\x11\x89\x60\x91\xAE\x9A\x9B\x98\xB0\x9A\xA7\x99\xFF\x98\xA9\x99\x74\x9A\xAB\x99\x03\x99\x66\x9A\x05\x99\x79\x9A\x0B\x9A\xA1\x9A\x0D\x9A\x98\x99\x91\x98\x21\x8F\x48\x77\xE7\x72\xC1\x8B\x2A\x01\xA9\x93\xF8\x8E\xE0\x9A\xB4\x98\xE2\x9A\x97\x93\xA8\x99\x99\x93\x05\x9A\x1C\x99\x89\x9A\x1E\x99\xF8\x99\x20\x99\x8D\x9A\x22\x99\x8F\x9A\xC2\x98\x70\x96\xA9\x7F\xAB\x86\xF6\x02\xDB\x8B\x85\x72\xF8\x9A\x01\x72\x8B\x99\xB2\x9A\x74\x99\xB4\x9A\x76\x99\xB6\x9A\x78\x99\xB8\x9A\x7A\x99\xBA\x9A\x7C\x99\xBC\x9A\x50\x97\x2F\x99\xF1\x8E\xF5\x8F\xBE\x8B\x5E\x89\x23\x8F\x0C\x8F\xF4\x90\x54\x84\x79\x94\x81\x54\x78\x05\x87\x7E\x1D\x9B\x48\x81\x80\x94\xDA\x91\x26\x94\x68\x57\xFD\x8B\x38\x73\x50\x81\x6C\x82\x29\x9B\x48\x99\xA0\x52\x89\x94\xFE\x6C\x34\x9B\x5B\x99\x6E\x97\xD7\x94\x46\x0A\x3F\x95\x89\x95\x0F\x6C\x92\x94\xE6\x94\x39\x9B\x47\x95\x60\x6F\x92\x5B\x67\x81\x76\x95\x4B\x95\x78\x95\x1C\x94\x50\x8C\x95\x82\x43\x9B\x54\x95\xB0\x82\x73\x81\xE8\x0F\x3F\x9B\xA9\x94\xF6\x7D\x4E\x9B\x60\x95\xAE\x94\x7D\x81\x88\x8C\x41\x95\x10\x94\x09\x6D\x55\x9B\x8D\x95\x20\x7E\xC7\x82\x12\x6D\x91\x95\xB4\x82\x9C\x94\x57\x94\x28\x7E\x38\x95\x28\x9B\x5F\x9B\xD9\x7F\xCE\x8D\xF4\x52\x53\x9B\x4C\x6F\x7B\x95\x70\x95\x55\x54\x6A\x9B\xDD\x1F\x14\x80\xCF\x94\x6E\x9B\xFB\x6C\xD4\x94\x42\x9B\x73\x9B\x0B\x94\xD9\x8B\x93\x07\x77\x9B\x48\x6D\x8B\x95\x7A\x9B\xD0\x99\x8E\x95\x98\x8C\xA5\x56\x9A\x95\xD2\x94\x27\x94\xE5\x94\x71\x9B\x56\x9B\x73\x95\x5B\x94\x6D\x6F\x7F\x9B\x77\x81\x6B\x82\xAE\x8C\x8C\x9B\xE7\x93\xD0\x96\xF4\x94\x03\x58\x69\x9B\x81\x8A\xF8\x94\xB3\x8C\x38\x9B\x6E\x94\x68\x8B\xDE\x81\x7E\x82\x46\x80\xB0\x95\x27\x5C\x01\x8C\x31\x8F\xF3\x53\x8C\x7E\x6F\x9A\x14\x93\xF5\x97\x98\x9A\x86\x9A\xFE\x9A\x37\x99\x76\x9A\x39\x99\x8B\x9A\x3B\x99\x7A\x9A\x55\x99\x3B\x96\xC6\x89\x7F\x99\xCA\x96\x81\x99\xDA\x8C\x97\x89\xB5\x96\xF5\x98\xB7\x96\xBE\x7A\x6C\x99\x64\x89\xA8\x9B\x81\x9A\x58\x92\x26\x9A\x84\x9A\x11\x9B\xCC\x9A\x13\x9B\xF5\x99\x00\x9B\xF7\x99\x41\x9A\xF9\x99\x43\x9A\xFB\x99\xB6\x9B\xF9\x98\x2C\x84\xD9\x84\xE0\x86\xEF\x54\x01\x87\x1D\x62\x50\x84\x4B\x92\xCF\x96\xE9\x6E\x13\x99\x3A\x88\xC3\x9B\x16\x99\xDE\x99\xD4\x97\xCB\x9A\xF3\x99\xCA\x9B\x1B\x9A\xE8\x97\x20\x98\x44\x98\x8C\x98\x46\x98\xED\x97\x48\x98\xC6\x8A\x13\x8D\xF1\x93\x20\x87\xDB\x91\x51\x5D\xDD\x91\x09\x52\x01\x7B\xE9\x86\xE0\x9B\x1D\x9B\xAE\x97\xC8\x9B\xE5\x9B\xF8\x97\x48\x97\xA2\x98\x4A\x97\xB3\x93\xB9\x9A\xB5\x93\xBB\x9A\xB7\x93\xDC\x9B\xBC\x89\xC0\x9A\xED\x74\xF4\x91\x02\x97\xF6\x91\xB8\x89\x08\x0A\x06\x97\x33\x70\xF9\x9B\x35\x9B\x65\x8D\x31\x99\x01\x9A\xE3\x9A\x61\x9A\x00\x99\x2A\x9A\x64\x9A\xE8\x9A\x9D\x9A\xEA\x9A\x9F\x9A\xD4\x98\x6A\x9A\x32\x9A\xEB\x99\x31\x9B\x7C\x76\x43\x87\x00\x00\x12\x9C\x3A\x9B\x49\x99\x82\x9A\xC9\x9A\x4D\x9A\xFC\x9B\x3C\x9A\x50\x9A\x9B\x9A\x1C\x9C\x08\x9A\x9E\x9A\x0A\x9A\xA0\x9A\xB5\x9B\x3E\x99\xDD\x95\x53\x84\x2A\x97\x90\x91\x02\x01\x28\x9C\x70\x99\xFA\x9A\x65\x93\x08\x98\x67\x93\xAE\x9B\x88\x9A\xB0\x9B\x8A\x9A\x34\x9C\x8C\x9A\xD0\x9B\x8E\x9A\xD2\x9B\x43\x8F\x11\x96\xE6\x80\xA5\x91\x77\x01\x88\x87\x3F\x97\x79\x97\x5B\x97\x8B\x7E\xC8\x9A\xD6\x90\x2D\x9C\x19\x99\x19\x9A\xE6\x9B\xCE\x9A\x4E\x8E\x40\x9A\xB2\x9B\x42\x9A\xB4\x9B\x44\x9A\x38\x9C\x41\x7F\xD7\x9A\x12\x95\x6F\x97\x16\x7F\xAA\x7B\x55\x97\xA6\x87\x76\x97\xA8\x87\x08\x0A\x53",
"\x92\x2C\x8A\x27\x9C\x57\x9C\x11\x92\xDF\x99\xE4\x9B\x2F\x9C\x9A\x9A\x3E\x9A\x9C\x9A\x33\x9C\x1E\x9C\x35\x9C\x20\x9C\xED\x9A\x6B\x9A\x33\x9A\x51\x97\x12\x90\xB2\x8D\x4F\x92\xBB\x99\xE5\x87\x1A\x90\x70\x92\xBA\x8D\x87\x99\x72\x9C\xA9\x9B\x26\x93\x71\x9A\x66\x93\x5E\x8E\x0F\x97\xD8\x97\xB3\x97\x2D\x9A\x57\x98\x68\x9A\x7E\x9C\x37\x9C\x7C\x9A\x9F\x8B\xF0\x97\xCD\x8D\x34\x90\xB3\x8D\x85\x63\x74\x97\xBB\x75\x6D\x9C\x64\x5A\x96\x97\xC0\x75\x3E\x9C\x8A\x99\xC2\x99\xE4\x98\x86\x98\x65\x85\xE7\x98\xE8\x9B\x64\x99\xEA\x9B\xCB\x99\xEC\x9B\x8E\x98\xEE\x9B\x18\x97\xA8\x97\x38\x7F\xA8\x64\xA7\x9C\xC1\x99\x17\x99\x59\x9C\x18\x9A\xB3\x9A\xFE\x9B\xB5\x9A\x49\x97\xB7\x9A\x02\x9C\x18\x9B\x04\x9C\x1A\x9B\x06\x9C\xF6\x98\xB1\x92\x1D\x7E\x26\x9C\xB9\x9C\xDD\x99\x40\x9C\x3D\x92\x18\x9C\xE5\x9A\x30\x9C\x79\x9C\x32\x9C\x5F\x9C\x48\x9C\xB3\x9B\xEC\x9A\x99\x9C\xA2\x9A\xE1\x7A\x0F\x9A\xC8\x8A\x6E\x53\xCC\x9C\x14\x9A\xC5\x9B\x39\x9A\xC7\x9B\x5A\x9C\xBE\x9C\x87\x9A\xFF\x9B\xF6\x99\x01\x9C\x35\x97\x03\x9C\x37\x97\x05\x9C\x40\x62\x23\x9A\x2B\x97\x56\x9C\x8D\x9C\x38\x93\x69\x98\x76\x9C\x99\x9A\x1A\x9C\x31\x9C\x2C\x9A\xE9\x9A\xAE\x99\xEB\x9A\x36\x9C\x63\x9C\x9A\x9C\xEF\x9A\xF3\x8F\x99\x90\x50\x88\x49\x9A\xDF\x9C\x5E\x9A\x2B\x9C\x58\x9C\xE3\x9C\xBD\x9C\x12\x9B\xBF\x9C\x14\x9B\xC1\x9C\x16\x9B\xC3\x9C\xC8\x97\x7B\x99\x7C\x7B\xCB\x97\x46\x9A\xFF\x00\x48\x9A\xAE\x6B\x78\x05\x05\x9D\x95\x9A\x5F\x9A\x7E\x97\xE4\x9C\x0B\x9D\xE6\x9C\xC0\x9C\x00\x9C\xC2\x9C\xEA\x9C\xC4\x9C\xEC\x9C\xC6\x9C\x70\x91\xC8\x9C\x5A\x9A\x15\x98\x11\x9C\x73\x9C\x07\x98\xFC\x9A\x73\x9A\xD2\x9C\x75\x9A\x7A\x9C\xD5\x9C\x7C\x9C\x49\x9C\x62\x9C\xD1\x9B\x64\x9C\xD1\x90\x69\x8E\x61\x7F\xA6\x9C\x2D\x9D\xFE\x98\xD0\x9C\xFD\x9A\xE6\x9A\xE3\x99\x33\x9D\x53\x9A\x35\x9D\xD7\x9C\xFD\x9C\x38\x9D\xFF\x9C\x7A\x8E\x41\x8B\x2C\x9D\xF2\x9C\x64\x93\xCF\x9C\xAC\x9B\x35\x99\x44\x9C\xE7\x9C\xCC\x9B\xE9\x9C\x1F\x99\xEB\x9C\x4D\x97\xED\x9C\x4F\x97\x11\x99\x24\x9B\x92\x9A\xF6\x88\x1A\x9D\xAF\x9A\x1C\x9D\xF4\x9C\x85\x98\x0E\x97\x1D\x98\x19\x93\x63\x99\x1D\x9A\x65\x99\xD2\x9A\xCC\x99\xD4\x9A\xCE\x99\x32\x7D\x76\x98\x26\x95\x52\x80\x5C\x93\xA5\x8E\x78\x93\x18\x95\xAB\x9A\x8D\x8E\x01\x01\xAA\x8E\x60\x9D\xE1\x9A\x62\x9D\x84\x98\xB4\x76\xAB\x9C\x64\x86\x09\x8D\x5D\x9C\xAA\x96\x56\x9D\x02\x9B\x58\x9D\x21\x99\x5A\x9D\x23\x99\xBD\x9A\xFE\x94\xA5\x9A\x74\x93\x53\x86\x93\x31\x7B\x98\x03\x97\x8B\x8B\x2B\x91\xC6\x8E\xF8\x8E\x7B\x9D\xF9\x9A\x7D\x9D\x9D\x98\x64\x9D\xD6\x97\x4F\x93\x93\x9C\x68\x9D\x86\x93\x1E\x9A\x88\x93\x20\x9A\xB8\x97\x86\x91\x90\x98\xA4\x93\x92\x98\x8F\x93\xC1\x72\x91\x93\x19\x7A\x93\x93\x60\x91\x97\x9D\x0F\x9B\xA9\x9C\x72\x9A\x43\x9C\x42\x9D\x06\x9A\x44\x9D\x77\x9A\x46\x9D\x61\x9C\xD8\x9C\xFE\x9C\xDA\x9C\x65\x9C\xD8\x98\x92\x98\xAE\x98\x4A\x77\xB0\x98\xA1\x7F\x95\x86\xAF\x9D\xC7\x72\xBB\x9C\x09\x9D\xF5\x9C\xAD\x9B\xB4\x9D\xFF\x9A\x46\x9C\x01\x9B\xCE\x9B\x03\x9B\x4A\x9C\x05\x9B\x45\x9A\x00\x9D\x1D\x9B\xC4\x98\xB2\x50\x0C\x9B\xC4\x9D\x3E\x9D\x4B\x99\x51\x9D\x4D\x99\x31\x9D\xE7\x9A\xF9\x9C\x1D\x9C\xFB\x9C\x1F\x9C\x30\x9A\x57\x9A\x22\x9C\x9B\x9C\x08\x9B\x92\x98\x8B\x91\x85\x77\xD4\x7D\xDD\x98\xC1\x9B\x6E\x53\x96\x7E\x4E\x9D\x96\x93\x41\x9C\x2F\x9D\xB3\x9D\xDE\x9D\x43\x9D\xD4\x9C\x45\x9D\xE2\x9D\x7D\x9C\xE4\x9D\xB1\x99\xD7\x84\xD8\x8F\xBE\x7E\x4F\x9C\xCB\x96\xF3\x98\x55\x01\x49\x8F\xA1\x74\x29\x9D\xDF\x8C\xEE\x9D\xF3\x53\xF0\x9D\xC4\x9B\x15\x9C\xC6\x9B\x97\x9A\x85\x9A\x52\x9D\xCB\x9D\xAF\x9B\xB6\x9D\xB1\x9B\xD6\x9C\xB9\x9D\x48\x9D\x4B\x9C\x2C\x68\xC9\x96\xD5\x73\x02\x9E\xBC\x9B\xCD\x96\x10\x99\x1B\x72\x53\x84\xDE\x9B\xCD\x74\x0B\x9E\xE1\x9B\xCE\x9C\x93\x92\x54\x7B\x9C\x9D\x92\x9C\x2B\x9A\xD9\x97\xFA\x9C\x2E\x9A\x97\x9C\xFC\x9D\xE9\x99\x80\x9C\xCC\x97\xB3\x89\x1E\x87\x7E\x8F\xF2\x9B\x43\x99\x5A\x93\xD6\x7E\x2C\x99\xF0\x9C\x00\x00\x25\x9E\xFA\x9B\x10\x9B\x1E\x9D\xC9\x9B\x0C\x9D\xCB\x9B\xCD\x9D\xCD\x9B\x60\x9C\xCF\x9B\x37\x9D\x19\x9E\x4A\x9D\x39\x9C\xA1\x4D\x99\x8F\x00\x97\x14\x67\x0C\x9C\xE8\x96\x0E\x9C\x07\x5A\x61\x7D\xAA\x97\x3F\x9E\x13\x9C\xFB\x9B\x42\x9E\xFD\x9B\x20\x9D\x0D\x9D\x22\x9D\x0F\x9D\x24\x9D\x11\x9D\x19\x9B\x13\x9D\xC1\x98\xE7\x54\x0B\x92\x57\x9E\xDA\x9D\x60\x9A\xDC\x9D\x29\x9A\xD7\x97\x2C\x9E\x94\x9C\x2E",
"\x9E\x96\x9C\xFC\x9C\x98\x9C\xBB\x9D\xEE\x9A\xCB\x77\xE9\x6E\x3B\x9C\x9F\x96\x02\x01\x58\x9E\x29\x9C\x30\x99\x5E\x97\xF0\x99\x17\x9C\x6B\x9E\x62\x9A\xF7\x9C\xD3\x9C\xE0\x9D\x7B\x9C\xFA\x9D\x36\x9D\xBA\x9D\x49\x9D\x09\x99\xFF\x9D\x4B\x84\x01\x9E\xBA\x9B\xF7\x8C\xF7\x7E\x3E\x97\xE0\x84\x8A\x9C\x55\x9C\x3E\x9E\x69\x9E\x1D\x9D\x0A\x9D\x43\x9E\x5D\x9E\x45\x9E\x14\x9E\x47\x9C\xB8\x9D\x49\x9E\x89\x9E\x4B\x9E\xBC\x9D\x07\x9B\x97\x95\x43\x8A\x6A\x9C\x9E\x99\x88\x8A\x93\x97\xA1\x99\x88\x9C\x2A\x01\x70\x9C\x1D\x90\x96\x9E\xF1\x9D\xAC\x93\x2E\x9C\xF6\x9C\x6D\x9E\x1B\x9C\x85\x9E\x34\x9D\x87\x9E\x47\x9D\x73\x9E\x8A\x9E\x75\x9E\xA9\x98\x13\x9C\x52\x97\xB7\x99\x9F\x9C\xFC\x7B\x6C\x92\x48\x8A\xD7\x99\xB8\x8D\x89\x9C\x5A\x97\x04\x85\x7A\x9E\x97\x9E\x63\x9D\x7F\x9D\x65\x9D\xE6\x98\x67\x9D\x1C\x9A\xA0\x9D\x6A\x9D\xA2\x9D\xD3\x9A\xA4\x9D\xD5\x9A\xA3\x93\x1D\x9B\x9D\x9C\x86\x92\x1E\x71\x6B\x9C\xB9\x99\xA7\x87\xA4\x9C\xD6\x8D\x3C\x90\x68\x9E\xB1\x9E\x1C\x97\x9B\x9D\x6B\x98\x12\x9E\x45\x9C\x9D\x9E\xCE\x9D\x48\x9E\xD0\x9D\x4A\x9E\xD2\x9D\x39\x9D\x66\x9E\xEC\x99\xFD\x87\xE4\x9E\x0C\x9E\x7E\x9E\x16\x9C\xFB\x9A\xE4\x9A\x41\x9D\xF6\x9D\xB5\x9D\xF8\x9D\xB7\x9D\xB9\x9E\x17\x9E\xBB\x9E\xA2\x9E\xBD\x9E\x60\x90\x10\x88\xF5\x9E\x26\x9E\x99\x9D\xB6\x98\xE7\x9E\xE1\x99\xE9\x9E\x54\x9D\x46\x9E\x85\x9D\xCF\x9D\x87\x9D\x04\x9B\x89\x9D\x06\x9B\x52\x84\xDC\x9C\x0F\x8E\x0A\x9E\xCC\x9E\x7E\x9D\xCA\x76\xCF\x9E\xAC\x9C\xD1\x9E\xAE\x9C\x69\x9D\xB0\x9C\x6B\x9D\xB2\x9C\xCD\x99\x24\x79\x85\x90\xDA\x80\x3C\x9C\x01\x01\x7B\x9E\x3F\x9C\x09\x9F\x72\x99\x0B\x9F\x5B\x9C\x44\x9E\xE7\x9B\x89\x98\xE9\x9B\xD1\x9A\xD5\x9E\x6C\x9D\xD7\x9E\x6E\x9D\xD6\x9A\xF0\x97\x02\x9D\x13\x75\x2B\x9F\xA8\x9C\xC7\x9D\x0F\x9E\xB3\x9E\xCA\x9D\xFC\x9E\xCC\x9D\xEB\x9E\x47\x9E\x16\x9E\xA0\x9E\x18\x9E\xF0\x9E\x4C\x9E\xDF\x8F\x17\x9D\xAA\x5A\x78\x05\x3E\x9F\xBA\x9C\xE2\x9B\xCA\x9A\x2F\x9F\xE5\x9C\x53\x9D\x21\x9D\xE8\x9C\x23\x9D\x57\x9D\x25\x9D\x59\x9D\x27\x9D\x5B\x9D\xBF\x9B\x2A\x9D\x6D\x79\xF4\x74\x51\x9F\xCD\x9C\x2D\x9F\x75\x9C\x55\x9F\x1F\x9D\x57\x9F\x5E\x9E\x59\x9F\x60\x9E\x5B\x9F\x62\x9E\xC5\x9C\x64\x9E\x1B\x9B\x97\x76\x0C\x0A\x86\x79\xA8\x64\x64\x9F\xE0\x9C\x0D\x9E\xE2\x9C\x41\x9F\x5B\x9E\x77\x9C\x83\x9E\x32\x9D\xFE\x9E\x15\x9E\x9F\x9E\xEE\x9E\xA1\x9E\x4B\x9F\xA3\x9E\x7D\x89\x2A\x01\x35\x93\x76\x9F\x1A\x9F\x9A\x9D\xCE\x9E\x2A\x9E\x66\x9D\x84\x93\x9F\x9D\x56\x98\xA1\x9D\xDC\x97\xA3\x9D\x31\x9A\xA5\x9D\xF0\x91\xD5\x7D\x5E\x9D\xF8\x8E\x77\x9F\x06\x9D\xE1\x9C\x83\x9A\x7B\x9F\x99\x9E\x5C\x9E\x6A\x9F\x9C\x9E\x80\x9F\x9E\x9E\x00\x9F\x49\x9F\x02\x9F\x85\x9F\x04\x9F\x8B\x9D\xA4\x9A\x09\x91\xA6\x9A\x77\x7E\x39\x9E\x93\x9D\xFF\x00\xAC\x9A\x9B\x9F\x8B\x9F\x0A\x9F\x8D\x9F\xE8\x9E\x44\x9F\x13\x9E\xA5\x9F\xEC\x9E\x48\x9F\x83\x9F\x4A\x9F\x14\x9F\xD3\x9D\xA3\x9A\x3C\x9B\x85\x8B\x81\x7F\x4F\x9E\x7A\x98\x77\x93\xA9\x9A\x7D\x98\x8C\x8B\xC6\x9A\xF6\x88\x9C\x9F\x1B\x9D\x07\x9D\x74\x9C\xE3\x9B\x68\x9F\x9A\x9E\xA3\x9F\x32\x9F\x90\x99\xD0\x9A\x8A\x84\xEB\x97\x24\x9F\x6D\x9D\xB4\x9C\xEF\x97\xE8\x9D\xF1\x9A\x71\x94\x7A\x8C\xC0\x72\xFD\x31\x0E\x74\x45\x91\xA8\x8B\xCE\x9F\xB6\x9F\x2E\x9F\xB8\x9F\x0C\x9F\xBA\x9F\xEA\x9E\xBC\x9F\x47\x9F\x82\x9F\x12\x9F\xD1\x9D\xC1\x9F\xF1\x9E\x02\x6B\xE0\x9F\x68\x9C\x88\x54\xC0\x9D\xF4\x9A\xFF\x00\xF6\x9A\x60\x91\xCF\x9F\x61\x9D\xD1\x9F\x2E\x9D\xFA\x9E\x30\x9D\x78\x9C\x7F\x9F\xB7\x9E\xF9\x9D\x2F\x9E\x72\x9E\x31\x9E\x21\x9C\x97\x9F\x8C\x93\xD5\x9D\x09\x9B\x7D\x9B\x0B\x9B\x45\x89\xB7\x7D\xB5\x9F\xE5\x9E\x2E\x97\xD4\x9F\xA2\x9F\x0D\x9F\x58\x9F\x55\x9D\x5A\x9F\x86\x9D\x5C\x9F\x88\x9D\x5E\x9F\x8A\x9D\x1C\x9B\x13\x9C\x76\x7D\xEA\x9D\x6D\x7A\x8D\x91\xED\x9D\x4D\x8F\x29\x9F\x00\x00\x9A\x7E\x17\xA0\x44\x97\x19\xA0\x7D\x9F\xB5\x9E\xF8\x9C\x2D\x9E\xE1\x9D\x0A\xA0\xE3\x9D\x56\x9A\xFD\x9D\xDD\x42\x1B\x9E\x83\x7E\x50\x9C\xBC\x9B\xF4\x98\x20\x9E\xF6\x78\x7E\x89\xE5\x7E\x64\x89\x2E\xA0\xF6\x9E\x18\x98\xA6\x99\xF9\x9E\x40\x9D\x05\xA0\x7E\x9F\xDF\x9D\x35\xA0\x86\x9E\x37\xA0\xFB\x9D\x39\xA0\x32\x9E\x3B\xA0\x0A\x99\x77\x8D\x0C\x99\xBF\x91\xCC\x96\x0F\x99\xDB\x9B\x5C\x9D\x72\x5B\x23\x9E\x19\x84\x46\xA0\x08\x9F\x02\xA0\x3F\x9D\x81\x9E\x19\x9C\x33\xA0\x84\x9E\x4F\xA0\xB8\x9E\x51\xA0\x88\x9E\xC0\x9F\x22\xA0\x15\x9F\x5D",
"\xA0\x25\x99\x14\x8D\x2D\x9B\xC3\x9A\x3B\x74\x2B\x99\xEB\x96\xE9\x86\x61\xA0\x40\x9E\xB1\x9D\x90\x9C\x1C\x98\xD0\x9E\x90\x9F\xD2\x9E\x92\x9F\xD4\x9E\x94\x9F\xD6\x9E\x96\x9F\xD8\x9E\x45\x93\xF1\x91\x92\x84\x50\x9E\x2D\x70\xB1\x9F\x13\x65\x9E\x8F\xAA\x97\x79\xA0\x59\x9E\x41\x9E\xA1\x9F\x32\xA0\x9D\x9D\x6E\x9E\x91\x9F\x95\x9C\x93\x9F\x55\x9A\x95\x9F\xE5\x9D\x0E\xA0\x20\x7C\x67\x9E\x49\x9A\x90\xA0\x7C\x9E\x14\x9C\xF7\x9E\x0E\x9E\xB1\x9A\x7C\x9F\xB4\x9E\x95\xA0\xB6\x9E\x69\xA0\x09\xA0\x71\x9E\x38\xA0\x9B\xA0\x3A\xA0\x9D\xA0\x0D\x8E\x6B\x99\x2B\xA0\x79\x9E\x01\x01\xA1\xA0\x2C\x9F\x63\xA0\xDB\x9D\x10\x9E\xDD\x9D\x06\xA0\x4E\xA0\x6F\x9E\x36\xA0\xAD\xA0\x52\xA0\xAF\xA0\x54\xA0\xEE\x98\x8C\x9E\xD5\x9B\xBD\x91\x58\xA0\x82\x99\x52\x9C\x93\x9E\xC9\x9E\x8C\x87\x02\x01\xB7\xA0\x3F\x9F\x53\x9F\xBC\x9C\xC9\x9D\x11\x9E\xEE\x9F\x0E\x9F\x46\x9F\x10\x9F\xED\x9E\xF3\x9F\xEF\x9E\xF5\x9F\x4C\x9F\xA4\x9E\x82\x9C\xA6\x9E\xFC\x84\xA8\x9E\x95\x8D\x86\x9C\x97\x8D\xAC\x9E\x99\x8D\xA3\x99\xCF\xA0\xEA\x9F\x67\x9F\xEC\x9F\x30\x9F\x9B\x9E\xD7\x9F\xCF\x9A\x8A\x98\xDA\x9F\x33\x98\xAB\x7C\x35\x98\x83\x79\xCF\x99\xA5\x9E\x4C\x92\xBF\x87\xB8\x99\xD4\x99\x92\x97\xB6\x8D\xC6\x9E\x3A\x90\x2A\x01\x21\x7F\x71\x9C\xD0\xA0\x52\x9F\x27\x9E\xD7\x96\x1B\x98\x3F\x98\xC6\x99\x41\x98\xC8\x99\x92\x99\xE6\x88\x9E\x7B\x53\xA0\x0D\xA0\x86\xA0\x6C\x97\xA2\xA0\xDB\x9E\x7F\x63\x87\x92\xB9\x99\xA1\x9C\x6A\x8A\x6E\x92\x58\x97\x3B\x90\x73\x7A\xA8\x64\x05\xA1\x65\x9F\xB9\xA0\x6A\x9E\xBB\xA0\x6C\x9E\xA9\xA0\x34\xA0\xBF\xA0\x50\xA0\xC1\xA0\x6C\xA0\xA9\x9F\xDD\xA0\x86\x9F\x9F\x5A\xA0\x92\xC0\x75\x21\xA1\x78\x9F\xA4\xA0\x7A\x9F\xA6\xA0\x93\xA0\xA8\xA0\x2B\x9E\xAA\xA0\x29\xA1\x6A\xA0\x2B\xA1\xBA\x9E\x0C\xA0\x7F\x9C\xE6\x9D\x36\x92\x2A\x01\xFE\x99\x8F\xA0\xEB\xA0\xD3\x9F\xED\xA0\x56\x9F\x1B\xA0\x6B\x9F\x1D\xA0\x6D\x9F\x1F\xA0\x6F\x9F\x26\x9D\x71\x9F\xC7\x9C\x21\x9E\x17\x9F\xC6\x92\x6E\x53\x33\xA1\x9D\x9F\x79\x9F\x9F\x9F\x37\xA1\xD4\xA0\xBC\xA0\x4D\xA0\xF7\x9D\x08\xA0\xFF\x9E\x6B\xA0\x3F\xA1\x11\xA1\x41\xA1\x22\x9A\x20\x8E\x60\xA0\x47\xA1\x54\x9F\x49\xA1\x69\x9F\x4B\xA1\xA4\x9F\x61\xA1\x81\x9F\xA7\x9F\xBF\x9F\x2D\xA1\x6E\xA0\xC2\x9F\xBE\x9E\xA2\xA0\x3C\x9F\xF4\x74\x58\xA1\xD0\x9F\x9E\x9F\x2C\x9C\xC8\x9D\x31\xA0\x39\xA1\x8F\x9F\x10\x97\x80\xA0\x98\xA0\x82\xA0\x9A\xA0\x84\xA0\x9C\xA0\x13\xA1\x15\x9D\x4E\x9F\x32\x6C\x78\x05\x7B\xA1\x01\xA0\x7D\xA1\x08\x9D\xA0\x9F\x5D\xA1\x26\xA1\x3A\xA1\x28\xA1\x97\xA0\x70\x9E\x99\xA0\x30\x9E\x65\xA1\xD9\x9C\xAB\x9F\x87\x9F\x79\x88\x2B\x9D\x20\xA1\x6A\xA1\xD3\xA0\x80\xA1\x43\x9F\xBD\xA0\x60\xA1\xAB\xA0\x62\xA1\x3E\xA1\x01\x9F\x40\xA1\x9D\xA1\x33\x9E\xBC\x7E\x6D\x9A\xA2\xA1\x2F\xA0\xE3\x97\x6C\xA1\xD5\x9F\x6E\xA1\xF0\xA0\x5E\x9C\xAC\xA0\x9A\xA1\x0B\xA0\x9C\xA1\x74\x9E\xAF\xA1\x43\xA1\xFF\x00\x89\x9F\x46\xA1\xB3\xA1\xAB\x9B\x25\xA1\x82\x9E\x67\xA0\x07\xA0\xA9\xA1\x71\xA1\x63\xA1\xAC\xA1\xBD\xA1\xBC\x9E\xBF\xA1\x76\x9E\xDB\x73\x9A\x9F\x60\x91\x8F\xA1\x7C\x9D\x23\xA1\x98\x9E\x94\xA1\xC7\xA1\x27\xA1\x68\xA0\x3C\xA1\xBA\xA1\x86\xA1\x9B\xA1\xC3\xA0\x12\xA1\x39\x9F\x75\x98\xBE\x9A\x93\x96\xAA\x03\x73\x9D\x6C\x8B\x75\x9D\xB2\x9F\xB4\x9F\xD4\xA1\xA3\xA1\x7F\xA1\xB5\xA1\x1A\xA0\xD6\xA0\x1C\xA0\x0F\x9F\x1E\xA0\x11\x9F\x20\xA0\x13\x9F\x75\xA1\xF6\x9F\xC8\x60\x70\x9D\x80\x7F\x78\x98\xC7\x9F\xC1\x9A\x76\x7F\xF4\x9B\x4E\x88\xCC\x9F\x59\x86\xF8\x8E\xD5\xA1\x98\x9D\xD7\xA1\xCD\x9E\x1C\x9F\x8E\x9F\x7E\xA0\x83\xA1\x20\x9F\xD3\x9E\x22\x9F\x36\x9F\xDC\x9F\x38\x9F\xDE\x9F\xA6\x9D\x10\xA0\xA8\x9D\xDA\x9A\x43\x91\x96\x98\xAC\x9D\x98\x98\xED\xA1\xC4\xA1\x8F\x9C\x42\x9C\x91\x9C\x82\xA1\x9E\x9D\x84\xA1\x99\xA1\xDF\xA1\xBC\xA1\xE1\xA1\x66\xA1\x8A\xA1\xD4\x9D\x25\xA0\xA5\x93\xA3\x94\xA7\x93\x29\x89\x5F\x91\x71\x8B\x8E\xA1\xEE\xA1\x93\xA1\xA5\xA1\xD5\xA0\xA7\xA1\xFD\x9E\x70\xA1\xA6\x9F\xCC\xA1\xA8\x9F\xAD\xA1\xBE\xA1\x42\xA1\x8E\x8D\x66\x9C\x69\x7A\x11\xA0\x0C\x8F\xD8\x9D\xF6\x88\x07\xA2\xB0\x9D\x40\x9F\x5C\xA1\x37\xA2\x5E\xA1\xC8\xA1\xBE\xA0\x98\xA1\xC0\xA0\xBB\xA1\xAE\xA0\x88\xA1\xB0\xA0\x2B\xA2\x42\xA2\xBE\x9D\xE1\x9F\x21\x9B\xD3\x7D\x29\xA0\x97\x96\x3D\x96\x3D\x74\xC7\x49\xBB\x89\x47\x47\xD6\x67\x0D\x50\x1D\x66\xE5\x80\x4B\x67\x1E\x81\xB9\x03\x55\x52\xDB\x57\x1B\x6E\x8A\x83\x69\x73\x64",
"\xA2\xFF\x4F\x66\x33\x41\x5C\x69\xA2\xCD\x94\x97\x5A\xF7\x53\x74\xA2\x17\x01\x24\x8C\xA9\x80\x26\x8C\x83\x80\x28\x8C\x28\x95\xA2\x5C\x93\x6D\x35\x66\x31\x17\x2B\x9B\x2E\x95\x81\x94\x4B\x9B\x81\x82\x30\x9B\x4F\x81\xCC\x6C\xF3\x53\x81\xA2\x3A\x81\x83\xA2\x37\x9B\x0A\x54\x8D\xA2\x53\x81\x0A\x17\xFF\x93\xF0\x7D\x87\x9B\x79\x95\xD4\x7F\x41\x9B\x71\x9B\x92\xA2\xA4\x58\x94\xA2\xA4\x82\xFB\x7D\x0E\x94\x63\x9B\xCA\x82\x93\x95\x4F\x95\x66\x80\x95\x82\x9C\xA2\x84\x58\x9E\xA2\x50\x9B\x16\x94\x57\x95\x90\x9B\x1D\x94\xF6\x7D\xA8\xA2\x0F\x84\x31\x17\x22\x94\x62\x9B\x5A\x9B\x59\x95\x5C\x9B\x0F\x6C\xB4\x94\x9B\xA2\xDF\x5E\xAA\xA2\xA0\x8C\x6A\x95\xAE\xA2\xD4\x7F\x6F\x95\x58\x81\x26\x81\x20\x83\xB3\xA2\x79\x8C\x37\x94\xEC\x94\xDB\x94\x15\x53\x35\x7E\xA7\xA2\xBC\xA2\xC6\xA2\x3D\x94\x3C\x7E\xC0\xA2\x6C\x81\x79\x9B\xBB\xA2\xC5\xA2\xFE\x1F\xE9\x82\x4B\x94\x97\xA2\x87\xA2\x58\x82\x81\x9B\xD5\xA2\x0A\x60\xBD\xA2\x7F\x95\xB9\x81\x99\x8C\xC9\xA2\x64\x95\x95\x95\xCD\xA2\xD6\xA2\x6B\x29\xD7\x6C\xEB\x94\xDA\xA2\x2E\x9B\xA5\xA2\xFF\x00\x92\x9B\x9E\x95\xC4\xA2\xDF\xA2\x83\xA2\xA1\x95\x7B\x6F\xAE\x8C\xB1\xA2\x31\x66\x0F\x66\x0F\x83\x9C\x9B\x91\xA2\xCE\xA2\xFE\x1F\x6F\x94\xF4\x93\xB9\x8C\xE8\xA1\x74\x94\x65\x9B\x76\x94\x24\x9B\x2A\x8C\x7A\x94\x2A\x81\x62\x58\x1C\x66\xA0\x58\x40\x81\x2D\x95\x1F\x87\x2F\x95\xDB\xA2\x4D\x81\xF5\x93\x32\x9B\xAE\x8C\x85\x6D\x7D\x58\x0C\xA3\x99\x58\x86\x59\x90\xA2\x33\x6F\x17\xA3\x9D\x58\x19\xA3\x8C\x6D\x67\x05\x95\xA2\xD0\x7F\xA2\xA2\xD5\x82\x6D\x95\x94\x95\x9A\xA2\xC3\xA2\x00\x00\x1E\xA3\x0B\x0A\x23\x83\x5D\x58\xDF\x4E\xD5\x47\x96\x94\x0E\x82\x25\xA3\xF6\x82\xED\x94\xA6\xA2\x68\x9B\x0A\xA3\x18\xA3\x0B\x66\x24\x83\x4D\x29\x31\xA3\x55\x95\x33\x12\xB2\x82\x34\xA3\x7D\x8C\x36\xA3\x78\x81\x95\x82\x2C\xA3\x07\x0A\x2E\xA3\x87\x29\x21\xA3\x3B\x82\xE9\x94\x79\xA2\x59\x9B\xA6\x94\x5B\x9B\x9B\x95\x1A\x7E\xF6\x7D\x47\xA3\x76\x58\x5A\x4F\x0D\xA3\xEC\x49\xFC\x7F\x23\x94\xB6\xA2\x6C\x95\xBC\x94\xC1\xA2\x54\xA3\x0F\x52\x49\xA3\xCB\x44\x4F\x58\x15\x37\x36\x94\x6D\x9B\xE4\xA2\xD3\x5B\x70\x9B\x2A\xA3\x55\xA3\x96\x58\x57\xA3\x1A\xA3\x22\xA3\x28\x6D\x81\x95\xAE\x05\xD2\xA2\xD3\x94\x60\xA3\x0E\x52\x62\xA3\x58\xA3\x15\x51\xD8\xA2\x55\x82\x68\xA3\x8A\x95\x76\xA3\x0B\xA3\x3B\xA3\x2F\xA3\x3F\x81\x59\xA3\x5D\x82\xFC\x5B\x74\xA3\x89\x9B\x7F\xA3\x3A\xA3\x6E\xA3\x4B\xA3\x17\x82\xE1\xA2\x31\x80\x67\x82\x7D\xA3\x0F\x6C\xF0\xA2\xF5\x94\x81\x6D\x61\xA3\x20\xA3\x30\xA3\xEC\x49\x0A\x83\xA2\x95\x16\xA3\x96\xA3\x81\xA3\x4A\xA3\x98\xA3\x15\x51\x9B\x9B\x89\xA3\x1F\xA3\x9E\xA3\x63\xA3\x25\x83\x15\x37\x00\xA3\x88\xA2\x72\x86\x01\x95\x04\xA3\x4E\x95\xC4\x7F\x01\x8C\x31\x0A\xB3\x00\x34\x83\x1F\x51\x53\x39\x74\x39\x23\x81\x92\x82\xB5\xA3\x6D\x05\x17\x8C\x6D\xA2\x9E\x83\xA3\x8E\x97\x39\x43\x66\x08\x83\x3C\x1F\x21\x8C\xD9\x82\x4F\x39\x7A\xA2\xF0\x80\x9A\x80\x7D\xA2\x5E\xA2\x10\x59\xA0\x5C\x6D\x4A\xD0\x5C\x07\x6A\x6C\x39\xDE\x45\x5C\x2A\x7A\x96\xA2\x82\x0E\x83\x1B\x83\xEA\x5A\x3A\x2B\xCE\xA3\x61\x96\x06\x09\x1C\x34\x4E\x8A\xAE\x82\xD5\xA3\x6E\x6D\x02\x01\xB6\x00\x34\x83\x00\x09\xF9\x46\x88\x54\x96\x83\xBD\x39\x98\x83\xAE\x69\xB6\x95\x00\x00\xB7\x00\xAF\x6D\xED\xA3\xBD\xA3\xDA\x95\xF8\x46\x56\x47\xE6\xA3\xF2\xA3\x79\x4B\x14\x51\x9A\x58\x02\x01\xEF\xA3\x47\x64\x17\x51\x6E\x49\x81\x58\x95\x5E\x0F\x3E\x2A\x3C\x66\x5C\xC3\x89\xD6\xA3\x89\x5F\x8D\x48\x64\x94\x25\x0A\xA7\x67\x31\x0A\x65\x66\xD0\x54\xFC\x69\x77\x84\x0E\x55\xD2\x04\xFD\x20\xE4\x6A\xFE\x69\x04\xA4\x06\x5A\x06\xA4\x3F\x7B\x5E\x61\x43\x3E\xC5\x69\xCB\x8A\xDA\x88\x16\x8C\xEB\xA3\x09\xA4\xAD\x68\xB3\x73\x61\x09\x1B\x40\xC2\x89\x46\x47\xFF\x04\x0D\xA4\x46\x47\x0F\xA4\x0D\x84\x56\x34\x66\x5C\xCB\x83\x13\xA4\x31\x83\x09\x52\x50\x5B\xBA\x00\xDB\x73\xA1\x62\xE1\x83\x10\x8C\x09\x57\x19\xA4\x76\x84\x46\x47\xDB\x73\x31\x0A\x16\xA4\xFC\x8C\x08\xA4\xAF\x6D\x0B\xA4\xE3\x56\x27\xA4\x90\x8B\xF8\x12\x29\xA4\x94\x83\xB2\x2B\x2C\xA4\xEF\x83\x94\x33\x59\x74\x05\xA4\x34\x83\xCB\x06\x1A\xA4\xE0\x8A\xE7\x89\x1D\xA4\x7F\x73\xE3\x6A\x0A\xA4\x03\x84\x06\x0A\x4F\xA4\x39\xA4\x44\xA4\xD9\x06\x26\xA4\xDD\x8B\xD0\x17\x46\xA4\x45\x4F\xD0\x17\x49\xA4\x34\x51\x2E\xA4\x97\x7A\x0C\x0A\x5D\x24\xCE\x83\x36\xA4\x58\xA4\xD6\x06\x50\xA4\x03\xA4\x1B\x86\x3C",
"\xA4\x34\x83\x22\xA4\xF8\x36\xC9\x55\x1B\xA4\xA4\x8A\x53\xA4\xE8\x6D\xDB\x69\x03\x58\x65\x66\x21\xA4\x4E\x63\xE5\x83\xDD\x83\xA3\x8A\xED\x86\xFA\x01\x5D\xA4\xC5\x8B\x96\x36\x60\xA4\xA7\x4F\xE0\x69\x67\x83\x9A\x29\xC2\x5C\x55\x52\x34\xA4\x71\xA4\x7D\xA4\x6D\xA4\x3A\xA4\xFD\x58\x22\x73\xBA\x89\x6A\xA4\xC6\x89\x1D\x3E\x79\x83\x6E\xA4\xCA\xA3\xB1\x58\x9D\x96\xB4\xA0\xD3\x9B\x9D\x0B\xF7\x8B\x84\xA4\xDE\x8B\x66\x9F\x48\xA1\x0B\xA2\xB9\x9F\x39\xA2\x45\x9F\xF0\x9F\xD9\xA0\xBE\x9F\xDB\xA0\x84\x9F\x2E\xA1\xA1\x91\xC6\xA0\xDF\x86\xC8\xA0\xD7\x9B\xF2\x98\x3F\xA0\x04\x9E\xDD\x8C\x9F\xA1\xAA\x91\x3D\x9E\xA0\xA4\x4F\x8A\x15\x8A\x7B\xA0\x21\xA2\x7D\xA0\x1E\x9F\x7F\xA0\x0F\xA2\x81\xA0\x11\xA2\x83\xA0\x37\x9F\x85\xA0\x81\x2F\x3C\xA0\x77\x7F\x3E\xA0\x02\x87\xDA\x9B\x33\x84\x07\x9C\x89\xA2\x9D\x89\x55\x84\xCD\x74\xBB\xA4\xA1\x89\x54\x88\xCB\x89\x09\xA2\x1B\x9F\xEE\x76\xEE\xA0\xD6\x9F\x83\x9D\xD0\x98\xEC\x79\xD2\x98\xE0\xA1\x55\xA2\xC4\xA0\x57\xA2\x4D\x9E\xD8\x91\xFC\x7A\xB6\x89\xCA\x9F\x34\x86\xDE\x91\x65\x68\xD5\xA4\xC9\x89\x3F\x86\x4A\x89\xAA\x9B\x20\xA2\xF4\x9D\x22\xA2\x0D\xA2\x24\xA2\xC3\xA4\x85\xA1\xC5\xA4\x87\xA1\xC7\xA4\x89\xA1\xE3\xA1\x87\xA0\x08\x9C\xFF\xA1\x0A\x9C\x42\x99\x74\xA0\xFA\x93\x45\x99\x33\x70\xEE\xA4\x0A\x8C\x1C\xA4\x7E\x88\x4B\xA2\x80\x9E\xC6\xA1\x66\xA0\xDB\xA1\xC9\xA1\xDD\xA1\xAA\xA1\x53\xA2\xC2\xA0\xE3\xA4\xE2\xA1\x15\xA2\x59\x85\x58\x99\xA8\x64\x08\xA5\xFC\x89\x52\xA4\x0B\xA5\xD2\xA0\xEF\xA1\xA5\xA4\xED\x9F\xA7\xA4\xBB\x9F\x3B\xA2\xBD\x9F\xF2\x9F\xF7\xA1\xF4\x9F\xF9\xA1\xDE\xA0\xD0\xA4\xD0\x96\x78\x9E\x9E\xA4\x78\x05\x1C\xA5\x2F\x8A\x81\xA4\xA5\x8A\x91\xA1\xD2\x9F\x6B\xA1\x22\xA5\xDC\xA4\xB7\xA1\xDE\xA4\x0D\xA1\xE0\xA4\x93\x99\x2C\xA1\x3F\xA2\xCF\xA1\x55\xA0\xB0\xA4\xA3\x91\xDA\x84\x8F\x9E\x67\x5E\x92\x9E\xDF\x8F\x86\x99\x95\x9E\x32\xA5\x80\xA4\xCA\x89\x31\x8A\xA3\xA4\x38\xA5\xDB\xA4\x4A\xA1\xF2\xA1\x4C\xA1\xF4\xA1\x4E\xA1\xF6\xA1\x50\xA1\x5D\x9F\x52\xA1\x28\x9D\x96\x78\xDA\x9E\x12\x90\xE2\xA0\x19\xA1\xC4\x9E\x75\x97\x1C\xA1\x77\x97\x6F\x9C\xE9\xA0\x01\x01\x4D\xA5\x75\xA4\x34\xA5\xCD\x8A\x07\xA1\x3D\x98\xC4\x99\x6B\x8D\x88\x98\xD8\x9F\xF2\xA0\xD5\x87\xDB\x9F\xF5\xA0\x47\x98\x36\x98\x16\xA2\xBF\x9E\x83\x9C\x5C\x5A\x85\x9C\xAA\x9E\xBC\x99\xB9\x99\x25\x85\x54\x9C\xCA\x9E\x69\xA5\x5E\xA4\xCD\x85\x48\xA0\x7F\x9E\x4A\xA0\x65\xA0\xD1\x9C\x24\xA5\xEF\x9F\x26\xA5\xF1\x9F\x72\xA1\xAC\xA4\x6D\xA0\x5C\xA5\x5F\x9F\x05\x5B\x43\xA2\xF9\x84\xB5\x75\xDC\x9E\xE1\x87\xE3\xA0\xFA\x8F\x7F\xA5\x87\x9C\xBD\x99\x1E\xA1\x02\x7C\x07\xA5\x86\xA5\xFA\x88\xF2\x9D\x50\x9D\x0E\xA5\x8C\xA5\x5F\xA1\x3A\xA2\xCA\xA1\x3C\xA2\xAB\xA1\x3E\xA2\xCE\xA1\x03\x9F\xD0\xA1\x8A\x5A\xB6\x9C\x4F\x90\xA3\xA5\xA1\xA4\x91\x8B\x51\xA5\xA4\xA1\xF0\xA1\x94\xA0\x96\xA1\xDC\xA1\x51\xA2\x2A\xA1\x14\xA5\x40\xA5\xB0\xA5\xAA\x9F\xB2\xA5\x05\x9F\xBC\x97\x1B\xA5\xA4\xA5\xF1\xA4\x8E\x9C\x49\xA0\xF3\x9D\x04\xA0\xF5\x9D\x8D\xA5\xD7\xA0\xA9\xA4\xF5\xA1\xDA\xA0\x29\xA5\xDC\xA0\x2B\xA5\x2F\xA1\x54\xA1\x09\x52\x85\x85\xAD\x95\xF3\x53\x6A\xA5\x51\xA4\x0B\x8C\xA3\xA0\x88\xA5\xF8\x9E\xCD\xA5\x4B\xA0\xCF\xA5\xAA\xA5\xA8\xA4\x8F\xA5\xAA\xA4\x28\xA5\x5A\xA5\x21\xA0\x94\xA5\x84\x90\xD9\x80\x83\x69\xDE\xA5\xF6\x8A\xBE\xA4\xF4\xA4\xC0\xA4\x81\x9D\xA8\x96\xD9\x7C\x84\x9D\xD3\xA5\xAB\xA4\xD5\xA5\xAD\xA4\xD7\xA5\x9E\xA1\xF7\x9F\x34\x9A\x4F\x88\x13\x75\xF2\xA5\x58\x8B\xD9\xA4\x8C\x9F\x39\xA5\x54\xA5\xD0\xA5\xF3\xA1\xD8\xA0\xFB\xA5\xEB\xA5\x77\x8F\x41\xA5\xB1\xA5\x41\xA2\x44\x8E\xAC\x90\xC0\x75\x05\xA6\x5B\xA4\xCA\xA5\xF3\x9C\xDA\xA4\x0A\x7D\xA6\xA4\xE7\xA5\x25\xA5\xAC\xA5\x27\xA5\x91\xA5\xFD\xA5\x93\xA5\xE7\x92\x2C\xA5\x07\x9E\xA0\xA1\x62\x9F\x16\xA6\xC9\xA5\x51\x8A\xCB\xA5\x89\xA5\xE4\xA5\x8B\xA5\xFB\x9E\x0B\xA6\x56\xA5\x0D\xA6\x58\xA5\xD4\xA5\xEC\xA5\xF8\xA1\xEE\xA5\x6F\xA0\x1B\x72\xB1\xA1\xAA\x97\x17\xA6\x00\x88\xF4\xA5\xCE\xA5\xF5\xA4\xC1\xA4\x0E\xA2\x33\x9F\xAF\x9C\x35\x9F\xC6\xA4\x13\xA2\xC8\xA4\x18\xA5\xFE\x92\x88\x9F\x4C\x9D\xC8\xA5\xB7\xA5\x87\xA5\xE2\x98\xCC\xA5\xA7\xA5\x42\x9F\x38\xA2\x1E\xA6\x8E\xA5\x20\xA6\x90\xA5\x3D\xA2\x73\xA1\x11\xA6\xC4\xA5\x13\xA6\xDF\x8F\xB8\x53\xBC\x00\xEF\x57\xA0\x5C\x61\x93\x9F\xA4\x2B\xA6\xD8\xA4\x36\xA5\x03\xA0\xE5\xA5\x42\xA6\xF7\xA5\x72\xA5\xF1\xA0\x34",
"\x9F\xF3\xA0\x45\x98\x77\xA5\xED\x9B\x79\xA5\x07\x91\x8C\x9D\xAE\x9F\x5F\x98\xA7\x9A\xFB\x5A\xEA\xA1\xAA\x9A\xB3\x9F\x78\x9D\xBE\x7F\x6E\x53\x3E\xA6\x69\x88\xB9\xA5\x21\xA5\x53\xA5\x6D\xA1\x55\xA5\x6F\xA1\x59\xA6\xEA\xA5\x22\xA6\x37\xA6\x2A\xA5\x39\xA6\x76\xA1\x08\x5B\xFC\xA1\x34\x86\x0D\x95\xF2\x91\xC1\x8E\xC2\x9A\x7C\xA6\xCB\x9F\x94\x9D\xCD\x9F\xF8\x8E\x82\xA6\xE1\x8A\x92\xA0\xD9\xA1\x0F\xA5\xBD\xA5\x11\xA5\xBF\xA5\x3D\xA1\xC1\xA5\x64\xA1\x29\xA2\xAE\xA1\x5F\xA6\xDF\xA0\x17\xA2\x5A\xA2\xA9\x9D\xE5\x9F\x18\x7A\xFF\x00\x1A\x7A\x9C\xA6\x67\xA6\x50\xA5\x07\xA6\xB7\x9F\x09\xA6\x87\xA6\x32\xA6\x89\xA6\x12\xA5\xCB\xA1\xAE\xA5\x5C\xA6\xC3\xA5\xAE\xA4\xC5\xA5\xAB\xA6\x2D\xA2\xBF\x9D\x27\x89\x5D\x91\x93\x86\x32\xA2\xE3\x6B\x66\xA6\x50\xA6\xA5\xA5\xB2\x9E\xA7\xA0\xA6\xA1\x57\xA6\xD1\xA5\xE9\xA5\x0E\xA6\x8C\xA6\x10\xA6\xC0\xA6\xFF\xA5\xC2\xA6\x24\xA0\xA2\xA0\xD6\x9D\x87\x57\x47\xA2\xB3\xA6\xCC\xA6\x19\xA6\x4F\x9D\x28\x9E\x62\x85\x3A\xA5\x88\xA6\xB8\xA1\xFA\xA5\x35\xA6\xFC\xA5\x8D\xA6\xD6\xA5\x8F\xA6\xFA\xA1\x96\xA5\x59\xA2\xF9\x9F\xB4\x7F\x22\x9B\xDC\x98\xAC\x63\xA6\x9B\x9D\x0B\xFB\x8B\xE0\xA6\x2C\xA6\x1A\xA6\x08\xA6\x86\xA6\xB6\xA1\xE6\xA6\x3C\xA5\x36\x7C\xC9\x99\x71\xA6\xEB\x9B\x73\xA6\xB3\x9C\xD2\x38\xCA\xA4\xC5\x77\x1D\x9E\xBB\x82\xAB\x77\xB6\x96\x42\xA0\x08\x9E\x9D\xA4\x6D\x99\x02\x01\xF8\xA6\xBC\xA4\x72\x8A\x0C\xA5\x8A\xA5\xA8\xA5\x31\xA6\xD1\xA6\x0C\xA6\xD2\xA5\xE9\xA6\x0F\xA6\x10\xA1\xA8\xA6\x40\xA2\xC5\xA0\x30\x92\xD9\x8F\x77\x89\x47\xA5\x4E\x84\x1F\x9E\x5C\xA0\x21\x9E\xC5\x91\x9E\x89\x3A\x88\x13\xA7\xD6\xA4\x83\x89\x68\xA6\x5A\xA1\x7E\xA1\x36\xA2\xBB\xA5\x81\xA1\xF6\xA4\x96\xA0\x25\xA2\x52\xA2\x27\xA2\x54\xA2\xFC\xA4\x56\xA2\xFE\xA4\x34\x9E\xE4\x96\x36\x9E\x27\x99\xFD\x7A\x98\xA6\xEB\xA4\xF6\x9B\xC5\x89\x30\xA5\x12\xA7\xB4\xA6\x35\xA5\x32\xA7\x92\xA1\x4C\xA2\x35\xA7\xD0\xA6\x4F\xA2\xA8\xA1\xBC\xA6\xAD\xA5\xA6\xA6\xCD\xA1\x20\xA7\x42\xA5\xB1\xA0\xFF\xA4\x4E\x9E\x95\xA6\x8A\xA0\x1D\x7B\xEA\xA4\x9D\x8F\x06\xA5\xA8\x64\x2E\xA7\xEF\xA4\x13\x88\x31\xA7\x35\xA1\x5B\xA1\x0D\xA5\x55\xA6\x4E\xA2\x10\xA5\x50\xA2\x39\xA7\xC0\xA5\x3B\xA7\x15\xA5\x3D\xA7\xE4\xA4\x3F\xA7\x27\x70\x9F\xA0\x18\x9D\x4A\xA7\xF9\xA6\x67\xA7\xE2\xA5\xA5\xA0\x6A\xA7\xCF\xA6\x56\xA6\x52\xA7\xAB\xA5\x54\xA7\x21\xA6\x5B\xA6\x92\xA5\x74\xA1\xED\xA6\x26\xA6\x2A\xA7\xC6\x8F\x2F\xA5\x11\xA7\x01\x01\x64\xA7\x09\xA5\x76\xA4\x1F\xA5\x6E\xA5\xC3\x99\xE5\x98\x43\xA6\xF7\xA4\x45\xA6\x21\x9F\x47\xA6\xFB\xA4\x49\xA6\xFD\xA4\xA3\x77\x56\xA0\x60\x8F\x26\xA7\x34\x92\x51\x78\xDF\x84\x4A\xA5\x68\xA5\x00\x00\x8F\xA7\x1D\xA5\xE0\xA5\x5A\x9E\x38\xA1\x51\xA7\x6D\xA7\x53\xA7\xA4\xA6\xDE\xA1\xFA\xA4\xE2\xA4\x73\xA7\x17\xA5\x75\xA6\x0F\xA0\x7B\xA5\xE1\xA0\x93\x8D\x9C\xA5\x37\x90\x6D\x92\x00\xA1\x6F\x92\xAD\x9E\xA6\xA7\xA8\xA7\x33\xA5\x4F\xA5\x4C\xA7\x68\xA7\x33\xA7\x4F\xA7\xB8\xA6\xFE\xA6\xBA\xA6\xE7\xA6\xDF\xA4\xA6\x7C\xE1\xA4\x28\xA2\x16\xA5\x2A\xA2\x75\xA7\x2C\xA2\x15\xA1\x7C\xA5\x02\x68\xBB\xA7\x56\x97\x65\xA5\x6E\x9C\x02\xA1\xC1\xA7\x4B\xA7\x6D\xA5\x84\xA6\x34\xA7\xC9\xA7\xF1\xA1\xCB\xA7\x00\xA7\x10\x7D\x02\xA7\x75\xA5\xF4\xA0\xDF\x7C\x78\xA5\xF7\xA0\xB7\xA7\xD5\xA7\x71\x86\x9E\x9C\x7E\xA5\xFF\xA0\x94\x97\x81\xA5\xA5\x9C\x33\x70\xC2\xA7\x4E\xA5\xF0\xA4\xFA\xA6\xE2\xA6\x08\xA1\xCC\x98\xD9\x96\x0B\xA1\xCF\x98\x3D\xA5\xCE\xA7\x3F\xA5\xA7\xA6\xD1\xA7\xA9\xA6\x5A\xA7\x23\x9C\x9F\x8A\xB7\x9C\xAA\x97\xF7\xA7\x6B\xA5\xC4\xA7\xDF\xA7\xB6\xA6\xEB\x9F\xE2\xA7\xBC\xA5\x23\xA2\x38\xA7\xF8\xA4\x26\xA2\xB2\xA7\xD0\xA7\xB4\xA7\xD2\xA7\x4B\xA6\x59\x9A\x44\xA1\x06\x9F\x49\x9A\x0C\xA8\xDF\xA5\x0A\xA5\xE1\xA5\x52\xA6\x2E\xA6\x54\xA6\x7F\xA7\x6C\xA7\xA2\xA6\x6E\xA7\x16\xA8\x3A\xA7\x18\xA8\x3C\xA7\x9C\xA7\x3E\xA7\x1C\xA8\xB2\xA0\x55\xA1\x11\x9A\x78\x05\x21\xA8\xF3\xA5\x16\xA7\x2F\xA6\x18\xA7\x4C\xA0\x81\xA7\xE8\xA5\x8A\xA6\xD4\xA6\x85\xA7\x23\xA6\x87\xA7\x25\xA6\xBF\x95\x68\xA1\xE9\x86\x37\xA8\x06\xA6\x69\xA6\x64\xA0\x3B\xA8\xE6\xA5\x3D\xA8\x1F\xA6\x83\xA7\x5A\xA6\xBE\xA6\x86\xA7\x5D\xA6\xC1\xA6\xAA\xA6\xDA\xA6\x5A\x96\x35\x9A\x03\x9D\x78\xA7\x8E\xA7\xDE\xA7\x92\xA7\xE0\xA7\xC8\xA7\xFD\xA6\xE3\xA7\x1A\xA7\x33\xA6\x1C\xA7\xDD\x96\x56\xA7\xAF\xA5\x58\xA7\x12\xA6\x07\xA8\x8B\xA1\x15\xA6\xF6\xA7\x5D\xA8\x24",
"\xA8\x70\x9A\x53\xA6\xE3\xA6\xF0\x87\xAD\xA7\x2A\xA8\xAF\xA7\x6F\xA7\xA5\xA6\x71\xA7\xC2\xA5\x69\xA8\x5E\xA6\x6B\xA8\xC0\xA1\x5B\x9A\x20\xA8\x6F\xA8\xAB\xA7\xA0\xA6\xA9\xA5\x4E\xA8\x58\xA6\x50\xA8\x8B\xA6\x41\xA8\xEB\xA6\xFE\xA5\x88\xA7\xD8\xA5\x36\x5E\x3C\xA6\x81\xA8\x7A\xA7\xB5\xA6\x4A\xA8\xBA\xA0\x6B\xA7\x95\xA1\x14\xA8\x3B\xA1\xB0\xA7\x13\xA5\x7A\xA8\x04\xA8\x1A\xA8\x06\xA8\xE5\xA4\xE3\x90\x4E\xA6\x0B\xA8\x82\xA8\x9F\xA6\x4D\xA2\x97\xA8\x37\xA7\x99\xA8\x78\xA8\xB1\xA7\x9A\xA7\xB3\xA7\x30\xA8\x74\xA7\x32\xA8\x5B\xA7\x91\x9A\x7F\xA6\xAA\x8E\x48\xA8\x18\xA6\xFA\xA7\xA6\xA5\x73\xA8\x15\x8E\xA1\xA6\x98\xA8\x97\xA1\xAA\xA8\x9B\xA8\x2E\xA8\x72\xA7\xAE\xA8\xB5\xA7\xEC\xA7\x58\x93\xE5\xA1\xF2\x94\xE7\xA1\xD2\x88\xB0\x08\x04\xA5\x88\x1B\x60\x93\xC2\x76\xB5\xA8\x3F\xA6\x39\xA8\x27\xA8\xAC\xA7\x80\xA7\xAE\xA7\x82\xA7\x9A\xA8\xBD\xA6\x67\xA8\xBF\xA6\x7C\xA8\x55\xA8\x7E\xA8\xC3\x9F\x4D\xA3\xA2\xA0\x43\x65\x89\xA0\xC8\x9F\x97\xA6\x60\xA7\x5F\x93\x58\x86\xCE\xA8\xA4\xA8\x40\xA6\x6B\xA6\xF6\xA5\xD2\x89\xAD\x9C\x98\xA7\x10\xA2\xAC\xA8\x19\xA8\xC2\xA8\x1B\xA8\xB6\xA7\x3A\x9F\xF8\x9F\x9A\x99\x5D\x89\xAE\xA6\x1A\x74\xAB\x9D\xB1\xA6\xAD\x9D\x33\xA2\x79\xA7\x14\xA7\x2E\x8B\x20\xA5\xE1\xA7\x61\xA8\x13\xA8\xA8\xA8\xBD\xA8\x2C\xA8\x70\xA7\xC0\xA8\x7B\xA8\x05\xA8\x21\xA7\xA0\xA8\xC3\xA6\xDB\xA6\x2E\xA2\x96\x7D\xC2\x9D\xF7\x8E\x60\x91\xCF\xA8\x83\xA6\x10\xA8\xEC\xA0\x12\xA8\x36\xA7\x96\xA7\x15\xA8\xEF\xA8\xC4\xA4\xF1\xA8\x2F\xA8\x05\xA7\x25\x9F\xF5\xA8\xD9\x9E\xC4\xA6\x5A\xA2\xAA\x7F\xBE\x93\xC7\x98\x16\xA9\xE9\xA8\xD1\xA8\xB9\xA8\x7C\x91\x0A\xA1\xE4\x8B\xE5\xA7\x91\x99\x3E\xA5\x0F\xA1\x58\x7C\xCE\x90\x0E\xA9\xD3\xA7\x58\xA2\xF7\xA8\xB5\x99\xC5\x86\xDA\x98\xC7\x86\xF2\x65\x8E\x91\x10\xA7\x64\x89\xFF\x8B\x92\xA8\xC5\xA7\x7C\xA7\x36\xA1\x7E\xA7\xD3\xA8\x29\xA8\xBC\xA8\xBE\xA5\xBE\xA8\xD8\xA8\x9C\xA8\x57\xA7\x0D\xA9\x59\xA7\xFB\x3B\x08\xA7\xDC\x95\xA1\xA7\xB4\x96\x40\xA0\x29\xA7\x0E\xA7\x4C\x8F\x44\xA0\x6E\x53\x45\xA9\x01\xA9\x44\x8B\x03\xA9\x60\xA8\x1C\xA6\x23\xA5\x63\xA8\xBB\xA6\xD7\xA8\x55\xA7\x51\xA9\x68\xA8\x53\xA9\x6A\xA8\x55\xA9\x9F\xA7\x80\x99\xC9\xA0\xBB\x9B\xCD\xA4\xC4\x7E\xBE\x9B\xE3\x77\x12\x99\xC6\x91\xCD\x74\x60\xA9\x2F\xA7\x50\x8A\x7B\xA7\x25\xA8\xE3\xA5\xD2\xA8\x84\xA8\x19\xA7\x86\xA8\xD2\xA6\x3F\xA8\x1D\xA7\xD5\xA6\x1F\xA7\x6D\xA9\x7D\xA8\x0F\xA9\xD0\xA4\xE7\xA4\xB5\x89\xED\x59\xCB\xA8\x7E\x94\xEA\x96\x84\x8F\x5F\xA9\x2D\xA9\x63\xA9\x4A\xA9\x82\xA9\x3C\xA8\xD5\xA8\x3E\xA8\x88\xA8\x40\xA8\x52\xA8\x42\xA8\x54\xA8\xD8\xA6\x56\xA8\x70\xA0\x40\x99\xF3\x91\x03\xA5\x45\xA7\x61\xA7\x05\x97\xB3\x7C\xA8\x64\x7B\xA9\x65\xA7\x29\x88\x7E\xA9\x71\xA8\x26\xA8\x2F\xA9\xD8\x96\xC5\x99\x32\xA9\xC7\x99\x01\xA7\x0E\xA1\xB7\x8E\x89\xA9\x9E\xA8\x39\xA9\xB0\xA8\x08\xA8\xB1\x8F\xDE\x03\xF4\x74\xAD\xA9\x90\xA7\x6C\xA5\x5E\xA8\x19\xA9\xA4\xA4\x05\xA9\x1C\xA9\x6D\xA6\xEE\xA8\x73\xA5\x70\xA6\xE8\xA7\x72\xA6\xEA\xA7\x74\xA6\xC4\xA8\xB2\xA0\x1F\x92\xDE\x98\xC3\xA9\xA9\xA7\x23\xA8\x83\xA8\xA6\xA8\xDA\xA1\x76\xA8\xD6\xA8\x4F\xA9\x6A\xA9\x0B\xA9\x9D\xA8\xF3\xA8\x9F\xA8\xC9\xA4\x70\xA9\xB9\x9B\x72\xA9\x90\x9E\x83\x99\xA4\xA7\x85\x99\xA6\xA7\xD7\xA9\xC3\xA7\xF9\xA7\xB0\xA9\xF2\xA4\x72\xA8\xFC\xA7\x70\xA5\xFE\x90\x33\xA9\xD9\x9F\xCF\xA9\x04\xA7\xD1\xA9\x06\xA7\xD3\xA9\x81\x9C\x5F\xA5\xB9\xA7\x45\x8A\x62\xA5\xD5\x99\xBD\xA7\xF3\xA7\xD8\x99\xAE\x9E\x8B\x9C\xEE\xA9\xF8\xA7\x66\xA7\x93\xA8\x4D\xA7\x37\xA5\xBA\xA5\x1B\xA9\x75\xA8\x4D\xA9\xA3\xA6\xDF\xA9\x84\xA7\x9F\xA9\x8B\xA8\x24\xA6\x3A\x7B\x00\xA6\x5E\xA5\xB8\xA7\xFA\xA0\xC1\x9E\xF1\xA7\x8A\x92\x05\xAA\xC7\x9E\xDC\xA7\x94\x9E\x84\xA5\x00\x00\x09\xAA\x0D\xA8\xF0\xA9\x0C\xAA\xC6\xA7\x4E\xA7\x98\xA9\xDB\xA9\xBB\xA8\x07\xA9\x4E\xA9\x09\xA9\x79\xA8\xE1\xA9\x52\xA9\xBC\xA9\x54\xA9\x3A\xA9\x77\xA1\x44\x9B\xF1\xA6\x6C\x9B\xD3\x99\x73\x97\x63\xA5\xA2\x9C\xDA\xA7\xE1\x9E\xA1\xA5\x46\x85\xAA\x97\x27\xAA\x22\xA8\x91\xA7\x70\xA8\xF2\xA9\xB2\xA9\xF4\xA9\x95\xA7\xCB\xA9\x1F\x9F\x1F\xA9\xF9\xA4\x21\xA9\xC1\xA8\x23\xA9\xDD\x9F\x25\xA9\x59\x87\xB4\xA5\xED\x99\x33\x70\x46\xAA\x38\xA8\x97\xA9\x17\xA7\x96\xA8\xDC\xA9\x12\xAA\x2B\xA8\x50\xAA\x17\xA8\x52\xAA\x0C\xA9\x36\xAA\x6E\xA9\x38\xAA\xC6\xA5\xB2\x92\xAC\xA9\x96\xA9\x93\xA7\xAA\x9C\x1D",
"\x9F\x4E\xAA\xC2\xA4\x63\xAA\x2D\xA8\x65\xAA\xE2\xA9\x54\xAA\x14\xA2\x56\xAA\xCC\x97\x34\xA8\x00\x95\x78\x05\x5B\xAA\x49\xA8\x0D\xAA\x6A\xA6\x30\xA6\x9A\xA9\xDD\xA9\x9C\xA9\x69\xA9\x15\xAA\xD9\xA8\x53\xA8\xD7\xA6\x8D\xA8\x8D\x42\xEF\x9C\x2C\xA0\x7E\xAA\xB6\xA8\xF1\xA9\x2D\xA6\x80\xA9\xB3\xA9\x09\xA1\xCD\x98\xFF\xA7\xF9\xA5\xCD\xA7\x07\x8E\x03\xA8\x35\xAA\xE3\xA9\xBD\xA9\x79\xAA\xE7\x9D\x02\xA6\x08\x0A\xF3\x8A\x5A\xAA\x6D\xAA\x5F\xA8\x2D\xAA\x50\xA7\xD4\xA8\x84\xAA\x4F\xA8\x86\xAA\x51\xA8\x88\xAA\xA0\xA9\x8A\xAA\x44\xA8\x1A\xAA\x5C\xA9\x8C\xA1\x9B\x4C\x7D\xAA\xA5\xAA\xC7\xA9\x52\xA5\x65\xA9\xE5\xA6\xE4\xA7\xB7\xA9\xE6\xA7\xB9\xA9\x76\x8F\xBB\xA9\x9D\xAA\x37\xAA\xBE\xA9\x15\x9D\x80\xA8\x5B\xA8\x26\xAA\xB7\xAA\x94\xA8\x24\xA1\x5F\xAA\x2F\xAA\x1D\xA9\xA9\xA8\x32\xAA\xAB\xA8\x03\xA7\xB1\x9C\x77\xAA\x4A\xA6\x9F\xAA\x5B\x72\x90\xA8\xC7\xAA\x8F\xAA\xD0\xA8\x5D\xAA\x3A\xA8\xCC\xAA\x85\xA8\x9B\xA9\xAB\xAA\x14\xAA\xAD\xAA\x6B\xA9\xDA\xA8\x8A\xA9\xDC\xA8\x8C\xA9\x27\xA6\xC2\xA1\x49\x9A\xDA\xAA\x18\xA9\xCA\xAA\xD8\xA1\x2E\xAA\xDF\xAA\xAA\xAA\x87\xA8\xAC\xAA\x89\xA8\x16\xAA\xD6\xA6\xDB\xA8\xA2\xA9\xDD\xA8\x4D\x9E\xB2\xA8\x1A\x95\xCA\xA6\xB6\xAA\x46\xA9\x0F\xA8\xEE\xAA\x0A\xA2\xC9\xA9\x11\xAA\x30\xAA\x13\xAA\xD0\xAA\xBF\xA8\x75\xAA\x9C\xAA\xD4\xAA\x9D\xA7\xD6\xAA\xDE\xA8\x68\x95\x37\x58\x8D\x9D\x5B\x93\xC9\xA8\xA8\x9A\x7C\x98\xC4\x8E\x64\x98\x85\x72\xEC\xAA\x9E\xA6\xEA\xA8\x82\xAA\x4D\xA8\xE0\xAA\xF3\xAA\xE2\xAA\xF5\xAA\xAE\xAA\x17\xAA\x43\xA8\x19\xAA\xD9\xA6\xF2\x5A\x92\xA6\xD0\x88\xC6\x9F\x5D\xA7\xE3\xA8\x01\xA2\x9B\x74\x5D\x7D\x7A\x93\x7F\x98\xFF\xA8\x01\x01\x1A\xAB\x1E\xA5\x49\xAA\x92\xAA\x7D\xA7\x5E\xAA\x28\xA8\xA7\xA8\xCE\xAA\x08\xA9\x73\xAA\x0A\xA9\x0A\xAB\x6C\xA9\x67\xAA\x8B\xA9\x69\xAA\x10\xA9\x90\x7C\x8E\x93\x19\xA2\x95\x98\xDC\x9A\xE7\x9F\xDE\x9A\x33\xAB\xC8\xAA\x00\xAB\xC6\xA9\x02\xAB\x1B\xA6\x68\x7D\x1D\xA6\x84\xA9\x1B\xA7\xD3\xA6\x87\xA9\x8A\xA8\xF7\xAA\xE6\xAA\xF9\xAA\xE8\xAA\x1B\xAA\x11\xA9\xC5\xA6\xA6\x93\xF5\x8E\xC8\xA6\xC2\x76\x35\xAB\xAA\xA7\xA5\xA8\xA8\xAA\x4C\xA9\x06\xAB\x62\xAA\xCD\xA9\x46\xA6\xD2\xAA\x23\x9F\x0C\xAB\x31\xA8\x0E\xAB\x39\xAA\x09\x94\xDC\xA6\xDF\x6A\xDE\xA6\x60\x91\x66\xAB\xD9\xA9\x68\xAB\x10\xAA\xA9\xAA\x61\xAA\x77\xA8\x08\xAB\x50\xA9\x34\xAA\x42\xAB\xC2\xAA\x68\xAA\xC4\xAA\xD4\xA7\x47\xAB\xD9\x98\x3E\x26\xD5\x93\x23\x9B\xDE\x95\x6B\x7F\xBD\x00\x1E\x58\xC4\x6B\x99\xA4\x9A\xA4\xFC\x8C\xAD\x43\xBE\x00\x92\xA4\x0C\x0A\x57\x55\xBF\x00\x30\x83\x6B\x5E\x7F\xA6\xED\x6B\x6F\x73\xCB\x08\x15\x95\xDD\x2E\x68\x1A\xBF\x9A\x0E\x95\x23\x95\x16\x74\x16\xAB\x2A\xAB\x42\x58\xE7\x58\x02\x01\xC4\x95\x94\xAB\xD1\x6B\xD8\x73\xC4\x00\xE1\x95\xEB\xA3\xC1\x00\xAF\x6D\x29\x5E\xD0\x54\xDE\x7C\x7D\x0C\x48\x96\x62\x3B\x8B\x54\x54\x4F\x54\x54\xD9\x00\xC2\x95\xC0\xAB\xC4\x5D\x29\x96\xAC\x2B\xE4\x64\xF6\x95\x02\x01\x06\x4D\x68\x59\x39\x7B\x71\x96\xDC\x3D\xA0\x64\x14\xA4\x4D\x52\xB2\xAB\xC8\x53\x0A\x96\x01\x01\xB5\xAB\x6C\x5C\xB7\xAB\xE3\x56\xB9\xAB\x19\x96\x5A\x5F\xBD\xAB\xAF\x6D\xC2\xAB\xB2\x6D\xDE\xAB\x82\x5F\xC4\xAB\x98\x37\xC6\xAB\x2C\x96\xC8\xAB\x86\x96\xCB\xAB\x1F\x5F\xFD\x95\x95\x65\xB2\x95\x17\x84\x43\xA9\x6E\x53\x9B\x96\x14\x54\xCC\x50\x9F\x7D\xDC\xAA\x81\xA9\xF0\xAA\x83\xA9\x1F\xAB\x85\xA9\x9D\xA9\x59\xAB\xF6\xAA\xC1\xAA\x71\xAB\xAF\xA8\x07\xA7\xE6\xA9\x1C\x9E\x58\xA9\xA6\x91\x5A\xA9\xCF\xA4\x27\xA6\xB9\xA4\x2C\xA0\xF0\xAB\x71\x5C\xF2\xAB\xBE\x7D\xF4\xAB\x94\xAA\xFD\xA7\xB5\xA9\x82\x9D\xBD\xAA\x34\xA9\x02\xA8\x36\xA9\x8C\x84\xE6\x92\x26\xAB\x43\xA5\x23\xA7\x00\x9E\x4B\x67\xCC\xA4\xD9\x9B\x75\xA9\x41\xA0\x84\x71\x22\x9E\x79\xA9\x19\x84\x0A\xAC\xCC\x60\x0C\xAC\x99\x7C\x2E\xA9\x4C\xAA\x80\x9D\xED\xA8\x4F\xAA\x6D\xAB\x99\xA7\x6F\xAB\x12\xA2\xFE\xAB\xC3\xA8\xAD\x84\x40\xA7\xC4\x74\x42\xA7\xE8\xA4\x90\xA9\xA8\xA9\x2F\x8F\xEC\xA4\x3A\x88\x26\xAC\x27\x6A\x28\xAC\x06\x7D\x0E\xAC\x2B\xAC\x70\xAA\x2D\xAC\x72\xAA\x2F\xAC\xF0\xA8\x31\xAC\x48\xA6\x33\xAC\xF4\xA8\xFD\xA9\x36\xAC\x00\xA5\x2C\xAB\x12\x67\x9B\x8F\x3B\xAC\x11\x66\x8E\xA0\x49\x9A\x3F\xAC\xA3\x8E\x41\xAC\xCD\xA6\xE6\x9E\x69\xAB\x3C\xAB\x71\xAA\x44\xA6\x48\xAC\x20\xA9\x4A\xAC\x9B\xA7\x4C\xAC\xE4\xA9\x87\xAB\x57\x99\x24\x9C\x13\x75\x58\xAC\x35\x86\x5A\xAC\xE1\xA6\xB8\xA8\x44",
"\xAC\x0C\xA2\x3D\xAB\x31\xAA\x3F\xAB\x33\xAA\x41\xAB\xE5\xAA\x43\xAB\xE7\xAA\x45\xAB\x2D\xA5\x77\x9E\xDE\x98\x6B\xAC\x52\x80\x6D\xAC\xB7\xA8\xCE\xA6\x4B\xA9\x5E\xAC\x46\xAC\x60\xAC\x6F\xA6\x6E\xAB\xF9\xA9\xD3\xAA\xFB\xA9\x24\xA9\xFD\x86\x01\xAC\x3D\xA0\x0A\xA7\xCB\xA0\xA5\xA7\x24\xAA\xCE\xA0\x01\x01\x7E\xAC\xBE\x80\x17\x4E\xE6\x51\xF3\xAB\x6E\xAA\xB2\x9D\x6C\xA6\x85\xAC\x97\xA7\x61\xAC\x51\xAA\x63\xAC\xAD\xA8\x65\xAC\x9E\xAA\x4E\xAC\xA0\xAA\xE0\xA0\x1D\xAA\xA7\x9E\x02\xAA\xFE\xA0\x20\xAA\xAB\x9E\xA0\xA5\xC0\xA7\x93\xAC\x6F\x8A\x9A\x96\x0F\x52\x77\x7A\x87\x81\x7C\x7C\xDA\xA9\x5D\xAC\x60\xAA\x6B\xAB\x80\xAB\x74\xAC\xD1\xAA\x89\xAC\x70\xAB\x8B\xAC\x55\xAA\xA6\xAC\x88\xAB\x4F\x9B\xA9\xAC\x84\x9C\xDE\x9E\x50\x92\x9B\x74\x98\x8D\x03\xA1\xAF\x9E\x96\xAC\xEF\x80\x98\xAC\x79\x7A\x89\x29\xB8\xAC\x7D\xAB\x6A\xAB\x72\xAC\x07\xAB\xBD\xAC\x09\xAB\xA2\xAC\xF2\xA8\xA4\xAC\xC3\xAA\x73\xAB\xBD\x9D\xD0\x99\xF2\x8E\x3C\xAA\x18\xA1\xFD\xA0\x9F\x99\x9E\xA5\xE6\xA0\xAF\xAC\xD9\x99\xE3\x9E\x57\xAC\xB4\xAC\xCE\x44\xB6\xAC\x65\x7D\x7C\xAB\x04\xAB\x7E\xAB\xBB\xAC\xDE\xA9\x81\xAB\xE0\xA9\x76\xAC\x89\xAA\xF8\xAA\x8B\xAA\x27\xAB\xE8\x5A\x31\xA1\x33\x70\xCE\xAC\x16\x4E\x80\xAC\x91\xAA\xFB\xA6\xB7\xA6\xF1\xAC\xD5\xAC\x5F\xAC\x9F\xAC\x87\xAC\x30\xAC\xBF\xAC\x32\xAC\xC1\xAC\x78\xAA\xC3\xAC\xEF\x62\x45\xA1\xEB\xAC\xF1\xAB\xE9\x51\x00\x15\xEF\xAC\x1C\xAB\x4C\xA8\x9D\xAC\x28\x8E\xBC\xAC\xA0\xAC\x64\xAA\xDA\xAC\x22\xA9\x0D\xAD\xD5\xAA\x0F\xAD\xDB\x9C\xDA\xA5\x73\x90\xDC\xA5\x9D\x0B\xFF\xAC\xB5\xAC\xE3\x47\x9A\xAC\xA6\xAA\x3A\xAB\x83\xAC\xBA\xAC\xD6\xAC\x6C\xAB\x09\xAD\x49\xAC\x0B\xAD\x4B\xAC\x20\xAD\x0D\xAB\xA8\x18\x8D\xAA\xB5\xA0\x00\x00\x28\xAD\xED\xAC\x2A\xAD\x0D\xAC\x9B\xAC\x7C\xA0\x31\xA9\x12\xAC\x0C\xA1\xB8\xA9\x35\xA9\xBA\xA9\x37\xA9\x18\xAC\x1E\x7C\xD0\x79\x3B\xA9\xA1\xAA\xEC\x92\x34\x8E\xC0\x75\x3C\xAD\xE4\x51\xEE\xAC\xD2\xAC\xF0\xAC\xBA\xAA\x0A\xA6\x67\xA9\xCC\xA7\x01\xA8\x9A\xAA\x16\xAC\xD7\x87\x49\xAD\xAD\x7C\x4B\xAD\x14\xA6\x60\x76\xF4\x74\x51\xAD\xD0\xAC\xC8\x50\x54\xAD\x17\xAD\xDE\xAA\xF7\xAB\xF2\xAA\xF9\xAB\xF4\xAA\x9E\xA9\x23\xAB\x5B\xAB\x78\xAC\x5D\xAB\x7A\xAC\x27\xA6\xC6\xAA\x4F\x9F\xB3\xAC\x13\xAD\x25\x4E\xD1\xAC\x0A\x7C\x68\xAD\x3B\xAB\x2F\xAD\x07\xAD\x1E\xA9\x1C\xAD\x74\xAA\x1E\xAD\x53\xAA\x36\xAD\x72\xAB\x22\xAD\xA9\x68\xD8\xAA\x76\xAD\x95\xAC\xEC\xAC\x52\xAD\x3E\xAD\x29\xAC\x43\xAC\x6F\xA5\x4D\xAA\x9E\xAC\x80\xAD\x32\xAD\x62\xAC\x34\xAD\x64\xAC\x85\xAD\xFF\xAB\x87\xAD\x4B\x8F\xEA\xAA\xC7\xAA\x64\xAD\x01\xAD\x2A\xAA\x48\xA9\x69\xA7\x2D\xAD\x99\xA9\x1E\xAB\x6B\xAD\x57\xAB\x86\xA9\x66\xA8\xE4\xAA\xF8\xAC\x5C\xAB\xFA\xAC\xA3\xA9\x8A\xA7\x5D\x9D\xB3\xA8\xEF\xAB\x8C\xAD\x65\xAD\xF4\x47\x16\xAD\x2A\xAC\x91\xAD\x2C\xAC\x1A\xAD\xF4\xAC\xD8\xAC\x82\xAB\xF7\xAC\xAF\xAA\xF9\xAC\xB1\xAA\xFB\xAC\x0B\x2F\x72\x93\x72\x26\xAF\x9F\x7F\x82\x91\xA9\x3B\x7D\x0F\x91\x7A\x7F\x4E\xAB\x9F\xAD\x14\xAD\x20\x39\x67\xAD\xB8\xAD\x94\xA7\xBA\xAD\xE9\x8F\xA8\xAD\xFA\xAB\xAA\xAD\x83\xAB\x77\xAC\x85\xAB\x44\xAB\x67\xAC\xCC\x59\xC5\xAD\x2A\x99\x2B\xAB\xE2\xA8\x00\xA2\x80\x72\x99\x70\x30\xAB\x7B\x93\x60\x91\xCE\xAD\x79\xAD\x66\xAD\x7B\xAD\xD2\xAD\x6F\xAA\x71\xAC\x7F\xAD\xCF\xAA\xBD\xAD\xF6\xAC\x83\xAD\x66\xAA\xDB\xAD\x79\xAC\xDD\xAD\xDF\xAC\xF0\x9A\x3B\xAA\x0D\x89\x94\x98\xAA\x9D\x1B\xA2\xFD\xA8\x1D\xA2\xCD\xAD\xB4\xAD\xA0\xAD\x47\xA9\x7F\xA9\x39\xAB\xDD\xAA\x7D\xAD\xCD\xAA\xF0\xAD\x3E\xAB\x81\xAD\x40\xAB\xF4\xAD\x76\xAA\x99\xAD\x34\xAC\x60\xAD\xF9\xAD\xA7\x9D\x5A\xA2\xFB\x9F\xA8\x93\xB1\x98\xF8\x8E\xE9\xAD\xC2\x50\xB6\xAD\xD1\xAD\x90\xAD\xD3\xAD\x45\xAC\xBB\xAD\x85\xAA\x21\xAB\x6E\xAD\xAB\xAD\xC0\xAD\xAD\xAD\xC2\xAD\xAF\xAD\xEF\xA6\x3C\xA9\xD1\x99\x02\x73\x0A\x9B\x01\x03\x78\xAB\x02\xAE\x78\xAD\x1C\xAE\x15\xAD\x1E\xAE\x40\xAD\xBF\xA4\x42\xAD\xF8\xA5\x57\x8F\x99\xAA\x75\x8F\x14\x85\xFD\xAB\x11\xAE\x4D\xAC\x35\xAC\xA7\xAC\xAC\xA6\xFB\xAD\x83\x77\x5C\xA2\x25\x8F\xAF\xAB\x27\x81\x81\x53\x02\x01\x2F\x83\x5B\x80\x55\x52\x28\x83\x77\x94\xC3\x80\x4C\xAE\x49\xAE\xD7\x73\x93\xA4\x01\x01\x15\x84\x17\xA4\x12\x8A\x97\xA4\x0E\x84\x47\xAA\xC5\xA9\x8D\x5C\x0C\x0A\x3F\x96\xC6\x00\x8F\x82\xEC\xA3\x6F\xA8\x55\x52\x74\x26\xC5\x00\x54\xAE\x25\x59\xAA\xA9\xCD\x69\x6C\x82\x35\xA4\x7C\xA9\x50",
"\xA4\xCF\xAB\xAD\x43\xC7\x00\x7E\xA2\x20\x7B\xFC\x69\xFE\x6B\x69\xA4\x6F\xAE\xF1\x83\x69\xAE\xD2\x58\xEC\x64\xC8\x00\x91\xAB\x73\x7E\x93\xAB\x9B\xA4\x09\x52\xDC\x5C\xC9\x00\xCB\xA3\xED\xAB\x5E\xA9\xF3\x53\x97\xAB\x1F\xA2\xF3\xA9\xB9\xAD\x21\xAE\xD5\xAD\x64\xA8\x58\xAB\xD8\xAD\xBF\xAD\x24\xAB\xA1\xA9\xAE\xAD\x22\xA7\x7E\x99\x4E\x9C\x1D\xAC\x0A\xA7\x7B\x89\x76\xA9\x61\x5F\xF7\x98\xEE\xAB\x89\xAE\x35\xA2\x64\xA9\x54\xAB\x66\xA9\x56\xAB\x90\xAE\xA9\xAD\xE7\xA7\xCF\xA7\x1F\xAD\x2F\x86\x41\xAE\x5C\x74\xB8\x9B\x02\xAC\xE8\xA9\x62\x8F\x5B\xA0\x06\xAC\xB0\xAD\x5E\xA0\x24\xAC\xE9\x86\x8A\xAE\x47\xA0\x06\xAE\x49\xA9\xA4\xAD\xF6\xAB\x83\xAA\x7F\xAB\xBC\xAD\x0D\xAE\x75\xAC\x0F\xAE\x0B\xAB\x40\xAE\x66\xAC\xDE\xAC\x9B\x89\x37\xAC\x26\x99\x39\xAC\x80\x8F\x0D\x9C\x82\x8F\x47\xA7\x3C\x9E\x2C\xA0\xB9\xAE\x62\xA0\x52\xAB\xFC\xA6\x56\xAD\xB9\xA6\x58\xAD\xF7\xA9\x74\xA5\xAA\xAE\x84\xAD\xAC\xAE\xC7\xAE\x9B\xAD\xD0\xA4\xA5\xA9\x9A\x8F\x0B\x9C\x8C\xA0\xAA\x59\x56\xAC\xC7\xAA\xD3\xAE\x7A\xA0\xED\xAD\x9C\xAC\xEC\xA8\x22\xAE\xE1\xAA\xF5\xAC\x87\xAA\x26\xAE\x94\xAE\xB0\xAA\x19\xAC\xFA\xAA\x11\x75\x1A\xA5\xAA\x97\xE9\xAE\x91\xA0\x7C\xAD\x2E\xAD\x0A\xAE\x93\xAD\xF1\xAD\xC2\xAE\xBE\xAC\xDC\xAE\xF5\xAD\xDC\xAC\x86\xAB\xC8\xAE\x7B\xAC\x72\x5B\x8C\xA7\x64\x89\xFA\xAE\xA2\xA0\xD3\xAC\x05\xAD\x84\xAC\xEE\xAE\x20\xAB\xF0\xAE\xE3\xAA\xD9\xAD\xAC\xAD\x71\xAD\x96\xAE\x6F\xA9\x44\xA5\xBC\x91\x25\xA7\xB1\xAE\xDC\x8F\xA3\xA7\xDE\x8F\xEC\xA9\xB1\xAC\x7F\x8D\x00\x00\x0C\xAF\xB8\xA0\xD5\xAE\x04\xAD\xD7\xAE\xCA\xA7\xD9\xAE\x13\xAC\xF8\xA9\x03\xAF\x10\xAE\xDE\xAE\xA5\xAC\x42\xAE\xC4\xAC\x57\x9B\x3B\xAA\x4D\x92\xC2\x9E\x42\x5A\x1A\xA1\x44\x50\xAE\xAC\xF4\xA7\x59\x97\x83\xA5\x94\xAC\x24\xAF\xA2\xAE\xA7\xAA\xD4\xAC\x10\xAF\x8F\xAE\x68\xA9\x24\xAE\xFB\xAB\x6F\xAD\x3F\xAE\x30\xAF\xDD\xAC\xE0\xAE\x01\xA6\xA8\xAC\x35\xAF\xFB\xA0\x37\xAF\x04\x68\x3F\xAA\x1B\xA1\xBE\xA7\x1D\xA1\x23\xAA\xCD\xA0\xB2\xAC\x01\x01\x25\xAF\xD1\xA0\x37\xAE\xF5\xA5\x39\xAE\x6E\xA6\xB9\xA1\xD9\xAC\x97\xAD\xA3\xAC\xC6\xAE\x31\xAF\x13\xAE\x46\xAB\xC5\xAC\x3B\xAA\xF0\xA7\xC8\xAC\xE5\xA0\x51\x92\xE7\xA0\xDA\x99\xF9\xAE\x41\xAF\xBD\xAE\xB9\xAC\xFE\xAE\x11\xAF\x6C\xAD\x47\xAF\x92\xAE\xC4\xAE\x84\xAB\x05\xAF\xDC\xAD\x07\xAF\x30\xA1\xF3\x9E\x13\x75\x5C\xAF\x06\xA1\x2C\xAD\x08\xAE\xFD\xAE\xF1\xAA\xC0\xAE\x23\xAE\x13\xAF\x22\xAB\xF2\xAE\x70\xAD\xF6\xAD\x72\xAD\xF8\xAD\x4B\x8F\x11\xAD\xE8\xAE\x73\xAF\x86\xAF\xA5\xAD\x19\xAD\x45\xAF\x59\xAD\x45\xAD\x15\xAC\x47\xAD\x17\xAC\x5F\x77\x29\xAE\xF6\xAE\x31\x75\x7B\xAA\x26\xAD\x78\x05\x83\xAF\x22\xA1\x27\xAF\x11\xA8\x0F\xAF\x7E\xAD\xFF\xAE\x0C\xAE\x95\xAD\xA1\xAC\x64\xAF\xDB\xAC\x66\xAF\x4C\xAF\x72\x0C\x39\xAD\x49\xA7\x5B\xAF\x95\xAF\xF5\xAB\x75\xAF\x88\xAF\xF3\xAC\x8A\xAF\xF2\xAD\xF1\xAE\x15\xAF\x27\xAE\x17\xAF\xA0\xAF\x5E\xAB\x2B\xAE\x4D\xAD\xFF\x00\xA3\xAA\xA8\x64\xA6\xAF\x34\xA1\xA2\xAD\xC7\xA7\x42\xAF\xAA\xAF\x76\xAF\x99\xAF\xDA\xAE\xCE\xA9\x2E\xAF\xC5\xAE\x4B\xAF\x06\xAF\x4D\xAF\x60\x9F\x47\x9A\x6D\xA8\xC9\xAF\xB8\xAF\x0F\xAC\xF5\xA9\x78\x92\x2C\xAF\xDB\xAE\x9B\xAA\x7C\xAF\xB2\xAF\xD7\xAF\x32\xAF\xEF\x62\x75\xAD\x8D\xA1\x02\x01\xCA\xAF\x59\xA1\x2B\xAA\x0E\xAA\x85\xA6\x29\xAF\x62\xA8\xA6\xAE\x46\xAF\x8B\xAF\x25\xAE\xC0\xAF\xF3\xAE\xC1\xAD\xF5\xAE\xC4\xAF\x84\x71\x89\xAD\xEA\xAF\xB7\xAF\x8B\xAE\x4B\xAA\x8D\xAE\xEF\xAD\xAC\xAF\x73\xAC\x01\xAF\x63\xAF\xD4\xAF\xE4\xAF\xD6\xAF\x7E\xAF\xD8\xAF\x5C\xA9\x9D\xAD\x8A\xAD\x40\xAF\x00\xB0\x93\xAA\x70\xAC\x55\xAB\xF8\xAB\xD6\xAD\x6D\xAD\x48\xAF\x8D\xAF\x4A\xAF\x38\xA9\xB3\xAF\x68\xAF\x08\xAF\x3C\x73\xD3\xA1\x4E\xAB\xEC\xAF\x7C\xA1\x80\xAA\x4B\xA8\x69\xAD\xBF\xAE\xBC\xAF\xEF\xAE\xBE\xAF\x14\xAF\x93\xAE\x8E\xAF\x7D\xAF\xF7\xAD\x7F\xAF\xFB\xA1\xC6\xA8\xE9\x96\x35\x86\x03\xA3\xCA\xA8\x54\xAC\x63\x98\xCB\xAD\x65\xA6\xA5\xAF\xDD\xAF\x13\xB0\xA5\xAE\x15\xB0\xA7\xAE\xD7\xAD\xA9\xAE\xE3\xAF\xDA\xAD\x2E\xB0\x90\xAF\x30\xB0\xC4\xAD\x29\xAB\x2F\x8F\x94\xA6\xE2\xAD\x90\x9D\xC9\x9F\xA9\xAB\xE6\xA8\x7E\x98\x95\x9D\x60\x91\x22\xB0\x90\xA1\x24\xB0\x95\xA8\x09\xAE\xBB\xAF\x30\xAD\x1B\xAD\xAE\xAF\x1D\xAD\xB0\xAF\xAB\xAE\x1B\xB0\xE6\xAF\x1D\xB0\x4E\xAF\x44\xAE\xF8\xA8\x20\x9B\xFA\xA8\x75\x86\x4C\xAB\xC2\x76\x54\xB0\xD6\xA1\xA8\xAF\x1A\xA9\xCF\xAF\x59",
"\xB0\x0B\xAE\x05\xB0\x5C\xB0\x82\xAD\x5E\xB0\xDD\xAE\x60\xB0\x0B\xB0\xE7\xAF\x74\xAB\x09\x91\x8F\x86\xC6\xA6\xAF\x98\xF5\x9A\x19\xAE\x53\xB0\x3C\xB0\x02\xB0\x14\xB0\xA7\xAD\x40\xB0\x17\xB0\x7A\xAF\x75\xB0\x04\xAF\xE5\xAF\x78\xB0\x62\xB0\x5F\xAB\x89\xAB\x92\x98\x29\xA9\xC6\x98\xAE\x86\xF6\x88\x6B\xB0\x08\xA2\x6D\xB0\xC8\xA9\xF1\xAF\x06\xA9\x5A\xB0\xC1\xAE\x73\xB0\x0E\xAE\x89\xB0\x2F\xAF\x77\xB0\x2F\xB0\x0C\xB0\x35\x7F\x97\xA5\x80\x77\x45\xAE\xD4\x93\x51\x74\x86\x77\x55\xAE\xEA\x5A\xCA\x00\x7F\xAE\x32\xB0\xBE\x8E\xA5\x9B\x5D\x7F\xD7\x52\xAE\xAB\x39\x97\x1A\xAF\x3B\x97\xB3\xA4\x0D\x99\xB5\xA4\x0C\xA7\x9D\xAE\xDC\x71\xC0\x9B\x10\xA7\xB3\xB0\x4A\x7F\xB3\x66\x9E\xA4\xAF\xAE\x8F\xAC\x03\xAC\x0E\x99\xCE\xA4\x4A\x8F\x1E\xB0\x29\x8C\xB7\xAE\x75\x8C\xB4\xB0\x95\xA5\x22\xAC\x35\x9E\xCB\xAE\x8F\xA9\xCD\xAE\x53\x9E\xCF\xAE\x0C\x0A\xF7\x9B\xCD\xB0\xC1\xB0\x8D\xB0\x77\xA9\x88\xA0\x87\x8B\x5E\xA7\x3E\x87\xCE\xAE\x44\x99\x6B\xAE\x56\x9E\xEB\x93\xBA\x73\xDA\xB0\xE7\x7E\x69\xAC\xA2\x5C\xCE\xB0\x23\xA0\x70\xA0\x2E\xA5\xB2\xB0\x6E\x53\xEB\xB0\xFE\x95\x1B\xAC\x8D\x9E\x9A\xAE\xC6\xB0\x91\x9E\x1F\xAF\xC0\xA1\x4B\xA5\x6E\x53\x78\x05\xF1\xB0\x90\xA6\x69\xAF\x34\xAF\x65\xB0\xF0\x70\x61\xA5\xE4\xAC\xA9\x9E\xF2\xA7\x3B\xAF\x06\xAA\x6E\x8A\xCD\x53\xE6\xB0\x65\x9E\x63\xB0\x1C\xAA\x50\xAF\x1E\xAA\x6D\xAF\xE6\xAC\x6F\xAF\xE8\xAC\xCC\xAC\xE4\x60\xFC\xB0\xE7\xB0\x25\x7F\x67\x96\x17\x63\x99\xA5\x17\xA1\xDD\x9E\xD8\xA7\x6C\x9C\x41\xAA\xEC\x25\x3D\x68\xA2\xA5\x1B\x81\xFD\xB0\xEE\xA6\x62\x68\x81\xAF\xEA\xB0\x18\xB1\x56\x79\xBB\x97\x6B\xAA\x43\x81\xAD\xAB\x2B\xB1\x49\x98\xA3\xAF\xAE\x8C\x26\xB1\x15\x69\xB5\xAF\xB4\x81\x35\xB1\x8E\xA8\xA4\xB0\x3B\x9F\x59\xA8\x51\x7F\x39\xB1\xB2\xAA\x9E\xAE\xAB\x90\x62\xAD\x1E\x83\xC3\x95\x31\xB1\x3F\x8B\x61\x9F\x5B\x7F\x2F\xB1\x0B\xB1\x72\x9F\x3B\xA6\x3B\x9D\xF2\x85\x09\xA3\x4B\xB1\x53\xA1\x0D\xB0\xA2\xA8\xE5\xB0\x45\xB1\x0C\xB1\xB5\xAE\x2C\x81\xF9\x94\xA6\x7E\xCC\x53\x30\xB1\x57\xB1\x48\xB0\xAF\xB0\x2A\x8F\x97\xAC\x35\xB0\x15\xAB\x92\x9D\x7D\xA6\xEC\xA1\x02\x5B\x5D\xB1\x4C\xB1\x5F\xB1\x77\xA6\x5E\x98\xE1\xAD\xDE\xB0\x2D\xAB\xE4\xAD\xDA\x7A\xE6\xAD\x32\xAB\x2C\x58\x17\xB1\x5E\xB1\x3B\xB1\x2C\xAE\xE1\xAC\xFC\xAD\x87\x6A\xDB\x9A\x77\xA4\x00\xAE\xE8\x9F\x6D\x7F\x69\xB1\x52\xB1\x78\xB1\xFA\xAD\x01\xB1\xF3\x8E\x7D\xB0\xC1\x9D\x7F\xB0\xC3\x9D\x89\x7F\x56\xB1\x6A\xB1\x84\xB1\x15\xAE\xA7\xB0\x69\x77\xD7\x9D\x14\xA0\xEC\x5A\x82\xB1\x5D\xA5\xC5\xAF\x90\xB1\x86\xB1\x1E\x73\xF3\xA6\xF2\x65\xD8\x73\xCE\x00\xB3\xAB\x54\xA4\x01\x01\x13\x1E\x6C\x5C\xBE\x5D\xD0\x54\x5B\x77\x86\x0C\xBB\xAB\xD6\x3E\x8B\x54\xCC\x00\xAF\x6D\xDB\x00\xC2\x95\xAE\xB1\xC3\x5E\xE2\xAB\x86\x24\xBF\x64\xC7\xAB\x01\x01\xCD\x00\x86\x96\xCD\x90\xCC\xAB\xA3\x38\xE4\x64\xCF\xAB\x31\x0A\x9F\xB1\xD2\xAB\xEB\xA3\xA3\xB1\x70\x55\xA5\xB1\xE3\x56\xA7\xB1\xDA\xAB\x22\x60\xAB\xB1\xAD\xB1\xAF\xB1\x4A\x7F\x86\x0C\xB2\xB1\xCA\x73\xB9\x65\xB5\xB1\x00\x00\xB7\xB1\x8D\x96\xD7\x87\xBA\xB1\xCB\x08\xBC\xB1\x9C\x96\x09\x52\xA3\x05\x27\x96\x96\x73\x1E\x96\x30\x96\x57\xA0\xC8\x3B\x33\x96\x4A\x07\x43\x03\xDF\x38\x55\x52\xE8\x09\xDC\xB1\x83\x73\xDE\xB1\x66\x43\xCB\xA4\xC5\x3D\xE2\xB1\xF1\x3B\x5E\x68\x55\x52\xDD\x04\xE8\xB1\xD9\x7D\x2F\x96\xEB\xB1\x09\xA7\x93\x70\xE2\xB1\x83\x07\xDF\x38\x7B\xAE\xCC\x5C\x4F\xAE\x02\x01\xB9\x83\x5C\x80\xAB\x7E\xA0\xAE\x9D\x0B\x62\xAE\x6E\x61\xFC\xA3\xB7\xAC\x55\xAD\xA4\xAE\xBB\xAA\x2B\xAF\x44\xAD\xBE\xAA\x46\xAD\xC0\xAA\x48\xAD\x9F\xAF\xFA\xAF\xE5\xA9\xB6\xB0\xF0\x98\xB8\xB0\x59\xA0\x03\x9E\xBB\xB0\x21\xAC\xBD\xB0\x43\xA0\x83\x69\x05\xB2\xFB\xA3\xF4\x4E\x0C\x48\xEC\xAD\x1F\xAE\xEE\xAD\x84\xB0\x89\xAF\x29\xB0\x06\xB0\xBE\xAD\x7B\xAF\x44\xB0\x8B\xB0\xA2\xB0\xC2\xB0\x4D\x9C\x24\xA7\x32\x92\xF6\xB0\x74\xA9\x99\x89\x1B\xB2\xBD\x7F\x01\x8C\x5F\xA0\xE9\x86\x1F\xB2\xD0\x65\x07\xB2\xB7\xAD\x24\xB2\xEC\xAE\x60\xAF\xCC\xA9\x9D\xB0\xC3\xAE\x9F\xB0\xD5\xAF\xA1\xB0\x46\xB0\xA3\xB0\x88\x5F\xF0\x9B\x2C\x9B\x28\x99\x37\xB0\xE0\xAD\x3B\x9E\x77\xA0\x3D\x9E\x3B\xB2\x6E\x68\x3D\xB2\x36\xAE\x85\xAF\xB9\xAF\x43\xAF\xAB\xAF\x77\xAF\x16\xB0\x79\xAF\x42\xB0\x5C\xAD\xAC\x85\x47\xB2\x18\xAF\x73\xAD\x58\xB1\xE2\xAE\xDF\xB0\xF5\x91\xD5\xB0\xE2\xB0\x0F\x9C\xAB\xA9\xAA\x97\x53\xB2\xB5\x68\x55\xB2\x23",
"\xB2\x5E\xAF\x41\xA6\xED\xAE\xD1\xAF\xE1\xAF\xD3\xAF\x43\xB0\x16\xAF\x8F\xAF\x62\xB2\x91\xAF\xF2\x9E\xE9\xB0\xC0\x75\x6D\xB2\xFF\x68\x6F\xB2\x2B\xAD\xB8\xAA\x0F\xAA\x6F\xB0\x6A\xAD\x27\xB2\x12\xAF\x2A\xB0\x8C\xAF\xF7\xAF\x2D\xB0\x2D\xB2\x48\xB2\x79\xB0\x90\x9A\x7C\xAC\x09\x9E\x04\xB2\x14\x74\x0A\x09\xF6\xA3\x22\xB2\x82\xB2\x97\xB0\xB9\xAA\x0A\xB2\x57\xAD\xF3\xAF\x9A\xAF\x0E\xB2\x9C\xAF\x10\xB2\x9E\xAF\xDA\x78\xC3\xAF\x14\xB2\xF3\xB0\xC7\xA0\x1C\xAF\x17\xB2\xCA\xA0\x49\xA5\x21\xAF\x59\xAF\x23\xAF\x7F\xB2\x67\x6A\x81\xB2\x3F\xAD\x57\xB2\xDE\xAF\x92\xAD\x5B\xB2\x86\xB0\x5D\xB2\xBF\xAA\x3E\xAE\x11\xB2\xA3\xB2\x13\xB2\x7B\xB2\x0D\xB1\xEE\xA7\xA9\xAC\x03\xB1\x3E\xAA\x03\xAA\xC5\x9E\x21\xAA\x01\xA1\xE8\xA0\x22\xAF\x6E\x53\xAF\xB2\xEA\x6A\xB1\xB2\x8F\xAD\x71\xB2\xEB\xA8\x41\xB2\x2E\xAC\x43\xB2\x02\xAF\x77\xB2\xC1\xAF\x79\xB2\xA4\xB2\xBE\xB2\x8E\xB0\x6A\xAF\x9A\xB1\x69\x92\xFC\xA0\xC3\xB2\xAC\xAC\xD6\x99\xC6\xB2\xBF\xA7\xFF\x00\x15\xB1\x95\x9E\xCB\xB2\x23\x72\xCD\xB2\x42\xAC\xCF\xB2\x1D\xAB\x98\xAF\xCE\x98\x98\xAA\x5A\xAD\x3D\xAE\xD6\x87\x60\xB2\x5E\xAD\xAC\x84\xDB\xB0\x8F\xB1\xFF\xA9\x33\x90\x9A\xA5\x86\x8A\x1F\xB1\xDF\x9E\xA3\x9C\x22\xB1\xF5\xA7\xA8\x64\xE7\xB2\xCD\x62\xE9\xB2\x5B\xAC\x18\xA0\xBA\xAF\x86\xB2\x28\xB0\x88\xB2\x29\xB2\xF3\xAD\x45\xB2\x09\xB0\x61\xB2\xD8\xB2\x47\xB0\x28\xB1\x58\xAA\xF4\x9E\x49\x9A\x02\xB3\xE7\xA3\xDF\x39\x97\xB2\xB2\xB2\x83\xB2\xF0\xAF\x9B\xB2\xD8\xAE\x9D\xB2\xD2\xAF\x88\xAC\x08\xB0\x2C\xB2\x0A\xB0\x2E\xB2\xF6\xB2\x1C\xB2\x1E\xA8\xC7\xA5\x6C\xB2\x94\xB2\x78\x4B\x00\x4F\xE9\xA3\x81\xAC\x5C\xAC\x59\xB2\xD0\xAF\xEE\xB2\x3B\xAE\xF0\xB2\xE3\x92\xF8\xAF\x28\xAE\xBD\xB2\x11\xB3\x4A\xB2\x33\xB1\xAB\xA3\x78\x05\x16\xB3\xF5\xA3\x2D\xB3\xF7\xA3\x05\xB3\x30\xA0\x07\xB3\x27\xB0\x9B\xB0\xBD\xAF\x0B\xB3\xBF\xAF\x2C\xB0\x1A\xB0\xF4\xB2\xFC\x86\xB4\xAF\x46\xA8\x52\xB2\x2B\xB3\x04\xB3\x6E\xAC\x82\xAC\x97\xAF\x73\xB2\x33\xB3\x73\x8F\x18\xB0\x8B\xB2\x4C\xB3\x12\xB2\x4A\xAD\xC0\x71\x1A\xB1\x99\xA6\xC7\xAF\xF2\x97\x01\xB3\x52\xB3\x21\xB2\xFD\xA3\xEA\xB2\xB3\xB2\x3D\xB0\x0B\xB2\x1F\xB3\x75\xB2\x21\xB3\xD5\xB2\x37\xB3\xC2\xAF\x39\xB3\x49\xB2\x61\x64\x42\xB1\xC9\x85\x33\x70\x3F\xB3\x95\xB2\x41\xB3\x19\xB3\xCE\xB2\x69\xB3\x83\xB0\x3E\xB0\x85\xB0\xF4\xAF\x89\xB2\xF6\xAF\x4B\xB3\xBB\xB2\xA0\x7B\x72\xB3\x8F\xB2\x4B\x8F\xE9\xAF\xB5\xAA\x02\x01\x78\xB3\x2C\xB3\x87\x4B\xF0\x4E\x54\xB3\x30\xB3\x85\xB2\x46\xB3\x71\xB0\xD7\xAC\x49\xB3\x2B\xB0\x2B\xB2\x78\xB2\x45\xB0\x7A\xB2\x3A\xB3\x5D\x69\x74\x9F\x23\x93\x77\xB3\x65\xB3\xE5\xA3\x67\xB3\x43\xB3\xB4\xA1\x31\xB3\x70\xB0\x04\xB0\x96\xB3\xD3\xB2\x07\xB0\x6F\xB3\x8C\xB2\x24\xB3\x8E\xB2\x26\xB3\x74\xB3\x34\x93\x54\xB1\xC7\xAA\x8D\xB3\x53\xB3\x2F\xB3\x06\xB3\xA7\xB3\x08\xB3\x47\xB3\x28\xB2\xAB\xB3\x2A\xB2\x0D\xB3\x23\xB3\x0F\xB3\x87\xB3\xB1\xB3\xA6\x95\x6B\x7F\x3A\xB0\x8C\xB3\xA2\xB3\xF3\xA3\xA4\xB3\x91\xB3\xB9\xB3\x93\xB3\xA6\xAD\x87\xB2\x78\xAF\xF5\xAF\x5A\xB3\x84\xB3\xA2\xB2\x86\xB3\x5E\xB3\x7E\x7F\x49\xB0\x73\x93\x13\xAB\x73\x94\x36\xB0\xE5\xA8\x46\x76\x39\xB0\xC2\x76\xB6\xB3\x66\xB3\x08\xB2\xFC\xAE\x56\xB3\xD1\xB2\x47\xAC\xBE\xB3\x0C\xB3\x22\xB3\x9A\xB3\x8D\xB2\x9C\xB3\x73\xB3\x54\x7D\x05\x58\x12\xAB\xFE\xA1\x51\xAC\x4D\xB0\xE4\xA8\x4F\xB0\xDF\xB3\x04\xA2\xE1\xB3\xC9\xB3\x96\xB2\xCB\xB3\xB8\xB3\x44\xB3\xBA\xB3\x94\xB3\xA9\xB3\x31\xAD\x62\xAF\xBF\xB3\xEB\xB3\xD6\xB2\x9B\xB3\x10\xB3\xEF\xB3\x4D\x7F\x57\x96\x2D\xAE\x41\x91\x49\xAB\xFE\xAD\x4B\xAB\x97\x98\x80\xB1\x60\x91\xE2\xB3\xA3\xB3\xE4\xB3\xEB\xAE\x41\xAD\x96\xAA\xB6\xA9\x0D\xB2\x14\xAC\x5B\xAD\x9D\xAF\x5D\xAD\x5D\xB3\x5F\xAD\x5F\xB3\x87\x96\x68\x96\x16\xAE\x88\xB1\xFC\x9F\xFE\x9F\x4E\xAB\x15\xB4\xCA\xB3\x17\xB4\x3F\xB2\x19\xB4\xFE\xA7\x1B\xB4\x00\xA8\x9B\xAF\x1E\xB4\xA1\xB2\x20\xB4\xBC\xB2\xD7\xB3\x81\x92\x79\xB1\x1F\x9B\x88\x54\x91\xB0\x75\x91\x2B\xA9\x2A\xB4\xFB\xB3\x7A\xB3\xFD\xB3\x02\xAD\xFB\xA7\x7E\xB3\x6B\xB3\x3F\xB0\x81\xB3\x97\xB3\x8A\xB2\xD4\xB3\x36\xB4\xD6\xB3\x22\xB4\x19\xB1\x24\xB4\x89\x91\xE9\x9D\x3F\xA9\x8C\x91\x48\xAE\xAB\xB0\x6B\x7F\xD1\x00\xAE\xB0\x6C\xB1\x81\xAE\x24\x9B\xFD\x01\x78\x6D\x16\x84\x02\xB2\x88\xAE\x9D\x0B\x85\xAE\x50\xAB\x37\xAB\x03\xAD\xA9\xAF\x99\xB0\xCA\xA9\x02\xB4\x5B\xB0\x04\xB4\xEA\xB3\xAD\xB3\x5C",
"\xB3\x37\xB4\x5F\xAD\x56\xA9\x46\xA5\x1D\xAF\x7A\x89\x48\x8F\xB7\xA4\x07\xAC\xDE\x98\x64\xB4\x61\xA9\x74\x8B\x18\xB4\x38\xAE\x1A\xB4\x43\xAD\x32\xB4\x9F\xB2\x34\xB4\xBA\xB2\xD5\xB3\xAB\x84\x4E\xB3\xAE\xAE\x99\xAE\xE2\x66\xE2\x86\xC1\x91\xFA\x8C\x90\xB2\xEA\x6B\x39\xB2\x3D\x9E\x7B\xB4\x79\xAE\x02\xA9\xEB\xB2\x18\xAD\x57\xB3\x97\xAA\x34\xB3\x33\xB4\xF1\xB2\x76\xA5\xED\xB3\x09\xB4\x88\xB3\x8D\xA9\xE5\x96\xF2\x93\xE7\x96\x92\x96\x6C\x7E\x3D\xAC\xCD\x74\x93\xB4\xAE\xA9\xA2\x89\x44\xB4\x6F\xAC\x46\xB4\x9C\xB2\x48\xB4\x9E\xB2\x1D\xB4\x9C\xB4\xE9\xA7\xAF\xB3\xEE\xB3\xA0\xB4\xA4\xA9\x09\x9C\x03\x78\x51\x9E\xE5\xAE\x7A\x62\x62\xA7\xAA\x97\xA9\xB4\xC4\xA9\x0E\xA8\x51\xAB\x56\xB0\xCB\xAA\x58\xB0\xBB\xB3\x95\xB3\x03\xB4\xE8\xA6\x88\xB0\x06\xB4\x70\xB3\xD7\xB2\xC3\xB3\xE8\xB0\x4F\x81\x25\x9C\x6E\x53\xC0\xB4\xD8\xA9\x48\xAA\x0E\xAF\x69\xB4\x05\xAB\xBC\xB3\x0A\xB3\xE9\xB3\x4A\xB3\x99\xB3\x07\xB4\x9E\xB4\xCF\xB4\xCE\x7E\xD5\xA9\x92\xB2\x78\x05\xD4\xB4\xEF\xA9\x0B\xAA\x05\xAE\xB1\xA9\x12\xB0\xAE\xB4\x1E\xB3\xB0\xB4\x20\xB3\x0A\xAD\xCC\xB4\xAE\xB3\xC2\xB3\x4A\xAD\x73\xB4\xD6\x9B\x29\x5A\xB4\xA4\xEA\xA9\x20\xAF\x9F\xA1\xFA\xB0\x3F\xAF\xE6\xB4\x0A\xAA\xAF\xA9\xA1\xAD\xBB\xAE\xA3\xAD\x96\xAF\xBE\xAE\xCF\xB3\x09\xB3\xD1\xB3\x82\xB3\xD3\xB3\xDE\xB4\xCD\xB4\x08\xB4\xE1\xB4\x39\xB4\xF9\xA0\x0F\xB1\xAA\xAC\x04\xB1\xE4\xA0\x12\xB1\xCA\xAC\xE7\xA0\x07\xAA\x95\x9E\xFE\xB4\x28\xAA\xE8\xB4\x01\xAB\xC4\xB4\xEF\xAA\x45\xB3\x06\xB5\xDA\xB4\x08\xB5\x4A\xB4\x83\xB3\x0B\xB5\xF2\xB4\x4D\xB3\x6D\x87\x3E\x89\x51\xB4\x4F\x27\xC0\x9E\x13\x90\xDE\xB2\x61\x5A\x39\xAF\x5E\x8D\xE7\xAC\x3C\xAF\xC8\x9E\x3E\xAF\x5A\xAF\x00\x00\x1A\xB5\x5D\xAE\xC2\xB4\x66\xB4\x45\xB4\x20\xAE\x03\xB0\xB6\xB2\x49\xB4\xDC\xB4\x98\xB3\xC0\xB3\xEC\xB3\xB5\xB4\x9F\xB4\xC4\xB3\x0B\xB4\xE1\x93\x9A\xB1\x6C\xAF\xFC\xB2\xC9\xAC\x76\x74\x98\x8D\x71\xAF\x49\x9A\x39\xB5\x5C\xAA\x96\xB4\x26\xB0\x21\xB5\xC8\xB4\x6C\xB4\xCA\xB4\x5E\xB2\x1F\xB4\xF3\xB2\x21\xB4\xF5\xB2\xD0\xB4\x2A\x01\xA9\x97\x52\xB5\xC9\xAA\x1E\xB5\x03\xAB\xD8\xB4\xF2\xAC\x22\xB5\x5C\xB2\xD2\xB3\xCB\xB4\x6F\xB4\x85\xB3\x87\xB4\x29\xB5\x78\x88\x93\xAF\x0F\xB0\x53\xB5\x7F\xAA\xEE\xAF\x81\xAA\x97\xB4\xE7\xB3\x86\xAC\x6D\xB4\xDD\xB4\x44\xB5\xDF\xB4\x46\xB5\x0E\xB5\x32\xB1\x24\xAD\xCE\x97\x7C\xAA\x02\x01\x74\xB5\x90\xAA\x01\xB5\xEA\xB4\x07\xAE\x58\xB2\xCE\xB3\xED\xB2\x99\xB4\x59\xB3\x6C\xB5\x5F\xB2\xE5\x92\x5E\xB5\x88\xB4\x37\xB1\x64\x89\x86\xB5\xDB\xAA\x55\xB5\xC6\xB4\x01\xB4\x40\xB5\xB1\xB4\x2D\xAF\x6D\xB5\x86\xB4\xF6\xA0\xB7\xB4\xDA\xB2\x09\x91\x79\xA1\xC0\x75\x97\xB5\xED\xAA\x65\xB5\x53\xAB\xDC\x8D\x3F\xB5\x74\xB2\x1C\xB4\x9E\xB5\x91\xB5\xC9\x97\xB6\xB4\xC4\xB3\x55\x7F\xF4\x74\xA7\xB5\x1B\xAB\x7E\xB4\x5F\xAF\x80\xB4\x3A\xAE\x8F\xB5\x5B\xB5\x35\xB4\x5D\xB5\x71\xB4\x5F\xB5\x64\x7F\x14\x98\x29\xA6\x33\x70\xB6\xB5\x36\xAB\xD7\xB4\x1D\xB3\x2A\xAF\x6C\xB3\xAE\xB5\xE2\xAF\xB0\xB5\x12\x9D\x47\xB5\xDB\x7E\xFD\xAF\x8B\xB3\x01\x01\xC6\xB5\x67\xAB\xE5\xB3\x05\xB5\x8D\xB5\x31\xB4\xEF\xB2\x9B\xB4\x36\xB3\x27\xB5\x93\xB5\x70\xB5\x37\x98\xB3\xB3\x39\x98\xC5\xB5\x64\xB5\x76\xB5\x25\xB0\x9A\xB5\x57\xB5\x6B\xB4\x9C\xB0\x7B\xB5\x43\xB5\xF1\xB4\x70\xB4\x4E\xB4\xC1\xB5\xDA\x76\xC6\x8F\x16\x5B\xD3\x00\xC5\xB3\xF5\x90\xC2\x76\xD5\xB5\x7B\xAB\xD7\xB5\x20\xB5\xD9\xB5\x81\xB4\xDB\xB5\x83\xB4\xB3\xB4\xD0\xA9\x7F\xB5\x38\xB4\x36\x7F\xDF\xAD\xA4\x73\x79\xA6\xB0\x9F\xC9\xAD\x38\x17\xCD\xA8\x85\x72\xF9\xB5\xD6\xB4\x09\xB2\xAB\xB5\x26\xB2\x07\xB5\x6A\xB5\x09\xB5\x90\xB5\x5C\xB5\x92\xB5\xC0\xB5\x88\xB4\xF4\x79\xD9\xB3\xC6\xAD\x8E\x9D\x27\x91\x5B\x7D\x68\xB2\x76\x9D\x31\xAB\x52\xB0\x4E\xAB\x0E\xB6\x5E\xAE\xC8\xB5\x11\xB6\x7F\xB3\xD0\xB3\x14\xB6\x24\xB5\x0A\xB5\x7D\xB5\x0C\xB5\xE0\xB4\x04\xB6\x2A\xB5\xA5\xB0\x25\x89\x18\xA2\x75\x95\x92\x7F\x11\xB4\x1C\xA2\x13\xB4\x25\xB6\xE5\xB5\xCC\xAF\x2C\xAA\x74\xAF\x00\xB4\xE9\xB5\x9C\xB5\xEF\xB4\x33\xAD\xEE\xB5\x6E\xB5\xA1\xB5\x48\xB5\x8E\x96\x88\x96\x3D\xA9\x42\x89\x95\x7D\x33\x7A\x18\xAE\x8B\xB1\xF8\x8E\x26\xB6\x3B\xB5\x28\xB6\x17\x91\x12\xB6\x69\xB5\xB7\xB2\x6B\xB5\xBD\xB5\x85\xB4\x4D\xB4\x6F\xB5\x14\x9D\x33\xAF\xA9\x86\x45\xA2\x74\x91\xFF\x00\xBF\x93\x60\x91\x53\xB6\x29\xAA\xE9\xB4\x4A\xAA\xEB\xB4\x3E\xB5\x57\xB6\x58\xB5\xEB\xB5\x5A",
"\xB5\xB9\xB2\xF2\xB2\x18\xB6\xF0\xB5\x1A\xB6\x50\xB4\x34\xB6\xD7\x8B\x8A\xAB\x50\x74\xDB\x98\x41\xA9\x37\x73\x4F\x81\xD4\x00\x5E\x66\xD8\x73\xAA\x37\x29\x52\xD3\xAB\x00\x00\xD7\x00\xAF\x6D\x7D\x5D\xD0\x54\x12\x85\x8F\x0C\xA9\xB1\xB0\x3F\x8B\x54\xD8\x00\xAF\x6D\xE0\x00\xC2\x95\x91\xB6\x59\x5E\xCE\xB1\x16\x06\x64\x65\xD1\xB1\xD5\x00\x86\x96\x9D\x7B\xD6\xB1\x2C\x04\xBF\x64\xBD\xB1\x02\x01\x82\xB6\xCD\x5C\x84\xB6\x86\xB6\x6C\x5C\x88\xB6\xE3\x56\x8A\xB6\xC7\xB1\x0C\x62\x8E\xB6\x90\xB6\x92\xB6\x4A\x7F\x8F\x0C\x95\xB6\xC8\x95\xE6\x68\x98\xB6\x9A\xB6\xF6\x5D\x9C\xB6\x6F\x82\xC6\x68\xEC\xAB\x02\xB2\xE0\xAB\xE9\xB1\x02\x96\xDF\xB1\xA0\xA7\x62\x3B\xE2\xB1\x96\x3D\x47\x01\x62\x4D\x7E\x74\x02\x01\xBB\xB6\xF4\xB1\xEA\xB1\x8A\xB4\xE4\x64\xE2\xB1\x5A\x01\xF4\x3F\x62\x4D\xEA\x6B\xC5\x04\xC7\xB6\xDC\x84\xF5\xB1\xCA\xB6\xE4\x65\x82\x7B\x51\x0A\xC8\x01\x0A\x2C\xCF\xB6\xFC\xB1\xBE\x8C\x87\xAE\x95\xB1\x01\x01\xF3\xB1\x0E\xAD\x2F\xB2\x24\x8A\x0B\x99\xA9\xB2\x73\xA9\x9C\xAE\x36\xB2\x06\x5E\x08\xAC\xC1\x52\x78\x05\xE1\xB6\x21\xAD\xE3\xB6\xD8\x7A\xF4\xB0\x8B\xB4\xD8\x9B\xC9\x77\x0D\xA7\xD0\xB0\x78\xA9\x2C\xA7\x8C\xB1\xEE\xB6\x37\xAD\xA2\xB5\xDC\xB0\xD7\x91\xA2\xB4\x38\x9E\x0A\xB6\xA2\x8E\x50\xB2\x00\x7A\x5C\xB1\xE0\xB6\x4A\x7F\xD0\xB5\xE2\xB4\xFE\x96\x01\xA5\xBA\xB4\x8B\xA0\x02\xB7\x55\x81\xBE\xB4\x75\x8C\xFB\xB6\x86\xAD\xFD\xB6\x12\xB3\xD1\xB4\x5A\x6B\x13\xB7\x9A\xAD\x15\xB7\x4A\xB2\xE3\xB4\x10\xA7\x06\xB7\x00\x00\x19\xB7\x12\xAE\xF5\xB4\xB2\xA4\xF7\xB4\xB9\xB0\xF9\xB4\xF9\xB0\x6E\x8A\xFF\x04\xED\xB6\x08\xB7\x80\xB5\x33\xB6\x9C\x9C\x60\xA5\xBA\xA7\xAB\xAC\xE5\xAC\x06\xB1\x80\xA5\x08\xB1\xB1\xAC\x2A\xB7\x26\x96\x2C\xB7\x32\xB6\xF7\x84\xE0\xAC\x3B\xB4\x1D\x6F\xC7\xAC\x4D\xB5\x6E\xAF\x16\xB5\x14\xB1\x29\xB7\x6E\x53\x21\xB7\xAD\xAE\x23\xB4\x77\xB6\x9A\x89\x6B\xAF\xFA\xB2\x72\x97\x30\xB5\x54\xAF\x3A\xAF\x35\xB7\x22\xAA\xE9\xAC\x1F\xA1\x05\x80\x47\xB7\xDF\xAE\x1B\xB7\x34\x58\xFD\xAC\x33\x6F\x57\xB7\x67\xAF\xFA\x71\xC9\x9C\x18\xB7\x3A\xB7\x4F\xB4\xF2\xB5\x0E\x8E\xA2\x5C\x5D\xB7\x1C\xB0\x37\xB1\x1F\xB7\x67\xB7\x61\xB0\x49\xB7\x3C\xB1\x03\xA6\x39\x6C\x6B\xB7\x8C\xB0\x5F\xB7\xFF\x92\xDB\xAF\x56\xB7\x62\xB7\xF1\xB5\x36\x7F\xC8\x7C\x57\x8E\xE6\x94\x71\xB7\x25\xB3\xD1\xB5\x4E\xB1\x61\xB7\xEB\xA7\x59\xB7\x81\x69\xE3\xB5\x5C\xB7\x77\xB7\x75\xB6\x64\xB7\x4A\x98\xC6\xB3\xAA\x53\x2B\xB7\x82\xB7\xC4\xB3\x06\xB6\x75\xA0\xDB\xB3\x60\x98\xDD\xB3\xF7\xB3\x38\xB0\x6F\x8B\xFD\xAA\xFB\xB0\x39\xB7\x8E\xB7\x1B\xB6\x60\xB1\x24\x91\x4B\xB0\x6F\xB1\xE3\xAD\xBC\xB4\x1B\x65\xE7\xA8\x0E\x7F\x07\xB7\x9B\xB7\x76\xB6\xF0\xA6\x9A\xB1\x7B\xB1\xE4\x9F\xFB\xA8\xFF\xAD\xB2\xA6\xFC\x7E\x9A\xB7\xD2\xA9\x83\xB7\x49\xB5\x4B\xB6\x0D\xB4\x4D\xB6\x17\xAE\x31\xA2\x8C\xB7\xB1\xB7\xFC\xA9\xB3\xB7\x4A\xB6\x25\xB4\x91\xB1\x3D\xB4\x64\xB6\x3F\xB4\x5D\x55\x8D\xB7\xB2\xB7\x49\xB6\x60\xB3\xD2\x93\x5A\xA2\x27\xA0\xD6\x93\x93\x07\x7D\xB6\x55\x9E\x76\xAE\x6E\x53\x00\xB2\x94\xB4\x79\x83\x4C\xA4\x2D\x81\x01\x01\xA5\x83\xB9\xB6\x07\x87\x84\x82\x44\xB1\x5F\xB4\xC1\xB4\x68\xB6\xB7\xB6\xCA\xA6\x72\xA0\xB7\x6C\xA3\x9B\x78\x54\x14\xA3\x8B\xA2\x9D\x0B\xDD\xB7\xD5\xB4\x5E\xAE\x37\x95\x63\x6D\xE9\xB7\xE7\xB4\x00\xB5\x64\x82\xA0\x8C\x3E\x9B\x91\xA3\x60\x81\xF6\x7D\xEE\xB7\xFF\xB4\xAB\xB4\x53\x82\x48\x95\xA0\xA2\x68\x81\x42\xA3\x92\x8C\x6F\x6C\x51\x95\xE6\x94\xF7\xB7\x1B\xB5\xF0\xB7\xEB\xA9\x7F\x95\xB1\x82\x1B\x82\xFE\xB7\x5A\x95\x6F\x6C\x5C\x95\x2A\xA3\x03\xB8\x3A\xB5\xDF\xB7\x20\xAF\x7F\x95\x62\x95\xF4\xB7\x4C\x6F\xBA\xA2\x0E\xB8\x6F\xA8\x5A\xA3\xB5\xA2\x50\xA3\xB7\xA2\x52\xA3\x48\x6D\xC2\xA2\xB4\x81\x0F\xB8\x77\x84\x66\xA3\x6F\x56\x15\xB8\xFB\x6C\x6A\xA3\x21\xB8\x19\xB8\x71\xA3\x3E\x94\xA5\x94\x2F\x94\xD1\x94\x98\xA2\xD3\xA2\xF6\xB7\x2A\xB8\x4A\x94\x7C\xA3\xEC\xA2\xE4\xB7\xA3\x52\x5B\x6F\x32\xB8\x65\xB4\x27\x80\xE2\x94\x36\xB8\x05\xA3\xDC\x94\xE6\xA2\x38\xA3\x77\x6D\x33\xB8\x8E\x9B\x5E\x7E\x26\xB8\x48\x6D\x93\xA3\x98\x9B\x02\x01\x22\xB8\x91\xA4\x70\x82\xAD\x8C\xF1\xA2\x00\x00\x4C\xB8\x87\xB5\xC3\x01\xA2\xA3\x95\x82\x52\xB8\x08\x6A\xA9\xA3\x1A\x83\xAB\xA3\x63\xB1\x88\x6F\x4D\x94\x5A\xB8\xD1\xA4\x60\x66\xDE\x98\xF5\xB5\x65\xB4\x55\xB6\x94\x92\x6D\xB6\xEA\xB5\x48\xB3\x42\xB5\x4B\xB4\x26\xB5\xEF\xB5\x5E\xB6\x7D\x99\xB7",
"\x9B\xD5\xB6\xE5\x7F\x18\xB2\xBA\xB0\xE4\x86\xB4\xAE\x5C\xA9\xEB\xB6\xB6\xAF\x00\x00\x63\xB8\x7C\xB4\xC6\x8B\x2E\xB4\x7F\xB4\x30\xB4\xFE\xB5\x9A\xB4\x00\xB6\xDD\xB5\x6D\xB8\x48\xB6\x23\xB7\xA8\xB2\x25\xB7\x73\xB8\x34\xB2\xC2\x91\x5B\x72\x23\xAC\xF9\xB6\x19\x84\x7B\xB8\xD3\xB7\x7D\xB4\x7E\xB8\xB9\xB5\x80\xB8\xBB\xB5\xE1\x92\x16\xB6\xBE\xB5\x73\xB6\x6E\xB8\x8E\xB1\x1C\xB7\x41\xA7\xD2\xB0\xE6\x96\xF3\x9B\x2F\xAB\x23\x87\xD0\xAE\x51\xB2\x2C\xA0\x91\xB8\xAA\xB4\xD7\xA4\x88\xB5\x6A\xB6\x8A\xB5\xB4\xB2\xD4\xAD\x58\xB3\x98\xB8\x5B\xB6\x72\xB6\xB1\xB5\x09\xB7\x89\xB7\x2D\x8D\xB9\xB4\x94\x84\x67\xB2\xA5\xB4\xF7\x91\xE3\xB0\x42\x87\x6E\x53\xA8\xB8\xDE\xB7\x1C\xB5\xC3\xB4\xE6\xB5\x57\xB0\x87\xAF\xC7\xB4\x68\xB8\xBD\xB3\xEC\xB5\x6B\xB8\x2F\xB6\xDE\xB5\x19\xB6\xE0\xB5\x84\x79\x77\xA7\x0F\xB0\xC0\xB8\xEA\xB7\x54\xB6\x10\xB6\x56\xB6\x2A\xB6\x13\xB6\x59\xB6\x15\xB6\xB2\xB8\x9D\xB4\x03\xB6\x63\xB7\x49\x98\x1D\xB7\x62\xB4\x78\x05\xD3\xB8\xEF\xB7\xF9\xB7\x69\xB6\x38\xAB\xBC\xAE\x04\xB5\xFC\xB5\x98\xB4\xDA\xB5\x82\xB8\xB2\xB4\x84\xB8\x47\xB6\x8E\xB7\x87\xB8\x32\xB2\x75\xB4\xDD\x84\xF8\xB0\x53\x9C\x4D\x8A\xE4\xB8\xF8\xB7\xAA\xB8\xE7\xB8\x67\xB4\x6E\xB0\x67\xB5\x06\xAD\xC8\xB8\xDB\xB4\xCA\xB8\x25\xB5\xCC\xB8\x85\xB8\xA7\xB7\x0F\xB5\x4F\xAF\xDC\xB2\x53\x97\x52\xAF\x20\x85\xE0\xB2\x04\xAA\x07\xB1\x53\xB7\x18\xB5\x25\xAA\xFA\xB8\x04\xB8\xE6\xB8\x1D\xB5\xC4\xB8\xC5\xB4\xC6\xB8\x9B\xB5\xAD\xB5\x82\xB4\xEF\xB8\xC7\x97\xCD\xB8\x74\xB6\xCF\xB8\xF8\xA0\x0A\xB9\x4C\xB6\x70\x97\x2E\xB5\x0D\xB9\x96\x75\xC4\xB2\x64\xA5\x56\xAF\x66\xA5\x58\xAF\x36\xB5\x23\xAF\x15\xB9\x10\xB8\xC2\xB8\x3C\xB5\xAD\xB4\x6C\xB6\xD8\xB8\x58\xB6\x41\xB5\x04\xB9\x2E\xB6\x46\xB6\xA0\xB5\x08\xB9\x36\x7F\xB4\xB7\xAF\x8D\x4C\xB7\x1D\xB1\x9B\xA5\x32\xB7\x05\xB1\xAD\xAC\x52\xB7\xC7\xB2\x51\xB5\xC7\xAA\x32\xB9\x54\xB5\x7D\xB3\x37\xB9\x47\xB4\x80\xB3\x9D\xB5\xCD\xB5\x17\xB6\xB4\xB8\x2D\xB7\xB5\x9C\x09\xA8\xB5\xA5\xA8\x64\x4D\xB9\x75\xB5\x3E\xB6\xEF\xAF\x04\xA9\x00\xB9\x44\xAF\xB0\xB8\xC5\x97\x99\xB8\x5C\xB6\xBF\xB5\x22\xB9\x5F\xB6\x10\xAD\x1F\xA8\x4C\xB9\x3D\xB6\x02\xB5\xCD\xAF\x40\xB6\x8C\xB5\xEC\xB8\x81\xB8\xBC\xB5\x71\xB6\xDD\xB8\xF3\xB4\xDF\xB8\xEF\x9B\x3C\xB3\x0E\x79\x02\x01\x5C\xB9\x53\xB8\x18\xB9\x5E\xB9\x77\xB5\x56\xB5\xFD\xB5\x97\xB8\x64\xB9\xDC\xB8\xB4\xB4\x77\xB9\xF5\xB2\x95\xB5\xBF\xB8\x6D\xB9\x89\xB5\xE9\xB8\x8B\xB5\x61\xB9\x5A\xB2\x1D\xB9\xFF\xB5\x1F\xB9\x79\x99\x30\xB6\xDE\xB8\x78\xB7\x2E\xB7\x32\x8E\x3D\xB1\xF4\x74\x7D\xB9\x98\xB5\x4F\xB9\x25\xB2\x38\xB9\x6E\xB6\x69\xB8\x3B\xB9\x65\xB9\xB3\xB8\xCF\xB5\x57\xB9\xE1\xB5\xDA\xAF\x43\xB1\x33\x70\x9D\xB9\xA8\xB5\x19\xB9\x1F\xB5\x41\xB6\x83\xB9\x61\xAF\x70\xB6\x0F\xB2\x66\xB9\x9B\xB8\x48\xB6\x73\xB7\xBE\x90\xC4\xB5\x5B\xB9\x8C\xB9\xAC\xB8\x8E\xB9\xAE\xB8\x8E\xAE\x63\xB9\x77\x99\xA5\xB9\x76\xB9\x28\xB5\x69\xB9\xDF\x6F\xD2\xB5\x26\x9C\xAD\xB9\xB7\xB5\x94\xB8\x72\xB2\x79\xB5\x08\xAD\xA4\xB9\x86\xB9\x02\xB6\x88\xB9\x88\xB7\x79\xB7\x7E\x9A\xA4\x88\x6C\xB9\x64\xB8\xD6\xB8\x66\xB8\xA1\xB9\x02\xB9\x23\xB5\x6A\xB8\x05\xB9\x3D\xB9\x5D\xB6\xB8\xB9\x0A\xB7\xB1\xAD\x98\xB7\x79\x9D\x8B\xB9\xDA\xB9\xFB\xB5\xB1\xB9\x72\xB9\x84\xB9\xC3\xB9\xD2\xB9\xFA\xA9\x97\xB9\xD5\xB9\x70\x7F\x1C\xB6\x4F\xB2\x72\x9D\x14\xAB\x7B\xA6\xDE\xB3\x96\xB7\x77\x9D\xE7\xB9\x80\xA6\xF3\x53\xCB\xB9\xC7\xB5\xDB\xB9\x29\x9E\x67\xB8\x43\xB6\x6D\xB3\xF0\xB4\x9F\xB5\xE3\xB9\x3F\xB9\xF4\xB9\x9D\xB7\x3A\x9E\x9F\xB7\x75\x93\xF5\xB3\x2E\xAB\x83\x96\x03\xA2\x9A\xA6\x05\xA2\x60\x91\x00\xBA\xD6\xB5\xB8\xB5\xCE\xB9\xBA\xB5\xB3\xB9\x3C\xAE\xF0\xB8\x3E\xB9\xC6\xB7\x6D\xB7\x3A\xB4\x5C\x5B\x4D\xB6\x67\xB0\x0F\x89\xDD\x9A\xC2\x76\x17\xBA\xFA\xB5\x19\xBA\xD0\xB2\x1B\xBA\x42\xB2\xD1\xB9\x75\xB9\x87\xB9\xC6\xB9\x77\xB1\xB1\x7D\x85\xB1\x26\xB9\x20\x9B\xB8\xB7\x5E\x91\x28\xBA\xBD\xB9\xE8\xB8\x03\xB5\x8F\xB9\xC9\xB5\xF2\xAF\xEE\xB4\x06\xBA\x45\xB6\x08\xBA\x67\xB9\x9C\xB8\x83\xB1\x34\xBA\x99\xB1\x36\xBA\x3C\xB4\x2F\xAE\x04\x73\x94\xB1\x85\x72\x29\xBA\x0F\xB6\xEB\xB9\x71\xB9\xCF\xB9\x94\xAD\x2F\xBA\xB5\xB9\xA6\xB9\x63\x9E\xB5\xB8\x40\xB9\xBE\xB7\x52\xB4\xCA\xB7\x54\xB4\xEB\x9D\x5D\xA2\x06\x5E\xF6\xA6\x78\x05\x7F\xB6\x11\xB0\xAD\xB8\x6A\xB3\xAF\xB4\x52\xB9\x44\xB6\x96\xAD\xE2\xB9\x45\xBA\x86\xB8\x8E",
"\xAC\xEC\xB1\x33\xB2\xE8\xB6\x5B\xA9\x41\xB1\x1D\xB2\x65\x68\x65\xBA\xBA\xAE\x8D\xB9\x3D\xBA\xC0\xB9\xAC\xB5\xC2\xB9\x15\x9B\xC4\xB9\x31\xBA\xDF\xB5\x42\x8F\xE4\xB6\xE0\xB1\x89\xB8\x82\x99\x1F\xAC\x35\xB2\x74\xBA\x9E\xB8\xDD\x9B\xCC\xB0\x2C\xA0\x78\xBA\xD4\xAE\xA9\xB5\xD6\xAE\x3F\xBA\x9A\xB0\xA2\xB9\xC9\xB8\xB4\xB9\xA0\xB2\xB6\xB9\x56\xB9\x3B\xB7\x97\x8F\xFF\xB6\x38\xAC\xD3\xB0\x16\x8D\x65\xB1\xFD\xA1\xA7\xB4\x19\x84\x8F\xBA\xEA\xAE\xCD\xB9\x2C\xBA\x96\xB8\x1C\xBA\x35\xB3\x20\xB9\x07\xB9\x20\xBA\xE5\xB9\x50\xAC\x4C\xB0\x0D\xB7\x5F\xA7\x95\xB7\x5B\x73\xE7\xAE\x0F\xB0\xA5\xBA\xFB\xAE\x2B\xBA\xEC\xB2\xED\xB9\xAA\xBA\xDC\xB5\xAC\xBA\xF1\xB8\xAE\xBA\xF2\xB5\xD1\xB8\xFE\xAF\x00\x00\xB8\xBA\x0D\xAF\x02\xBA\xE4\xA6\x69\xBA\x2B\xB6\xDA\xB8\x2D\xB6\x80\xBA\xD3\xB9\x32\xBA\x9D\xB8\x37\xB2\x91\xB2\x03\xB2\x64\xBA\x82\xB0\x50\xB9\xCA\xBA\xD9\xB8\x3A\xB9\x97\xBA\x84\xB4\x58\xBA\x70\x9F\x47\xB5\xF3\xB8\x12\x96\x33\xB2\x91\xAC\xAC\xB2\x30\xB9\x6E\x53\xC6\xBA\x26\xAF\x91\xBA\x28\xAF\x93\xBA\x6A\xB4\x05\xBA\xCC\xB5\x76\xB2\xCE\xB5\x59\xBA\xA8\xB9\x7A\xA5\xC0\xB2\x11\xB5\xC2\xB2\x4F\xB7\x2B\xB9\x40\xAA\x2D\xB9\xDB\xA7\xC8\xB2\xAD\xB2\xE6\xBA\xD6\xBA\xA0\xB9\x51\xB9\xCB\xBA\xDA\xBA\x1D\xBA\xBF\xBA\x1F\xBA\xBC\xB7\xC7\xB7\x2B\xB5\xB6\x27\x2D\xB5\x40\xB7\x46\xB9\x14\xB5\x34\xB7\x9F\xA5\x34\xB5\x2F\xB9\x4D\x8A\xE7\xBA\x5D\xAF\x9F\xB9\x40\xB2\x2D\xBA\xD2\xB2\x56\xBA\x98\xBA\xDD\xBA\x51\xA1\x5A\xBA\x99\xB9\x10\xB5\x4B\xB5\x4D\xB7\x2F\xB5\xB4\x8D\x0F\xB9\xC5\xB2\x11\xB9\x4A\xB9\xEA\xAC\xC7\xAA\x14\xBB\x84\xAF\x1B\xB3\x60\xB9\xEB\xBA\xD9\xB4\x95\xBA\x03\xB9\xDB\xBA\x01\xB6\xF1\xB9\xD4\xB9\x23\xB9\x4D\x90\x13\xB3\x13\x75\x2B\xBB\xA7\xAF\xE9\xBA\x68\xB4\x2F\xBB\x68\xB5\x31\xBB\xDF\xB9\x1A\xBB\xDC\xBA\xC5\xB9\x82\xBA\x33\xBA\xB2\xB3\x28\xB3\x2E\xB1\x49\x9A\x3B\xBB\xCB\xAF\x6E\xB9\x3F\xB6\xEA\xB8\xEC\xB9\x54\xBA\x00\xAF\xE0\xB9\x3C\xB9\x44\xBA\xB7\xB9\x0A\xBA\x68\x84\x7A\xB9\xB9\x8C\xD5\xBA\x66\xBA\xBF\xB9\x68\xBA\xED\xB4\x6A\xBA\x42\xBA\x6C\xBA\x56\xBB\x9A\xBA\x5F\xAD\x8A\xB9\xF3\x53\x4C\xBB\xED\xAF\x80\xB9\xE7\xB5\x1B\xB9\x42\xB6\x92\xB9\xEE\xB8\xAF\xB5\x55\xB9\xA7\xB9\x9B\xBA\xF3\xBA\x58\xA8\x6F\xB7\xC0\x75\x69\xBB\x23\xB0\xAF\xB9\x66\xB5\x3F\xBB\x01\xB9\xED\xBA\x1E\xB9\x71\xBB\x9A\xB8\x65\xBB\x98\xB9\x04\x8B\x75\xB7\x4B\xBB\xFF\xBA\x17\xBB\xA9\xBA\x2E\xBA\x33\xBB\x1E\xBA\x09\xBA\xC1\xBA\xD6\xB9\xC3\xB5\x49\xB1\x87\xBB\x5D\xBB\x7B\xBA\x5F\xBB\xCA\xB5\x41\xBA\xEE\xBA\x6E\xB3\xF0\xBA\xDE\xBA\xF2\xBA\x26\x98\x80\xB7\xF4\x74\x79\xBB\x55\xB0\x7B\xBB\xAA\xB5\xD7\xB8\x01\xBB\xD9\xBA\x53\xB9\xEF\xBA\x72\xBB\xF1\xBA\x74\xBB\x10\x93\x38\x98\x7F\x9A\xA8\x64\xA1\xBB\x6C\xB0\x3D\xBB\xFF\xB8\x7D\xBB\x62\xB9\x8E\xB5\xB1\xB8\x30\xBA\xCF\xBA\x46\xBB\xD1\xBA\xF6\xB5\x5A\xB1\xC2\x76\xB1\xBB\x96\xB0\xB3\xBB\x98\xB0\xB5\xBB\x91\xB9\x7E\xBA\x0E\x9D\xCE\xBA\x35\xBB\xD0\xBA\x47\xBA\x65\x0C\x90\xB7\xD4\x79\x08\xB6\xC8\xAD\x4E\xB2\xC4\x9A\x18\xAB\x95\x86\xC0\xBB\x4A\xA2\xA7\xBA\xBB\xBA\x52\xBB\xAD\xAF\x43\xBB\x34\xBB\x8A\xAC\xF2\xB9\x37\xBB\xC5\xA8\x6C\xB1\xA5\xAB\xF4\xB3\xDF\x80\x11\xBA\x19\x65\x73\xB1\x24\xB6\xFE\xAA\x02\x01\xD5\xBB\xC6\x9D\xD7\xBB\x78\xB5\x18\xBB\xE8\xB3\xDB\xBB\x8D\xBB\x6E\xBA\x58\xBB\xDF\x9F\x35\xBA\xB6\xB7\xF9\xA8\x0F\xB4\xAF\xA6\xFC\xA8\xAF\xB7\x4E\xAB\xEB\xBB\x83\x74\xBA\xBA\xEE\xBB\x8A\xBB\x19\xBB\x8C\xBB\x05\xBB\x8E\xBB\x07\xBB\x21\xBA\xF6\xBB\x7A\xB1\xF2\x9A\xFE\x73\x28\xB4\x80\xB0\xFD\xBB\x88\xBB\x2F\xB4\x11\xAC\xEE\xB9\x7F\xBA\xF0\xB9\xDD\xBB\x36\xBB\xC7\xB9\x14\xAE\x64\xB0\x4A\xBA\x4B\x5B\xC1\xB7\x65\xB6\x0F\xBC\x94\xBB\x6F\xB9\x50\xBB\x53\xBA\xEF\xBB\x7A\xB5\x04\xBC\x95\xB9\x21\xB9\x46\xBA\x97\xB1\xF7\xB2\x27\xA9\x91\xB1\xCB\xB7\x8D\xAB\xBA\x5C\x08\x0A\xDC\x57\xB0\xB1\xC2\x5A\xD4\xB6\x31\xB2\xE1\xBA\x2D\x3F\xCC\xB6\x6C\x3D\x1D\x40\x55\x52\x01\x58\x33\xBC\xDD\xB1\xBD\xB6\xF6\xB1\x57\xA9\x38\xBC\x3D\x97\xDE\x03\x80\x3D\x1D\x40\xDC\xB6\xCE\xB7\x4D\x52\xDD\x00\xA0\xB1\x78\xA4\xDE\x00\xAF\x6D\xF6\x5F\xD0\x54\x10\x85\x98\x0C\x8C\xB6\x63\x70\x8B\x54\xDF\x00\xAF\x6D\xE5\x00\xC2\x95\x59\xBC\x88\x5E\xB0\xB6\xD1\x95\xC7\x40\xD1\xB1\xDC\x00\x86\x96\x33\x88\xB6\xB6\x3A\x96\xF1\x67\x9F\xB6\x01\x01\x4B\xBC\xC0\xB1\xA1\xB1\x00\x00\x4E\xBC\x6C\x5C\x50\xBC\xE3",
"\x56\x52\xBC\xA9\xB6\x65\x62\x56\xBC\x58\xBC\x5A\xBC\x4A\x7F\x98\x0C\x5D\xBC\x9F\x63\x60\xBC\x62\xBC\x24\x5E\x64\xBC\x0C\x64\xD9\xB7\x62\x89\x5D\x7F\x0A\xB1\x00\x00\xD2\xB6\x38\xA6\xDF\xBA\x70\xBA\xF7\xB1\xF5\xB8\x04\xAC\xB6\xA4\xA8\x91\x4B\x8F\x78\xB8\xA9\x53\x01\x01\x85\xBC\x8E\xA6\x87\xBC\x15\xB2\xE5\xB6\x86\xBA\xE7\xB6\xF5\xB6\xBC\xB0\xD2\xBA\x90\xB4\x8D\xBA\x99\xB7\x91\xBC\xCC\xB1\x17\xBC\x47\xBB\xE3\x66\x00\xB7\x11\xA3\xA2\xB7\x3C\xAC\xA5\xB8\x00\x7A\x83\xBC\x92\xBC\xEC\xA6\x1E\xBB\x68\x84\xB7\xB8\x0C\xB7\xB9\xB8\x52\x9E\xBB\xB8\x54\x9E\x25\x67\x1D\x7D\x7B\x7F\xC6\xB6\xA0\xBC\xCA\xBB\x2A\xBC\x05\x5E\xC3\xBA\x46\x0A\x78\x05\xAB\xBC\x8C\xA8\xAD\xBC\x9C\xBA\x61\x8D\x82\xBC\x6E\x53\xC0\xBC\x18\xAA\xF4\xB4\x88\xBC\x42\xBC\xE6\xB6\xE9\xA9\xE3\xBA\xFB\xB4\x6E\x8A\xA3\x05\xBF\xBC\xB9\xBC\xBB\xBB\xCB\xBB\x49\x63\x25\xB9\xF7\xBB\x69\x9C\xF6\xBA\x24\xBB\x33\xB7\x48\xB9\x10\xBB\x36\xB7\x59\xAF\xD1\xBC\xB8\xBC\x73\xBB\x78\xB9\x3C\xB7\x20\xBB\x1B\xBC\xB1\x8D\x7D\xA5\x11\xB1\x0F\xBB\x33\xB5\xD8\x99\xE5\xB2\x74\x59\xD2\xBC\xE3\xBC\x84\xBB\xF5\xBB\xD7\xBC\xE1\xAC\x4C\xB5\x0D\xBB\x9D\xA5\xEB\xBC\x13\xB1\x11\xBB\x54\xB7\x24\xB1\xB7\xBC\x9F\xBC\xF1\xBC\xF3\xB9\x58\xB9\x61\xB5\x0A\xA8\x68\xB1\xFF\xBC\xAB\xBB\xE4\xBC\xA9\xB9\xFF\x00\x72\xB5\xDF\x54\xF0\xBC\x07\xBD\xF2\xBC\x12\x8D\x5A\xBB\x2A\xA3\xC7\xBC\x25\xAB\x4A\xAD\x37\xB1\xAA\xBC\xD3\xBC\xCE\xB8\x18\xBC\xFF\xB0\x78\x7F\x9B\xB9\xAD\x7F\x13\xBD\x95\xAE\xC2\xBC\xBD\x90\x16\x9D\x86\xBB\x75\xB1\xE2\xBC\x0E\xBD\x01\xBD\x09\xBD\x8A\xB3\x1F\xB7\x1F\xBD\xF4\xAE\xAC\xBB\x21\x93\xD2\xB5\x2B\xBD\x18\xBD\x68\xB9\xA2\xBC\xA3\x88\xDF\xB6\x84\xBC\x32\xBD\x29\xBC\xCF\xB0\x8B\xBA\x99\x9F\x7F\xA6\x38\xB7\x06\xBD\x9C\xBB\x2E\xBD\xE0\xBB\xAD\x9F\x6D\xB1\x34\xB0\xF8\xB9\xE5\xBB\x81\x72\x13\xBA\x7E\xA6\xFD\xB9\x3E\xBD\x37\xBD\x00\xBD\xDF\xBB\xE4\xA1\xE1\xBB\x93\x96\x26\x91\xF9\x79\x91\x9D\xE1\xB0\x22\xB6\xE7\xAD\xDA\xA3\xF3\x53\x2C\xBD\xF9\xAF\x41\xBD\x26\xA9\x60\xAB\xAD\xA6\xF9\xBB\xAD\xB7\x39\xB6\x7F\xB1\x4D\xAB\xDD\x6A\x5A\xBD\x38\xBD\xE4\xB9\x09\xB9\x1A\xBC\xD8\xBC\xFA\x9F\x27\xB4\x50\xB6\x15\xA9\x59\xBD\x9D\x0B\x5B\xBD\x38\xB3\x5D\xBD\xFE\xA9\x2C\xBC\xAA\xB7\xBC\x93\x93\xB1\x2A\xA9\x93\xB0\x50\x96\x72\xBD\x68\xBD\xF4\xBB\x75\xBB\x75\xAB\x79\xB6\xF2\x8B\xCD\xB7\xBD\xBB\x07\x8C\x64\x7E\xD8\xB7\xA9\xB8\x30\xA7\xD3\xA3\xAF\x59\x9C\xA4\xE5\x7E\x4C\xBD\x3E\xBC\x16\xBC\xBA\xBC\xB0\x96\xCA\xBC\x74\xB4\xCC\xBC\x30\x84\x05\xAC\xC9\xB0\x79\xB4\x6C\x99\x90\xBD\xAE\xB6\xAD\xBA\x07\xBB\xE0\xBA\x8E\x9E\x8A\xBC\xC7\xB0\x20\xAC\x8A\xBA\x9B\xBC\xDD\x6B\x9D\xBC\xEB\x52\x78\x05\x91\xBD\xC0\xAC\xDE\xBB\x1A\xBD\xA1\xB4\x9E\xBA\xA1\xB8\xA6\xBC\xDA\xB3\x04\xB7\x0F\x52\x9D\xBD\x81\xBA\x19\xBD\xA2\xBC\x91\x84\xA0\xB7\x02\xA5\x01\x97\xB3\xBD\xC6\xAD\xB6\xBA\xF3\x53\xAB\xBD\x9E\xBD\xC0\xBA\x07\xBC\x11\x76\xBD\xBC\x83\xBC\xAC\xBD\x0C\xAD\xAE\xBD\xBA\xBD\x6F\x87\x9C\xBD\x6E\x53\xCA\xBD\x35\xAD\xCC\xBD\xDD\x86\x95\xBC\x85\xBA\xD2\x59\x44\xBC\x29\x8A\xCC\xA0\x36\xB5\xE8\x09\xC3\xBD\xB8\xBD\x33\xBD\xBC\xBB\x41\xB9\x1B\xB1\x00\xAA\x9D\x99\xF7\xBC\xBC\xA7\x26\xBB\x49\xB9\xE3\xB2\x13\xB9\x86\x81\xDD\xBD\xBA\xBB\xB9\xBD\xE0\xBD\x5C\xBA\x2C\xB5\xD6\xA7\x18\x7F\xE5\xBD\xD9\xA7\xFA\xBA\x42\xAA\x12\xBB\xB6\x5F\xEC\xBD\xC9\xBB\xD4\xBC\xBB\xBC\x12\x7F\xF8\xB2\x43\xB9\x2A\x7F\x1E\xB1\xF4\xBD\x20\xB1\xF6\xBD\xFF\xB2\xE2\x9E\x55\xB7\x16\xB1\x02\x01\xD1\xBD\x98\xAD\xD3\xBD\xD5\xBC\x21\x7C\x04\xBD\xC4\xB7\x0A\xBE\xC4\xBD\x06\xBB\x8C\xAC\x83\xB7\xB5\x8A\xA5\xB7\x00\x00\x0B\xBE\x65\xAF\x0D\xBE\xFD\xBD\x9A\x5D\xDB\xA5\xFE\xBC\x19\xBE\x13\xBE\x06\xBC\x15\xBE\x06\x5E\x79\x80\x37\x74\xD0\xBD\x22\xBE\xF3\xBB\x8F\xBB\x1F\xBB\x01\x9D\x1D\xBD\x22\x7F\x12\xBE\xDE\xBD\x39\xBD\xEC\xB0\xD9\xAF\x23\xBD\xAB\xB9\x1F\x5F\xFA\xBD\x92\xBD\xFC\xBD\x3A\xBD\x48\xBB\x28\xA6\x92\xBB\x11\xBE\x01\x01\x1A\xBE\xB1\xAF\x1C\xBE\x3B\xBE\xEA\x6B\x75\x9F\xB0\xB7\x40\xBE\x29\xBE\x57\xBB\x2B\xBE\x78\x88\x0E\xB0\xC2\xBD\x30\xBE\xED\xBD\xDF\xBD\x0E\xBE\xB2\x8C\x7F\xA6\xE1\xBC\x48\xBE\x31\xBE\x69\xBD\x05\xB6\xF5\xB9\x07\xB6\x92\xB7\x7A\xA6\x47\xBD\xE5\xAD\x49\xBD\x67\xB1\x62\x61\x28\xBE\x57\xBE\x80\xBD\x76\xA6\x43\xBD\xE2\xBB\xB1\xBA\x28\x91\xB3\xBC\x0E\x91\xF9\xB3\x0E\x52\x55\xBE\x21",
"\xBE\x64\xBE\x4B\xBE\xF3\xBC\x6B\xBD\x0A\xBC\xE2\x9F\x22\x77\x10\xB4\x7E\xB1\xFC\xBB\x62\xBE\xF3\x53\x41\xBE\x5F\xB0\x93\xBD\x33\xBE\x98\xB1\x74\xBE\x3E\xB7\xE5\x72\x2F\xA2\x63\xAB\x14\xA9\xC9\xA6\xEF\xBC\x4F\xBE\xFB\xBD\xEE\xBD\xD5\xBC\xE1\xBD\xBA\x93\x28\xA9\x4C\xBA\x0D\x8F\x7C\xBD\xC2\x6E\x9D\x0B\x7D\xBE\x76\xB0\x7F\xBE\x3A\xA6\x81\xBE\x77\xBD\xE7\xBC\x22\x8F\x47\xAE\xD7\x93\xD0\x96\x48\x05\x93\xB6\x34\xBC\xC9\xB6\x36\xBC\xA2\xBD\x4F\x3F\x82\x7B\x5C\x0A\x69\x0A\x63\x3F\x55\x52\x1B\x04\xA2\xBE\x3F\xBC\x71\x8B\x1F\x96\xB0\xAE\xA7\xBE\x01\x87\x67\x0A\xAA\xBE\x75\x6A\x55\x52\x00\x07\xAE\xBE\xBC\xB6\xB0\xBE\xBE\xB6\x71\xA9\xB3\xBE\xF8\xB4\xA9\xBE\x11\x0E\xB7\xBE\x09\x52\x64\x01\xBA\xBE\xC8\xB6\x40\xBC\x71\xB8\xE6\x68\xA8\xBE\x6D\x96\x91\x0B\xAB\xBE\x09\x52\x93\x02\xC6\xBE\xD3\xB6\xA4\xBE\x1C\xAC\x0C\x64\xCB\xBE\x23\x21\x80\x0A\xCE\xBE\x0C\x0A\x19\x02\xD1\xBE\xBF\x91\x35\xBC\xD4\xBE\x64\x65\xD6\xBE\x37\x03\x88\x0A\x75\x6A\x48\xBC\xAC\x59\x3D\x74\xE2\x00\x4C\xBC\x8B\x54\xE3\x00\xAF\x6D\x72\x64\xD0\x54\x36\x8B\xA3\x0C\x54\xBC\x45\x42\x8B\x54\xE4\x00\xAF\x6D\xEE\x00\xC2\x95\xF6\xBE\x55\x5E\x79\xBC\x08\x64\xD1\xB1\x13\x46\x5D\x96\xC8\x99\x7E\xBC\x33\x65\x67\xBC\x65\x3F\x01\x96\xBC\xBE\x41\xBC\x96\xBD\x8B\x70\xE2\xB1\x98\x41\xEF\x67\x19\x67\x25\x0A\xEB\xBE\x6C\x5C\x72\x64\x0F\x96\xB0\x04\xC9\xBE\x0B\x69\x09\xBF\x50\x02\x0B\x69\x48\x5C\x7B\x5D\xF1\xBE\x04\x76\xF3\xBE\xF5\xBE\x1D\x96\xC8\xBE\xA5\xBE\xF5\xB0\x44\x6A\x15\xBF\x46\x02\x17\xBF\x02\x01\xF8\xBE\x7A\x5F\xFA\xBE\x60\x65\xFC\xBE\x2E\x96\xD3\xBE\xF2\xB6\x33\x65\x23\xBF\x4F\x66\xC7\x40\xB6\x25\x7B\x5D\x00\xBF\xA8\x66\x80\xBC\x61\xB8\x6C\x99\x6F\xBE\xDC\xBE\x59\xA5\x28\xBC\x6F\xBA\xD5\xBD\xBF\xB6\x97\xBD\x4E\x84\x99\xBD\x06\x9E\x34\xBE\x8F\xBC\x3A\xBF\x77\xBC\x64\xBB\x4E\xBD\x83\xBA\xF1\xB6\xA7\xB2\xF4\xB8\x41\xBF\x76\xB4\x8D\xB4\xF6\xB6\x3B\xBD\x60\xB8\x91\xB4\x7B\xBE\x9D\x0B\x3B\xBF\x36\xA6\x3D\xBF\x65\xBE\x6A\x99\xD1\xB0\xE2\xB7\x44\xA7\xFA\xB9\x4F\xB2\xA3\xBA\x94\xBE\x78\x05\x58\xBF\xEA\xA6\x5A\xBF\x72\xBE\x1E\x92\x0B\xB7\xE3\xBB\xB1\xBC\xBF\xBD\xB5\xBA\x11\xB7\x66\xBD\x57\xBF\x48\xBF\x9B\xBB\x1D\xBB\x9D\xBB\x38\xBB\x17\xB7\x27\xBE\xF3\x53\x65\xBF\x1E\xA7\xC5\xBD\x24\xBE\xDB\x7E\xB3\xA0\xE5\x7E\x47\xBF\x05\xBC\x2A\xBE\xA0\xBD\x95\xBD\xF6\xB4\xD7\xBD\xF8\xB4\xCE\xBC\x27\xA6\xFC\xB4\xBE\x3D\x64\xBF\x72\xBF\xAA\xBB\x40\xBD\x08\xBD\x81\xBD\x00\xB1\xE7\xBC\x36\xAF\x1F\xAA\xE1\xB2\x27\xBB\xE9\xBD\x6E\x8A\xDD\x04\x8D\xBF\x82\xBF\x4A\xBE\xC6\xBD\x6A\xBD\x0E\xB1\x0B\xB9\x10\xB1\x41\xB7\x15\xB5\x4F\xB5\xE7\xA0\xEE\xBC\xDB\xB7\x9C\xBF\x27\xBC\x9F\xBD\x7D\xBF\xA8\xB7\x3D\xB7\x23\xBA\x33\x68\x22\xBB\x29\xB9\x13\x04\x31\xB5\x86\x63\xE8\xAC\x4B\xB9\xE3\x56\xAA\xBF\x17\x9B\x96\xB9\xA1\xBC\xBC\xBB\x0F\xBE\x5A\xB9\x69\x96\x6E\x53\x7A\xBF\x88\xA9\x7C\xBF\xC2\xAC\x16\xBE\x2D\xB1\x1D\x7E\x4C\xBD\xC3\xBF\x5A\xAB\xAC\xBF\xC6\xBF\xC4\xB3\x43\x7F\x83\xB5\x37\xBE\x02\x01\xCB\xBF\xFC\xAB\xC5\xBF\xE2\xB6\x25\xBE\x2D\x73\x84\x59\xBA\xBF\x10\x9D\x67\xBF\x9F\xBF\x5B\xBA\xC8\xB7\xA3\xB7\x77\xBB\xDD\x50\xCA\xBF\x8E\xBF\x82\xBB\x4A\xBF\x34\xBD\xC8\x85\xB1\x7C\x71\xBD\xDB\xBF\x61\x9E\xDD\xBF\xAD\xBF\x2C\xB1\x91\xBB\x7B\xB7\xB9\xBF\xD3\xBF\xE5\xBF\x99\xBA\xE7\xBF\xBE\xBF\x22\x93\x6A\x8E\x78\xBF\x71\xBF\x9D\xBF\x83\xBB\x28\xBD\x22\xBD\x4D\xBE\x58\x25\xEC\xBF\x6E\x9F\xEE\xBF\xCE\xBF\x7E\xBF\x8C\x8E\xFD\xB9\xDC\xBD\xF4\xBF\xFD\xBF\xF7\xBF\xD5\xBC\xCD\xBB\xEF\x93\x45\xBD\xDC\xB3\x64\xB1\x56\xBD\xEB\xA1\x7F\xA6\x0A\xC0\x01\x01\xD4\xBF\x49\xAF\xD6\xBF\xEF\xB6\x8F\xB7\x5A\xBE\x91\xB7\xF3\xB3\x69\xBE\x20\xB6\x6B\xBE\x79\x93\x58\xBD\xA4\x58\x03\xC0\x4F\xA1\x05\xC0\xD7\xBF\x08\xBC\x49\xBA\x6C\xBD\xBE\x72\x61\xBD\x68\xB0\x12\xB4\x65\xBD\x84\x58\x27\xC0\x3C\xBF\xCD\xBF\x2A\xC0\xAE\xBF\x09\xBC\x83\xBE\x56\xBF\x13\xA9\x8A\xB1\x70\xBD\x26\xC0\x0B\xC0\xAB\xBF\x1B\xC0\xFC\xB6\x08\xBB\x4A\xB7\x0A\x8F\x62\xB6\xC5\x98\x3E\xB4\x93\xBE\x53\x81\x34\xC0\x59\xBF\x36\xC0\x1C\xC0\x2B\xC0\x82\xBE\xB0\xBF\x20\x9B\x2E\xBC\xF4\xA6\x30\xBC\x2A\x01\x64\x26\x5B\xBC\xE5\xBE\x11\x59\x3D\x74\xE9\x00\xE9\xBE\x25\x0A\xE6\x00\xAF\x6D\xB0\x5D\xD0\x54\xF4\x7C\xAE\x0C\x1A\xBF\xEE\x48\x8B\x54\xE7\x00\xAF\x6D\xEF\x00\xC2\x95\x6B\xC0\xEF\x5D\x29\xBF\x63",
"\x67\xD1\xB1\xE8\x00\x86\x96\x57\x8F\x35\xBF\x3A\x67\x02\xBF\x5D\xC0\xA1\x59\xDE\xBE\x2E\xBF\x60\x65\xC1\xB6\xCF\x0C\xBA\x67\x0C\xBF\x02\x01\x60\xC0\x6C\x5C\xB0\x5D\x11\xBF\x37\x43\x45\xA5\x86\xBF\x45\x42\x7D\xC0\x16\x06\xBA\x67\xFF\x04\x64\xC0\x72\xBC\x9B\x63\x68\xC0\x6A\xC0\x1E\xBF\x05\xBF\x13\xBF\xED\x67\x8A\xC0\x1E\x03\x8C\xC0\x02\x01\x6D\xC0\xBB\x5E\x6F\xC0\x8C\x67\x71\xC0\x2C\xBF\x1F\xBF\xDF\xBE\x7C\xC0\xD8\xBD\xDB\x41\x09\x69\xA3\x05\x74\xC0\xE9\xAB\x39\x96\x63\x62\x37\xBF\xA3\x7F\x17\xC0\x00\x00\x59\xC0\x9A\xBB\x8F\xBF\x74\xBF\xC9\xBC\x3F\xBF\xBE\xBE\x97\xBC\xE9\xA9\x73\xBA\x76\xB8\x75\xBA\x0F\xA7\xE5\x7E\xAE\xC0\xB0\xC0\x07\xBA\x73\xBF\x5B\xA5\x94\xBC\xA6\xB2\xB1\xA4\x88\xB8\x87\xBF\x26\xB7\x88\xBA\x8C\xB8\xD1\xA1\xA8\xBD\x8F\xB8\x47\x66\x78\x05\xBF\xC0\x43\xBA\xC1\xC0\xED\xA5\x21\xBD\x98\x9F\x71\xA0\xF1\x9B\xA5\xBC\x0F\xB7\x4B\x5B\x62\xBF\x4B\xC0\x02\x01\xD0\xC0\x63\xBB\xD2\xC0\x86\xBC\x75\xBF\xFD\x96\xDD\xB0\x0F\xBA\xB2\xBA\xE0\xB0\x21\xB6\xD3\x5D\x6F\xBF\x89\xBE\x01\x01\xDE\xC0\xAF\xAF\x6D\xBA\x9E\xBF\xEF\xBF\x42\x7F\xBD\xBC\x6F\xBE\xED\xC0\x5D\xB0\xEF\xC0\xFE\xBF\x4F\xBD\xB1\xA8\xD3\xBA\xBD\xC0\x6E\x53\xF5\xC0\x74\xB0\xF7\xC0\x0D\xC0\xB5\xB0\xC4\xC0\x87\xC0\x24\xB7\xC7\xC0\x8A\xB8\x89\xBF\x34\xBE\x8B\xBF\xC5\x04\xCF\xC0\x4A\x7F\xC8\xBB\x39\xBE\x8C\xBE\x1D\xBE\x8E\xBE\x0A\xBB\x30\xB7\x01\xAA\x13\xB5\xF8\xBC\xDD\xBC\xEC\xBC\x12\xB9\x6E\x8A\x0B\xC1\xDD\xC0\x0D\xC1\x15\xBC\xAD\xBD\xBD\xBF\x8D\xBE\xF0\xBD\x13\xC1\xA6\x9E\x0C\xBB\x16\xC1\xE6\xBD\x2C\xB9\xE2\xB2\x57\xAF\xE4\xB2\x1B\xC1\xFD\xC0\x1E\xC1\xB9\xBB\x8B\xBE\x51\xBE\x11\xC1\x23\xC1\x1A\x71\x1C\xB1\x01\xBE\x45\xB9\x27\xC1\xF5\xBD\x2A\xC1\x2E\xB9\xFC\xBC\x44\xAA\x84\xBE\x0C\xC1\x54\xB9\xE6\xBF\x27\xBD\xF9\xC0\xBF\xA9\xAD\x63\x10\xBE\xEB\xC0\xAF\xC0\x2F\xC1\x57\xBA\x45\xBB\x10\xC1\x44\xBE\x17\xBE\x0D\x52\xF4\xC0\x4A\xC1\x1B\xBB\x4C\xC1\x32\xC1\x44\xBE\xD0\xBF\x10\x9A\xE3\xBF\x2E\xC1\x41\xC1\xF6\xBF\x43\xC1\x9A\x85\xF0\xA5\xF9\xBD\x1D\xC1\x5B\xC1\x1C\xBB\xC2\xC0\xE2\xC0\x5E\xBD\x76\xBB\xA2\xAA\x63\xB3\x63\xBF\x61\xC1\xA9\xBB\x42\xC1\x90\xBF\x0F\xBD\xAD\xBB\x74\xB7\x36\xBE\x6A\xC1\xEC\xC0\x52\xC1\x44\xBB\x71\xBE\xDE\xBF\x47\xB1\xBA\xB9\x3E\xBE\x48\xC1\xFE\xC0\x9E\xB0\x00\xC1\x5D\xC1\xCD\xBD\xD2\xB5\x51\xC1\x62\xC1\x54\xC1\x32\xBE\x99\xBE\xBB\xC0\xC1\xA1\xB4\xB3\x7C\xC1\x75\xC1\xDC\xBB\x20\xC1\x98\xBE\xFE\xB0\xCA\xB0\x64\x94\x20\xB0\x78\x5C\xF3\x53\x7D\xC1\x44\xB2\x7F\xC1\x6E\xC1\xFF\xBF\x66\xBE\xC4\x9F\xF2\xB3\xF7\xB9\x12\xC0\xF9\xB9\xB4\xBA\xD2\xBB\xE0\xB3\x07\x81\x5A\xC1\x6C\xC1\x5C\xC1\x99\xC1\x44\xC1\xAB\x63\x0F\xC0\x92\xA9\x20\xC0\xBC\xBD\xE4\xBB\x71\xB1\xBF\x7E\xE7\xBB\x9B\xA6\x0C\x84\x95\xC1\x8C\xC1\xF2\xBB\xF0\xC0\x06\xC0\x38\xC0\x2C\xC0\x75\xBE\x93\x98\x7C\xB1\x1A\xA2\x63\xBD\x7A\xBE\xE7\x81\xB5\xC1\x84\xC1\x77\xC1\xF1\xC0\x2C\xBE\x51\xC0\x32\x61\x0B\xBC\x9E\x7F\x89\xB1\xFD\x9F\x0E\xBC\x94\xC1\x9D\x0B\x96\xC1\xD4\xB2\xE0\xC0\x93\xBC\x65\xC1\x76\xBD\x5F\xBD\xC0\xB7\x91\xBE\x31\xAE\xCF\xC1\x40\xC1\xA6\xC1\x63\xC1\xD3\xC0\xD5\xC1\x14\xA1\x8F\xB0\x5E\xBA\x8B\xAB\xA9\xB0\x6E\x7A\xD8\x73\x74\x4E\x83\xB6\xEB\xA3\xAA\x18\x6C\x5C\x7F\x5E\xD0\x54\xC0\x7B\xBB\x0C\x66\xC0\xC5\x0C\x8B\x54\xED\x00\xAF\x6D\xFA\x00\xC2\x95\xF6\xC1\x82\x5E\x9D\xC0\x76\x66\xD1\xB1\xEA\x00\x86\x96\xA4\x84\x75\xC0\x8C\x67\x02\xBF\xE8\xC1\xBB\xBE\xCA\xA6\xB1\xBE\xC5\xB0\x07\x69\xE1\xBE\x65\x03\x3A\x4B\x80\xC0\x01\x01\xEB\xC1\x70\x55\x7F\x5E\x85\xC0\x06\xC2\x71\xBA\x08\xC2\xB4\xBE\x29\x70\x3A\x4B\xFF\x04\xEF\xC1\x8F\xC0\x5C\x65\xF3\xC1\xF5\xC1\x93\xC0\x05\xC2\xBD\xBE\xE7\xA9\xB9\x41\x09\xC2\x31\xBF\x3C\x4B\xFF\x04\xF8\xC1\x27\x5F\xFA\xC1\x41\x51\xFC\xC1\xA0\xC0\x94\xC0\x20\xBF\x9B\x63\x23\xC2\x20\x01\x3A\x4B\xA3\x05\xFF\xC1\xA9\xC0\x72\x96\x63\x67\x5A\xC0\xFC\x8C\x30\x26\x27\xBF\x38\xC2\xB9\x5C\x55\x52\x51\x0C\x00\x00\x9B\xC0\x3C\xC2\x0F\x83\x31\x0A\xF3\x00\x5E\xC0\x02\x01\xF0\x00\x64\x6E\x5C\x5C\x56\x55\x1B\x5E\x39\x74\x30\x4B\x8B\x54\xC8\x3D\x54\x54\xC1\x5F\x66\x6E\x1B\x5E\x93\x83\x53\x3B\xFD\x42\x98\x6A\xD1\xB1\xF2\x00\x86\x96\x2F\x87\x00\xC2\x76\x66\x02\xBF\x45\xC2\x79\xC0\x2D\xBF\x4D\xBF\x37\xBC\xC5\x42\x82\x7B\xDD\x16\x2D\x2B\x3D\x42\x14\x02\x23\x42\xAD\x09\xC5\x42\x0C\xC2\x00\x00\x48",
"\xC2\x6C\x5C\xC1\x5F\x11\xC2\x20\xC2\xB2\xBE\x69\x74\x66\xC2\x86\x92\xBF\x42\x6A\xC2\x6E\x01\x76\x66\xFF\x04\x4E\x71\x76\x66\x4D\xC2\xDA\x42\x4F\xC2\x49\xC2\xDF\x54\x7A\xC0\x63\xC2\xA6\xBE\x76\xC2\x01\x87\x67\xC2\x21\x42\x7A\xC2\xE1\x01\x7C\xC2\x00\x64\x76\x66\x55\xC2\x7A\x47\x14\x8C\x81\xC2\xE5\xAB\x01\x01\x5A\xC2\x34\x5A\x85\xC2\xC5\xC0\x4E\xBF\x88\xC2\xF8\xB4\x8A\xC2\x79\xC2\x91\x01\x6B\xC2\xD7\x09\xAC\x42\xA3\x05\x5C\xC2\x35\xC2\xCD\xAB\x36\x67\xAC\xC0\x5D\x7F\x9B\xBF\x26\xBF\x4A\x7F\xF1\xBB\x0C\xC0\x80\xC1\xD4\xBD\x03\xC1\x1B\xAF\x9B\xC2\x06\xC1\x87\xBA\x77\xB4\x8D\xBC\xB8\xA4\xAA\xC2\x6E\x53\x3B\xC2\x14\xBC\x30\xC1\x0F\xC1\x55\xC1\x49\x84\xB5\xC0\x21\xC2\xB7\xC0\xB2\xAE\xC8\xB0\x44\xBF\xFE\xB6\x54\xBF\xA9\xBD\x8C\xBF\xAC\xC2\xB8\xBB\x4B\xC1\xC5\xC1\xB9\xC1\xB6\xB8\x9F\xB8\x5E\xBF\xE9\xA4\xA1\xC1\x1F\xC0\xDB\xC0\xDB\xC1\xCC\xC2\x85\xB9\xBE\xC2\x8E\xC1\x3A\xBE\x80\xBE\xF7\xB6\xE4\xC0\x8F\x9D\xE6\xC0\xBA\xB8\xDC\x91\x1F\x7B\xBD\xB8\xDF\x5E\x78\x05\xBC\xC2\xC7\xBB\x1F\xC1\xCB\xBD\x21\xC1\x1D\xBE\xF1\x81\xC1\xA9\x0A\x60\xE8\xC2\xAD\xC2\x26\xBC\xBB\xBF\x29\xC0\x4F\xC0\xAF\xBA\xC4\xBC\x6C\x99\xAB\xC2\x01\x01\xE9\xC2\x5F\x9E\x0E\xC1\xDC\xC2\x4D\xC1\xC1\xC2\xB2\xC2\xB7\xB0\xC4\xC2\x1E\xAF\xD9\xBD\x92\xAC\x59\xAF\x48\x05\xF2\xC2\xCD\xC2\x53\xC1\xCF\xC2\x37\xC0\xA0\xBF\xF4\xBA\xA2\xBF\x12\xB5\xDF\xB2\xDC\xBC\x97\xBF\xE8\xBD\x2B\xC1\xEA\xBD\x31\x4B\x0B\xC3\xDA\xC2\xCE\xC2\x50\xBE\x86\xC1\x90\xC1\xBF\xB2\x3A\xAA\x12\xC3\x26\xC1\x14\xC3\x47\xB9\x16\xC3\xDE\xBC\x53\xB7\xA8\xBF\x1A\xC3\xD9\xC2\xEF\xB9\xDB\xC2\xEC\xC2\x8F\xC1\x27\xB1\x48\xBA\xFF\xBD\x21\xBB\x44\xB9\xFB\xB2\x03\xBE\xFD\xB2\x21\xB1\x4B\x8A\x00\xB3\xCE\xC0\x2C\xC3\xBD\xC2\x1D\xC3\x31\xC1\x1F\xC3\x31\xC3\x5A\xB7\x29\xB1\xF1\xC2\x3D\xC3\xEA\xC2\x2E\xC3\xD2\xBD\xED\xC2\x4E\xC1\xC8\xBF\xE7\xC2\x46\xC3\xFE\xC2\xEB\xC2\x49\xC3\x30\xC3\x89\xA7\x73\x67\x11\xBD\x47\x5A\x1B\xC3\x2D\xC3\x3F\xC3\xBF\xC2\x41\xC3\x36\xB1\x50\xB3\xD8\xC2\xFC\xC2\xF3\xC2\x04\xBB\x41\xC0\x14\xBE\xD0\xC2\xDF\xBF\x09\xBB\xE1\xBF\x68\xC1\x4F\xAD\x3C\x61\x57\xC3\x3E\xC3\x0D\xC3\x1E\xC3\x58\xBE\x79\xC1\x35\xBE\x76\xB3\x0D\x61\x6B\xC3\x47\xC3\x59\xC3\x00\xC3\xC0\xC2\x87\xC1\x27\xB3\x3D\xBE\xF2\xBF\xEB\xBD\x4E\xC3\x6C\x9F\xFF\xC2\x2F\xC3\xDD\xC2\x79\xC3\x9E\xB3\xD4\x5A\xA0\xB3\x73\xC3\x7E\xC3\x4D\xA1\x80\xC3\x51\xC3\x82\xC3\x20\xC3\x34\xBE\x01\xC0\xAE\xC0\xFD\xC2\x7F\xC3\x50\xC3\x0C\xBE\x4A\xC3\xDE\xC2\x53\xBF\xFC\xAA\xCC\xAD\x90\x96\xF3\x53\x91\xC3\x89\xC3\x93\xC3\x1B\xBE\x95\xC3\x83\xC3\xF0\xB3\x6B\x9B\xC5\x9F\x11\xC0\x93\xB7\x13\xC0\xE8\xC0\x66\xB1\x7F\xA6\x1C\xC1\x5F\xC3\x0C\xC3\x76\xC1\x6E\xC3\x5B\xBF\x42\xBD\x9C\xC1\x78\xA6\x6E\xB1\xE5\xC0\x6A\xBE\xE4\xC2\x2A\x91\x23\xB6\xB3\xC1\xF1\xA3\x9B\xC3\x60\xC3\xAB\xBA\x62\xC3\x23\xBE\x64\xC3\xC7\xC1\x9B\xBE\x2D\xC0\xAB\xA3\x77\xBE\xFA\xBB\xAE\xB7\xFE\xA8\x9A\xC3\x9D\x0B\x9C\xC3\x57\xA5\x8A\xC3\x94\xC3\x52\xC3\x3A\xB1\x32\xC3\xC3\xC3\xBC\xC1\x38\xBA\x64\xAB\x0E\x52\xAB\xC3\x00\x00\xCC\xC3\x34\xA6\xCE\xC3\x9F\xC3\xD0\xC3\x40\xB1\xD2\xC3\xD7\xC1\x78\xBD\x43\x89\x7A\xBD\x92\xB0\x46\x89\xDD\x50\xD8\xC3\xDA\xC3\x65\xA8\x9E\xC3\x42\xBE\xA0\xC3\x8D\xC3\x9A\xBE\xE1\xC3\x9C\xBE\x46\xAE\x8C\xAB\x55\xC0\x8E\xBD\x0F\x52\xD8\xC3\x41\xC2\x25\xBC\x61\xC3\xF5\xC2\x4E\xC0\x43\xC0\xA1\xBD\x21\xBF\x4F\xBF\x59\xA9\x8C\xBC\x52\xBF\x3C\xBE\x8F\xBC\xF7\xC3\x4A\x7F\xA8\xBB\xB1\xC0\x6D\xC1\xB3\xC0\x72\xB4\x85\xBF\x05\xC1\x0B\x2F\x8C\xB4\x4F\x84\xA5\xBD\xBA\xC0\x97\xC3\x9A\x5D\x55\xBF\x36\x8C\x78\x05\xF8\xC3\xD0\xB9\xF4\xC2\xDC\xBF\xFC\xC3\x14\xB7\xCF\xBF\x1D\x87\xA0\xB8\xA3\xB4\xA2\xB8\x12\xBA\xA6\xB4\xA8\xBC\xF6\xC3\x6E\x53\x19\xC4\x55\xBA\x1B\xC4\xED\xBF\x1D\xC4\x1A\xB7\x1F\xC4\x3A\x87\x6B\xBF\x53\xAC\x60\xBF\xA4\x73\xC1\xBD\xCB\xC2\x01\x01\x29\xC4\x53\xBB\xAE\xC2\xBF\xC3\x83\xBF\xC6\xC1\x02\xBD\x02\x8C\x7C\x76\xFB\xC2\x40\xC2\x07\xC4\x6B\xBA\xEE\xC0\x49\xBF\xB0\xC2\x52\xBE\x7F\xBF\x27\xC4\xF3\x53\x38\xC4\xDA\xBB\x2B\xC4\x04\xC0\x2D\xC4\x22\xB7\x0D\xC4\xC6\xC0\x0F\xC4\xD8\xBD\x7B\x8D\xE4\xBA\xF2\x55\x18\xC4\x43\xC4\x62\xBB\x45\xC4\xD3\xC1\xAC\xBC\xE0\xC1\x43\xAE\xA1\xBF\x94\xBF\x0C\xB9\x96\xBF\x10\xB9\x17\xC3\x3C\xC1\x19\xC3\x3F\x66\x9A\xC0\x5A\xC4\x99\xBB\xC0\xC0\xB2\xC0\x64\xC1\x75",
"\xBD\xE1\xC1\xDB\xB2\x62\xC4\xA3\xBF\x37\xC3\x4E\xB5\x19\x65\xCB\xAC\x6E\x8A\x69\xC4\x37\xC4\x6B\xC4\x80\xBB\xC4\xC1\xAF\xC3\x68\xBF\x24\xB9\x33\xC3\xE7\xBC\xF6\xBC\x39\xC1\x04\xBE\x3B\xC1\xFB\xBA\xB8\xBF\xA9\xBF\x6A\xC4\x8B\xBB\xFA\xC3\x1C\xC4\x42\xC0\x1E\xC4\x60\xB5\x46\xC1\xC0\xBF\xF8\x80\x28\xC4\x7C\xC4\x93\xB9\x81\xBB\xA7\xC1\x0B\xC4\x6F\xC1\x4C\xA6\x0A\xBD\x6B\xB9\xC2\xC1\x9D\x0B\x4C\xC4\x72\xB0\x3A\xC4\xFB\xC3\x8F\xC4\x2E\xC4\x7E\xBF\x55\xC3\xAE\xC0\xA1\xC4\xAA\xB3\xA3\xC4\x8E\xC4\x63\xC3\xD7\xBF\x37\xB1\x06\xC4\x8C\xC4\xBE\xC3\xA4\xC4\xAE\xC4\xF7\xC2\x10\xC3\x67\xC1\x4E\xAD\x36\x9A\xDE\x80\x59\xC4\xB2\xC4\xBE\xBA\x3B\xC4\xB8\xC1\x0F\xC3\x90\xBB\x71\xC1\x72\xC3\xB4\xC1\xA0\xC4\x96\xC4\x70\xBB\x7E\xC4\x40\xC3\x6F\xC3\x17\x8B\xA1\xA1\xC5\xC4\xBC\xC4\x03\xBC\x8D\xC4\x2C\xC4\xA5\xC4\x12\xAE\x7F\xB7\x9F\xB3\xFA\xBF\x1D\x81\x95\xC4\xBD\xC4\x83\xB8\xAF\xC2\xA8\xC1\xAF\xBD\xE9\xAA\x8A\xC1\x8A\xC4\x7B\xC4\xDA\xC4\x94\xB9\xB4\xC4\xC0\xC3\xC1\xC4\xEF\x9B\x08\xC0\x99\xC3\x02\x01\x0A\xC3\x8B\xC4\xD0\xC4\xB3\xC4\xAD\xC4\xE6\xC4\xB6\xC4\x59\xBE\x0C\xBA\x77\x98\x9E\xC1\xA6\xC3\xA0\xC1\xA1\xBA\x17\xAB\xA3\xC1\x0D\x52\xEC\xC4\xE2\xC4\xEE\xC4\xBE\xC4\xE5\xC4\x3C\xC4\xC1\xC3\x4E\x86\xF4\xC4\x71\x9D\xEE\x88\x21\xC0\x55\xBD\xA8\xC3\x61\xB3\x25\xC0\xEB\xC4\xD9\xC4\xFF\xC4\xDB\xC4\xBF\xC4\xF8\xC0\xDE\xC4\xA3\xB5\x61\xB6\x36\xB6\xE3\x9F\x74\x86\x26\xBA\x69\xB0\x0E\x52\xFD\xC4\x42\xC4\xE3\xC4\x98\xC4\xDE\xC1\xE1\xC0\x70\xC4\x60\xC4\xF0\xC3\xC4\xC3\x3B\xC0\x4F\xB6\xB9\xB7\x1B\xC5\x0E\xC5\xF0\xBB\x4E\xC4\x28\xC0\x50\xC4\x48\xB7\xBA\xC1\xC8\xC1\xEF\x65\xE3\xC3\xDD\xA6\x4E\xBA\xFC\xC4\x2A\xC5\xF9\xC3\xEF\xC4\xD2\xC4\xB5\xC4\x43\xC0\x50\xC0\xD3\xC3\x3A\xC0\xF2\xC3\xE5\xC1\xB6\x7F\xD8\x73\xFF\x3C\x29\x52\xAB\x73\x01\x01\x3C\x17\x6C\x5C\x43\x61\xD0\x54\xBD\x7B\xCC\xBB\xA6\xC2\xBB\xB1\xD6\x77\x8B\x54\xF7\x00\xAF\x6D\x4A\xC5\xE3\x56\x4C\xC5\x1A\xC2\x50\xC5\x25\x0A\xF6\x00\xAF\x6D\xFB\x00\xC2\x95\x5C\xC5\x5D\x62\xD0\x83\xC6\x36\x83\x43\x83\x83\x13\x70\x8B\x54\xF5\x00\xAF\x6D\xF9\x00\xC2\x95\x68\xC5\x5F\xC5\x9B\x59\x81\x83\x4D\x43\xA1\x42\x98\x6A\x96\x96\x55\x52\xAA\x03\x6A\xC5\x05\x8C\x55\x52\xD0\x05\x27\xC2\x42\xC2\x79\xC5\xFD\x57\xFE\xB1\x01\x01\x5E\xC5\x36\x73\x43\xC5\x8E\xA4\xB1\x06\x46\x5A\x4E\xC2\x46\xC5\x3B\x17\x53\xC5\x6E\xA2\x95\x5E\x91\x06\xD1\x5D\x30\x4B\xFF\x04\x56\xC5\x00\xC2\x53\x51\x51\xC5\x87\xC5\xF0\xA3\x75\x53\x8A\xC5\x78\x62\x8C\xC5\x61\x85\xBD\x95\x13\x52\x90\xC5\x59\xC5\x5B\xC5\x57\xA4\x27\x53\x95\xC5\x16\x67\x97\xC5\x7D\xC5\x6C\x6B\x6F\x42\x60\xC5\x65\x3E\x5F\x3E\xEF\x05\x58\xC2\x25\x0A\x66\xC5\x6C\x5C\x74\xC5\x7C\xA4\x82\xC5\x8B\xC5\xDA\x42\xFF\x04\x74\xC5\xAD\x65\x80\x83\x97\x3C\xA8\xC5\x49\x02\x70\xC5\x02\xBF\xFC\x00\x46\xC2\x01\x01\xFE\x00\xAF\x6D\x9A\x66\xD0\x54\xC7\x78\x53\x51\x39\x74\xFE\xB8\xE5\x06\x25\x0A\xFD\x00\xAF\x6D\x0A\x52\xD0\x54\x0A\x52\x11\x70\x9D\xC0\x53\x51\x94\x96\x99\x96\x08\x0A\xD9\xB1\x61\xB4\x18\x9F\x9D\x0B\xB4\xC5\x6A\x7C\xDF\xAF\x2E\x98\x5B\xC4\xF6\xC0\x46\xC4\xDD\xC4\x6F\xB8\xC3\xB0\x95\xC0\x72\xBA\xB7\xC2\x03\xC4\xEA\xB6\x5D\x7F\x15\x76\xD8\xC5\x63\x85\xDA\xC5\x8E\x99\xDC\xC5\xFF\xC0\xDE\xC5\x9A\xC4\x88\xB4\xFE\xC3\xF3\xB6\xF8\xB4\xC9\xC0\x8E\xB4\xC9\xAE\xB6\xAE\xCD\xC0\x3D\xB3\x02\x01\xE9\xC5\xE9\x8C\xEB\xC5\xCD\x9A\xED\xC5\x7E\xC1\xEF\xC5\x6F\xC4\x91\xBF\xD5\xC0\x8E\xA9\xB2\xBD\xD9\xC0\x01\x8C\xD8\xB0\x7B\xB9\x01\x01\xFC\xC5\xD0\x89\xFE\xC5\x5C\x9C\x00\xC6\x97\xC1\x02\xC6\xDF\xC1\x22\xC5\x8D\xB8\xAF\xBC\x31\xC4\xE4\xAE\x08\xC6\xF2\x74\x6B\xB2\x09\x57\x78\x05\x0D\xC6\xED\x89\x0F\xC6\x31\x9F\x44\xC4\xDD\xC5\x5D\xC4\xC1\xBC\x5F\xC4\xA7\x97\x77\xBF\xE2\x54\x1E\xC6\xA4\xC5\xA4\x61\x21\xC6\xEF\xA0\x23\xC6\xEE\xC5\x25\xC6\xC8\xBC\x04\xC6\x5C\xBF\x8B\xA7\xE7\xC5\x6E\x53\x1F\xC6\xAF\x8B\x2E\xC6\xDD\xA4\x11\xC6\xD2\xC1\x6E\xC4\x14\xC6\x0C\xC4\xC2\xC2\x75\xC2\xB5\xC2\x73\xA9\x08\xC1\x5C\xA9\x8B\xBF\x64\x89\x39\xC6\x62\x86\x3B\xC6\x3B\xA5\x3D\xC6\xAC\xB3\x32\xC6\x14\xBD\x34\xC6\xF6\xA8\xE6\xBC\xC4\xC3\x95\xBF\xEA\xBC\x18\xC1\xFA\xBC\xDF\xBC\x36\xB5\x49\xC6\x2C\xC6\x2B\x65\x4C\xC6\xFF\xA6\x4E\xC6\x05\xB4\x13\xC6\x21\xC5\x52\xC6\x66\xC1\x72\xC4\x55\xC6\x51\xAF\x64\xC4\xE7\xBD\x28\xC3\xC7\xB2\x2A\xC3\x5C\xC6\xC8",
"\x75\x5F\xC6\xBC\xAA\x6C\xC4\xD1\xC0\x3F\xC6\x64\xC6\x9B\xC4\x53\xC6\xF4\xBC\x83\xBE\x84\xC4\x25\xC3\x0E\xBB\x58\xC6\x43\xB7\xFB\xBC\x89\xC4\xBB\x3D\x2B\xC6\x70\xC6\xB5\xB2\x6F\xBB\x74\xB9\x76\xC3\x81\xC3\x01\xC3\xA1\xC3\xBF\xBF\x59\xAA\x95\x5E\x83\xC6\x91\x77\x71\xC6\x0C\xB2\x7D\xC4\xDD\xC1\x85\xC1\xCB\xC4\x09\xBD\x0B\xBD\x82\xC6\xFB\xC5\x5D\xC6\x90\x64\x91\xC6\xCB\xB5\x93\xC6\x09\xC4\x99\xC4\x03\xC6\x77\xC6\x33\xA8\x82\xB5\x58\xC1\x41\x6E\x38\xC6\x9B\xC6\xFA\x64\x9D\xC6\x98\xBB\x9F\xC6\x6D\xC4\x0A\xC4\xA2\xC6\x94\xB5\x5D\xC3\x5B\xBB\x9A\xC6\x84\xC6\xAF\xB8\xB7\xBB\x1C\xC3\x6D\xC3\xCA\xC4\xB0\xC3\x66\xC6\xA4\xB5\x2E\xBE\x8E\xC6\xB4\xC6\x90\xC6\x85\xC6\xC6\xBB\x4F\xC3\x48\xC3\xCF\xC3\x8C\xC3\x42\xC3\x06\x5E\xB4\xAA\x7A\xC4\x00\x00\x4A\xC6\xED\x6F\xAB\xC6\x61\xBB\x73\xC6\xDF\xC0\x75\xC6\xD4\xC1\x15\xC6\xE8\xAF\xCD\xC4\x1D\xC6\xC0\xC6\xA6\x7A\xCF\xC6\x02\xBB\x08\xC4\xAE\xC6\xA1\xC6\x40\xC6\xA3\xC6\x1C\x87\xD2\xB5\xCB\xC6\xCD\xC6\xEE\x6A\xDB\xC6\xA7\xBB\x30\xC6\x01\xC6\x50\xC6\x20\xBD\x27\xC6\x4B\x9D\x85\xB7\x5E\x61\x8F\xC6\xDA\xC6\xC2\xC6\xB7\xC6\x58\xC3\xB9\xC6\x5A\xC3\x96\xC6\x69\xBF\xE6\xB9\xEA\xC4\xC4\xBA\xE5\xC6\x66\x72\xE7\xC6\x39\xB9\xDD\xC6\x74\xC6\xAF\xC6\xE0\xC6\x9A\xC1\x6F\x9D\x05\xC5\xFD\xA1\xF6\xC4\x5D\xBE\xB0\xC1\xE6\x80\x30\xAB\x61\xBE\x0F\xB0\xFD\xC6\xE7\x71\xFF\xC6\x41\xBB\x2C\xB6\x54\xBB\xDC\xC3\xEC\xC3\xDE\xC3\xC3\xAD\x99\x72\x1E\xC0\xCE\xBB\xB4\xC3\xE1\xC2\xB6\xC3\x02\xA2\xB8\xC3\x0C\xC5\xFC\xC6\xA9\xC6\x5A\x65\x12\xC7\xDE\xB9\x14\xC7\xAC\xC4\x3A\xC5\xF1\xC4\x3C\xC5\x30\xC5\x3E\xC5\x52\xC0\x90\x7F\x2F\xC0\x19\xC5\x31\xC0\x13\x75\x10\xC7\xC3\x6F\x26\xC7\x7F\xBB\x97\xC4\xC9\xC4\xF7\xC6\xBB\xC6\xD6\xC1\xE2\xC1\x91\xB1\xD5\xC3\x87\xBE\x34\xC7\x24\xC7\xEC\x5E\x37\xC7\x86\xC6\xAD\xC3\x8D\xC1\x89\xC6\x78\xC3\xEE\xC3\x2B\xBC\x24\xC5\xBC\xC1\x1D\xBC\xC3\xB7\x0F\xC7\x43\xC7\xBA\xA8\xA8\xB3\x38\xC7\xC8\xC4\x94\xC6\x0E\xC3\xF2\xC4\xC2\xC3\x4D\xC7\x3F\xC5\xA8\xB0\x7B\xB6\xAA\xB0\x62\xBA\x5D\x7F\x1C\xC5\x78\xC5\xFF\xC5\xD1\xC6\x5C\xC4\xD3\xC6\x5E\xC4\xB4\xC0\x03\xC3\x16\xB2\x05\xC3\x50\xBF\xBD\x9B\xE9\xB6\xC5\xB6\x6C\x99\x62\xC7\x4A\x7F\x55\xC7\x87\xC6\xF6\xC6\x77\xC3\x5B\xC3\x8B\x9E\x6A\xC7\x96\xBC\x44\xC6\xB8\xC0\x99\xBC\xE9\xB6\xC6\x8F\x16\xC4\x01\x01\x72\xC7\xE0\xAF\x65\xC7\x24\xC6\x67\xC7\x26\xC6\xD5\xC6\xE6\xA4\xA4\xBC\x86\xA2\x6D\xBF\x5B\xBE\xB5\xBD\x29\xC5\xF3\x53\x63\xC7\x10\xC6\x85\xC7\x31\xC6\x87\xC7\x33\xC6\xE1\xC6\x4F\xAC\x5C\xA7\xB1\xBA\x6C\xBF\x1A\xC6\x35\xC4\xD8\xC3\x92\xC7\x22\xC6\x61\xC6\x6E\xB4\xEB\xC6\x2D\xBD\x65\xC6\x57\xAA\x29\xC6\xE7\xC3\x6E\x53\xA0\xC7\x2F\xC6\xA2\xC7\x7C\xB5\x98\xC1\xF0\xC5\xA9\xC1\x16\xC6\x36\xC6\x71\xC7\xAA\xC7\x73\xC7\x46\xC7\xB8\xC6\xAE\xC3\xBA\xC6\xC6\xB7\xF2\xC5\x48\x67\xE2\xB1\x56\xC4\xCF\xBC\xB1\xAC\x15\x76\xAB\xC7\x3C\xC6\x94\xC7\xEA\xC6\x96\xC7\x51\xC6\x98\xC7\x23\xC5\x22\xC3\x73\xC4\x13\xC3\xF7\xBA\x25\xBB\x29\xC1\x98\xBF\x18\xC3\x6E\x8A\xC2\xC7\xB6\xC7\xC3\xC6\x92\xC3\xC5\xC6\xDD\xC3\xC7\xC6\x53\xC3\x4C\xC7\xCB\xC7\x68\xC6\x74\xC4\x85\xC4\x38\xC3\x05\xBE\x3A\xC3\xBE\x99\x56\xA1\x91\xC7\xD5\xC7\xF4\xC6\x6C\xC3\xB9\xC7\x3B\xC7\x80\xC4\xED\xA7\xDD\xC7\xF5\xBC\xB2\xBF\x6A\xC6\xD0\xC7\x66\xC4\x88\xC4\x29\xBB\x17\xC4\x02\x01\xC3\xC7\x4D\xC6\xC5\xC7\x12\xC6\xA4\xC7\x5C\xBD\xA6\xC7\x45\xC1\x62\xB5\xCA\xC3\x78\x05\xF8\xC7\x60\xC6\xFA\xC7\x3E\xC6\x03\xC7\x76\xC6\x05\xC7\x1D\xA8\x9D\xC4\x29\xB3\xBB\xC3\x9D\x0B\x03\xC8\x72\xC6\xAD\xC6\x02\xC7\xDF\xC6\x08\xC8\xB1\xC7\xFB\x59\x55\xC3\x41\xC4\x0F\xC8\x92\xC6\x39\xC7\x57\xC7\x7F\xC4\x07\xBB\x37\xB1\x83\xC7\xDB\xC5\x05\xC8\x4F\xC6\xC7\xC7\xEC\xC6\x89\xC7\x19\xBC\x13\x9C\xA5\xB5\xA9\xC7\xE6\xC7\x84\xC7\x11\xC8\xD2\xC6\x07\xC8\xD4\xC6\xFE\xC7\x6C\xA8\x72\xC1\x0D\xC8\x02\xC8\xE7\xC7\xED\xB8\x75\xC7\xEA\xC7\x77\xC7\xF8\xC6\x70\xC1\x7A\xC1\x7C\xC3\x74\x16\x35\xC8\x2C\xC8\x1B\xC8\xA0\xC6\x20\xC5\x30\xC8\xC9\xC7\xD7\xAA\x9F\xBB\x0D\x52\x9F\xC7\x36\xC8\x73\xB9\x47\xC7\xB7\xC1\x12\xC5\xE8\xBF\xAE\xBB\xD8\xB9\xF6\xC7\x01\x01\x19\xC8\x9E\xC6\x42\xC8\xDE\xC6\x44\xC8\x68\xC7\x31\xC8\xB2\xC7\xFA\xC6\xA6\x7E\xCB\xC6\x55\xC8\xAC\xC6\x57\xC8\x12\xC8\x59\xC8\x88\xC7\x5B\xC8\x0F\xAB\x55\x7D\xB3\xC3\xA5\xC3\x0A\xC7\x8D\xC7\x2C\x1B\x0C\xB6\x2A\xC6\xF7",
"\xC7\x4B\xC8\x13\xBC\x75\xC3\x76\xC7\x49\xC7\x78\xC7\xDF\xC3\x4D\xC5\x07\xC7\x93\xA6\x07\xC5\xAE\xC1\x1F\xC7\xA3\xB8\x21\xC7\x74\xB1\x27\x53\x40\xC8\x21\xC8\x2D\xC8\x66\xC7\x2F\xC8\x5A\xC8\x46\xC8\x4C\xAD\xBB\xC1\x5C\xC7\xBD\xC1\xAC\xB7\x30\xC0\x3A\xB6\x32\xC0\x26\x55\x82\xC8\xEC\xC5\x22\xC8\x62\xC6\xFC\xC7\x74\xBD\x66\xC8\x7A\xB0\x15\xC5\x26\xB4\x62\xAB\xC7\xA6\x41\xC7\x84\x54\x92\xC8\x64\xC7\x84\xC8\x86\xC7\x86\xC8\x65\xC8\x88\xC8\x99\xC8\xC3\x86\xD8\xC1\x12\xA0\x30\xAE\x35\xC5\x1B\x55\xA0\xC8\x93\xC7\xA2\xC8\x95\xC7\xA4\xC8\x97\xC7\x09\xC8\xBC\xC6\x9A\xC8\x2D\xBC\x5F\xBA\x28\xA0\x56\xB4\x60\xC7\x6C\x99\x15\x76\x7E\xC5\xF2\xC6\xB6\xC6\x37\xC8\x4D\xC8\xDC\xC4\xB0\xC7\x4B\xBF\xD4\x9B\x9A\xC2\x64\xC2\x6C\xC7\x01\xC4\x1A\xB2\xA6\xBD\xE6\xC5\xBC\xC8\x6E\x53\xBE\xC8\xD9\xC5\xF3\xC6\xC1\xC8\xB8\xC7\x48\xC7\x8B\xC3\x8A\xC6\x4C\x9C\x84\xBA\x40\xBF\xC9\xC8\x5A\xA0\xC6\xC2\xC3\x91\xED\xB0\x15\xC4\xCA\xC2\xBD\xC8\x52\xC7\x30\xA9\x24\xBC\x1A\xC4\xD1\xC4\x4F\xC4\xD3\xC4\x2F\xC5\xD1\xC2\xCA\xAE\xD3\xC2\x3A\xAC\x33\xC4\xD6\xC2\x26\xC4\xE5\xC7\x9D\x0B\xD0\xC8\xEA\xC5\xD2\xC8\x4C\xC8\xD4\xC8\x4E\xC8\x01\xC1\x56\xC1\xDC\x89\x18\xC6\xA7\xA9\xEF\xC8\x05\xA5\xE6\xC2\x9F\xC8\x02\x01\xF4\xC8\xFD\xC5\xF6\xC8\x72\xC8\xC4\xC6\x88\xC6\xD6\xC8\x4A\xC7\xC8\xC6\xEF\xC2\xC3\x76\x99\xC6\xA3\xC5\xB5\xC6\xC1\xB9\xE8\xC7\x73\xC8\x39\xC8\x75\xC8\x3B\xC8\x35\xC6\x29\x97\x37\xC6\xF3\x53\x04\xC9\x0E\xC6\x06\xC9\xBD\xBA\x10\xC5\x01\xC5\xC0\xC4\x1C\xC0\xBC\xC7\xCD\x7F\x55\xC4\x84\x7B\x08\xC3\x5B\xC6\xCF\xC8\xE3\xC8\xB4\xA9\x71\xA5\x1E\xC5\x3A\xC7\x3A\xC8\x3C\xC7\x71\xC4\x93\xBF\xDE\xC7\xCD\xC7\xDB\xBC\x26\xC3\x65\xC4\x6C\xC6\x99\xBF\xB1\xAC\x64\x89\x1C\xC9\x20\xC6\x1E\xC9\x2E\xC9\x1C\xC8\xBA\xC7\x78\xC1\xE5\xBC\x79\xC6\x2F\xC7\x3F\xB7\xE9\xBC\xA4\xBF\xF9\xBC\x7F\xC6\xED\xBC\x6E\x8A\x3C\xC9\x2B\xC9\x95\xAA\x02\xBC\x2B\xC5\xE7\xC8\x2D\xC5\xE9\xC8\x58\xB7\x44\xC0\x2F\xB7\xEF\xA7\xF0\xC7\x57\xC6\x27\xC3\x19\xC1\x28\xBB\x08\xBE\x75\x53\x78\x05\x3D\xC9\x3A\xC6\x3F\xC9\x0F\xC5\xE4\xC4\xF0\xC4\x02\xC5\xE7\xC4\x3E\xC4\x00\xC8\x81\xC8\x03\xC9\x4F\xC9\x10\xAC\x2D\xC9\x65\xC9\x1F\xC5\x95\xC6\x31\xC9\x15\x9D\x98\xC6\xCB\xC6\x62\xC9\x4B\xC6\x64\xC9\x52\xC9\x39\xC5\xE8\xC8\x3B\xC5\x90\xC4\xCE\x7E\x55\xC3\x1C\xC5\x78\xC9\xCE\xC6\x7A\xC9\x38\xC5\x00\xC5\x67\xC9\x22\xC9\x43\xC0\x37\xB1\xE2\xC8\x11\xC9\x7D\xBA\x13\xC9\x08\xC9\x74\xC8\x0A\xC9\x76\xC8\x19\xC7\xE0\xC3\xB8\xC4\x62\xB3\x69\xC3\xBF\xC6\x10\xC9\xC1\xC6\xC0\xC8\xF7\xC8\xF5\xC6\x15\xC9\x92\xC9\x17\xC9\x0A\xC8\xCA\xC6\x2A\xC9\x8D\xC9\x04\xBA\xB7\xC7\x9E\xC9\xD5\xC8\xC6\xC6\xD7\xC8\xC8\xC6\x7A\xB7\x58\xC4\x6D\xC9\xA5\xC9\xDD\xB9\x74\xC7\xC2\xC8\x11\xC5\xFA\xC8\x96\xC3\x84\xC3\x2A\x01\x46\xBE\xD8\xC6\x9A\xC9\xBF\xC8\x12\xC9\xD3\xC8\xA8\xC9\xF9\xC8\x47\xC4\x1D\xBE\x35\xBD\x02\xC9\xBB\xC9\xD1\xC8\x9C\xC9\x07\xC9\xD7\xC7\x09\xC9\xAA\xC9\x0B\xC9\xDB\xC7\x14\xC4\xD2\xA1\x7F\xA6\x26\x9C\x83\xC9\xE6\xC6\x85\xC9\xE6\xC8\x7C\xC9\x54\xC9\x7E\xC9\xA6\xC4\xD8\xB3\x79\xC8\xAA\xAB\x09\xC7\x09\xB6\xD1\xBB\x6D\xC8\xD3\xBB\x33\x70\xD2\xC9\xFE\xC6\xD4\xC9\x2A\xC4\x53\xC9\x35\xC0\x55\xC9\x5E\xB7\xDA\xC9\x51\xBD\xF2\x94\x53\xBD\xF0\x88\x22\xC0\xB7\xC3\x57\x86\x51\xB0\xBA\xC3\xC7\xAA\xE3\xC9\x11\xC7\xE5\xC9\x39\xC4\x2C\xC5\xE8\xC9\xD8\xC9\xD4\xC4\x2D\xC7\x5B\xC7\x46\xC9\xC5\xC3\x16\x7A\x4A\xAB\x79\xBE\xC9\xC3\x0F\xB0\xF6\xC9\x36\xC7\xF8\xC9\x4D\xC4\xE7\xC9\x4D\xC0\xE9\xC9\x1C\xB0\x3D\xC5\xFF\xC9\xC9\xC1\xBF\x8B\x49\x77\x0D\xBC\x51\xB6\xAA\x97\x07\xCA\xEE\x5F\x45\xC7\xD6\xC7\x9D\xC3\xD8\xC7\x17\xC7\xDA\xC7\xD1\xC3\xFE\xBD\x2E\xC7\x11\xCA\x92\xB1\x34\xC5\x7B\xBD\xE6\xC3\xA8\x64\x17\xCA\xD4\x62\x19\xCA\x8F\xC9\xC9\xC9\x91\xC9\xCB\xC9\x93\xC9\x2A\xAE\xDC\xC7\x82\xBD\x53\xB4\xE4\xC1\x5E\xC7\xEC\x9D\xD5\xB7\x4D\x52\xBC\xC5\x61\xC2\xA1\xC0\x7B\xC0\x86\x78\xD7\xB6\x71\x04\x24\x43\xAC\x88\x2C\x4C\x6E\xC2\xBF\xC5\x6C\x5C\x9A\x66\x73\xC2\x06\xBF\x19\x65\x53\x51\x3E\xCA\xBB\x6F\x40\xCA\x01\x8A\x2C\x4C\xFF\x04\xC3\xC5\x35\x4C\xC5\xC5\x4F\x9D\x8B\x54\xC9\xC5\x6C\x5C\x0A\x52\x47\xCA\xC9\xBE\x4A\xCA\x01\x87\xFF\x04\x08\x01\x4D\xCA\x1B\x75\x9A\x6E\x24\xC7\x72\x0C\xCF\xC5\x35\x4C\x37\xCA\x31\x0A\x06\x00\xDE\x58\x25\x6F\x8B\x54\x07\x00\x8F\x53\x31\x0A\x06\x7B\xD0",
"\x54\xEA\x7C\x6B\xBB\xF3\x06\x38\x6E\x32\x52\x1F\x55\x27\x53\xEC\x7C\x00\x84\x55\x01\x6C\x5C\x3F\x83\xE3\x56\xBA\x6A\xC2\xBB\xFD\x04\xB6\xC5\x8A\x96\xFB\xB8\x8B\xBD\x54\xB8\x27\x6A\xC9\x05\x24\xA4\x7E\xB9\x4B\x83\x01\x01\x9D\x6D\xC2\x56\x27\x00\x4A\xC2\x58\x25\x8E\xCA\x57\xB2\x81\xCA\xDF\xC9\xC3\x71\xDC\x6D\x6D\xCA\x33\x37\x8F\xCA\xFF\x04\x24\x00\xCE\x9C\x0E\x55\xDB\x07\x17\x3B\x5A\x96\x8E\x6E\x97\xCA\x01\x01\x23\x00\x99\xCA\x02\x01\xA4\xCA\x57\xB2\x9D\xCA\xFD\x06\xC6\x1B\xA0\xCA\xB4\x66\xA2\xCA\x6E\x0E\xA5\xCA\x01\x01\x22\x00\x9C\xCA\x30\x81\xA3\x58\x53\x96\x52\x54\xAF\x6D\x21\x00\xB0\xCA\x8A\x0A\xCE\x9C\x0D\x66\xC0\x07\x6B\x29\xAC\xCA\x19\x81\xAE\xCA\x20\x00\xBA\xCA\xC3\xCA\xA8\xCA\xB4\xCA\xF2\x6D\xA4\xB5\x25\x0A\x66\x18\x6C\x5C\xDA\x45\xD0\x54\xDA\x45\x99\xB2\x6D\x03\x74\xCA\xC4\x08\x96\xB6\xB6\xCA\xD7\x54\xAE\xCA\x1B\x00\xBA\xCA\xD8\xCA\x92\xCA\x79\xB6\x78\xCA\xAD\x83\xAE\x53\xAE\xCA\x78\xBA\xD0\x54\x3B\xBB\xC6\xC5\x80\xCA\x6C\xC5\x4E\x37\x24\xC4\xD9\x79\x5A\x52\xAE\xCA\x7B\xB8\x9E\x54\x01\x01\x32\xB9\xE4\xCA\xD1\xCA\xE6\xCA\x8C\x3E\xD8\x6F\x23\xB8\xDE\x80\x7A\x3E\x50\x15\x9F\x47\x82\x3E\x77\x84\x8B\x54\x05\x00\xAE\xCA\x7B\xB4\xED\xCA\x38\xB5\x2B\xB3\x40\x32\xB6\xC5\xF3\xCA\x99\x70\xF5\xCA\xC5\xC4\xF7\xCA\x29\x01\x48\x5C\x6C\x7A\xA4\x51\x7E\x6D\x5B\x8D\xC2\x56\x1F\xB2\xD0\x54\x8D\xB3\x03\xCB\xE6\xCA\x82\xCA\xE8\xB2\xE3\xB3\x98\x1E\x8B\x54\x11\x00\xAE\xCA\xB9\xAE\xD0\x54\xA6\xAF\xF0\xCA\x73\x02\x93\xCA\xFF\xC8\xCC\xA8\x25\x0A\x09\x00\xAE\xCA\x0A\xAC\xD0\x54\xFF\xAC\x20\xCB\x0A\x02\x76\x7D\x29\xAD\x4E\x49\xEC\x49\x8B\x54\x48\x3B\x6C\x5C\x60\xA9\xD0\x54\x46\xAA\x2B\xCB\x0C\x66\xDE\x80\x92\xC2\xDA\x7A\xFB\xCA\x25\x0A\x03\x00\xAE\xCA\x13\xA7\xD0\x54\x21\xA8\x37\xCB\x4E\x01\x22\xCB\x59\x6A\x3C\xCB\x23\x54\xAE\xCA\xBB\xA4\xD0\x54\xDE\xA5\x43\xCB\x29\x01\x45\xCB\x4A\x62\x47\xCB\x8B\xCA\xAF\x6D\x46\xA0\xD0\x54\x21\xA1\x4D\xCB\xA6\x5C\x84\x59\xDE\x27\x57\x04\xC8\x89\xAD\x6D\x95\x56\xAE\xCA\x0B\x9E\xD0\x54\x64\x9F\x57\xCB\x1E\x9B\xC4\x08\x11\x6B\xD5\xCA\x52\xCB\x6C\x5C\xC3\x9B\xD0\x54\xCC\x9C\x63\xCB\x4F\xCB\x14\xC0\x88\x59\xB7\xCA\x6C\x5C\xFB\x98\xD0\x54\xDC\x99\x6D\xCB\x15\xCB\x94\xCA\x24\xCB\x66\x52\xAE\xCA\xA1\x96\xD0\x54\xD1\x97\x76\xCB\x49\x5B\x3B\x31\xC0\xCA\xCC\xAD\x31\x0A\xAC\x91\xD0\x54\x90\x92\x7F\xCB\x0D\xC8\x05\xCB\x72\xB1\x03\x55\x25\x0A\x0B\x00\xAE\xCA\x50\x8F\xD0\x54\x63\x90\x88\xCB\x70\xBF\xBE\x73\x67\xCB\x72\x12\xAE\xCA\x1E\x1F\xD0\x54\xBD\x8D\x63\xCB\x76\x6E\x5C\x55\x96\xCB\xB1\x69\x70\x55\x81\x89\x00\xCB\xDF\x8A\x93\xCB\x89\x96\x78\x62\x5C\xB4\x5C\xA7\x98\x2A\xB5\x35\x45\x45\x30\x2B\xB8\x35\x98\xA4\x0E\xCB\xBE\x69\x70\x55\xD2\x69\x00\xCB\x8E\x87\xA5\xCB\xEB\x6E\x16\xCB\x33\xB9\x05\xB8\x65\xBC\x12\x8A\xFF\x35\x48\x36\xE6\x83\x16\xB9\xFC\xB8\x6F\x01\x84\x0C\x6C\x5C\x7C\x84\x00\xCB\xB0\x86\xBE\xB9\x3D\xBA\x6E\xCB\xD1\x60\xA8\xCB\x73\x84\x0B\x01\xEC\x14\x5A\xA4\x08\x6A\x8B\x54\x8E\xCB\x45\xCA\xC2\x95\x00\x7A\xB6\xCB\xCE\x0B\x0C\x03\x8E\x6F\x5D\xCB\xEF\x56\xAE\xCA\xA1\x62\xD0\x54\x7C\x76\x63\xCB\x57\x74\x8C\xCB\xAD\xCA\x6C\x5C\x4A\x21\xD0\x54\xA6\x72\xC8\xCB\x21\xBC\x1B\x52\x9F\xC4\x2E\x6E\x78\x7F\x25\x0A\x02\x00\xAE\xCA\x17\x26\xD0\x54\x42\x64\x3C\xBA\xEA\xCB\xCA\xCB\x83\x7E\x51\xCB\x29\x0A\xAE\xCA\xDC\x5C\xD0\x54\x70\x5E\x4E\xBB\x5F\xB9\x38\xCB\xA6\x59\xC4\x08\x16\x67\xAB\x81\x13\x02\xD4\xC5\x08\x0A\xA3\x7F\x26\x9C\xCD\xC5\x5F\x79\x00\xBB\xD8\xBA\x00\xC7\xE9\xC6\xFB\xC7\x24\xC8\xA5\xC7\xF5\xB2\x24\xC9\x72\xB8\xB6\xC2\xBA\x7A\x05\x9E\xDE\xC8\x45\xBF\x5D\x7F\x0A\xCC\x62\xCA\x3E\xBA\x29\xB6\xA6\xBB\x0F\xCC\xAD\xC7\xED\xB5\x63\xC6\x45\xC8\xF1\xC5\x52\xC4\xB4\xC2\x54\xC4\xF4\xC5\x7E\xC7\xCC\xC8\x80\xC7\xCA\xC2\x1D\xCC\x64\x72\x0D\xCC\x60\xBB\xDC\xC6\x10\xCC\x06\xC8\x13\xC8\x26\xCC\x15\xC8\x8A\xC7\xB1\xBD\x22\xC4\x6C\xC8\x1C\xC7\x8F\xC7\xC0\x75\x0B\xCC\x2D\x79\x32\xCC\x97\xBB\xD0\xC6\xB0\xC8\xC6\xC7\xB2\xC8\xC8\xC7\xB4\xC8\x5B\xA7\x65\xB2\x2B\x70\x32\xC4\xD5\xC2\x00\xC9\x6A\xB2\xB6\xBC\xFA\xC5\xD3\xC5\x31\xCC\x89\xBB\x12\xBC\x1F\xC9\x66\xC9\x2A\xC7\x68\xC9\x59\xC7\x3E\xC4\x48\x7B\xF2\xC8\x78\x05\x41\xCC\x2E\x85\x43\xCC\x40\xBA\x45\xCC\x62\xC8\x2E\xC8\x37\xCC\x87\xC8\x4A\xCC\x99\xC7\xEE\xB0\x6C\x99\x30\xCC\x0D\x73\x63",
"\xCC\x94\xBA\x27\xC7\xCC\xBA\x15\xC7\xEB\xC3\x7E\xBE\x1E\xCA\xAF\xA4\x7A\xC7\xD6\xBD\x2A\xCC\x26\xB7\x46\xC6\x88\xC1\x8B\xBF\xAA\x8E\x61\xCC\xF1\x86\x70\xCC\xEC\xBA\xA7\xC9\xE9\xC7\xA9\xC9\xD9\xC7\xAB\xC9\xCD\xC9\x20\xCA\x11\xC3\xCC\xC7\xDA\xBC\xA0\x9C\x50\xB7\x32\xB5\x59\xC6\x1A\xC1\xB1\xAC\x80\xCC\x1E\xCC\x7C\xBA\xA6\xC9\x1A\xCA\xCD\xC3\x75\xCC\x97\xBE\x77\xCC\x94\xC9\x8B\xCC\xEE\xC7\x83\xBE\xDD\xB2\xB3\xBF\x16\x90\x15\xC3\x38\xC9\x5D\xC9\xE3\xB2\x2A\xC3\x95\xCC\x55\xCC\x11\xBC\x70\xC9\x7B\xC9\x87\xC9\x5A\xCC\x89\xC9\x7F\xC9\xB7\xC4\x67\xC6\xEF\xC7\x35\xC3\x4E\xB7\x36\xC9\x7D\xC6\x5C\xC9\x92\xCC\x5E\xC9\xFD\xBC\x53\xCC\x2A\x01\x96\xCC\x96\xBB\x64\xCC\x34\xCC\x23\xCC\xCB\xB8\xAF\xC7\xB0\xC6\x39\xCC\xF7\xAE\x39\xBB\x5F\xCC\x0C\x0A\xC0\xCC\xEC\xB4\x44\xCC\xC3\xCC\x94\xC8\xA3\xC7\x12\xCC\xFD\xC7\xA6\xC8\x6A\xAA\x1D\x7E\x15\x76\x81\xCC\x96\x88\x83\xCC\x30\xBB\x72\xCC\x03\xBB\xD6\xC9\xFB\xC9\x2B\xC7\xB2\xCC\x81\xB5\x0C\x0A\x1F\xBE\xBA\xC9\xBF\xCC\xAB\xCC\x7F\xB8\x57\xCC\x40\xC9\x43\xC8\x73\xC9\xC6\xB7\x37\xB1\x6E\xCC\x3F\x78\xDB\xCC\x40\xBB\xDD\xCC\x01\xC7\x67\xCC\x64\xC8\xB3\xC8\xC8\xCC\x1B\xBD\x30\xAB\xC8\xAF\xC7\x57\xF3\x53\xD9\xCC\x87\x89\xF2\xCC\x7E\xBB\x85\xCC\x14\xC9\x87\xCC\x1D\xCA\x89\xCC\x1F\xCA\xC9\xC6\x24\xBD\xB3\xC6\x54\xCC\x6F\xCC\x56\xCC\xAD\xCC\x86\xC9\x20\xC9\x88\xC9\x4F\xC8\xBC\xBB\xAD\xC9\xCB\xCC\x0C\xCD\xF1\xCC\x0E\xCD\xF6\xA9\xC4\xCC\xE1\xB9\x25\xCC\x69\xCC\xF9\xCC\xA2\x74\xD2\xB5\xD8\xCC\xCD\xCC\xD7\xBA\x33\xCC\xE8\xC6\x1B\xCD\x55\xBB\x96\xC8\x71\xB3\x26\xC8\x9C\xAD\xE0\xC4\x9C\x4B\x60\xCC\x23\xCD\x01\xCD\xB6\xBB\xBE\xC9\x86\xCC\xC0\xC9\xDF\xC5\xF8\xBF\x8A\xB7\xF7\xB5\x65\x68\xFF\xCC\x54\x8A\x31\xCD\xC5\xBB\x2B\xCA\x1B\xCA\xCA\xC9\x88\xCC\xCC\xC9\x08\xCD\xAB\xC1\x36\x95\xCF\xBB\x0C\x91\x23\xCB\xB5\x1C\x6E\xC8\xCD\x74\x3B\xCD\xE4\x67\x3D\xCD\x32\xB3\x3F\xCD\x9A\xCC\x1C\xCA\x76\xCC\x07\xCD\x77\xC8\xA2\xC3\x2D\x58\x9D\xC1\x7B\xC8\xB5\xC3\xF0\xC9\x20\xC7\xF2\xC9\x6D\xBE\x3A\x88\x4D\xCD\xAD\x71\x4F\xCD\x54\xC7\x03\xCD\x90\xC9\x9F\xC9\x2E\xCA\xA1\xC9\xB5\xC8\xA8\xC8\xE2\xC3\x8C\xC8\x18\xC5\xE6\x9F\x33\xC7\x3A\xCD\x30\xCD\x19\xCD\x41\xC8\x56\xC7\xEC\xCC\x58\xC7\x2C\xC7\xB3\xCC\x7B\xB0\x12\xA9\x27\xC5\x39\xBA\x71\xCD\xE8\xCC\x95\xB8\xEA\xCC\x71\xC9\x2F\xC9\x16\xC9\x74\xC9\x60\xB6\x6B\xCD\xF1\xC3\x33\xC5\x77\xAB\xAC\xC8\x19\x84\x61\xCD\x8E\x69\x63\xCD\xC7\xB8\xB2\xC9\xF8\xC8\xC3\xC8\xC7\xCC\x13\xC5\xEF\xC3\x3E\xC7\x6C\xCD\x54\xC0\x7C\xB6\x59\xB1\xFD\x01\x89\x83\xD1\xC5\x09\x52\x14\x0B\x16\x00\x69\xCA\xFC\x8B\x6F\x70\x7D\x83\x74\xAE\x7A\x5B\x50\x55\xA2\xCD\x88\x7E\x6F\x70\x6A\x83\x95\xA4\x94\x80\x60\x44\xBE\xCB\x7F\xA4\xC0\xCB\x84\xCA\xE0\xB7\x60\xB4\x59\x8D\x01\x01\x57\x83\xD2\x57\xCF\x68\x45\x26\xEE\x05\xD1\x3A\x06\x84\x83\xCA\x7D\xA9\x8C\xBD\x7A\xC5\xF4\x8B\x4D\x52\x1C\x00\xF7\x53\xDE\x58\xD3\x51\x71\x22\x84\x20\xD6\x51\x5A\x58\x77\xCA\x44\x7D\xEA\xA3\x6B\xBC\xE5\x7A\x31\x0A\xD4\x27\xB3\x73\xC8\xCD\xAD\x50\xA2\x44\x83\x33\x75\x53\xDD\xCA\x82\xA4\x1C\xC6\xD9\xCD\xCE\xCD\x62\x02\x9D\xCB\x1A\x23\xA4\xC3\x3C\x73\xFD\x01\xDA\xCA\x7F\xC5\x3D\x74\xC5\xCD\x62\xA2\xD5\xCD\x42\x7B\xCA\xCD\xD7\xCD\x4B\x58\x26\x55\xDA\xCD\x63\xBD\x25\x0A\xD1\xCD\x04\x7C\xD4\xCD\xD6\x01\x5E\x1E\x43\x7B\xBC\x44\xD8\xCD\xCD\xCD\x22\x7D\x91\x02\xFF\x04\xB9\x7D\xF0\xCD\x0B\x01\xE0\xCD\x5F\x12\xE2\xCD\x8E\xAB\x06\x5A\x1D\x00\xC6\xCD\x0F\x52\xE8\x51\xEA\xAD\xEA\x51\x97\xAC\x04\xAE\x7E\xB1\x25\x0A\x6B\x1E\x54\x54\x2D\x43\xB3\x73\x0A\xCE\x34\xAE\x0A\x15\x7F\xAC\xCF\xAD\xDA\x44\x15\x37\xFF\x04\x3E\xC1\x18\xCE\x0B\xCE\x35\xAE\xA1\x58\xDE\x80\x4A\x49\x9C\x26\x04\xCE\x94\xAB\x6F\x70\x2F\x74\x9C\xAB\x26\x59\x7F\xA6\xAA\xCD\x09\x52\x84\x03\xCF\xCA\x00\x8C\x1D\x59\xE2\x0E\xA9\xCD\x60\xB8\xD8\x55\xA6\x7E\xDE\x58\xB6\x44\x6F\x48\xF9\xC4\xDC\xC9\xB0\xAB\x2D\xCE\x02\x01\xB9\xCA\x62\xA2\xFD\x01\x85\x48\xCC\x2F\xA0\x7E\x4F\xCC\x10\xC0\xFF\x95\xC5\x5C\x6E\x6E\x33\xCE\x01\x8C\x35\xCE\x34\x83\xC4\x07\xD2\x45\x54\x30\x78\xCB\xAC\xC1\x57\xB4\x2A\x01\x4B\x0B\xA6\x7E\x9F\xAB\x5A\x6E\xFD\x06\x50\x48\x27\x45\x15\x02\x86\x7A\x09\x46\xE7\x93\xBD\x08\x58\x48\x51\xCE\x46\xCD\x06\x5E\x4C\xCE\xA1\x59\xBD\x6C\x05\x46\x10\x27\xDD\x04\x00\x46\xB5\x1C\x5F\xCE\x75\x08\x0C\x46\x49",
"\xCD\x63\xCE\x01\xB2\xB6\xCD\xFB\xC6\x10\x0B\xBD\x6C\xEC\x46\x85\x18\xF5\x03\xE8\x48\x20\x3B\xE7\x93\x4B\x03\xC5\x46\x70\xCE\x2C\x95\x0F\x83\x23\x59\xA7\xCA\x24\x59\x31\xCE\x83\xCE\x59\xB1\x65\xCE\xC2\x5A\x76\xCE\x09\x49\xD3\x4A\x79\xCE\x56\x46\x08\x38\x23\x3B\x7C\xCE\x0C\x94\x26\x38\x62\xCE\x80\xCE\x72\xCE\xD6\xB7\x74\xCE\x57\xCE\x07\x0A\x48\x05\x77\xCE\xCF\x02\xC3\x24\x2E\x49\x93\x30\x1B\x46\x91\xCE\xDB\x7F\x93\xCE\x7F\xCE\x03\xB7\xC3\xCD\x23\x59\x9B\xCA\x29\x59\x31\xCE\xA9\xCE\xD5\x7D\x88\xCE\xB5\x55\x8A\xCE\x2B\x49\x5F\x18\x27\x19\x9F\xCE\xE9\x48\xD6\x1B\xA2\xCE\xB5\xCE\x07\x49\xA5\xCE\x88\x54\xE6\xCD\xE3\xB0\xD0\xB7\xF3\x53\x9D\xCD\x20\xB2\x16\xB4\x7A\x7A\xAA\xCE\x3D\x74\x25\x00\x08\xCE\x14\x54\x36\x4F\xB7\xA3\x70\x81\xCF\x31\x6E\xC2\x18\x8C\xC2\x56\x1A\x8C\xC8\xCE\x28\x51\x8F\x80\xCB\xCE\x37\x39\xC3\xA3\xB6\x81\xCF\x31\xC6\xA3\x72\x5C\x7C\xA2\x7C\x01\xD7\x83\x7B\xCA\x2A\x0A\x02\x66\xC3\x81\x30\x66\x05\xCC\x75\xA2\x7E\xCA\x46\x81\xCF\x31\xBD\xCA\x71\x49\x73\x16\xE5\xB8\xC1\xCB\xBB\xCB\x1B\x7F\x03\x1F\xD0\xCB\x50\x65\x54\xAE\x7B\x62\xBE\xCE\x9D\x0B\xA5\xCD\x92\xB8\xBF\xCB\x96\xCE\xB5\xBC\x64\xAE\x3C\x96\xF3\xCE\x63\xAE\xAC\xCD\xF7\xCE\xB1\xCD\xF9\xCE\x87\xBD\xA5\x5A\xB8\xCD\x8A\xBD\xC0\xCD\x85\xCA\x8D\xBD\xDE\xB6\x65\x68\xE5\xCD\x80\x7D\xBD\x7D\x7C\xB3\x2D\xBB\xA3\xAE\x20\xCC\x0E\xCC\x13\xC7\x73\xCC\x29\xC7\x7D\xC9\xE1\xCC\x2E\xC4\x15\xCC\xF0\x7F\x7D\xC7\x18\xCC\x78\xB4\x1B\xCC\xE4\xB4\x02\x01\x0C\xCF\x43\x7D\xFC\xCD\xAB\xB8\xF5\xCB\x4F\xBB\x1F\xCC\xA5\xBB\x13\xCF\xF4\xCC\x35\xCC\x23\xC8\x48\xCC\x25\xC8\x41\xC6\x79\xCC\xDA\xC8\x7C\xC7\xC5\xC2\x12\xC4\x9A\xBD\x58\xB1\x38\xB2\xCA\xC2\x64\x89\x22\xCF\xEB\x7C\xDE\xCD\xAC\xB4\x55\xB3\xD8\xB5\xBC\xBA\xEB\xCC\x58\xC8\xED\xCC\x43\xC9\xC3\xBC\x06\xC6\x3C\xCC\x1A\xC6\x76\xA0\x94\xA9\xF3\x53\x3B\xCF\x09\x57\x00\xCE\xC3\xB8\x72\xCA\x1A\xB9\xE6\xB3\xE5\xC8\xE6\xC9\xDF\xCC\x0C\xCA\xFC\xC9\xEA\xC8\xE0\xB8\x6A\xBF\x9B\xC7\x4E\xCC\x3A\xCE\x18\x67\xEA\xC0\xC4\xBA\x4D\xCF\xDD\xCD\x24\xCF\xFD\xB8\x3D\xB5\x8F\xCD\x1C\xB9\x99\xCC\xDB\xC3\x9B\xCC\x8A\xB0\x43\xBE\xB6\xC9\xAC\x63\x5E\xCC\xC0\x75\x62\xCF\xFB\xCD\x81\x7D\xCC\xB3\xFF\xB3\x23\xBC\x51\xC9\x10\xCD\x59\xCC\x17\xCF\x5B\xCC\x78\xCD\x5A\xCF\x19\xC9\x20\xCF\xB3\x55\x64\x7D\x56\xB2\x10\xCF\xCE\xAF\x90\xB9\x50\xCD\x33\xCD\x04\xCD\x35\xCD\xC4\xC8\xE0\xC5\x30\xB2\xA2\xC0\x16\xCC\x45\xC6\xAB\xB2\xC0\xC7\xFD\xBA\x4C\xCF\x82\xCF\x70\xB2\x16\xBB\xAC\xCC\x1A\xCD\xD1\xCC\xAE\xC7\x1D\xCD\xA5\xC8\x6A\xCC\xCA\xC7\xB4\xCC\xA1\xCC\x63\xC4\x5B\xC9\xA6\xCC\xBB\xCC\x3A\xC9\x93\xCF\x9D\x0B\x72\xCF\xEF\xCD\x3D\xCF\x25\xCF\x63\xCB\x97\xCC\xB1\xC9\x65\xCD\x2C\xCA\x67\xCD\x42\xCD\x2F\xCA\xA1\xAF\x57\xA8\xA0\xCF\x00\xCA\xA2\xCC\xF1\xC7\xF9\xBA\x87\xC4\xF7\xBD\x2C\xC1\xC9\xB2\x94\xCF\x9D\x7D\xE3\x7B\x1A\xB3\xD0\xCA\x1C\xB3\x12\xCF\x25\xCD\x22\xCC\x9A\xCF\x24\xCC\x29\xCD\xCE\xB4\x2B\xCD\xB6\xCF\x33\xC9\xB5\xCC\x37\xC1\x36\xC3\xE0\xC7\x76\xC4\xD8\x6F\x50\xB5\xF5\xC7\x61\xCF\x95\xCF\x98\xB2\x7F\xCA\x84\xB2\x86\xCF\x64\xCD\x69\xCF\xEA\xC3\x53\xCD\x9C\xCC\x55\xCD\x9E\xCC\x37\x7F\x93\xC4\xC7\xAA\xA9\xCF\xBB\x3D\x4F\xCF\x35\xB9\x3F\xCF\xEB\xB8\xD9\xBB\xA2\xC4\xFA\xC9\x57\xCF\x18\xCF\xFD\xC9\xF0\xBF\x3E\x7C\x9E\xC4\xD8\xCF\xC1\xCF\x09\x7C\xDA\xCF\xA3\xBB\x92\xBA\xC6\xCF\xCF\xCC\x26\xCD\xC9\xCF\xC5\xCC\x9C\xCF\xF8\xCC\x95\xCD\x22\xAC\x55\xC3\x15\x76\xE8\xCF\x9B\x50\xF9\xCF\xC3\xCF\xDB\xCF\xC5\xCF\x29\xCF\xC7\xCF\x14\xCF\xDE\xCC\xAF\xCC\x7B\xCF\xB1\xCC\x2E\xC4\x67\xBB\xA8\xCF\xD9\xCF\x0B\xD0\xFB\xCF\xEA\xBA\xFD\xCF\xC2\xCC\xFF\xCF\x46\xCC\x11\xCC\x2E\xCF\x13\xCC\x9E\xCF\x86\xCD\x49\xBD\xFC\xCC\x49\x9A\x08\xD0\xC9\x47\x0E\xCF\x68\xB3\x84\xCF\x70\xB9\xDD\xCF\x90\xCD\xB0\xCF\x40\xCD\x2D\xCA\xB3\xCF\x69\xCD\x55\x8E\x75\xB3\xEA\xBF\xE7\xCF\x18\xD0\x0F\xCF\xC4\xCF\x2E\xBB\x1C\xD0\x71\xCC\x91\xCD\xBF\xC9\x93\xCD\x04\xC7\x1F\xCD\x74\xAD\xD7\xC6\x38\xD0\xF8\xCF\x2D\xB4\x99\xB5\x6D\xBB\xB2\xB9\x42\xCF\x63\xC8\x44\xCF\x3D\xC4\xE2\x7C\x48\xC8\x33\x70\x28\xD0\xD0\x51\x74\xCF\xFE\xB3\xA6\xB3\x77\xCF\x81\xCD\xAE\xCC\x11\xCD\xB0\xCC\x13\xCD\xD5\xBC\xC3\xC9\x71\xCF\x39\xD0\x2B\xD0\x3B\xD0\x11\xCF\x0E\xD0\xFE\xCF\xC8\xCF\x1F\xD0\x36\xCC\xF7\xCC\x49\xCC\x43\xD0\x37\xCF\x60\x7B\x93\xC1\x8E",
"\x8E\x17\xD0\x47\xD0\x3E\xB2\x49\xD0\x53\xCF\x78\xCF\xD5\xC9\x12\xD0\xD7\xC9\xF2\xCF\x59\xCF\x0B\xBA\xEC\xC9\x33\xB0\xDD\xC9\xD0\xBB\xBA\xCE\x4D\x7E\xFC\xB9\x74\xCE\xAA\x8E\x53\xD0\xA3\x50\x2A\xD0\xA5\xB3\xC5\xA1\x82\xB9\x41\xCF\x82\xCD\x41\xC9\xEB\xC7\x45\xCF\xC5\x95\x1B\xC7\x46\xCE\x5A\xCD\x1E\xC7\x5C\xCD\x7E\xC8\x5E\xCD\x14\xBA\xC2\x76\x86\xD0\xEA\xCF\x65\xB8\x03\xBA\xAF\xCF\xDF\xCF\x91\xAE\x6B\xCF\xA0\xB0\x18\xC7\x30\xCA\x95\xC9\x32\xCA\x60\xBD\x37\xB6\xA5\x8B\xC8\xC3\x01\xAE\xE9\xBB\x81\xCF\x72\xD0\x83\xCF\x63\xD0\x85\xCF\xC4\xBB\x87\xCF\x9D\xC9\x34\xCD\x41\xD0\x14\xC8\x04\xD0\xA6\xD0\x7A\xCD\x61\xAB\x85\xBE\x9D\xC8\x3D\xC0\x88\xBE\xE8\xB9\xC0\xCF\xBC\x7D\xC2\xCF\x3A\xD0\x0C\xD0\x3C\xD0\x65\xD0\x1D\xD0\x67\xD0\x66\xCC\x85\xC8\x68\xCC\x9D\xCF\x6C\xD0\x96\xCD\xA7\xD0\xA9\xC8\x46\xA2\x8B\xCD\x60\x91\x9B\xD0\xAB\xCF\x65\xCF\x36\xB9\x67\xCF\x6E\xBB\xA0\xD0\xA8\xAE\xE1\xCF\x6C\xCF\xED\xC3\xC8\xC6\x12\xC1\x60\x96\xB7\xC8\x34\xCA\x40\xA9\x5F\xC7\xC2\xCD\x5F\xA2\x0C\x0A\x29\x4D\x7B\xC5\x83\xAE\x02\x01\x26\x00\x4A\xCE\x5F\xAE\x08\xCC\xDE\x98\x2F\xCE\xB9\xBA\xED\xBB\x8B\xD0\xEE\xCF\xAB\xC4\xF0\xCF\x66\xBF\x2E\xC5\x56\xC9\x1A\xCF\x1E\xAC\xE4\xC5\x9A\xBC\xCD\xC8\xD4\xBA\x02\x01\xF4\xD0\xC7\xBA\x52\xBA\x2E\xD0\x68\xCF\x51\xCD\x6A\xCF\xDE\xD0\xA3\xD0\x9D\xCC\x1A\xAC\x98\xAE\x2E\xC2\xBD\xC7\xF4\xB6\x51\xBF\x01\xD1\x2E\xCC\xF9\xC5\x2C\xA0\x05\xD1\xE8\xBA\x1A\xD0\x3E\xBB\x3D\xD0\x84\xCC\xDC\xD0\x41\xB0\x0C\xD1\x46\xB2\xA4\xD0\xB5\xCF\x70\xA0\x47\xCF\x01\xB7\x94\xCE\x03\xB7\xD7\xC2\x3A\xAD\x19\xD1\x15\xBB\x2C\xD0\x22\xBC\x08\xD1\xDB\xD0\x0A\xD1\xE0\xCF\x41\xCD\x06\xCD\x43\xCD\x56\xCD\xBB\xBD\xE5\xC0\x9C\xC7\x28\xD1\x10\xB7\x01\xC9\xC0\x75\x2C\xD1\x2C\xBB\xB1\xD0\x2D\xD0\xB3\xD0\xDE\xCF\x32\xD1\xA1\xD0\x21\xD1\x0E\xB3\x23\xD1\xFB\xAF\xBC\xBC\xF8\xAE\x49\x9A\x3F\xD1\x3C\xBB\x1B\xD1\xB4\xBB\x1D\xD1\xDC\xCC\x3F\xD0\xB6\xD0\xB4\xC9\xC1\xC9\xFB\xC8\x49\xC4\x65\x68\x4E\xD1\x4D\xBB\x7A\xBA\xEA\xCB\xAE\xCF\x21\xCC\x10\xD0\xF5\xCC\xCC\xD0\x6A\xD0\x2F\xCF\x14\xCC\x28\xCC\xC8\xC8\x33\xCF\x06\xC3\xBF\xC7\x8A\xBF\xA6\xA7\x5B\xD1\x6A\xBB\xFF\xCB\x81\xB9\xE8\xB5\x4B\xD0\x8D\xD0\x76\xCD\x1D\xC8\x4F\xD0\x92\xBF\x8D\x9B\xF5\xBA\x31\xB7\xD3\xCF\x42\xB7\xA6\xBF\xE8\xAC\x19\xC3\x23\xAF\x6E\xD1\x7A\xBB\x51\xCF\xB0\xB9\x58\xD0\x0F\xCD\x77\xD0\x5B\xD0\x13\xD0\x5D\xD0\x33\xC1\xE0\xBF\xF2\x2C\x0B\xBB\x48\xC9\x75\xC4\x7D\xD1\x77\xC4\xA7\xBF\x6D\xD1\xF0\x97\x9D\xD0\xC9\xBA\x0F\xD0\x2B\xCF\x27\xCD\x16\xC7\x54\xCD\x36\xD1\xE4\xCF\xE2\xD0\x8E\xD1\x36\xC1\xCF\x8D\x23\xBB\x8F\xCC\xF8\xBA\x55\xAF\xBC\xCF\x06\xBE\x43\xAA\x13\x75\x82\xD1\xA2\xBB\x84\xD1\x7C\xBB\x52\xD1\xF3\xCC\x54\xD1\x89\xCF\xB7\xD0\x38\xCC\xB9\xD0\x43\xC3\xCA\xCC\x3E\xD1\x96\xD1\xC8\xBA\x74\xA8\xB1\xD1\x30\xD0\x52\xCD\x34\xD1\x9D\xD1\xB4\xCF\x4A\xD1\x3C\xBE\x98\xC6\x26\x9C\xAC\xD1\xB2\xBB\x50\xD1\xC3\xBB\xB0\xD1\x02\xCD\x1F\xD1\x87\xB0\xA2\xD0\x22\xD1\x0E\xD1\x24\xD1\xD9\xA5\xE4\xCC\x25\xAD\xFD\xCC\x9D\x0B\xC7\xD1\xC1\xBB\xC9\xD1\x9A\xB2\xCB\xD1\x32\xCD\xB5\xD0\xB3\xD1\x56\xD1\x36\xCD\x38\x88\xB2\xC6\x79\xB8\xD8\xD1\xD6\xBB\x74\xD0\x40\xCF\xF8\xD0\xC9\xB4\x0B\xCA\xFB\xD0\x0D\xCA\x6C\xB7\xFE\xC9\x96\xC9\x26\xD0\xC7\xAA\xE5\xD1\xEC\xBB\xE7\xD1\xED\xCF\x54\xCF\xF9\xC9\xEB\xD1\x7B\xBF\x58\xCF\x56\xC9\xB9\xB9\x71\xC3\x37\xD0\x0F\xB0\xF3\xD1\xFF\xBB\xF6\xD0\x72\xD1\x8C\xD0\x5A\xD0\x7A\xCF\x79\xD0\x7C\xCF\xE2\xCC\x70\xC3\x8A\xB3\xC6\xD1\xBA\xD1\x07\xD1\x43\xD1\x2F\xD0\xCD\xD1\xB8\xB2\xC0\xD1\xE2\xCF\x9E\xD1\xA5\xD0\xB7\xC9\xFF\x00\xB9\xC9\xF2\xD1\x0E\xD2\x00\xBC\xF7\xD0\xF7\xD1\x0A\xCA\x56\xCF\xEC\xD1\xFB\xD1\xEA\xC9\xF4\xCF\x4D\xA6\xEF\xC6\x4D\xD1\x1C\xD2\x03\xD2\x4A\xD0\x05\xD2\x79\xCF\x72\xC9\x77\xCD\x0A\xD2\xAE\xBC\x51\xAE\x39\xCD\x95\x86\x01\xD2\x31\x76\xF5\xD1\x51\xBB\x1F\xD2\xEF\xCF\xF9\xD1\xC4\xBF\x23\xD2\x0E\xCA\xEB\xC9\x67\xBE\xE6\xA1\xAE\x95\xE9\xA1\x81\xD0\x06\x5E\x0E\xC7\xC1\xD0\xD7\xD1\x29\xD2\x37\xD2\x86\xD1\x99\xCF\x68\xD0\x2D\xCF\xCD\xD0\x03\xD0\xA2\xBC\x45\xCD\x95\xCE\x0E\xBA\x95\xD0\x09\xC5\x23\xC0\x57\xBD\x80\xC8\x47\xD2\x78\x05\x35\xD2\x63\x76\x2E\xD1\x28\xCF\xDC\xB9\x60\xD1\x9A\xD1\x00\xD0\x1C\xCD\xCB\xCF\x0D\xB5\xCD\xCF\x21\xC3\xD1\xD0\x6C\xCD\x25\xBA\x6F\xCD\x8F\xC8\xC2\x76\x5C\xD2\x2A",
"\x77\x97\xCF\xE9\xCC\x87\xD1\x55\xCF\x78\xD0\xE0\xCC\x09\xD2\xD9\xC9\x79\xCD\xB6\xC8\x6C\xCD\x40\xC7\xBF\xD0\x6E\xD2\x49\xD2\x71\xD2\x80\xCD\x73\xD2\xF8\xD1\x21\xD2\xFA\xD1\x7A\xD0\xFC\xD1\xEF\xD1\x69\xD2\x88\xCD\x23\xCA\x8A\xCD\x25\xCA\x15\xA0\x60\x91\x6F\xD2\xB2\x77\x80\xD2\x1A\xBA\x76\xD0\x74\xD2\x89\xD1\x08\xD2\x14\xD0\xF3\xCF\x65\xC3\x45\xC0\xA8\x7F\x33\xCA\x7A\xB6\xE6\xD0\x36\xCA\xBB\xC8\x03\xD1\x01\x01\xC5\xCA\x79\xBA\xE9\xCB\x27\xCF\x5F\xD1\x2A\xCF\xB2\xD1\x66\xCD\x05\xCD\xC1\xD1\x3E\xBF\x31\xCF\xB6\xC0\x69\xD1\x6D\xC7\x43\xBF\x1A\xCC\x77\xB8\xDE\x98\xA4\xD2\x90\xBA\xDA\xD1\xDC\xCF\x10\xD2\x09\xD1\x88\xCF\xAB\xD2\x8A\xCF\x94\xCD\x8C\xCF\xD9\xC8\xB0\xD2\x7B\xCC\x8A\xB8\xF5\xC5\xE5\xC5\x16\xD1\xD3\xA4\x19\x84\xB7\xD2\xA6\xBA\x4A\xD2\x30\xD1\x73\xD1\x06\xD2\x2E\xD2\x76\xD1\x03\xC5\x46\xCF\x8B\xC7\x73\xA0\x3B\xD1\xDA\xC0\xF1\xC8\x3A\x88\xCB\xD2\xF5\xD0\xCD\xD2\xBB\xD2\x31\xD1\xBD\xD2\xB1\xCF\xAC\xD2\x15\xD2\xC2\xD1\x63\xB2\xC8\xC2\x4C\xCC\x52\xAC\x19\xC6\xD7\xD2\x06\x8C\xDC\xCD\x0F\xB0\xDB\xD2\x06\xD1\x1D\xD2\x04\xD2\xE9\xD1\x59\xB5\x3B\xD2\xCC\xBF\xED\xD1\x72\xB7\xC7\xBD\x4C\xD1\xC7\xAA\xEE\xD2\x1A\xD1\xAE\xD1\xA4\xBB\x60\xD2\xA9\xD2\xBE\xD1\x0B\xD1\x14\xD2\xDF\xD0\x49\xD1\xE5\xD2\xDF\xC2\x3A\x9C\xB6\xD2\x7F\xD2\x5E\xD2\xA8\xD2\x99\xD1\xAA\xD2\xE1\xD2\xBF\xD2\x42\xD0\xC5\xC8\x97\x70\x86\xC2\xFF\xC3\xDB\xC8\x51\x9C\x91\xCF\x6C\xD1\xBF\xCF\x9D\x0B\xFB\xD2\x2D\xD1\x41\xD1\x2F\xD1\xDE\xD2\xCF\xD2\x2D\xD2\x83\xCD\xA0\xC9\x85\xCD\x89\xC8\x82\xC4\x34\xC9\x8E\xCC\xC3\x9E\xA6\xD1\x51\xB7\x39\xC9\xD2\xC7\x1A\xD3\x78\x05\x1C\xD3\x40\xD1\xC6\xD0\x64\xD0\xFF\xD2\x0D\xD3\x01\xD3\x33\xD1\x32\xD0\x35\xD1\xE4\xD2\xD9\xB2\xD0\xD0\xCF\xCF\xA1\xCF\xDF\xC7\x7C\xC6\x17\xC1\xBA\xCC\x4B\xC9\x29\xC3\xA6\xA7\x31\xD3\x4F\xD1\xFD\xD2\xFC\xCF\xC8\xD0\x3E\xD0\x37\xD3\x46\xD1\x03\xD3\x0D\xD1\xE3\xCF\x17\xD2\xD6\xBC\x27\xD3\xD0\xCF\xA3\xD1\xA3\xCC\x1A\x7F\x37\xC9\x6B\xC6\xA7\xCC\x2B\xC1\x81\xC6\x26\x9C\x47\xD3\x5C\xD1\xA6\xD2\x00\xCC\xB2\xD0\xDC\xD1\x3E\xCD\xE0\xD2\x31\xD0\xB2\xCF\x3A\xD3\x34\xD0\xFF\xC7\x47\xC1\xC4\xBA\x5F\xD3\x6F\xD1\x5D\xD1\xA7\xD2\xC1\xCC\x4C\xD3\x12\xD2\x5A\xB6\x47\xD1\xC1\xB3\x05\xD3\x3C\xD3\x88\xC1\xC5\xD1\x6E\x53\x6E\xD3\x83\xD1\x70\xD1\x6C\xBB\x75\xD0\x59\xD0\x22\xD3\x8E\xD0\x30\xC9\xEC\xC7\xC3\x92\xA5\xC6\xDD\x9C\xF3\x53\x7D\xD3\xAD\xD1\x7F\xD3\xC5\xB8\x81\xD3\x82\xD2\x20\xD2\x75\xD2\xF1\xCF\x77\xD2\x12\xAE\x16\xD0\x30\xD3\x0A\xD3\x1E\xD3\x5F\xD2\x9E\xD0\x61\xD2\x0E\xD3\x67\xD3\xE2\xD2\x04\xD3\xD1\xD1\xC3\xD1\x53\xD3\x28\xC8\xBE\xC6\xAA\x97\x8B\xD3\xC8\xD1\x49\xD3\x1B\xD0\x4B\xD3\x1E\xD1\x45\xD1\xDD\xD0\x4F\xD3\xD0\xD1\x51\xD3\xD2\xD1\xB3\xAA\x0A\xCD\x6D\xD3\x98\xD3\x33\xD3\x63\xD3\xAB\xD3\x53\xD1\x4D\xD3\xAE\xD3\x39\xD3\xAD\xD2\x25\xD3\xB7\x7E\x0C\xD2\x7C\xD3\xB6\xD3\xB9\xD2\x0D\xD0\x35\xD3\x66\xD0\x61\xD1\x2C\xCF\x95\xC8\xD3\xCC\x97\xC8\xD5\xCC\x3A\x9D\xD6\xC4\x3C\x9D\x33\x70\xA7\xD3\xD9\xD1\xA9\xD3\x1C\xD1\xB9\xD3\xBD\xD1\x74\xD3\xDB\xB8\x76\xD3\x45\xB5\xE0\xD0\x8A\xCC\x84\xB7\xAF\xBB\xA6\xD3\xC3\xD3\xD4\xD3\x51\xD1\xD6\xD3\xCC\xD1\xAD\xD3\x20\xD1\xAF\xD3\x48\xD1\xA1\xD3\x06\xD3\xCE\xC9\x1F\xB0\xB2\xAD\x8A\xD3\xE1\xD3\x8D\xD3\x52\xCF\xE8\xD1\x39\xD2\xF9\xD0\xF4\xD2\xD5\xBF\x3D\xD2\xEE\xD1\xDA\x76\x52\xD2\xA6\xCE\x62\xB1\x46\xBD\x0B\xC7\x4B\x67\x0D\xC7\xEE\xD3\x1B\xD3\xF0\xD3\x70\xD3\x62\xD3\x42\xD1\x64\xD3\xB4\xD0\xC8\xC9\x9E\xD3\x10\xD3\xB8\xD0\x51\xD2\x92\xD0\x52\xCE\x94\xD0\x1F\xB6\x56\xD2\xF1\xC9\xF1\x8A\xB9\xC3\x15\xBA\x4E\xAB\xD2\xD3\xE6\xD1\x92\xD2\xA8\xBA\x82\xD3\x88\xD1\x07\xD2\x76\xD2\x98\xD2\x7B\xD0\x44\xC9\x31\xC5\x82\x77\x76\xBE\x02\xCA\x78\xBE\x62\x01\x27\xBA\x85\x72\x19\xD4\xF4\xD1\x1B\xD4\xD8\xBB\xF4\xD3\xEA\xD1\x84\xD2\x3C\xD2\x86\xD2\x24\xD2\x9A\xD2\xA9\xB7\x8A\xD2\x7C\xD2\xCD\xC1\x15\xCA\x18\xD4\x04\xD4\x61\xD3\x71\xD1\x2B\xD2\xF2\xD2\x6F\xB6\xF6\xD3\x1A\xC0\xF8\xD3\xF7\xD2\x79\xD2\x87\xCD\x25\xC5\x79\xBD\x24\xCA\xE5\xC3\x8E\xD2\x3C\xD4\x20\xBC\x71\xD3\xCE\xCC\xC9\xD0\xC8\xD3\x9B\xD1\xCF\xD1\xE9\xD3\xB1\xD3\xA2\xD3\xA0\xD1\x1C\x73\x83\xBD\x9C\xB1\x5F\xC7\xF5\xC3\x65\x68\x3F\xCE\xA5\xD2\x26\xCF\x06\xD4\x1F\xD3\x08\xD4\x44\xD1\x66\xD3\xBF\xD1\xBD\xD3\xE3\xD2\xAE\xD2\x10\xD1\x8E\xCF\x1B\xCF\x98\xBD\x02",
"\xC4\x01\xD1\x70\xC7\xA2\xD2\xBB\xCA\x4F\xD4\x63\xD4\x9A\xD3\x98\xD1\xC7\xD3\x62\xD2\x4D\xD2\xCA\xD3\x21\xD0\xD4\xCC\x27\xCC\x42\xC6\x07\xC2\x00\xC4\xDC\xC8\x35\xCF\xC7\xC2\x07\xD3\xC9\xC2\x17\xD1\x3A\xAD\x60\xD4\xB8\xD2\xE2\xD3\xCA\xD1\xE4\xD3\xDD\xD1\x0A\xD4\x68\xD4\x68\xD3\xBE\xD3\x86\xD3\xD4\xA9\xD2\xC2\xD7\xC0\x8C\xC7\x49\xCF\x93\xA9\x83\x69\x8A\xD4\xCC\xD2\x2E\xD4\x01\xBC\x1D\xD4\x95\xD2\x1F\xD4\x93\xD3\x21\xD4\x87\xD2\xEB\xC8\xB0\xBA\xAE\xC1\x3A\xD1\x44\xD2\x1B\xC6\x52\xCC\xC7\xAA\x9C\xD4\xDC\xD2\x9E\xD4\x1E\xD2\x94\xD2\x83\xD2\x92\xD3\x22\xD2\x34\xD4\x3E\xD2\xC2\xBA\xF9\xD2\x0F\xB0\xAE\xD4\xEF\xD2\x2A\xD2\x8F\xD3\x4C\xD2\xCB\xD0\xA3\xC8\x4F\xD2\x6B\xD0\xB6\xD1\x59\xB1\x0A\xAF\x6E\x53\xBB\xD4\xFC\xD2\xF1\xD3\x85\xD1\xCE\xD2\x2C\xD2\x1E\xD4\xD1\xD2\x42\xC9\x24\xBE\xFE\xD0\x90\xAC\x18\xD3\x09\xC1\xA6\xA7\xC8\xD4\x1D\xD3\xB7\xD3\x07\xD4\x8E\xD4\x65\xD3\xDE\xD1\xBE\xD2\xB4\xD1\x1E\xCD\xC4\xD4\x59\xD4\x98\x78\x14\xC1\xE4\xBD\x7C\xD1\xA5\xBF\x93\xD1\x7F\xD1\xD6\xD4\x3D\xD4\x62\xD4\x3F\xD4\xBE\xD4\x74\xCD\x38\xC8\x9F\xD3\x50\xD3\x16\xD2\xB2\xD3\x31\xCA\x3E\xD3\xB8\xCF\x69\xC6\xA3\xCF\x5A\xD3\xA5\xCF\x2B\xC1\x2A\xC3\x23\xAF\xD7\xD4\x32\xD3\xC4\xD3\xC7\xD0\xC6\xD3\x52\xD4\x7A\xD4\xC0\xD4\xB1\xC8\xC2\xD4\x65\xD1\x23\xD0\x26\xD3\x61\xC4\xC4\xC3\x7B\xC6\xCE\xC7\xA5\xCC\xFA\xD4\x44\xD3\xBC\xCC\x1D\xCE\xBA\xD4\xEB\xD4\xAD\xCF\x72\xD3\xAC\xD3\x67\xD4\x02\xD3\x69\xD4\xA0\xD3\x57\xD4\xEB\xD3\xB7\xD1\x59\xB9\x8D\xC6\xAA\x97\xFF\xD4\x48\xD3\xCA\xD4\xAF\xD1\xDB\xD4\x09\xD4\x58\xCC\xCF\xD4\x8F\xD0\x77\xD1\x3C\xC8\x0B\xC8\x4A\xBB\xAD\xD4\x16\xD5\x66\xCF\x73\xCD\x83\xC8\x06\xD5\x47\xCC\x08\xD5\x22\xD0\xCF\xD0\x05\xD0\x88\xD3\xD6\xC5\x78\x05\x24\xD5\x60\xD3\xEC\xD4\x80\xD3\xF3\xD3\xB2\xD4\x91\xD3\x96\xD2\x20\xD4\x8B\xD1\xD6\x92\xE3\xD1\x8D\xA7\x74\xD4\x61\xD4\x17\xD5\x51\xD4\x73\xD3\xE6\xD3\xCE\xD1\xDA\xD3\x7E\xB5\xDC\xD3\x08\xCD\xE2\xD4\xF5\x1B\x29\xC8\xA8\x64\x3F\xD5\x6F\xD3\x3E\xD4\x42\xD5\xF6\xD1\x44\xD5\x3A\xD2\x32\xD4\xF5\xD2\x45\xD4\x7E\xB7\xC2\xB5\xC3\xC4\xFF\xD1\xC4\xBA\x5B\xD5\x7E\xD3\x05\xD4\xED\xD4\x43\xD5\xA0\xD4\xB3\xD4\x46\xD5\xA3\xD4\x48\xD5\x6E\xCF\x15\xCD\xC0\x75\x6A\xD5\x8C\xD3\x6C\xD5\x5E\xD5\x38\xD2\x60\xD5\xF5\xD3\x62\xD5\xF7\xD3\xB6\xD4\xF9\xD3\x6E\x87\xC9\xB9\xC7\xD4\x32\xD5\xD9\xD0\x34\xD5\x93\xC8\x7B\xD4\xD2\xCC\x7D\xD4\xCC\xD3\x0A\xD5\xB7\x7E\x01\xC0\x26\x9C\x77\xD5\xA8\xD3\x26\xD5\xFE\xD2\x9B\xD3\x00\xD3\xD8\xD3\xCD\xBA\x55\xD4\x77\xD3\xEA\xD3\x79\xD3\xEC\xD3\xC6\x8F\x6F\xD0\x5A\xD2\x3E\xCE\x85\xD5\xEC\xCF\x7B\xD5\x6F\xD5\x45\xD5\xA2\xD4\xB5\xD4\x94\xD3\x22\xD4\x83\x8B\x7D\xD0\xB0\xB0\xCF\xAC\x5C\xB8\x5E\xBE\x8B\xCB\xB8\xC3\x46\xD2\xFE\xB9\x9D\x0B\x91\xD5\xD3\xD3\x93\xD5\x4A\xD3\x03\xD5\x50\xD5\x1A\xD5\x38\xD3\x92\xD4\x6A\xD4\xBF\xD3\x91\xA6\xDB\xC9\x4A\xB0\x11\xD4\x54\xBD\x4E\xB0\x5E\xCF\xF8\xB3\x99\xD0\x85\x72\xB6\xD5\x1A\xD4\x0B\xD3\x18\xD5\xBA\xD3\x97\xD5\x74\xCC\x53\xD5\xBC\xBF\x78\xD3\x9D\xB3\xA3\xD3\x10\xCA\x32\xC5\x6D\xCD\x1F\x74\xFB\xBB\x05\xCA\xA0\xD5\x01\x01\xCB\xD5\x2D\xD4\xCD\xD5\x4F\xD5\x19\xD5\xDD\xD4\x0F\xD3\xDF\xD4\xCE\xD0\xE1\xD4\x34\xC1\xD8\x9A\xBC\xD0\x3C\xC0\x3A\xD4\x3E\xC0\x70\xD0\x3E\xD5\xA2\xD5\x92\xB3\xCC\xD4\x41\xD4\xA3\xB9\xFA\xD0\x85\xD2\xA9\xD5\xA5\xD4\x36\xD4\x22\xBA\x22\xCA\x4F\xC7\x4A\xC0\xAD\xD0\x4C\xD5\x8B\xD4\xB8\xD5\xAA\xD3\xBA\xD5\xE3\xD5\x90\xD4\x1B\xD5\xBE\xD5\x1D\xD5\xF3\xD4\x58\xD4\xE9\xD5\x5A\xD4\x9D\xD2\x84\xBD\xF6\x02\xB1\xB0\x80\xCF\xAF\xCA\x75\xD4\x6D\xD5\x5F\xD5\xA5\xD5\x61\xD5\xB4\xD4\xF7\xD5\xA4\xD4\x67\xAF\xD2\xD4\xE3\xC5\x1D\xCF\xB8\xC2\x9B\xBD\x73\xD4\xB2\xCA\x14\xD6\x7A\xD5\x4B\xD2\xEF\xD4\xB3\xC9\x21\xC9\x73\xD5\xF2\xB0\x6C\xD4\x3C\xCA\x6E\xD4\x27\xA7\xB3\xAE\x36\xCF\xC8\xC2\x38\xCF\x88\xD4\x79\xB8\x23\xD6\x4D\xD5\x33\xD5\x98\xCF\x27\xD6\x92\xCD\xE0\xD1\x8B\xCF\x37\xCD\x5D\xBF\x97\xD4\xD6\xD2\xAA\xD4\x4A\xCF\x83\x69\x36\xD6\x01\xD6\x79\xD5\x8E\xD3\x6E\xD5\x90\xD3\x18\xD6\x71\xD5\xA8\xD5\x1B\xD6\xB7\xD4\x7E\xCF\xA7\xD4\x39\xD1\x5D\xCF\x6F\xCB\xE6\xAE\x60\xCF\xD3\xB5\x13\xD6\x37\xD6\x86\xD5\x39\xD6\x35\xD5\x75\xCD\x43\xCF\x2F\xD2\x78\xD2\xF2\xC0\xB9\xD4\xC4\xBA\x45\xD6\x9D\xD4\xE1\xD5\x24\xCD\x79\xD4\x9D\xD3\x91\xD4\xF1\xD4\xB0\xD3\x0A\xD6\x1F\xD5\xC5\xD4\xDE",
"\x98\x64\xD6\xAF\xD4\x66\xD6\xDA\xD0\x21\xD3\xCE\xD4\x23\xD3\x68\xCD\xF2\xB8\x67\xD1\x87\xC2\xB1\xD2\xF6\xB8\x07\xC3\x57\xC4\x9E\x75\x71\xD6\xBC\xD4\xDD\xD2\x65\xD4\x11\xD2\x51\xD5\x13\xD2\x1C\xD5\xF2\xD4\x3B\xD3\xD5\xD5\x57\xD5\xDD\x8C\x7A\xD1\x15\xC1\x41\xD3\x28\xC1\xBB\xCF\xD1\xC7\x67\xC4\xA6\xA7\x81\xD6\xC9\xD4\x47\xD6\xF2\xD3\x16\xD6\x4A\xD6\x7D\xD5\x19\xD6\x33\xD4\xF8\xD5\x35\xD4\x5A\xC7\xA0\xCC\xF7\xD4\x40\xD3\x0F\xD5\x59\xD3\xF2\xC7\x2D\xD3\x3C\xC1\xFD\xD4\x6E\x53\x96\xD6\xD8\xD4\x01\xD5\x34\xD3\x95\xD5\x36\xD3\xD0\xD5\x16\xCF\x97\xD2\x2A\xD6\x4B\xC7\xBA\xD0\x79\xD1\x34\xC3\xD1\xCF\xB7\xCC\xA5\xD1\xCF\xC7\x92\xD6\xF3\xC7\xBD\xCF\x5D\xD3\xAB\xD6\xF1\xD5\xCD\xB3\xF3\xD5\x30\xD4\xF3\xD2\x7E\xD5\x44\xD4\x80\xD5\x46\xD4\x61\xD6\xB8\xD1\x33\x70\xAC\xD6\x00\xD5\x8C\xD4\xDB\xD1\x28\xD5\x66\xD4\xE4\xD5\x0B\xD4\xE6\xD5\x50\xD2\x14\xCD\x4C\xC3\xF4\x74\xCF\xD6\x25\xD5\x98\xD6\xCB\xD4\x20\xD3\xCD\xD4\xA1\xD4\x2B\xD5\x85\xD3\x90\xD0\x83\x85\x06\xD0\xC2\xD6\x24\xD6\x48\xD6\x9A\xD6\xBF\xD4\x5D\xD6\x4D\xD0\x5F\xD6\x95\xD3\x4A\xD5\x64\x89\xDC\xD6\x40\xD5\x4E\xD5\x67\xD6\x04\xD5\x69\xD6\x07\xD6\x6B\xD6\x56\xD4\x6D\xD6\x9C\xD5\x9F\xCC\x53\x96\xA5\xD3\x49\x9A\xF3\xD6\x5C\xD5\x41\xD5\xEA\xD6\xA4\xD5\x9B\xD6\x31\xD4\x9D\xD6\x63\xD5\xCA\xD6\x65\xD5\x25\xD2\xFE\xD1\x13\x75\x02\xD7\x6B\xD5\x5D\xD5\x05\xD7\x26\xD6\x5C\xD6\xF0\xD4\x0C\xD4\xB5\xD1\x50\xC8\x48\xB1\x3E\xC8\x26\x9C\x10\xD7\x78\xD5\x12\xD7\x99\xD6\x06\xD7\xEC\xD6\x16\xD7\xD7\xD6\xC3\xD4\x81\xC1\x51\xD0\xA8\x64\x1D\xD7\x92\xD5\xDE\xD6\x27\xD5\x04\xD6\xCF\xD5\x86\xD6\x75\xD3\xE8\xD3\x9A\xD5\x1E\xD5\xFD\xD6\xDE\xD3\x52\xC8\x63\xD6\xC3\xD6\x76\xCF\xC5\xD6\x7C\xD5\x08\xD7\x4C\xD6\x1A\xD6\xB5\xD6\x0C\xC9\x53\xBE\xFD\xB9\xAA\x8E\x29\xD7\xB7\xD5\x2B\xD7\x94\xD5\x78\xD4\xF7\xD6\xBB\xD3\xE7\xD3\x88\xD6\x6C\xD6\x8A\xD6\xEF\xB3\xFB\xD3\xBB\xCE\xFD\xD3\x9F\xC1\xB0\xD5\xB1\xC1\x60\xBE\x02\xD4\x78\x05\x44\xD7\xCC\xD5\x99\xD3\x0C\xD3\x68\xD6\x4A\xD7\x52\xD5\x31\xD7\xDB\xD3\xD4\xD5\x4F\xD7\x0F\xD4\x71\xCE\x54\xD2\x12\xD4\xC6\xD5\x54\xD6\xFA\xC4\x5F\xCD\xF6\x88\x59\xD7\xE0\xD5\x5B\xD7\xCE\xD5\xD7\xD3\x2F\xD7\xD9\xD3\x60\xD7\x54\xD5\x62\xD7\xBD\xB7\x8D\xD1\x0D\xD6\xA8\xD0\x17\xC5\xDA\xD5\xAB\xD0\x3B\xB6\xFF\xD5\x6D\xD7\x02\xD2\x83\xD6\xD3\xD6\x85\xD6\xBC\xD5\x4E\xD3\x4C\xD7\xFB\xD6\x4E\xD7\x77\xD7\x66\xC3\xEA\xD5\x9B\xC8\xBD\xD0\x7E\xB0\xED\xD5\xC0\xD0\xB4\xD5\x58\xD7\x38\xD7\x57\xD0\x3A\xD7\x17\xD6\x9C\xD6\x3D\xD7\x9E\xD6\x4E\xD6\x81\xD5\xA1\xD6\x89\xD2\x49\xD4\x89\xCD\x47\x04\xDA\xC1\xEF\xD5\x49\xCE\xE9\xD6\x20\xD7\x14\xD7\x88\xD5\x36\xD5\x20\xD0\x38\xD5\x7E\xD4\x3A\xD5\xB7\xD6\x48\xD4\xBC\xC1\x99\xCD\x5D\xD4\x0A\xCF\x3A\x88\x86\xCE\x65\xD6\x6F\xD7\xE2\xD5\x2E\xD7\x85\xD7\xBC\xD3\x08\xD6\x89\xD6\x6B\xD4\x70\xB8\x11\xD1\x25\xC9\x2B\xCC\x1F\xD6\xE5\xC5\x72\xD4\xE2\xB8\xA6\xCA\x94\xD7\x8A\xD0\xF1\xD2\xC6\xD6\x42\xD4\xC8\xD6\x19\xB0\xF6\xD2\x25\xB3\x1D\xD6\xA3\xBD\x1E\x9E\x30\xD6\x85\xD4\x9D\xD5\x47\x73\xFE\x8C\x3A\xAD\xB5\xD7\x72\xD6\xB7\xD7\xF6\xD6\xBB\xD5\xD5\xD6\x6A\xD6\x17\xD7\xE0\xD4\xCD\xBD\x4B\xB2\x85\xA2\x41\xD6\x45\xCE\xAC\xC1\x2A\xD1\x79\xB8\xDA\xD7\x82\xD6\xB0\xD4\xCA\xD7\x3B\xD7\xC7\xD6\x09\xD7\x7F\xD5\x9F\xD6\x4F\xD6\xE8\xC4\x5B\xCF\xA8\xD4\x53\xD6\x0A\xC5\xBD\xB4\x3D\xD1\x33\x70\xEB\xD7\x97\xD6\x1F\xD7\xDF\xD6\x84\xD6\xBC\xD2\xDF\xD7\xF9\xD6\xE1\xD7\xE7\xD5\xBA\xBD\xBD\xBC\x26\x9C\xFD\xD7\xAD\xD6\xD1\xD6\xBA\xD2\x01\xD8\xDF\xD2\x03\xD8\xBD\xD5\xFA\xD6\x32\xD7\xFC\xD6\xD5\xD5\xEE\x7E\xDE\x98\x0A\xD8\xD0\xD6\x02\xD6\xD5\xD3\x2D\xD7\x71\xD7\xBA\xD7\x4B\xD7\xBC\xD7\x4D\xD7\xBE\xD7\xE1\xC5\xC0\xD7\x8F\xCF\xCD\xBC\xD4\xD4\x47\xC6\xA6\xA7\x18\xD8\xDD\xD6\xFF\xD7\x2C\xD7\xB0\xD6\x5D\xD7\xB2\xD6\xF6\xD5\x9A\xD7\x3F\xD7\xDD\xD3\x8C\xD6\x8D\xBC\x8E\xD6\xE5\xD4\x90\xD6\x3A\xC1\x93\xD6\xFB\xBA\x80\xD1\x6E\x53\x2A\xD8\xF4\xD6\x38\xD6\x72\xD2\x22\xD7\x28\xD6\x12\xCD\xB5\xC9\xA1\xC3\x35\xD8\xC5\x7E\x11\xB5\x24\xC3\xA5\xD6\xB9\xCC\xA4\xCF\x12\xD5\xA8\xCC\x29\xD8\xC8\xD7\xF3\xA4\x93\xD2\x97\xD7\x3C\xD7\xA7\xD5\x3E\xD7\x46\xD8\xB6\xD6\xFE\xD6\xF6\xD4\x98\x5E\x0E\xD5\xB8\xCC\x42\xD3\x4E\xD8\x7E\xD1\x80\xC6\xD7\xCF\x57\xD6\x3F\xD8\x03\xD7\xF5\xD6\x74\xD6\xE1\xD6\x70\xD5\x57\xD8\x32\xD8\x59\xD8\x0C\xC9\x5B",
"\xB7\xAA\x97\x66\xD8\x11\xD7\x04\xD7\xA6\xD7\x96\xD7\x07\xD7\xF0\xD7\x99\xD7\x0A\xD7\xF3\xD7\x9C\xD7\x71\xB5\xF6\xCF\x65\xD8\x52\xD8\x8C\xAE\xDD\xD7\x05\xD6\x2A\xD5\x77\xD6\x33\xD0\xC0\xD5\xA2\xAF\x3C\xD5\x16\xCD\x00\x00\x72\xD8\x1E\xD7\x74\xD8\x00\xD8\x83\xD7\x02\xD8\x06\xD6\x11\xD8\x05\xD8\xD8\xD6\xE2\xD1\x27\x9F\x83\x69\x8C\xD8\x2A\xD7\x2C\xD8\x47\xD7\xBC\xD1\xE5\xD3\x1E\xD8\x5F\xD7\x87\xD7\x13\xD8\x89\xD7\x57\xC9\x9A\xB9\xE2\xBF\xA8\x64\x99\xD8\x45\xD7\x9B\xD8\xB9\xD5\x2E\xD8\x49\xD7\x30\xD8\x43\xD4\xCE\xD7\x64\xD5\xB0\xB3\xFD\xD1\xB4\xAA\x09\xD8\x80\xD8\x01\xB0\x82\xD8\xB9\xD7\x10\xD8\x86\xD7\x20\xD8\x88\xD7\x6A\xD3\xC5\xAA\x45\xD0\x0F\xB0\xA8\xD8\x5A\xD7\xD9\xD4\x64\xD4\x90\xD8\x0F\xD8\x92\xD8\xBB\xD8\x12\xD8\x61\xD7\x9B\xD5\x15\xD8\xF9\xBF\xD0\xD3\xA7\xD8\xB6\xD8\x6B\xB6\x69\xD8\xF4\xD5\x96\xBA\xAF\xD8\x5B\xB3\xCF\xD7\xB2\xD8\x66\xD5\x26\xD2\xDF\xD3\x49\x9A\xC2\xD8\x6E\xD7\xC4\xD8\x77\xD4\x9D\xD8\x8F\xD4\x84\xD8\x84\xD3\x84\xCD\x94\xD4\xFA\xC0\xCF\xC9\x42\xD7\x3E\xD8\xD1\xD8\x67\xBA\xB8\xD7\x1D\xD8\xBA\xD8\xBB\xD7\xCA\xD8\x75\xD7\xCC\xD8\x63\xD7\xC2\xD5\xB4\xBD\x7F\xD0\x48\xCD\xE7\xD7\xCA\xAD\x97\xB7\x84\xD0\xEB\xD8\xA5\xD7\x8F\xD8\x1C\xD8\x9E\xD8\xF0\xD8\x1F\xD8\xF2\xD8\xD3\xD5\xF4\xD8\x83\xB7\x50\xD7\x3C\x6E\x0C\x6E\xB9\xB4\x7D\xC8\xE8\xCA\x15\xD4\x22\xC7\x92\xD7\xC7\xD7\xFF\xD8\x2D\xD8\x48\xD7\xDE\xD7\xC8\xD8\xF1\xD8\x94\xD8\x25\xD7\xEF\xBD\x78\xD7\x44\xA2\x16\xC5\xC6\xC3\x62\xBD\x04\xCA\xAC\xD0\xA3\xD7\xA3\xCA\xEC\xD8\x5E\xBB\xEE\xD8\x02\xD9\x17\xD9\x04\xD9\x19\xD9\x09\xD5\xAD\xD7\x5B\xD8\x7A\xD2\x38\xD4\x6E\xBD\x28\xC5\x95\x86\xDE\xD8\x81\xD7\xED\xD7\x40\xD4\xCB\xD7\xF5\xD5\xD6\xD8\x4C\xB4\x7B\xD8\xCB\xD6\x9D\xD7\xBB\xD0\x90\xBE\xAA\xC8\x4D\xBA\x8D\xD2\xC2\x76\x34\xD9\x36\xD2\x36\xD9\xEE\xD4\x15\xD7\x44\xD8\x5C\xD0\x6E\xD8\x34\xD8\x0C\xD6\x1D\xD9\xE3\xC1\x9E\xD2\x55\xB4\x9F\xBE\xF5\xA6\xDE\x98\xAC\xCE\x46\xD6\xAA\xD8\x03\xD6\xAC\xD8\x16\xD9\xE4\xD8\x75\xD1\xD0\xD4\xCE\xBF\xD1\xD7\x82\xD4\x19\xB2\x75\xB8\x31\xD6\x88\xC1\x8F\xBC\x64\x89\x56\xD9\xB6\xD7\xE0\xD8\x5C\xD7\xAD\xD8\x72\xD7\x98\xD5\xD2\xD5\xF6\xC2\xFD\xC3\x7A\xD6\x15\xD3\x7C\xD6\x83\xD4\x89\xBA\x13\xC4\xA7\xBD\xCB\xB0\x34\xD6\x4B\xD5\x68\xD9\xDB\xD7\x6A\xD9\x70\xD7\x28\xD9\x5C\xD9\x5E\xD6\xD2\xD2\x69\xC9\xD4\xD2\x3B\xCC\x27\xD1\x42\xD6\x9A\xD4\x65\x68\x7C\xD9\xEC\xD7\x73\xD6\x87\xD5\xA1\xC8\xA9\xD7\x69\xD0\x4E\xD0\xD3\xD2\xF9\xC6\x51\xD6\xE1\xC2\xA9\xD4\xFA\xD8\xE8\x7D\x35\xC4\x26\x9C\x8B\xD9\xFE\xD7\x8E\xD8\x14\xD9\xE2\xD8\xDC\xD4\x29\xD9\xA0\xD8\xBC\xD8\xA2\xD8\xBE\xD8\x28\xC6\xC0\xA9\x0E\xC9\x9B\xD9\x25\xD9\x95\xBB\x27\xD9\xE3\xD8\x4C\xD0\xF6\xCC\x92\xD9\x84\xD9\x94\xD9\xF9\xC2\x73\xD4\x9C\xD9\x0B\xD8\x1A\xD8\xE3\xD3\x01\xD9\xAE\xD9\x74\xD1\x82\xD9\x5E\xD9\xD7\xBF\x60\xD9\x16\xD3\xF7\xB0\x7E\xD6\x92\xCF\xE5\xBA\xF3\x53\xB6\xD9\x19\xD8\x46\xD7\xAB\xD8\x15\xD9\x83\xD8\xAF\xD9\x63\xD1\xB1\xD9\x5C\xCC\x73\xBE\x0C\xD5\xE1\xAC\x56\xC6\x49\xC9\x7E\xC6\x62\xD8\x5A\xC6\x4D\x8A\xC7\xD9\x2B\xD8\x9E\xD9\x9C\xD8\x53\xC7\x84\xD7\x03\xD9\xA3\xD9\x05\xD9\x70\xD9\x30\xD2\xD1\xD9\x8C\xCC\x34\xC9\x4B\xD8\x5F\xD8\x91\xD6\xA7\xD1\x3B\xD8\xBD\xCF\xAA\xD6\xC6\xD9\xAB\xD9\x5E\xD1\x7F\xD9\xBB\xD9\xD0\xD2\x85\xD8\x69\xD3\x87\xD8\xCE\xCF\xB8\xD6\x83\xC4\x5A\xC9\xD5\xD9\x43\xD3\xD7\xD9\x53\xB7\xC1\xD6\xEF\xD9\x13\xD9\xDD\xD9\xE4\xC8\xEF\xD7\xCC\xD7\xF1\xD7\xC9\xD6\x3C\xD9\x0C\xD7\xCC\xD6\x21\xD5\x14\xB3\xC7\xAA\xDA\xD9\x40\xD8\x5A\xD6\x42\xD8\x3A\xD6\x40\xD0\x3C\xD6\xC0\xD2\xD9\xD6\x60\xB7\xF4\x74\x0F\xDA\x67\xD8\x41\xD8\x81\xD2\x43\xD8\x3B\xD6\x29\xD6\x4C\xD9\x08\xCD\x57\xC1\x89\xD3\x9D\x0B\x1A\xDA\x73\xD8\x68\xD8\x8E\xD9\xAF\xC8\x90\xD9\x4E\xD2\x64\xD1\x39\xD5\x5E\xC1\x78\x80\xD9\xBF\xE9\x86\x26\xDA\x8D\xD8\x28\xDA\x5B\xD6\xA8\xD7\xED\xD6\xB0\xD9\xEF\xD6\xAA\xD5\x78\xD1\xFB\xCC\x69\xC1\x49\x9A\x33\xDA\x9A\xD8\xDC\xD9\xCA\xD9\xA0\xD9\x29\xD5\xCD\xD9\xC1\xD4\x2D\xDA\xAC\xD7\xC4\xD4\xB4\xB5\xC0\x75\x40\xDA\xA9\xD8\x42\xDA\x59\xD9\xCB\xD9\xB9\xD8\xA2\xD9\x87\xD6\xA4\xD9\xCB\xD8\x33\xD7\xD5\xD5\x75\xD5\x33\x70\x4D\xDA\xC3\xD8\xAE\xD6\xB8\xD3\xBA\xD9\xA1\xD9\x81\xD9\xEE\xD6\x83\xD9\xD0\xD9\x68\x8E\xCF\xD3\x4F\xB1\x0F\xB0\x5B\xDA\xDF\xD8\x5D\xDA\xDA\xD4\x5F\xDA\x45\xDA\xBC\xD9\x62",
"\xDA\xBE\xD9\x64\xDA\x2E\xD5\x8F\xD5\x6E\x53\x69\xDA\x35\xD9\x8D\xD9\x36\xDA\x8F\xD9\x38\xDA\xCE\xD9\x3A\xDA\xF9\xD5\xF5\xD7\x5D\xC8\xC2\x76\x76\xDA\x46\xD9\x78\xDA\x12\xDA\x49\xD9\x1F\xDA\x45\xD8\x57\xD1\x6E\xCF\x09\xD9\x0A\x91\xFE\xD3\x3D\xCC\xCC\xA8\xE1\xC9\xF8\x8E\x82\xDA\x5D\xD2\xDC\xD7\xD3\xD8\x38\xD9\xD5\xD8\xCD\xD7\xD7\xD8\xB1\xD8\xB2\xB5\x9C\xB7\xAC\xD5\x61\xB1\x0B\xD9\x0C\xB7\x0D\xD9\xE6\xBB\x49\xBD\x10\xD9\xAA\x8E\x92\xDA\x70\xD2\x84\xDA\x1D\xDA\x13\xDA\x55\xD1\x20\xDA\x89\xDA\x47\xD8\x4E\xD9\x1F\x77\x1E\xD9\x27\xD4\xC7\xC3\xC0\xC1\xDC\xD5\x11\xD9\x7C\x1F\xF0\xD9\x50\xD4\xB8\xD8\xEF\xD8\x53\xDA\x30\xD7\xA1\xD8\x56\xDA\x14\xD8\x0A\xB4\xAF\xDA\xA6\xB0\x7B\xD2\x31\xD9\x7D\xCD\x95\x86\xA6\xDA\x91\xD2\xA8\xDA\x54\xD8\x77\xD8\x06\xDA\x79\xD8\xF2\xD7\x9B\xD7\x3D\xD9\x23\xD4\x21\xCA\xD8\xD5\xFD\xD5\x26\xCA\x60\x91\xC8\xDA\xDF\x79\xCA\xDA\x1C\xD4\xCC\xDA\x39\xD9\x98\xDA\x3B\xD9\xD0\xDA\x0A\xDA\x3E\xD9\x2F\xD9\x9F\xD7\x5B\xA2\xF3\xC3\x9A\xCD\x69\xAE\x12\x5A\x91\xCA\xAD\xCD\x9C\x4B\x7A\x49\x69\xD7\x3B\xCE\x1A\x59\x5E\xD4\x3A\x88\xEA\xDA\x57\xD9\x4F\xDA\x1B\xD8\x5A\xD9\xCC\xD9\x6F\xDA\x39\xDA\x63\xDA\x71\xD9\x80\xD4\x13\xC2\x61\xD9\x74\xB8\x19\xCC\xC0\xA1\x66\xD9\xE0\x59\xB8\xDA\x76\xD4\x6B\xD9\x5B\xD9\x46\xDA\x07\xD5\x48\xDA\x8C\xD5\x7D\x7B\x72\xD9\xF3\xC5\xC8\xC0\x2C\xCC\x77\xD9\x3C\x73\x81\xC7\x4B\xD5\xF3\xDA\x69\xD9\x6B\xDA\xC5\xD8\x6D\xDA\xD4\xD6\xBC\xDA\x73\xD7\xBE\xDA\xF3\xD8\x57\xDA\xEF\xB3\x01\x70\xD5\xD2\x4D\xB2\x88\xD9\x3F\xCC\xCD\x74\x16\xDB\x7D\xD9\x18\xDB\xE1\xD8\xDE\xD9\x91\xD8\x61\xDA\xFA\xDA\x71\xDA\x7D\xCF\x7F\xDA\x95\xD9\x02\x78\x97\xD9\xC7\xD5\xC0\xBD\x56\xD6\x26\x9C\x28\xDB\x8C\xD9\x94\xDA\x29\xDA\xA1\xC7\x63\xD2\x28\xCD\xCB\xD3\x2A\xCD\x98\xC8\xC9\xCC\xA8\xC7\xA8\x64\x3A\xDB\x9D\xD9\x35\xDA\x85\xDA\x37\xDA\x23\xD7\x15\xDA\x11\xD3\xE3\xD7\xE1\xB8\x83\x69\x47\xDB\xB7\xD9\xC9\xD9\x50\xDA\x44\xDA\x1B\xDB\x2E\xDB\x7C\xDA\xFB\xDA\x1E\xC4\xC0\xD9\x74\xD9\x17\xD3\xF7\xB8\xDA\xBD\x4D\x8A\x52\xDB\xC8\xD9\x58\xD9\xF6\xDA\x51\xDA\xBB\xDA\x58\xDB\x47\xDA\xCF\xD9\x31\xDB\xD2\xDA\xE6\xD9\xD3\xD9\xA2\xCF\xFC\xD9\x61\xD8\xE8\xD4\xFB\xBC\x3D\xD8\x4E\x5A\x05\xDB\x15\xD6\x21\xD7\xAA\xDA\xDF\xD1\xAC\xDA\xE1\xD1\x8C\xD1\x8B\xD7\x67\x9C\x23\xC3\x90\xD1\xE6\xD4\x4A\xC9\xFE\xD9\x6D\xC6\xA6\xA7\x62\xDB\xDB\xD9\x49\xDB\xA9\xDA\x86\xDA\x14\xDA\x7B\xDB\x3D\xD6\x22\xC1\x1C\xD9\x98\xA5\x59\xC9\xB6\xCC\xA4\xD1\x2A\xD3\xBD\xD6\xEB\xD9\xBF\xD6\xA9\xD1\x8C\x8A\x5F\xC9\x0F\xB0\x87\xDB\x10\xDA\xA3\xD5\xA7\xD7\x7A\xDA\x4C\xDB\x8D\xDB\x16\xDA\x0E\xBE\x70\xD8\x49\x9A\x9D\xDB\x1B\xDA\x11\xDA\x8A\xDB\x4B\xDB\x4A\xD9\x8A\xD1\x21\xDA\x56\xCD\x4F\xC1\x33\x70\xA8\xDB\x27\xDA\x1C\xDA\xCB\xDA\x1E\xDA\x8C\xDB\x88\xDA\x7C\xDB\x58\xD1\xE7\xD6\x75\xDB\x02\xDA\x43\xDA\x2C\xDB\xC7\xD8\x68\xDB\x0A\xDB\x6A\xDB\x1E\xC4\x96\xD3\x58\x0E\x76\xDB\x25\xD6\x76\xD8\xB7\xDB\xAB\xDA\xB9\xDB\x8E\xDB\x7D\xDB\x9B\xD2\x0B\xB6\x00\xD7\xC7\xAA\xB3\xDB\x34\xDA\xB5\xDB\xDB\xDA\xCB\xDB\x7A\xDB\xCD\xDB\xA4\xDB\xC2\xC9\xE9\xBF\x13\x75\xD4\xDB\x41\xDA\x89\xDB\xB6\xDB\x79\xDB\xDE\xD4\x4D\xDB\x0D\xD4\x17\xDA\x1A\xD7\xDE\xDB\xC8\xDB\x13\xD7\xCA\xDB\xE3\xDB\xE5\xD5\xE5\xDB\x18\xD7\xF8\xBF\x83\xD5\xBD\xDB\x59\xD6\x9F\xDB\xEC\xDB\x8B\xDB\xCC\xDB\x4B\xD9\xAD\xDA\x5A\xD8\x35\xD7\xE9\xDB\xBE\xDB\x55\xDB\xC0\xDB\x75\xD6\xE2\xD6\xF5\xD9\x93\xD4\xE5\xD6\x18\xC9\x3C\xBD\xEA\xD8\xF3\xDB\xF4\xDA\xE1\xDB\xD7\xDB\xED\xDB\xD6\xD6\xEF\xDB\xE2\xD7\xBC\xBB\x8B\xDA\xC7\xAD\xF9\xD8\x36\xDB\x58\xD5\x90\xDA\x60\x91\xDF\xDB\x4E\xDA\x0B\xDC\x2F\xD4\x05\xDA\xDD\xDA\x07\xDA\xB0\xD8\x0B\xD7\xD9\xD8\xFA\xD3\x64\xD7\x53\xD2\xC4\xD5\xEF\xC9\x13\xD4\x5D\xCD\x0F\xD9\x59\xD2\xB6\xDA\x91\x0E\xEA\xDB\x75\xD8\xE0\xD6\xD4\xD8\x32\xBB\x3A\xD9\x6C\xB8\xD8\xD8\x9B\xDA\x88\xD2\x3F\xD9\x91\xB1\x6B\xD2\xB0\xA6\xC1\xC1\xDD\xD5\x2D\xDC\xFE\xDB\x65\xDB\x56\xDB\xDF\xD9\x1C\xDB\x6E\xD9\x74\xD7\x06\xD9\x20\xDB\x8A\xD7\xD0\xDB\x4F\x96\xEB\xD5\x7C\xCD\xD6\xC3\x95\x86\x19\xDC\x5C\xDA\x0C\xD8\xC5\xD3\xF7\xDA\x52\xDA\xC2\xDB\x37\xD5\x0B\xDB\x42\xDB\xCD\xD3\xF8\xD9\xAF\xD7\x8B\xC8\xD5\xDA\x4D\xD4\xFF\xD5\x4F\xDC\x6A\xDA\x51\xDC\x02\xD5\x53\xDC\x67\xDB\x09\xDB\x56\xDC\xC4\xDB\x60\xD6\xE2\xDA\x5B\xDC\x00\xCA\x9D\xBE\xE6\xDA\xE4\xC3\xE7",
"\xCC\x01\x01\x29\x00\xF0\xD0\x4E\xAE\xDA\xB1\x02\x01\x2A\x00\xF7\x53\xEA\x7E\x72\xDC\xA4\xC1\xD8\x4F\xA8\x4E\x33\x02\xDD\x50\x90\x28\x85\x51\x87\x07\xE7\x4F\xBF\x30\xBD\x49\x1E\x03\xC3\xCE\xE2\x9F\xB0\x4E\x08\xCF\xC3\x5C\xA0\x5C\x77\xDC\x39\x6C\x7A\xDC\xD8\xC4\x7C\xDC\xE0\x50\xFB\x03\xC4\x6B\x81\x51\x93\x07\x87\xDC\x17\xC6\x81\xDC\x93\x07\xB0\x49\x26\x83\x88\xDC\xED\x4F\x99\xA3\xB0\xA3\xEA\x0A\xA9\xCD\x6E\xC2\x2B\x00\xAE\xCA\xA4\xDC\x83\x6D\x02\x01\xA6\xDC\x11\x9A\x89\xDC\x01\xCE\xDE\x80\xEB\x49\x15\x51\x66\x5C\x9F\x4E\x83\x49\x92\x03\x8B\x54\xA9\xDC\x54\x54\x8F\xDC\xD0\x54\x8F\xDC\x00\x95\xAB\xDC\x0A\x01\x37\x66\x89\x29\xB0\xDC\xEA\x50\xF6\x02\x01\x4A\x66\xCA\x11\x58\xC7\xCE\x5C\x74\x99\xDC\xC1\xDC\x92\x03\xCF\xC1\x1D\x4A\x6B\xA2\xF2\x0A\xAE\xCA\x30\x00\x88\xC5\xCF\x77\xC7\xDC\xA0\x4E\xFB\x03\xCA\xDC\xE4\x50\x58\x25\xCF\xDC\x7B\xDC\x10\x4B\x7D\xDC\x6D\x01\x0E\x55\x22\x82\x38\x4A\x94\xC4\x91\xDC\xEB\x50\xF4\x10\x9A\x5D\xA3\x05\x8D\xDC\x44\xB1\xB5\xDC\xDE\x80\x1D\x4A\x7F\xDC\x90\x07\x57\x04\x8C\x49\x83\xDC\x8F\x01\x85\xDC\xEA\x4F\x15\x37\xC7\x6B\xBB\xDC\x3C\xCE\xEA\x5A\xE6\xDC\x0A\x54\xE8\xDC\xC5\xC4\x1D\x4A\x94\xDC\xC0\xDC\x01\x03\x97\xDC\x6A\xBF\xD2\xDC\xBE\x01\x9B\xDC\xF3\xDC\xB9\x8C\xF5\xDC\xE8\xD0\xF6\xDC\xDA\xB7\x89\x25\x33\xCE\x70\x84\x1B\x0A\x73\xDC\xAB\x59\xD8\x73\x31\x00\xC5\xDC\x60\x5E\x02\xDD\x94\x07\x2E\x4A\xD5\xDC\x11\x4B\xCC\xDC\x01\x01\x5E\x5C\x70\x55\x1C\xDD\xB3\x73\xED\x50\xFE\x4C\xCA\x4F\xFA\x6D\xB1\xDC\x16\xDD\xF4\x10\xFF\x04\x1C\xDD\xCA\x80\xFE\xDC\xFD\x31\x2E\x4A\xDD\xDC\x4A\x59\xC9\x4A\x6A\x80\xB0\x80\x57\x04\x4A\xAE\x75\xDC\x01\x01\xF8\xDC\x33\x6F\xD8\xDC\x90\xDC\xDA\xDC\xBC\x4E\xF4\x10\x78\x05\xB9\xDC\xE9\xDC\xD6\xDC\xEB\xDC\x0B\x03\xEE\x50\x47\x04\xEF\xDC\x1E\x03\xF1\xDC\x7C\x7C\xF4\xDC\x9E\xDC\xA1\xA3\xFD\xB1\xEC\x64\x36\xDD\x20\xBE\x38\xDD\x29\xDD\xE1\xDC\xF9\x4A\x3C\xDD\xD0\x57\x77\xA2\x2A\xDD\x8D\x49\x6D\x01\xFD\xDC\x52\xDD\xFF\xDC\x9C\xDC\x98\xDC\xE3\x50\xBA\x49\x04\xDD\x0E\xA3\x9D\xDC\xE1\x4F\x9F\xDC\x33\xDD\x4D\x62\x5E\x80\x62\xA2\x7C\x51\x8B\x5C\x89\x80\x31\xDD\x06\xCC\x24\x81\xC7\x80\x39\x6C\x28\xDD\x83\x56\xA5\x80\x3E\x61\x76\xA2\x21\x81\x7F\x17\xDE\x09\x71\x80\x01\x42\xAC\xA2\x24\x52\x67\x53\x38\xCD\x65\x94\x31\xDA\x55\xB1\x72\xDD\xA7\x56\x74\xDD\xF8\x7B\xCE\x80\xA3\x8E\x0C\x81\x40\x21\x72\x5B\xE8\x80\xA2\x5C\x83\xDD\x30\xDD\xBB\x80\xFE\x4C\x14\x81\x7B\xA2\x1D\x8C\xE6\x80\x64\x94\xF5\x80\x0A\x54\x8E\xDD\x7C\x80\x90\xDD\x6C\x80\x0A\x81\xCF\x80\x60\x5C\xDB\xCE\xA2\xC2\x50\x5A\x9D\x80\x9F\x80\x23\x01\x34\x52\x03\x81\xBB\x4B\xD7\x5A\x99\xDD\x6C\xDD\x9B\xDD\x8B\x80\x20\x81\xE3\x80\x9F\xDD\x94\xDD\x40\x01\xAC\x80\x47\xD2\xA9\xDD\xF7\x53\x79\x51\xA7\x0F\x48\x33\x92\xDD\xC7\xA3\xD1\x80\xDF\x4F\x55\x52\xA6\x4E\x50\xDD\x6C\x82\xAA\xDD\xAE\xCD\xAC\xDD\x61\x07\x18\x81\x9C\x4B\xB5\xDD\xAF\x63\x85\xDD\xCD\x80\xA8\x80\xBB\xDD\x67\xA2\xD0\x96\x06\x0A\x34\x00\x0F\xDD\x08\xDD\xEC\xD0\x0C\x0A\xBF\xDD\xD2\xDD\xEA\x6B\x06\x0A\x54\x69\xF8\x8B\xF1\xDA\x59\xC1\xF3\x53\x57\xDC\xCC\xCF\x30\xCF\x2C\xD6\x14\xD3\x0F\xDB\xC5\xD2\x00\xD1\x6F\xC7\x9F\xAE\x8F\xBD\x6E\x53\xDF\xDD\x66\xD2\xE1\xDD\xBF\xD7\x6D\xD4\xFF\xD0\x14\xD1\x7F\xC7\x64\x94\x14\xDB\x4C\xBD\xEB\xDD\x31\xB6\x43\xDB\xF7\xC5\xD6\xC0\x4C\xB2\x5F\xBF\x98\xD9\x29\xD1\xD9\xD2\xDD\xDD\x02\xD0\x1A\xD9\x48\xC4\x17\xC6\x5C\xCF\xE9\xD2\xAA\xD4\x35\xC4\x83\xBC\xF6\xDD\x6D\xCF\x8B\xC6\xC8\xBD\xEA\xDD\x68\xDC\x99\xD2\x32\xDB\xB4\xD9\xE9\xDD\xDE\xDD\x0F\xDE\xAD\xAE\x5C\xDB\xC4\xD2\xAA\xB2\x5F\xDB\x28\xC9\x4D\xC3\x8B\xD5\x58\xDC\x8D\xD5\x27\xC8\x6D\xDB\x3F\xD3\x35\xC9\xBC\xD6\x10\xD5\xA7\xD6\x5B\xD3\x94\xD6\xB1\xAC\xAE\xC0\x0A\xDE\x55\xD5\x56\xCD\x48\xD8\x4B\xB7\x80\xDB\xD7\xA7\x91\xD1\xE7\xD4\xD5\xCF\x94\xD1\x29\xDE\x0E\xDE\x7D\xDA\xA0\xD6\x6C\xDB\xA2\xD6\x5D\xD8\xFB\xD9\x32\xDE\x83\xDB\x72\xDB\xD8\x99\x81\xC6\x09\xDE\x15\xDE\x7E\xDA\x6A\xC9\x6C\xD3\x90\xBC\xAB\xD7\x0C\xDB\x4A\xDA\xDA\xD6\x68\x5A\x65\xD2\xF7\xDD\x59\xDC\x36\x78\x55\xC3\x1F\xB7\x2B\xDE\x76\xD7\xD8\xBF\x9C\x85\x7D\xBD\x4E\xDE\x0B\xDE\xFB\xDB\x2E\xDE\x4A\xCD\xD2\xDB\x9E\xBC\x49\xDE\x1E\xDE\x2D\xD9\x09\xCD\x33\xC8\x3F\xBE\x60\xDE\xE0\xDD\x50\xDE\x34\xBE\x8A\xB3\x43\xDE\x38\xDE\xF4\xD7\x69\x7F\xD2\xB5\x6B",
"\xDE\x5A\xDB\x69\xDC\x4C\xBE\x2D\xCD\x70\xDE\x30\xDB\xE4\xD9\xB3\xD9\x98\xC3\xA6\x7E\x6F\xBE\x54\xDE\x07\xD9\x1D\xC0\xF6\xD8\x1D\xB6\x5C\xBE\xDE\xC9\x44\xD2\x4B\xCD\xDA\xBF\x41\xDB\x67\xDE\x1F\xDE\xAC\x9F\xB2\xC3\x44\xBD\x66\xD7\xC5\xD5\xF6\xB3\x15\xDC\xA2\xC1\x6B\xD7\x85\xDE\x1D\xDE\x87\xDE\x62\xDE\x5C\xDE\x9C\xD2\x7A\xD7\x1F\xD9\x8E\xC8\x64\xBD\x0F\x52\x7B\xDE\x44\xDE\x39\xDE\xE5\xD9\x97\xCD\x30\xD9\x9C\xC8\x8F\xD7\x29\xB4\x56\xBF\x59\xDE\x2C\xDE\x9F\xD1\xC2\xDA\x35\xB6\x40\xD9\xD3\xD0\x43\xD9\x6E\xBE\x37\xDE\x71\xDE\x10\xDE\x3A\xDE\x9E\xD7\xB0\xD7\xB8\xC8\xCC\xB7\x13\xA0\xCC\xCC\x00\x64\xDB\xDD\xB3\xD7\xAD\xC8\x2C\xC9\xD8\xDB\xE4\xDB\xA3\xDB\x4E\xDB\xB1\xC2\xE2\xDD\xC7\xC8\x7B\xD6\x18\xDE\x98\xBC\xC3\xD7\x71\xD4\xE8\xDD\xAE\xC9\x50\xC9\x55\xD8\x78\xD8\x6C\xD8\x7A\xD8\xE0\xDA\xB0\xB3\x17\xDE\x65\x5E\x10\xDB\xF1\xDD\x2D\xCC\xF3\xDD\xCA\xC2\xCB\xC6\x2A\xCA\x9F\xD8\x54\xDA\xE2\xD9\xFC\xD0\x9F\xDE\xB3\xD9\x26\xD1\xD8\xC0\xEA\xD2\xEB\x66\x48\xA7\x0F\xC9\x6F\xC9\xBF\xDE\xEE\xDB\xC1\xDE\xE6\xDB\x03\xDE\xF6\xD7\x52\xD6\x06\xDE\xFD\xDD\x3C\xD1\x51\xCC\xE4\xB0\x6B\xA4\x89\x6B\x09\xCA\x4B\xD6\xD0\xDE\xCF\xDA\x33\xD8\x22\xDA\xBD\xBC\x1C\xC5\xDC\xDE\xE0\xD9\xDE\xDE\x2B\xD9\x2E\xDA\x4F\xDB\xB3\xC7\x10\xA7\xDB\xDE\xF8\xDE\x98\xD7\xFA\xDE\x08\xDA\xD2\xDE\xB2\xB5\xD4\xDE\x1A\x62\x26\xC9\x84\x99\xC4\xD9\x13\x75\x00\xDF\x43\xDC\xD1\xD5\x45\xDC\xE3\xD9\x72\xDE\xA0\xDE\xB7\xCF\x98\x5E\xD4\xD9\x3E\xDE\xD6\xD9\x40\xDE\x93\xCC\x59\xAF\x26\x9C\x15\xDF\x55\xDC\xAA\xD7\x7C\xDE\x47\xDC\xA4\xD8\x54\xC6\x6E\xDB\xA4\xD6\xE9\xD9\x3A\xD8\x98\xDB\xE3\xC7\x35\xB5\x14\xDF\x09\xDF\x56\xD8\xE3\xD6\xE6\xD8\x05\xDC\x78\xC6\x54\xD3\x7A\xC6\x3D\xDE\x82\xDB\x20\xDF\x34\xDE\xB7\xBF\x64\xD8\xFF\xDE\x34\xDF\xCF\xDE\x36\xDF\x24\xD3\xE7\xD8\x6B\xD3\xE6\xCF\x0D\xC5\xF7\xDE\xC7\xC9\x26\xDF\x91\xD9\x6C\xDE\x7C\xD8\x97\xC6\x7E\xD8\x42\xDF\x4C\xDF\x66\xDC\x27\xDF\x9E\xDE\x6D\xDE\xF9\x7A\x55\xC3\xD8\xC3\x25\xDF\x55\xDF\x4E\xDF\xB1\xDE\xAD\xAE\x37\xB1\x08\xDF\x54\xDF\xF9\xDA\x59\xDB\x76\xDE\x1A\xDF\x3C\xDA\x25\xD0\x3E\xDA\xF6\xDE\x00\xDC\x6A\xD8\xA6\xD5\x45\xDF\x78\xD6\x47\xDF\x32\xC8\xC4\xC4\x9A\xCE\x78\x6B\x43\xDF\xCD\xDA\x0B\xDF\x20\xDC\x09\xDA\x22\xDC\xC2\xC4\x3D\xC8\x09\xCE\x75\xDF\x63\xDF\xF4\xD9\xE5\xD8\x46\xDF\x38\xDF\x6C\x9A\x27\xD7\x58\xCE\x4B\xDF\xBD\xC9\x01\xDF\xBD\xDA\x55\xDA\x1F\xDB\xC0\xDA\xC7\xBF\x51\xC8\x7E\xDF\x88\xDF\x8E\xC9\xDD\xDE\x8B\xDF\xDF\xDE\x35\xDC\xD4\xC0\x06\xDC\x59\xB1\x9F\xD5\x2E\xCD\xBE\xDE\x0D\xDC\xE0\xD7\x24\xD7\x2C\xD9\xC4\xD4\x12\xDC\x47\xCD\x5D\x93\xEA\xD2\x84\xDE\xD6\xD1\x04\xDA\xCE\xDE\x77\xDF\x6F\xDF\x86\xD8\x71\xDF\x5C\x98\x9D\xDA\x9E\xB7\x26\xDC\x83\x7F\x68\xD7\xF9\xD7\x67\xC3\xC9\xD5\x35\xA8\x9D\xDF\xF7\xDB\xD9\xDB\xF9\xDB\xBA\xDB\x6E\xCF\x96\xDE\x38\x17\x48\xAB\xA9\xD0\x7D\xB1\x29\xD4\x1A\xC5\xB8\xDF\xCD\xDE\xDC\xDA\x97\xDA\x1F\xDC\x99\xDA\x21\xDC\x36\xDC\x47\xD4\xB2\x7F\x8D\xD7\xEC\xD5\xA5\xDE\x0B\xCD\xE9\xDE\x9E\xDF\x04\xD8\xA0\xDF\x04\xDF\x1B\xD9\x7E\xDB\x4F\xD9\xD2\xD0\x63\xB6\x1E\xBC\x0B\xC6\xD4\xDF\xBA\xDF\xC0\xDE\xDA\xDB\xC2\xDE\x8F\xDB\xDA\xDF\xB0\xDA\x50\xD9\x0F\xD6\xAB\xC8\xB9\xDE\x86\x70\xBB\xDE\xD5\xC5\xD7\xC3\x6E\x53\x16\xDF\xB3\xD6\x47\xD5\xAF\xDB\xFE\x9D\xAF\xD2\xC3\xC2\x5D\xDB\x00\xDB\x1E\xCF\xB5\xD2\x6C\x99\xD8\xC3\xF1\xDF\x31\xD8\xD1\xDE\xFC\xDE\x78\xCC\xC4\xDE\x04\xC1\x53\xC4\xD5\xDE\xE5\xDD\xD7\xDE\x12\xDB\xC8\xD2\xD8\xD7\xEB\x6E\xAE\xD8\xDE\xDA\x34\xDC\x9A\xDA\x98\xDF\xE3\xC0\x9D\xBA\x21\xC4\x87\xD9\xF2\xDE\xD8\xD2\xD7\xB0\xE7\xDE\xFD\xDF\x4D\xDF\x2C\xDA\x57\xDF\x50\xDF\xB3\xD9\xE7\xD2\xBD\xBD\xBB\xB4\x9D\xC7\x56\xD6\x41\xC4\xFE\xDF\x33\xDC\x06\xB9\x97\xDF\xED\xC6\xB3\xA5\x45\xDB\xCE\xC4\x6D\xD9\x17\xDF\x1E\xDB\x46\xDC\x8E\xDF\x2F\xC4\x50\xDB\xEF\xDF\xF3\x53\x26\xE0\x0E\xE0\x28\xE0\x10\xE0\xC3\xB3\x0F\xDF\x65\x0C\xBE\xC7\x27\xC9\x7F\xD6\x6F\xC8\x94\xDF\x1D\xDB\x8C\xDF\x31\xE0\xA3\xD8\x0F\xCA\x3B\xDE\xA9\x7B\x29\xD3\x38\xAF\x90\xCC\xB6\xBF\x73\xDB\x79\xC4\xF0\xDF\x1B\xE0\x7C\xD4\x66\xDE\xEC\xDD\x68\xDE\x3D\xD3\xF9\xD9\xE7\xD9\x81\xDB\x39\xD8\x86\xC4\xEC\xD9\x99\xDB\xBE\xCF\x59\xAF\xCB\xC6\x37\xE0\xCA\xDF\xDF\xDA\x01\xE0\xA9\xDE\x90\xDB\x8D\xD6\xB9\xD6\x56\xD3\xBA\xCF\x97\xDB\xA8\xD6\xF4\xC7\x9B\xDB\xE1\xC4\x8A",
"\xDF\x43\xE0\x96\xDF\x3A\xE0\x67\xD2\xFC\xAC\x44\xC3\x51\xDD\x5E\xD7\x02\xDF\xD7\xDF\x49\xDA\x19\xD7\x49\xBB\x1D\x7E\x25\xE0\x51\xE0\x8A\xD5\x53\xE0\x4F\xDE\x88\xDE\x16\x9F\x89\xD8\x45\xC3\x42\xE0\x44\xDC\x30\xE0\x19\xDF\xF0\xD6\x97\xD8\x35\xE0\x78\xE0\x95\xDF\x03\xDF\x7B\xE0\xD9\xDF\x49\xDC\xDE\x6C\x68\xC3\xBA\xC4\x2D\xE0\x88\xE0\x2F\xE0\x44\xE0\x8B\xE0\x3B\xDA\x2E\xD5\xB4\xAA\x7F\xE0\x5D\xDF\x1C\xE0\x4F\xDF\xD1\xDA\x29\xBD\xC0\xD8\x6F\xE0\x61\xE0\xCE\xDA\x0C\xDF\x64\xE0\x52\xD3\x8E\x88\xD7\xC4\x77\xE0\x0D\xE0\x62\xE0\x0F\xE0\xCC\xDF\x11\xE0\x13\x98\xE2\xB5\xDC\xD8\x5E\xC3\x70\xE0\x89\xE0\x9B\xE0\xE0\xDE\x58\xDF\x78\xDE\x6E\xD0\x7F\xA6\x1C\xC5\xA8\xE0\x78\xDF\xCB\xDF\x7A\xDF\xCD\xDF\xF3\xC4\xB0\xDF\x0D\xBA\x52\xD7\xF7\xC4\x54\xD7\x0C\xC7\x56\xD7\xFD\xB9\xC1\xE0\x80\xE0\x9B\xCF\xA7\xDE\x55\xDE\x9C\xDA\x40\xD2\xED\xC9\x0C\xD9\x96\xD0\x0E\xD9\x6C\xBE\xB7\xDF\x58\x66\x36\xE0\xD1\xE0\xCA\xCF\x86\xDE\x54\xE0\x84\xE0\x68\xD2\x38\xDC\x6A\xD2\x31\xC7\x6C\xD2\x9B\xDE\x90\xC7\x8F\xE0\x71\xE0\x91\xE0\x4A\xDE\xA2\xBC\xBF\xDF\x4A\xDC\xD0\xDF\x4C\xDC\x9E\xC8\x36\xC5\xDE\xE0\xA1\xE0\x52\xE0\x28\xDF\x32\xE0\x47\xE0\xB4\xDE\x5C\xDC\xD9\xC1\xD4\xD0\x74\xDF\xF6\xE0\x64\xDF\x69\xDB\xA3\xE0\xE1\xDA\xB3\xDE\xE5\xE0\x8A\xD2\xB1\xD7\x4B\xD4\x70\xDC\xCD\x0E\xD7\xDD\xD3\xDD\xA6\x73\x1C\x83\x5A\xB4\x43\xBD\x78\xA3\x6F\xA3\xEB\x81\xAC\x63\x06\x0A\x3E\x00\x0D\xE1\x0E\xE1\xBD\xBB\x61\xAE\xDF\x56\x55\x52\x06\x0A\x40\x00\x19\xE1\x1A\xE1\xD2\x6B\x08\x0A\xDE\x53\x49\xBC\x06\x0A\x42\x00\x21\xE1\x22\xE1\xC6\x8F\x8C\xDD\xD4\xDD\x17\xCD\xE5\xCE\xFC\xCE\xBC\xDE\x19\x84\x2F\xE1\xEB\xCE\xB3\xCD\x50\xCF\xB8\xD9\x8D\xD4\x1A\xDB\x42\xDC\xDF\xE0\x01\xD0\xD3\xE0\x7D\xDE\x3C\xE0\xEA\x61\x42\xBF\x70\xD4\xE7\xDD\xBE\xB0\xC6\xD7\x87\x69\xC1\xB8\xBA\xCB\xEB\xCF\xF2\xD5\x30\xDC\x96\xDA\x32\xDC\x38\xE0\xC6\xCC\xE4\xDF\x02\xC1\x03\xE0\xB3\xC2\x68\xD1\xC7\xDE\x1C\xCF\x11\xC4\x76\xD9\x64\xD9\xD6\xD7\xE1\x6F\x83\x69\x33\xE1\xBF\xCD\xBD\xA4\xF0\xD2\x37\xD9\x1D\xDC\xC9\xDF\xA9\xE0\x79\xDF\x0D\xDF\xB4\xE0\x5B\xA7\xE3\xDE\x98\xD4\xE5\xDE\x43\xD6\x65\x68\x5D\xE1\xB2\xCD\x07\xCF\x7F\xB9\x37\xE1\xD2\xD6\x39\xE1\x2D\xDB\xF7\xE0\x81\xE0\xF9\xE0\x46\xE0\xF8\xC2\x20\xE0\xE2\xC2\xB2\xBC\x14\xD4\x32\x8D\x35\x0A\x03\xCF\x6C\x82\x6E\xE1\xB9\xCB\x17\xB9\x62\x01\x10\x9C\xA8\x64\x83\xE1\x4E\xB9\xDA\xDA\x1C\xDC\xAA\xDF\x1E\xDC\x64\xE1\xC4\xE0\x66\xE1\x2A\xE0\x44\xDB\xA8\xD9\xD2\xB4\xF3\x53\x89\xE1\x5D\xB9\x72\xE1\x0D\xD8\xC6\xD8\x01\xDC\x6B\xD8\xAC\xDF\xF6\xD9\xAE\xDF\xCB\xC0\x01\x8C\xC6\xD4\x96\xE1\xE6\x6A\x2A\xBA\xBD\xD4\x49\xD6\xEA\xDE\x0E\xDC\xEC\xDE\xF0\xDB\x5E\x8F\x0E\xDB\x12\xD1\x88\xBF\x27\xD8\x7E\xCC\xA6\xA7\x97\xE1\x89\xCA\x49\xE1\xC4\xD6\x4B\xE1\x62\xE1\x4D\xE1\xB1\xE0\x39\xE0\xB3\xE0\x92\xE1\xFA\xCC\xE0\x94\xC1\xB2\x7B\xD1\x5A\xE0\xE1\xC7\xA8\xD1\x31\xDF\xB0\xAC\xA7\xCF\x06\x6A\xD4\xB8\x11\xB8\xB6\xE1\x39\xD7\xB8\xE1\x8D\xE1\x63\xE1\xC3\xE0\x63\xE0\xF4\xDF\x52\xD3\xF0\xE0\x45\x7E\x58\xE0\x31\xDE\x3D\xDF\xFD\xD9\x21\xDF\x85\xDB\x2F\xD3\xD3\x68\x47\xE1\x85\xE1\xCC\xE1\x95\xD7\xCE\xE1\xC8\xDF\xBA\xE1\x8F\xE1\xD2\xE1\xFA\xDB\xE1\xD0\xAA\xDE\x49\xD8\x68\xE0\x8F\x97\x57\xD3\xBA\x99\x33\xDE\x99\x70\xD6\xCF\x6E\xE0\x57\xD6\xB4\xE1\x9E\xB9\x8B\xE1\x9F\xD4\xE4\xE1\x42\xBB\xFF\xDF\xFB\xDE\xD3\xE1\xF4\xD4\x4B\xD1\xCD\xD6\x88\xE1\xA5\xE1\x51\xBA\x60\xE1\x48\xD9\xAC\xDB\x87\xDA\xBC\xDF\xCE\xDB\x4B\xC3\x18\xDA\xC0\x75\xF5\xE1\xAE\xB9\x62\xDC\xAF\xD6\x66\xDB\x80\xD9\x76\xE1\xD2\xE0\xE1\xE0\x83\xE0\x62\xDE\x23\xDA\x3D\xD5\xDE\xE1\xCA\xE1\x34\xB9\x97\xD1\x41\xDC\x75\xE1\x02\xE1\xC3\xDB\x04\xE1\xB0\xB3\xC6\xDB\x46\xE1\x1B\xE2\x48\xE1\x1D\xE2\x6C\xDF\x31\xDC\xFA\xE1\x27\xE0\x4F\xE1\xED\xDE\xCF\xDB\x6E\xB7\x96\xE0\x5A\xA8\x0F\xB0\x0D\xE2\xCC\xB9\x82\xD7\x74\xE1\xC1\xDB\x13\xE2\xE0\xE0\x93\xDE\xE2\xE0\x62\xDE\x4B\xDA\x33\x70\x34\xE2\x01\xBA\x0F\xD2\x0E\xD8\x9C\xE1\x6E\xDF\x03\xDC\xBF\xD5\xA0\xE1\xC0\xD3\xA6\xE0\xF4\xE1\x02\xE2\x27\xB6\xBB\xD1\x29\xE2\x4C\xE1\x2B\xE2\x4E\xE1\x01\xDE\xA1\xDF\x26\xD7\x66\xDA\x13\x75\x40\xE2\x18\xBA\xA7\xE1\xEB\xD6\xD5\xDF\x93\xD8\x7A\xE0\xEE\xE0\xE7\xDB\xDB\xD8\x36\xD7\x4B\xE2\xEA\xB9\x04\xE2\xA8\xE1\x5C\xE2\xC9\xD8\xED\xE0\x61\xDE\x4B\xDE\x0C\x0A\x2C\xE1\xA5\x5A\x58\xE2\x23",
"\xA8\x55\x52\xB0\x69\x34\x83\x41\x83\xBE\x35\x90\xA4\xB5\xE1\xBC\x69\xF9\x07\x62\xA2\x36\x03\xC3\x69\x89\x34\x82\x47\x01\xCF\xFB\xCA\x09\x52\xCA\x69\xDB\x73\xD1\x69\xDB\x73\xD8\x69\xDB\x73\xDF\x69\x66\x5C\x53\x84\xE6\x69\xED\xCE\x53\x84\xED\x69\xDB\x73\xF3\x69\x60\x7B\xF9\x69\xB7\x79\x08\xDC\x9D\x0B\x6F\xE2\x03\xE2\x5A\xE2\x78\xDB\xE1\xDF\xEB\xDE\xE3\xDF\x2E\xE2\x44\xBE\xA3\xDF\x81\xDE\x80\xD0\x16\xE0\x45\xD2\x57\xD7\x1A\xE2\x34\xE1\x70\xE1\x36\xE1\x54\xDB\x40\xDC\x4F\xE2\xB9\xE1\x51\xE2\xBB\xE1\x2D\xE2\xAC\xE1\x1D\xBE\x9F\xE2\xAD\xC1\x5B\xCD\x28\xDC\x97\xD0\x2A\xDC\xE8\xBB\x23\xD9\x33\x6A\x00\xCF\xA2\xA4\xF7\xE1\xB1\xD4\xCF\xE1\xE5\xE1\xD1\xE1\xB2\xE0\xC5\xE0\x67\xE1\x32\xC9\xE3\xDA\xBC\xC1\x3A\xDC\xDB\xD5\x22\xD9\x3D\xDC\x96\xE2\x4D\xE2\x42\xE2\x9B\xE1\x6D\xDF\xF9\xDE\x9E\xE1\x04\xDC\x2D\xD5\xED\xC7\xFC\xE0\x6C\xDC\xCA\xC1\x30\xA2\xC6\xDA\xF6\x88\xCC\xE2\xD5\xB8\xCE\xE2\x37\xE2\x44\xE2\xD1\xE2\x46\xE2\x09\xD6\x79\xE1\xCE\xDF\xAA\x95\x6C\xCD\x5D\xDC\xC2\x76\xDC\xE2\xCB\xE1\x28\xE2\xA9\xDF\xF9\xE1\x28\xC7\xFB\xE1\xAA\xE0\xFD\xE1\x0B\xD6\x66\xE0\xAB\xDE\xE4\xD0\x51\xD9\x60\xBA\xA1\xD7\x09\x52\x06\x0A\x46\x00\x29\xE1\x95\x96\xFD\xCE\x80\xB6\xFA\xE2\x32\x69\xED\xDF\xF2\xD0\x39\xBF\x6E\x53\x72\xE0\xBD\xE1\x69\xC7\x52\xE1\x04\xC3\xF8\xDF\x0B\xA7\x63\xD9\xD5\xD7\x04\xC4\x5D\x7F\x6F\xBE\x07\xE3\xC3\xE2\x3B\xE0\xAE\xE1\xC1\xD7\xD6\xDE\x57\xE1\xCA\xC0\xFB\xAA\xE0\xC8\x7A\xD9\x12\xE3\x69\xE2\x94\xDE\xC4\xD4\x22\xDB\x86\xD9\xE4\xDE\x25\xDB\xE9\xD7\x56\xC3\x18\xDF\xBC\xE0\x1E\xE0\xD5\xC0\x7B\xE1\x35\xDB\xEE\xDA\x5F\xCF\xFB\xD7\x58\xDE\x28\xE3\x29\xE0\x74\xE0\x42\x71\x62\xD6\x02\xC0\x32\xE3\x73\xE0\xF8\xDD\x91\xC1\xEA\x6B\x8C\xA7\x1E\xE3\x5E\xE2\x6A\xE2\xC1\xD2\x4C\xBF\xC5\xDE\x73\xD9\x55\xE1\x48\xA5\x1A\xDE\x40\xE0\xAF\xE0\x38\xE3\x08\xE3\x3A\xE3\xE4\xE0\x57\xE0\x2C\xDF\x23\xDE\x95\xDB\x25\xDE\xBE\xD6\x6C\xE0\xBD\xCF\x19\xC3\x41\xC4\x13\xE3\x91\xE1\x34\xE3\xF5\xD4\x4E\xE3\x22\xDE\xE8\xD9\x24\xDE\xA6\xD6\x53\xE3\x27\xDE\xFB\xBA\x2A\xC3\x57\xE3\x1F\xE3\x3C\xE2\xE8\xD5\xF4\xE2\xEB\xE1\xFA\xD9\x93\xDB\xEE\xE1\xB5\xBF\xE0\x9E\x5D\xE0\x81\xC6\x4C\xBD\x58\xE3\xAB\xE0\xFE\xE1\x20\xD5\x03\xBD\x49\xDF\xAA\xBD\x4A\xE3\x14\xE3\x5A\xE3\x7A\xC3\x98\xC6\x72\xE3\x66\xE3\x16\xE2\x21\xE3\x65\xB7\x4D\xDE\x7A\xE3\x59\xE3\x66\xBB\x4A\xD5\x3E\xE3\x0F\xDC\x06\xD8\x93\xE0\x30\xE2\xB9\xC4\x32\xE2\x79\xE3\x8A\xE0\x29\xE3\xA4\xE0\x22\xBD\xB4\xAA\x7F\xE3\x3F\xE3\x20\xE3\x7C\xE0\x7B\xC3\xB6\xBD\x06\xE3\x80\xE3\x5A\xDE\x40\xD7\xD2\xB5\x96\xE3\x8A\xE3\x95\xD8\xDC\xDB\x90\xDF\xFB\xBF\x6F\xD9\x92\xE3\x05\xE1\xC3\xBC\x79\xDE\x1C\xDE\xBB\xE0\x33\xE3\x4C\xE3\x31\xB0\xC8\xE0\xF5\xC4\xCA\xE0\x6B\xC8\x08\xC6\xA7\xDF\xDC\xC0\x91\xE3\xAE\xE3\x55\xE0\x1A\xC7\x7F\xDE\xF6\xB9\xB2\xDF\x96\xA6\xCC\xE0\x00\xD4\xA3\xDA\x2B\xDC\xAE\xC0\x73\xE3\xF2\xE2\x6E\xD6\xD5\xE1\xB5\x6D\xB1\xDA\x0E\x89\xE8\xE0\x3C\xDC\xB2\x4B\xA7\xE3\xB9\xE3\xE3\xE0\x14\xC5\x6B\xDC\x22\xCA\x39\xD4\xD2\xDF\x7D\xC3\xB8\xE3\x39\xE3\xBA\xE3\xAE\xD7\xCF\xDF\xDC\xDF\x48\xC0\xC2\xB7\xFE\xD5\x33\xC0\x85\xE3\x74\xE3\xF3\xE2\xE6\xDF\xC3\xDA\x08\xE1\xB6\xDE\xAD\xDE\x17\xCD\x89\x67\x03\xE3\x81\xBC\xB4\xC7\xF3\x53\xEE\xE2\x15\xCF\xF0\xE2\x65\xE1\xE3\xE3\xA5\xB2\x0A\xE3\x6B\xC7\x0C\xE3\xB9\xC0\x59\xE1\x10\xE3\xEE\xE3\xD0\xE2\x0A\xDF\xD2\xE2\x47\xE2\x84\xBF\xFD\xDA\x89\xBC\xFF\xDA\x8B\xB8\xF6\xC5\xCA\xB0\xD7\xD7\x91\xDF\xFD\xE3\x35\xDF\xE2\xE2\xBD\xD7\xF7\xD9\x25\xD1\x23\xDB\xFC\xDD\x8F\xDE\xF0\xC8\x18\xE0\xD1\xAE\x4A\xDF\x0A\xE4\x44\xDF\x0C\xE4\x21\xD8\x0E\xE4\x64\xB2\xB8\xB8\xF8\xD7\x57\xD2\xE9\xC0\x30\xE3\x02\xCC\x17\xE4\xAB\xDF\x19\xE4\xBD\xD8\x1B\xE4\x35\xE3\x7D\xB2\x2A\xC8\x23\xE4\x8E\xE1\xC1\xE2\xBC\xE1\x7B\xE3\xAF\xE3\x32\xD6\xFB\xC0\x09\xE4\x2A\xE2\xEF\xE2\x2C\xE2\x53\xE2\xD8\xDF\xAD\xE1\x02\xE4\xCB\xBC\xC1\xD9\x27\xB7\xF8\xB8\x8A\xD8\xF0\xE3\x11\xD0\xE6\xE1\xC2\xE2\x86\xE3\xDA\xE3\x2E\xD9\x7E\x95\x12\xC3\x4A\xE0\x53\xAF\x2B\xD3\x91\xCC\x4F\xD8\x2E\xD3\x59\xAF\x15\x76\x40\xE4\x62\xD1\x03\xE1\x5F\xDF\x45\xDE\x1B\xDF\x5C\xD8\x65\x8A\x59\xE0\x4C\xD8\x60\xD8\x11\xD5\x84\xDB\x50\xD8\xC1\xC7\x6E\x53\x51\xE4\xC9\xD3\x77\xE1\x1D\xE0\x93\xE3\x81\xC4\xD2\xD9\x3B\xDF\x6C\xE3\x6A\xE0\x2C\xD3\x62\xE3\xC0\xD6\x64\xD8\xD8\xC3\x61",
"\xE4\x54\xD4\xCF\xE3\xD9\xE3\xD1\xE3\x28\xE4\x0C\xDA\x4A\xC4\x2B\xE4\xD0\xE1\xFF\xE3\xE3\xE2\xA6\xD9\x6A\xB9\x0C\xC8\x01\xC8\x50\xE2\x35\xE4\x52\xE2\x3D\xE1\x29\xDF\xA7\xC4\x86\xE0\x49\xE3\xAC\xE2\x81\xE4\xAE\xE2\x37\xE4\x92\xE0\x96\xD8\x5F\xC1\xF5\xE0\x78\xE4\xC0\xE2\x7A\xE4\x0D\xE4\x48\xE2\x20\xDE\xF0\xD1\x6A\xDF\x53\xC8\xBF\xE2\xAD\xE2\x42\xE4\x2E\xE4\x44\xE4\x74\xE4\x88\xC1\xB4\xAA\x6F\xE4\xA9\xE1\x9F\xDF\xA2\xE3\x02\xDE\xA4\xE3\xE8\xDB\x8E\xE0\x34\xE4\xF1\xE3\x36\xE4\x83\xE4\xFA\xE0\x5F\x7F\x86\xDF\x34\xC8\x80\xE4\xAA\xE4\x82\xE4\x15\xE2\x9E\xE3\xDD\xD3\x5F\xD0\x2A\xE4\xA9\xE4\x41\xE4\x2D\xE4\xAF\xE2\x10\xDC\xEE\xDE\x80\xDA\xC4\xC9\x99\xE4\x89\xE4\x9B\xE4\xBC\xE4\x8B\xE3\x0E\xC0\x24\xDC\xFC\xD3\xAE\xD5\x8D\xDA\xB5\xE3\x17\xDC\xE6\xCC\x70\xE4\x3F\xDB\x9C\xD1\x00\xE4\xD4\xE2\xB1\xC3\xDF\xA8\x25\xCE\x58\x28\xA0\xDA\xD9\xE0\xA2\xDA\x7F\xC8\xB8\xE2\x91\xC8\xB1\xE4\xBA\xE4\x92\xE4\x1A\xE4\x94\xE4\xBF\xE1\xE6\xE2\x8A\xD2\xC8\xE2\x7D\xD7\x90\xC8\xE8\xDE\xCE\xE4\x89\xD5\x14\xE2\x3B\xE2\x81\xE3\xEF\xE0\xEA\xE1\xD8\x8E\x4B\xDC\xC0\x8B\x6F\xBD\x91\xD7\xCB\xC6\xE9\xE4\x2B\xDA\xF8\xE0\x64\xE4\xA9\xE3\x68\xDF\xE3\xE4\xE4\xDA\xE8\xE2\xC0\xE4\xF6\xE4\x7B\xDA\x53\xE4\x66\xDF\xB2\xDE\x56\xE4\xC6\xE2\x8B\xC8\x09\xE1\x8C\xD2\x17\xCD\xDC\x74\xEC\xE3\x38\xBF\x10\xA7\xAE\xC0\xBB\xE4\x8B\xE4\x5F\xE2\x39\xE4\xF6\xDF\x43\xC6\x45\xE3\x41\xE1\xCB\xC8\x12\xDB\xC5\xD7\xAC\xE3\x10\xE5\xAC\xE4\xA3\xD8\x3F\xE1\x10\xC4\x28\xA7\x09\xE0\xD9\xDE\x7A\xD9\x0F\xE5\xDF\xE4\x26\xE4\xE1\xE4\xB0\xBD\x14\xE0\x24\xE3\xA2\xE2\xE6\xDE\x15\xE4\xD7\xE3\xC3\xE4\x11\xE5\x40\xE3\x3E\xD6\xEF\xDE\x96\xD9\x1E\xE4\x7E\xE1\x69\xB2\x55\x9E\x41\x7C\x6F\xBE\x1C\xE5\xB4\xE4\xA8\xDE\xAC\xE0\xF3\xC0\x6E\x53\x3C\xE5\xEC\xE4\xB5\xE4\x22\xDA\xCE\xBD\x0E\xE5\x41\xE5\x26\xE5\xA5\xD9\x79\xD6\x3A\xE4\x07\xBF\x0C\xE3\x7D\xCC\x7A\xC3\x0A\xC1\x48\xE5\x25\xE4\x4A\xE5\x28\xE5\x4D\xE3\x47\xE4\x8D\xCC\xC2\xE1\x5A\xE4\xEA\xD9\x6B\xE4\xFB\xD4\x28\xDE\x59\xAF\xD8\xC3\x42\xE5\x82\xE0\x44\xE5\x2D\xDE\xEF\xE4\x3C\x95\x30\xDE\xF3\xBD\xD9\xE1\x71\xDB\x3F\xDF\xFB\xBC\x2A\xC3\x60\xE5\x49\xE5\xBF\xDA\xE4\xE2\xFA\xD5\x2B\xDF\x68\xE4\xBA\xD6\x94\xDB\x4B\xE0\x4B\xE4\x4D\xE0\x41\xDE\x64\xD8\x3B\xE5\x6F\xE5\x8D\xDF\x71\xE5\xED\x7E\xA6\xDB\xA6\xDE\xB3\xE4\x43\xE5\x3E\xE5\x75\xE3\xCF\x63\x7E\xD8\x7C\xE5\x53\xE5\x70\xE5\x7C\xE4\x23\xAD\xD4\xD1\xD1\xBF\xC1\xBF\xF3\x53\x61\xE5\x78\xE1\x48\xB6\x37\xB1\x25\xE5\x8A\xE5\x7E\xE5\x8C\xE5\x95\xE4\xFF\xD6\xA6\xD8\x73\xC1\x30\xE5\x1D\xE5\x99\xE5\x4B\x8F\xB4\xAA\x89\xE5\x82\xDF\x70\xDF\x84\xDF\x35\xD0\xA7\xE4\x50\xC1\x52\xE5\xA4\xE5\xAD\xDF\xA6\xE5\xAF\x7E\x82\xC1\xAA\xE5\x5D\xD9\x2C\xD5\x93\xD9\x73\xDA\x2D\xCD\xA3\xE5\xB1\xE5\xE4\xD6\xD2\xE4\x95\xD4\xBF\xE4\x39\xDD\xAB\xE4\x3D\xE5\xD4\xE0\x3F\xD2\x8A\xDE\xE7\x93\xC8\xA8\x53\xD7\xFF\xD3\x78\xA1\xCC\xE4\xB8\xE0\x92\xE5\xF9\xE4\x7B\xDF\x7C\xD0\xD6\xE0\x7E\xD0\xBE\xE3\x17\x06\xA1\xDA\x48\xBD\xDA\xE4\xF4\xC9\x9F\xC4\xBD\xE5\x84\xE5\xBF\xE5\xE5\xE2\xFD\x94\x39\xDC\xE7\xE0\x3B\xDC\xB5\xDA\x41\xC4\xC9\xE5\x22\xE2\xC6\xE0\x6A\xDC\xDC\xE3\xC4\xDA\xA3\xDE\xCC\xC1\xD6\xE3\x36\xC4\x9E\xE5\xBE\xE5\x7D\xDE\xFB\xE0\x07\xE1\xFD\xE4\xFE\xE0\xAE\xDE\xBC\xE5\x83\xE5\x62\xE5\x85\xE5\xE4\xE3\x94\xE0\xC9\xE3\xE8\xDF\x5C\xD4\x0A\xE1\xCD\xC5\x6B\x72\x0C\xE5\xA3\x7F\x41\xC4\x01\xE5\x21\xE2\x54\xE4\x1C\xD6\x16\xE3\x25\xD8\x6F\xD4\x18\xE5\xFA\xE3\x02\xD1\xE5\x7E\x00\xE6\xA2\xDB\x9C\xE2\xB0\xE2\x94\xBD\x4C\xE5\x88\xC0\x06\xE0\x17\xCC\x19\xE3\x06\xE4\xDF\xC8\x9C\xBC\x7A\xD9\x0C\xE6\xAD\xDB\xB4\xD6\xC6\xE3\x34\xD7\x22\xE3\x2A\xE5\x6A\xE1\x25\xE3\xFF\xDD\xBB\xC4\xCF\xE4\x99\xD5\x8B\xE5\x27\xE4\x86\xD4\x2C\xE3\x36\xE5\x29\xDC\x32\x8D\x56\xD6\xAE\xC0\x01\xE6\x67\xDC\xE1\xE5\xC4\xE2\x76\xA7\x36\xE3\x2F\xE6\x0D\xE6\x08\xE2\xDB\xDB\x58\xD1\x34\xE0\xF2\xE5\xEA\xE4\x3A\xE2\xF4\xE5\x55\xDE\x1F\xE5\x11\xDF\xEB\xA9\x13\xDF\xEA\xE0\x71\xE4\xE2\xE3\x1D\xE6\x8B\xD6\x65\xE5\x83\x92\x48\xE4\x59\xE5\x2E\xDF\x5B\xE0\x30\xDF\xB0\x7B\x67\xA5\xB1\xAC\x1C\xC5\x30\xE6\x56\xDF\x32\xE6\xBE\xE1\x5A\xDC\xC0\xE1\x4A\xD8\x59\xE4\x4E\xE6\xC4\xE1\x5C\xE0\xC6\xE1\x5E\xE0\x36\xB5\x54\xE6\x37\xE6\xAE\xDB\xE8\xE1\x4D\xD9\x69\xE3\x2F\xDE\x6B\xE3\x75\xE5\x6D\xE3\x4C\xE0\x6F\xE3\x60\xE6\x81",
"\xC6\x36\xE6\x1B\xE6\xF3\xDF\x66\xE6\xFD\xDE\x76\xE0\x87\xC3\x3D\xE6\x3C\xE1\xEB\xE5\x84\xE4\xDA\xD8\x2F\xD5\x1D\x7E\x71\xE6\x07\xE2\x65\xE6\xBD\xDF\x8B\xC6\x83\xE3\xDD\x50\x6F\xBE\x55\xE6\x5E\xDF\x03\xE5\x60\xDF\x4A\xD5\x1A\xE6\x80\xE6\x1C\xE6\x74\xE6\x64\xE5\x68\xE6\x5D\xDE\x9C\xE5\xB7\xE3\xF7\xE4\x63\xE4\x57\xE6\x7C\xE3\x3C\xBE\xB4\xAA\x7F\xE6\xB8\xDB\x38\xE6\x50\xE1\x0A\xE2\xA8\xE5\x6A\xC3\x25\xE6\x72\xE4\x4B\xE3\x45\xE4\x45\xBE\x86\xC3\x3C\xC3\x78\xE6\x64\xD2\x7A\xE6\xAD\xE4\x0D\xD7\x8F\xC3\x6E\x53\x87\xE6\xA2\xE0\x03\xE6\xBD\xE0\xD5\xC0\xAB\xE3\xA8\xE4\xA2\xE6\x47\xE6\x8F\xE6\xE4\xCF\xB2\xE2\xF8\xD8\xA5\xDF\x83\xDE\xC7\xE5\x98\xE4\xB0\xE6\xF8\xE4\x97\xE6\x30\xE4\xBB\xE3\xB1\xE3\x06\xC5\x9F\xDA\xE3\xBB\xD1\xE5\x5F\xBE\xD3\xE5\x17\xD4\x7F\xE4\xA9\xE6\x40\xDB\xD7\xE5\xEC\xE5\x37\xDC\x06\xE5\xD7\xE2\x26\xD4\xCB\xE3\xDD\xE5\xCA\xE2\x3F\xC8\xB7\xE6\xD8\xE3\xA4\xE6\x9E\xE4\xDB\xE3\xFC\xE4\xD4\xC3\xC5\xDA\x4D\xDC\xB8\xE4\xDB\xE6\xAD\xE3\x73\xE4\x95\xDE\x4A\xE6\xC0\xDF\x47\xC0\x6F\xDC\xDF\xE3\xD6\xDA\xB0\xE4\xCF\xE6\xD0\xE4\x7B\xE4\x28\xE6\xDF\xE6\xDA\xE5\x98\xCD\xE8\xE3\x63\xB6\x06\x0A\x1A\x75\xFE\xE5\x1A\xC9\x2B\xDB\xED\xE2\xA2\xE4\xD6\xDF\xA4\xE4\x54\xE2\xC3\xDE\xEE\xDD\x2D\xD6\xF0\xDD\x6E\xC7\xCC\xC8\x1A\xE5\x8A\xD8\x95\xDA\x88\xE4\xB2\xE4\x8A\xE4\x9F\xE5\x4B\xE5\x14\xE5\x81\xD4\x3C\xE4\xC6\xD2\x15\xD1\x23\xE5\xC9\xD2\xA8\xDF\xF2\xD9\x60\xDA\x39\xE2\x79\xE6\xD1\xE6\x7B\xE6\xA6\xD4\xFA\xDD\xE5\xD7\x24\xDB\x2C\xE5\x6C\xE1\xC6\xDF\xBA\xDA\x12\xE2\x20\xE2\x31\xE6\xB2\xE6\x2A\xE3\x99\xDF\x2A\xE6\xF1\xDE\x12\xE4\x50\xCC\x39\xE5\xCC\xDE\x26\xE7\xF3\xD9\x83\xD3\xB7\xE5\x37\xDF\xB9\xE5\xA7\xC7\x94\xE1\x32\xE7\x0B\xE7\xC1\xE4\x0D\xE7\xEA\xE5\x1D\xE7\xAC\xE6\x50\xD6\x12\xDE\x19\xE2\xAD\xD9\x1A\xE7\x28\xE7\x56\xE6\x2A\xE7\x8C\xB0\x41\xE6\xB0\xE1\x47\xE3\x44\xE6\x3A\x88\x3C\xE7\x00\xE5\x64\xE6\x8E\xE6\x82\xE6\x5B\xDE\xE9\xE6\x3B\x9B\x58\xE5\x8F\xD6\x5A\xE5\x2F\xDF\x54\xE3\x5D\xE0\x19\xC3\x64\x89\x50\xE7\xFF\xE6\x5D\xE2\x01\xE7\x38\xE4\x2F\xE2\xAF\xBF\x1D\xDF\xF8\xD4\x70\xDB\x5C\xE4\xDB\xE1\x5E\xE4\x59\xAF\x5F\xE7\x3D\xDB\xAC\xC7\xE5\xE6\xC5\xE3\xB9\xE6\xD4\xE1\x56\xE7\xD6\xE1\x55\xD3\xED\xE1\x6A\xE4\x4C\xE4\x5D\xE4\x5C\xD3\x64\xD8\xCB\xC6\x60\xE7\x67\xE2\x18\xD9\x97\xE3\x67\xE3\x07\xD8\x76\xE6\xF0\xC6\x19\xE7\x6E\xDA\x81\xDF\x36\xE7\x83\xDF\x38\xE7\x7D\x9A\x0B\xE2\xBD\xDE\x45\xE7\x88\xE7\x35\xE7\xBD\xD9\xB2\xE5\xB2\xD9\xE6\xD6\x86\xE4\xA7\xC6\xF3\x53\x7F\xE7\x9A\xE2\xAA\xE1\x0E\xE6\xBD\xE4\xEE\x9C\x4A\xD5\x15\x76\x9A\xE7\x06\xE2\x9C\xE6\x81\xE6\x09\xE2\xBE\xDF\x75\xE7\x82\xD0\x97\xC9\x97\xE0\xE6\xCC\xA2\xE7\xA1\xDB\x72\xE6\x72\xD5\x48\xE6\xEF\xB3\x3E\xE2\x99\xC9\x33\xE7\x46\xE7\x89\xE7\x93\xE7\xB8\xE5\xB3\xE5\x9C\xC4\x8A\xB3\x7E\xE7\x6F\xE7\xC4\xC7\xF0\xE6\x26\xE6\x98\xE5\xF3\xE6\x18\xD2\x1A\xD2\x6C\xC9\x90\xE7\x57\xDB\x1B\xE7\xAA\xE6\x40\xE7\x7F\xE5\x73\xDE\x27\xD2\x60\xC9\x87\xE7\xC8\xE7\x47\xE7\x88\xE6\x94\xE7\x72\xDA\x99\xDF\xB5\xE6\xC0\x75\xAD\xE7\x2A\xDA\xC1\xE6\x96\xE6\x49\xE7\xFA\xE4\x9B\xC1\xD4\xE4\x59\xCD\xC9\xE4\xC4\xE5\x8E\xDA\x92\xE6\xFC\xD8\xA6\x7E\x26\x9C\xD9\xE7\x3E\xDB\xC0\xE7\xA3\xE6\x2F\xE4\xA5\xE6\xBB\xE6\xCF\xE5\x70\xB1\xE4\xE7\xFB\xD8\xDC\xE0\xA8\x64\xE9\xE7\x70\xE7\xEB\xE7\xB8\xE6\x54\xE7\xE9\xE1\x91\xE6\x97\xDE\xDB\xE5\xC2\xDF\xBF\xC1\x21\xD9\x7E\xD7\x0F\xB0\xF6\xE7\xBF\xE7\x95\xE6\xEB\xE4\x3F\xE6\xD2\xE6\xD9\xE5\x40\x89\x3F\xC7\xE2\xE6\xF4\xE0\x33\x70\x04\xE8\xF9\xC7\xF8\xE7\xDC\xE6\xED\xE7\xDE\xE6\x46\xE4\xE4\xE5\x8A\xD2\xFE\xE4\xD8\xE7\xBE\xE7\x11\xE8\x06\xE8\x3E\xE6\x93\xE5\xC3\xE7\xD6\xD5\xA1\xDE\xE4\xDA\x08\xE5\xF9\xE2\xEB\xDF\x85\x03\xFD\xE2\x9A\xA4\x85\x53\x67\x80\x33\x6F\x3B\x5C\x0B\x81\x43\x5C\x4E\x66\xC3\x53\x9D\xDD\x88\xDD\xB0\xDD\xC8\xA3\xD2\x80\xC1\x52\xD4\x80\x51\x9B\x13\x81\x7E\xDD\x1B\x86\x26\xBE\x44\xB1\x2D\xE8\x9E\xDD\x4D\x66\x55\x5C\x84\x28\xBA\xDD\xDA\xCE\xB1\xDD\xE9\x6E\x6D\xE2\x1B\x81\x3F\xE8\x33\xE8\x41\xE8\x4D\x5C\xE9\x53\x32\xE8\x35\x86\x89\xDD\x4F\x06\x90\x80\x2B\xE8\x05\x80\x4A\xE8\x50\xE8\x2F\xE8\x42\xE8\x50\x4C\x44\xE8\x51\xE8\x5A\x06\xFF\x80\x2D\x05\xDB\x53\xA4\xDD\x06\x5E\x25\xE1\xA2\x5C\x56\xE8\x98\x80\x58\xE8\x4D\xE8\x56\x5C\x5B\xE8\x34\xE8\xBC\xDD\x06\x5E\x0F\x81\x64\xE8\xCC",
"\xDD\x53\x80\x44\x5C\x6A\xE8\xB4\x80\xF9\x65\x00\x54\x27\x53\xC6\x8F\x08\x54\x51\x7F\x65\xE8\x97\xAC\xF9\x53\x58\x05\xC6\x15\x73\xE8\x22\x81\xA0\xDD\xCF\xDD\xCC\x62\xFB\xE6\x6D\xCC\x6E\x53\x98\xE2\xA0\xDB\xDA\xE7\x52\xE7\x73\xE6\xFA\xE7\x82\x87\x11\xE7\xFE\xDA\x13\xE7\xE6\xDD\x08\xE7\xCB\xDE\x1D\x78\x36\xE2\x64\xDC\x27\xE7\xB7\xE7\x70\xDA\xD4\xE7\xFC\xDA\x8F\xE8\x03\xE4\x91\xE8\x08\xE0\x09\xE6\x0A\xE0\x09\x78\x96\xE8\x11\xE2\x34\xE7\x76\xD6\xAB\xE5\x9F\xE1\xAD\xE5\x28\x97\x13\xE0\xED\xC8\xD4\xB0\x1F\xE4\x26\x95\x26\xE3\x26\x9C\x88\xE8\xF6\xDB\xA3\xE7\xF8\xDB\xA5\xE7\x39\xE6\x6E\xCF\x38\xD1\x35\xE5\x2E\xE7\x2E\xE3\x55\xAC\x56\xD6\x15\x76\xB3\xE8\xE3\xE1\x61\xE7\x68\xE2\x82\xE7\xED\xE4\xBE\xBF\xBD\xBC\xC0\xE8\xA4\xE8\x1E\xE2\x38\xE2\xD2\xE7\xB1\xE6\x89\xE6\x55\xE4\xBE\xE0\x09\xAF\x1C\xCC\x87\xE8\xCA\xE8\xAB\xE2\x3D\xE7\xDE\xE4\x97\xE5\x45\xE0\x22\xD8\x8D\xCF\x05\xE7\xD3\xD4\x4D\xE7\x19\xD3\x59\xAF\xAA\x8E\xC1\xE8\x43\xE2\x90\xE4\x9A\xE4\xE0\xE5\xDD\xE7\xCB\xE5\x06\xE1\x5C\xE3\xA3\xD6\x50\xE3\x77\xE5\x96\xDB\x5C\xE5\x4D\xE4\x5E\xE5\x36\xB5\xE2\xE8\xD5\xE8\xFE\xE6\x80\xE7\x2A\xD9\xC5\xE8\x63\xE5\x65\xE0\xE5\xE3\x36\xD8\x67\xE5\x1E\x85\x69\xE5\x6A\xE7\x6B\xE5\x4C\xC9\x94\xCC\xD4\xE8\x47\xD9\x66\xE2\x9B\xE7\xA3\xE4\xAB\xE1\x9E\xE7\x44\xBE\xC8\xE3\xF4\x8F\x00\xCA\x5E\xD8\x5F\xE3\x4D\xD8\x01\xE9\xF1\xE1\x70\xAF\x64\xD8\xC9\xE8\x06\xE9\x5B\xE2\x08\xE9\x00\xE7\x0A\xE9\xC5\xE4\xEE\xC2\x81\xE5\xD3\xDF\xE3\xE8\xCF\xE2\xB9\xE4\x52\xE4\x02\xE6\xCF\xE8\xE1\xDE\x2E\xD5\x98\xC6\x17\xE9\xBD\xE2\xEE\xD7\xD7\xE8\x24\xE9\x29\xE7\x26\xE9\xB3\xE6\x6A\x99\x55\xC3\xCB\xC6\x21\xE9\xDF\xE2\xE5\xE8\xC2\xE4\xE7\xE8\x30\xE9\x61\xB0\xEF\xCC\x05\xE9\x2B\xE9\x61\xE1\x2D\xE9\x62\xE4\x07\xE8\x1F\xE8\x55\xE5\xD2\xE3\x69\xDF\x98\xC9\x18\xE7\xDE\xE2\x97\xE8\xA6\xE8\x02\xDC\xA8\xE8\xD3\xE2\xBA\xE7\xA2\xC9\xB4\xD3\x9C\xDF\x49\xE9\xA5\xE8\xB6\xE7\x92\xE7\x9A\xE8\xB9\xE7\x95\xE7\xBB\xE7\x4A\xE2\x2A\xE9\x3C\xDB\x79\xDA\x8A\xE8\xAF\xE7\x4D\xD6\xF4\xE3\x1E\xE6\xCE\xD8\x67\xDA\xE2\x9F\xEC\xE2\xB9\xDF\xB5\xE8\xBB\xDF\xB7\xE8\x9E\xE6\x74\xD5\xD7\xB9\x44\xE7\x65\xE2\x19\xE9\x69\xE9\xE2\xDF\x9D\xE6\x9D\xE2\xB9\xE8\x41\xD7\x74\xCE\x64\x89\x35\xE9\x4A\xE9\x55\xE9\xA7\xE8\x8A\xE7\xA5\xE5\x8C\xE7\xAA\xC1\xC7\xE4\x51\xD7\xE2\xE7\xCB\xE0\xC5\xE5\x96\xC9\xB3\xD5\x79\xE9\xF5\xE8\x68\xE9\xAE\xE7\x8D\xE6\x8C\xE8\xA6\xE7\xA1\xC3\xEF\xE7\xC8\xE6\x08\xC5\xB4\xDF\xAF\xE8\x0B\xC5\x2B\xDC\x89\xE9\x18\xE9\x99\xE2\x72\xE9\x9B\xE2\x74\xE9\x0F\xE6\xA7\xE7\xFC\xE7\xEA\xE6\xCA\xE3\xFD\xAD\xB3\xDA\x01\xE8\xE7\xE4\x98\xE9\x3E\xE9\x05\xE2\x8C\xE9\xA4\xE7\x53\xE7\x8F\xE9\x55\xE7\xA0\xE9\xF1\xE0\x0C\xE8\xE6\xE5\x14\xCA\xEE\xD5\x79\xB8\x7A\xE9\x54\xE9\x91\xE7\x7D\xE9\xB8\xE7\x37\xE7\x4F\xE9\x6A\xCD\x17\xE8\xEF\xE5\x41\xD9\x92\xBE\xEE\xE6\x2C\xA0\xB6\xE9\xCB\xE8\xE0\xE2\xFE\xE3\xD9\xE8\x9C\xE0\xD0\xE8\x66\xE4\xD7\xD5\x25\xD4\xE5\xDA\x41\xC5\x25\xE8\x17\xCD\x25\x2D\x2A\xE1\xDA\x58\x4A\xD5\xFC\x57\x1E\xE1\x4F\xE8\xD3\xDD\x2A\xE8\x6E\x5C\xD7\x5A\x87\xDD\x57\xE8\x74\xE8\x23\x81\x7A\xDD\xC8\x42\x7C\xDD\x09\x81\x61\xE8\x96\x6C\x3D\xE8\xA5\x5A\xDD\xE9\x66\xE8\xDF\xE9\x82\xE8\x8B\xDD\xC6\x89\xE8\xE9\x70\xE8\x5C\xE8\xEE\x04\x53\xE8\xDB\xE9\x1B\x81\xE9\xE9\x7C\xE8\x6B\xE8\xCE\xDD\xE1\xE9\x1E\x03\x60\xE8\x02\x81\x09\x52\x63\xE8\x6A\x7E\xF0\xE9\xF8\xE9\x0D\x81\xB3\xDD\xB4\xD5\xEF\xE9\x77\xDD\xEE\x28\x91\x51\xC6\xDD\x1A\x81\xAE\x8C\xF6\xE9\xCF\xAC\xF1\xE9\xC1\x80\xD8\xDD\xDE\x5F\x28\xE8\xD3\xE9\x0F\x83\xDF\x5F\x5B\x25\x2F\x81\x22\xE4\xBB\x4F\xCF\x02\x6A\xDD\x84\x07\xB7\xDD\x02\x10\x48\x33\x55\x52\xC1\x5A\x17\xEA\x1A\x5C\x5C\x52\x63\x07\xC3\x4F\x52\x6F\xEC\x4C\x1E\xEA\xB6\x4F\xDB\x4A\x2C\xCE\xEA\x5A\x5C\x00\xC5\xDC\xC4\x6B\x2A\xEA\x39\x03\x61\x80\xBD\xBB\x14\x0B\xC2\xDD\x8B\xA4\x01\xE3\x5D\x5D\x13\xEA\xBC\xCE\x08\x0A\xE5\xDC\x13\xDD\x0F\x0A\x80\xDC\x5F\xDD\x44\xDD\x0F\x05\x47\xDD\x97\xDC\x95\xDC\xF6\x02\x00\xDD\xE9\xD0\x6B\x7F\x4E\xDD\xDC\x84\x5A\xDD\x3A\xDD\x96\xDC\x5D\xDD\x01\xDD\x42\xEA\x87\x07\x61\xDD\x65\xDD\x9C\x4B\x07\xDD\x9A\x5D\x06\x0A\xB0\x39\x14\xEA\xC1\x58\x0A\xEA\x7F\xDD\x06\x0A\x62\x00\x3B\xEA\x5C\xEA\x7F\xDD\x6E\xE8\x82\x82\x06\x0A\xD5\x71\x85\xE8\x10\xA7\x83\xBC\x9D\xE4\x0D\xDB\x11\xE6\x0E\xC4\x13",
"\xE6\xC8\xDE\x07\xE7\x19\xE5\x94\xE8\x84\xE3\xDD\xE6\x6D\xEA\x9D\xE8\x3B\xE4\xF8\xE3\x11\xDB\xA1\xE8\x16\xE7\x0B\xE0\x48\xDE\x6C\xEA\x82\xE3\xE4\xD7\x10\xA3\x21\xE6\x23\xE7\x89\xD9\x75\xEA\x14\xE8\x17\xE2\xFC\xC8\x05\xDE\xFE\xC8\x2C\xE5\x35\xC4\x1F\xB7\x80\xEA\x84\xE7\x29\xE4\x81\xB1\x76\xEA\x81\xEA\x3B\xE6\x2F\xBE\x94\xEA\x41\xE3\xC6\xC8\x04\xE0\x29\xCC\x70\xEA\x26\xD8\xDF\xE8\xD5\xD4\xB1\xAC\x6F\xBE\x90\xEA\x8C\xE3\x66\xE7\x49\xE0\x4D\xE6\x11\xE9\x5B\xE4\x26\xDE\x5D\xE5\x3C\xD8\xD0\xBC\x6E\x53\xA3\xEA\xE5\xDF\xF7\xE5\x0E\xE9\x67\xE7\x2D\xDF\xA8\xEA\x5B\xE5\x7A\xE7\x6B\xE7\xFC\xD4\xAD\xEA\xDC\x80\x62\xE9\x49\xE6\xAF\xE9\x76\xE7\x74\xE5\x69\xE0\xF9\xD4\xAA\xEA\xF1\xE8\x6D\xE0\xBD\xCC\x25\xBD\x98\xEA\xC7\xE8\x85\xE7\x05\xBD\x88\xEA\x6B\xE2\xF5\xCF\x7E\xE4\xEC\xB6\xE7\xE6\x81\xEA\x55\xC3\xD7\x52\xAF\xEA\x9F\xE7\x8D\xE0\x87\xEA\xD5\xEA\x0C\xE9\xA8\xE7\xF1\x97\x47\xE9\xCB\xEA\xD9\xEA\x6D\xE9\x36\xD0\x36\xBD\xDF\xEA\xA1\xC3\x59\xDA\x93\xEA\xCC\xEA\x55\xE2\x85\xC3\xAE\xE0\xE6\xEA\xE3\xEA\xFB\xDB\xB7\xE4\xEB\xEA\xBC\xEA\x21\xDB\x77\xE9\xA6\x7E\x4C\xBD\xEC\xEA\xC8\xC6\x91\xE9\x16\x4E\xAF\xD5\x86\xE9\x9B\xE5\xE6\xE7\x9B\xE3\xBB\xEA\xB1\xE7\x08\xD9\x82\xE9\x0A\xD9\xD6\xE4\xC9\xE6\xD8\xE4\xD2\xE5\x98\xD0\x16\xD4\xFD\xEA\xA8\xE3\xE9\xE8\x05\xE5\xD3\xE3\xD8\xD5\xE5\xE4\xB4\xDA\xD9\xE6\xF4\xEA\xF0\xEA\x48\xDC\x37\xD4\xE4\xDA\xD5\xE3\xCE\xC1\xF3\xBF\xC8\xEA\xB0\xEA\x15\xEB\x4E\xC7\xF0\xE5\x4C\xD4\x09\xEB\xD0\xE3\xE8\xE6\xBE\xEA\xF8\xE5\xF6\xE2\xE9\xDF\x42\xD9\x17\xCD\x66\x00\x62\xEA\x5A\xC0\x9D\xAB\xB1\xAC\x99\xCE\x37\xD8\x05\x7F\x69\xE7\xC3\xEA\x7B\xE7\xF2\xE8\x54\x73\x25\xC1\x5C\xE6\xB5\xEA\x5B\xE7\x6C\xE4\x5D\xE0\x2A\xC3\x2E\xEB\xEC\xE1\x3D\xAA\x5A\xE7\x4F\xE6\x5C\xE7\x2A\xB9\x0F\xE1\x26\xE8\x68\x00\x2A\xEB\x63\xEA\xC3\xCD\xCD\xE3\xA8\x6C\xF1\xE4\x13\xCA\x11\xEA\x90\x82\x47\xEB\x48\xEB\xBD\xBB\x10\xD9\x4B\xEB\x98\xDE\xB2\xDA\x20\xD9\x65\xBC\xD7\xE9\x59\x0C\x50\xEB\x51\xEB\x49\xBC\xDE\xDF\x03\x58\x26\xA0\xF7\xE6\xDE\xE3\x06\x0A\xD3\x6E\x2B\xEB\xDC\x6E\x34\x83\xBF\x7F\x21\xE7\x4B\x81\x3F\xB8\xB1\x95\x6F\xCF\x36\x8C\xC6\x8F\xFC\x81\x9F\x67\x23\xA3\x6B\x95\x42\x8C\xAE\xA3\x44\x8C\x2A\x01\x29\xA3\x75\xCE\x9F\xA2\x47\x9B\x4A\x95\x01\xA3\x41\x94\x9B\x94\x75\xEB\x9D\x94\x50\x95\xEC\x6B\x93\xC0\xAE\x52\x39\xE8\x09\xB8\x5C\xA3\x74\xEB\xA4\xA2\xB6\x82\x45\xA3\xB3\x81\x3D\xEB\xDF\xA8\x14\xB8\x3E\xB8\x80\xEB\x66\x9B\x65\x95\x29\x7E\x8E\xEB\x10\xAB\x6C\x8C\xBF\xA2\x47\xB8\x77\x81\x20\xB8\x96\xEB\x48\x07\xC4\x94\x48\x9B\x7D\xEB\x4C\x95\x64\x9B\x92\xEB\xA6\x8C\xC9\x94\x95\xEB\x84\xEB\x1E\x53\x45\x6F\x82\x95\x9A\xEB\x72\x8C\xD4\xA2\x6E\x5C\x7B\xA3\xEE\x5B\xAC\xEB\xD4\x7F\xDD\xA2\xAF\xEB\x85\xA3\x44\x6D\x91\xEB\x8A\xEB\x76\xEB\x41\xB8\x53\x56\x9D\xEB\x60\x9B\xA1\x8C\x90\xA3\xB8\xEB\x5E\xB8\x27\x94\x49\xB8\x7F\xDD\x97\x9B\x6A\xAE\x6B\x7F\xBC\xEB\x03\x58\xCD\xE5\xA0\x9B\x42\xD2\xAD\xA3\xB9\xEB\xE4\x81\x06\x5E\x06\x0A\x71\xCA\xA6\xCD\x04\xE3\x73\xD4\xD3\xEB\x73\xCF\x88\xD0\x75\xCF\xE2\xE1\xE4\xE8\x23\xE9\x41\xE9\x1E\xE8\xCA\xE5\x0E\xDF\x05\xE6\x2E\xD6\xB2\xD2\x42\xE1\x93\xE8\x44\xE1\x83\x69\xD7\xEB\xAA\xCF\x64\xCF\x71\xE1\xA9\xE2\xB9\xD9\x7B\xE9\xB8\xE9\x4C\xE9\x7E\xE9\xAC\xE5\xD1\xD4\xE2\xEB\x06\xE7\x21\xE5\x7C\xEA\x8E\xB8\x17\xE7\x3D\x9E\xE9\xEB\xE9\xCF\xD7\xD0\xEC\xEB\x64\xDB\xEE\xEB\xB7\xE9\xD1\xE7\x99\xE8\x2F\xDB\x9B\xE8\x77\xDE\x05\xC6\x10\xE4\xD4\xC2\x2F\xE7\x10\xC0\x26\xE3\x64\x89\xFC\xEB\x09\xD0\x48\xD0\x99\xE9\x89\xE8\xEA\xE7\x1D\xE8\x1C\xE7\x08\xE8\x1E\xE7\x42\xE7\x2D\xE7\x8C\xEA\x0B\xEC\xE6\x73\x9A\xD9\x87\x85\x61\xD0\x89\xD0\x53\xD8\x0C\xDC\x1A\xE9\x62\xE7\x1C\xE9\xA3\xE3\x56\xC1\x08\xD8\x1F\xEC\xAF\xD0\x96\xCF\xA8\xE9\x07\xE9\x9B\xE9\x9C\xE7\x9D\xE9\x0B\xE9\x76\xE9\x59\xD1\x3A\x88\x0F\xEC\x29\xD0\xC4\xD0\x62\xD0\x7E\xD9\xC7\xE7\x3A\xE1\xC9\xE7\xD0\xE6\x17\xEC\x32\xE0\x4B\xE7\x7C\xCC\xB1\xE1\x50\xE5\xA6\xA7\x36\xEC\x54\xD0\xD9\xEB\x56\xD0\xC9\xD7\x3F\xE9\x51\xE7\x60\xE9\x58\xD8\x73\xE7\x86\xE5\x0D\xE9\x2D\xB5\x49\xE4\x0E\xB9\x52\xE3\x6B\xE0\x3A\xEB\x60\xE6\x74\xDB\x9D\x0B\x46\xEC\x87\xD0\x38\xEC\x21\xEC\x81\xD8\x10\xE8\x04\xC8\x12\xE8\xE6\xE6\x1A\xEB\x65\xE7\x73\xE5\xEC\xE8\x5E\xE3\x51\xE3\x60\xE3\x56\xEC\xAB\xEA\xED\xD9\x45\xEC\x20\xEC\xDA",
"\xEB\x4A\xEC\xA9\xE9\x5F\xE9\x8D\xE9\xB0\xE7\x4F\xEC\xF6\xE5\x58\xC9\xF9\xB2\x69\xE4\xC2\xEA\x61\xE3\x6C\xEC\x70\xE3\x64\xD8\x26\x9C\x5B\xEC\x9C\xD0\x4E\xE2\xF6\xE8\x24\xEC\xC4\xE8\x63\xE7\x8C\xE4\x1E\xE9\xCA\xEA\xC7\xAA\x81\xEC\xFE\xEB\xA8\xE2\x00\xEC\x38\xE1\xEF\xEB\x03\xEC\x56\xE9\x05\xEC\x58\xE9\xD5\xE7\x0A\xC8\x7B\xD3\x7B\x84\x6F\xEC\x49\xEC\x22\xEC\x8C\xE1\x4C\xEC\x74\xEC\x61\xE9\xFF\xEA\x2F\xC4\xBC\xDB\x5A\xEC\x9A\xEC\x3E\xCF\x4A\xE1\xDC\xEB\xDD\xE4\x2E\xE9\x48\xE7\x3A\xE9\x8C\xB0\x24\xE2\x20\x7D\x23\xCF\x55\xD0\xA6\xEC\xB7\xE1\xA8\xEC\x0C\xE7\xD8\xE8\x4D\xE9\xD1\xE4\xBC\xE9\x3D\xC7\xFB\xEA\x8E\xE3\x13\x75\x8C\xEC\xEB\xEB\x8E\xEC\xF5\xDA\x01\xEC\xC5\xE9\x37\xE9\x3E\xE7\x39\xE9\x06\xEC\x67\xDF\x9E\xE0\x51\xE9\x80\xEC\xA5\xEC\xAC\xCF\xD6\xDB\x9D\xEC\xC3\xE8\x81\xE7\x87\xEC\x12\xE5\xA6\xE4\x7D\xDF\x5C\x85\xCC\xEC\xD8\xD0\xF5\xDB\xC2\xE8\xF7\xE8\xE1\xD9\x9D\xE3\xF5\xE5\x6E\xD6\xAD\xE0\xCF\xD8\xAA\x97\xBE\xEC\xB1\xEC\xCD\xEC\xAA\xDB\xE2\xDB\x85\xEC\xD1\xEC\x26\xEC\xA5\xE4\x9F\xE6\x61\xE2\xBD\xEC\xD7\xEC\xFF\xEB\xC1\xEC\x90\xEC\x02\xEC\x3C\xEC\xCD\xE8\xC2\xE6\xE8\xE8\xE2\xE5\x31\xD2\xBB\xE5\xF6\x88\xE3\xEC\x48\xEC\xB2\xEC\xCD\xE1\xB4\xEC\x40\xE9\x46\xE6\x13\xE8\xF5\xEA\xDD\xD3\xF7\xEA\xC3\xE5\x85\xE9\xF2\xE7\xD1\xDB\xFB\xC4\xFB\xEC\xEF\xEC\xC0\xEC\x1B\xDC\xF8\xE1\xD0\xEC\xF8\xE8\xD2\xEC\x32\xE5\xC6\xE4\xBC\xE3\x8E\xC7\x8C\xDE\x27\xDC\x94\xE9\x37\xE5\x58\xD2\xDB\xE4\x2C\xDC\xFC\xEC\x5D\xEC\x70\xEC\x9C\xEC\x10\xED\xDB\xEC\x79\xE0\x13\xED\x98\xE3\xA4\xEA\x39\xC0\xD5\xE6\xD9\xD5\x38\xB6\xA5\xE9\xC2\x76\x1F\xED\x0A\xD0\xC5\xD0\x2A\xDB\x07\xDB\xF8\xDA\x04\xEC\x65\xDF\xC7\xEC\x04\xE5\xFB\xE4\xF5\xE6\xA2\xDE\x8E\xD7\xE7\xE5\x18\xEB\x3D\xDC\x2F\xED\x11\xEC\x2D\xEC\x71\xE9\xAA\xE9\xB6\xE8\xAC\xE9\xB8\xE8\xAE\xDA\x23\xEB\x64\xCB\xFC\xD5\x1E\xEB\x49\xC0\xC2\xE9\xB9\xE2\x40\xED\x73\xD0\x12\xEC\xB4\xE8\x44\xED\x6A\xE9\x46\xED\x6C\xE9\x48\xED\xFC\xE8\x78\xB6\x0E\xD6\xFA\xE5\x09\xE5\x0B\xE1\x9C\x45\x5C\xEB\xC2\x58\x32\xD9\xD9\xA3\xDD\xE3\x0A\x6B\x59\xEB\x09\x01\x5B\xEB\x60\xED\x07\xDC\x00\x00\x71\x7A\x28\x8F\x5D\x98\x2E\xCB\x18\x4E\x56\xEA\xD1\xEB\x71\x78\x49\xAE\x08\xE4\x62\xA2\x69\xE1\xE6\xD7\x1C\xEC\x71\xCE\x26\xE3\xDE\x58\x1A\xEC\xBE\xBD\x23\xE0\x21\xE4\x95\xAB\xB2\x8F\x24\x81\x8B\xBF\xD7\x52\xB1\xEA\x52\xEC\xA7\xEA\x69\xEC\x12\xE9\x32\xEB\xB8\xEA\x34\xEB\x39\x6C\x86\xED\xF2\xBD\xFF\xE8\xC3\xE1\xD4\xCF\x14\xE9\x44\xB7\xB1\xAC\x85\xED\x78\xEC\x00\xBE\xC1\xEA\x31\xEB\x7C\xEC\xC4\xEA\x6D\xE4\xF3\xE1\x01\x8C\x6B\xC9\x60\xB8\x98\xC6\xE9\x6E\xE7\xE9\x6C\x82\xB1\xEA\x59\xD5\xFC\x8C\xB4\xAA\x9A\x5D\x8A\xB3\x60\xB8\xC5\xE7\x60\xB8\x01\xC0\xC3\xCD\x9B\xDF\x25\x0A\x06\xED\xCD\xEB\x94\xB7\x79\xED\x0A\xED\xFC\xEA\xA1\x59\xF7\xEA\xEE\xC9\xB3\xDF\x8E\xDE\xBD\xE8\xFB\xB9\x08\xEB\xA2\x5C\xB1\xEA\xC1\xDF\x7B\xD7\x2C\xED\xC4\xDF\x70\xCD\x44\xB1\xC3\xED\x7B\xCD\xF2\xE4\x62\xED\x1B\x81\xCA\xED\x90\xB0\x4C\xED\xED\xE6\x5E\xDC\x27\x9B\xDB\xEA\x60\xEB\xE5\xD0\x52\xD9\xAC\x86\x26\xE8\x62\x71\x69\xEA\xE5\x7E\x0C\x95\x04\xE7\xE3\xDD\xAF\xE1\x18\xE3\xB3\xD2\x02\xDB\x5D\x7F\xDE\xED\x23\xD8\xEF\xDD\x9B\xAE\x7B\xEA\x0F\xE3\x13\xDB\xCA\xC2\xEA\x7E\x11\xDE\x77\xED\x22\xE7\xB7\xED\xFE\xDD\x14\xE4\xA6\xB8\xD4\xED\x1F\xE7\x7D\xED\x22\xE0\xE5\xDE\x35\xC4\xFE\x6B\x80\xE5\x36\xE3\xFC\xED\xF9\xEC\x08\xD3\x6C\x99\xE6\xED\xDC\xE8\xE0\xED\x17\xE3\x07\xC1\x43\xEC\x3C\xBE\x8B\xBF\x1F\xB7\xE3\xE5\x1B\x85\xE3\xBD\x30\xEB\x1F\xDF\xDA\xE1\x02\xE9\x22\xDF\x36\xB5\x0B\xEE\xEA\xE8\x57\xE5\xD7\xE1\x68\xE5\x92\xED\x92\xD1\x12\xEE\xDC\xE1\x59\xAF\x15\xEE\x0C\xEB\x5A\xE6\x3E\xEB\xE3\xAC\x1A\xEE\xF0\xE1\xDA\x7A\xF2\xE1\xC6\xEA\x4A\xB8\xB8\xD4\x00\xE2\xAE\x8C\x70\xC3\x98\xC6\xFF\xED\x59\xDF\x97\xE7\xF3\x94\x81\xDD\x50\xB1\x72\xE5\x2D\xBE\x93\xE6\x94\xA3\x7C\xDF\x0E\xD7\xDA\x69\x0B\xD2\x4A\xE2\x2F\xEE\x65\xDA\xE9\xEA\xE1\xEC\x50\xB8\x70\xC3\x01\xC0\x3E\xEE\xB4\xE6\xBF\xE0\xFD\xB9\xD7\x52\xCC\xE5\xC1\xE5\x41\xD2\x72\x94\x08\xED\xCB\xE4\x0B\xED\x33\x6F\x4A\xEE\xE0\xE7\x69\xC8\x18\xED\xBD\xED\xC0\xE3\xC6\xE5\xF3\xC9\xCD\xE6\x71\x9B\x0C\xEE\x3A\xED\xE4\xDA\x0F\xEB\x2D\xED\x39\x6C\x5C\xEE\x0B\xE8\xE5\xE5\x3C\xED\xB3\xE9\x91\xD7\x49\xEE\x16\xEE\xBE\xE9\x1D\xEB\xC0\xE9\xA2\xD7\x2A\xA3\x62\xEE\x0C",
"\xB4\xB5\xDE\xD7\xED\xF8\xE2\xDA\x8B\x39\xEA\xAC\x6F\xDC\xED\x5A\x6B\x77\xEA\xF6\xE3\x7B\xC7\x16\xE5\xE4\xEB\x08\xE6\xEB\xED\x09\xE7\xFE\x6C\x79\xEE\xDF\xED\x43\xE3\xE4\xDD\x14\xE6\xF7\xEB\xEB\xED\xA2\xE8\x39\x6C\x89\xEA\x82\xEA\x37\x9E\x2B\xE5\xF2\xED\x88\x54\x26\xE3\xD7\x52\x8B\xEE\x04\xDE\xF7\xD7\xBC\xE8\xB5\xDF\x2F\xE3\xF4\xDE\x41\x7C\xEA\x7E\x17\xE2\xBD\xBC\x9B\xEE\x95\xEA\x06\xDF\xE5\x7E\x92\xEE\x12\xD3\xC4\xB0\x90\xE8\x4E\xE5\x08\xEE\x06\x5E\x8B\xBF\x83\xBC\x22\xEB\x59\xED\x69\xE6\x28\xD3\x88\xED\xEE\xE8\x55\xEC\xF0\xE8\x33\xEB\xAC\xEA\xB1\xAC\xAA\xEE\x68\xE3\xAC\xEE\x66\xE5\xCC\xC7\x68\xEC\xB0\xEE\x6A\xEC\xB2\xEE\x8C\xED\x63\xE3\x09\xB1\x6E\x53\xAB\xEE\x8F\xED\x92\xDB\x6B\xE6\x79\xE7\x79\xE5\xFF\xD9\x64\xD8\x9E\xEE\x91\xEA\x76\xE4\xA2\x5C\x3D\xE2\x4C\xDE\xD7\x5A\x8B\xEE\x55\xC3\xFE\x6B\xCF\x79\x37\xB1\xA2\xEE\xEE\xE4\x49\xED\xA8\xED\x55\xB1\xCF\xEE\xE1\xEA\xCE\xEE\xCD\xEA\xD5\xEC\x44\xB1\x89\xEA\xD2\xB5\xCB\xEE\x60\xE2\x89\xC1\xCE\xE7\xF6\xED\x15\xE8\xBD\xBB\x9B\xDF\x1F\xB7\x62\xDE\xB4\xED\x4D\xEE\xB4\xE3\xA6\xDF\xBF\xE6\x0C\xBD\xC4\xE6\xFC\x25\xBB\xED\xD8\xE0\xB5\xE2\xDA\xE0\x24\xC0\x2B\xDC\xEC\xEE\xB7\xEE\xCF\xED\x55\xEB\xD7\xE6\xC9\xE2\x02\xE8\xF3\xEE\xA5\xE6\x0D\xE9\x7C\xB0\xB2\xE9\xF3\xE4\x36\xBD\xC3\xEE\x1C\xEB\xFD\xE0\x6C\xEE\xFF\xE0\xC7\xEA\xE9\xEE\x05\xEF\x5B\xD4\x9E\xBE\xD9\xED\x17\xCD\x5D\x68\x77\xEE\xA2\x7F\x3E\xE1\xF5\xEB\xE9\xED\xC9\xDE\x43\xE1\x76\xBA\xAD\x7F\x1E\xE5\x1A\xEF\x1E\xD6\x15\xE6\xC7\xD2\x7D\xEA\x36\xBD\xCC\xE7\x85\xD9\x20\xE6\x78\xED\xBF\xED\x61\xBF\x23\xE6\x20\xBE\x27\xEF\x1F\xE0\x1D\xE4\x96\xEE\x95\xE9\xFA\xD7\x99\xEE\x5A\x6B\x2F\xEF\x19\xA5\x92\xEA\x05\x80\x37\xEF\xD6\xE7\x32\xE4\x18\xEF\x29\xDF\x41\xEC\x07\xEE\x9F\xEA\x28\xD8\x37\xB7\x6E\x53\x3B\xEF\x39\xDF\x67\xE4\xEC\xE8\x53\xEC\x43\xEB\xB1\xEE\xB7\xEA\x1C\xEE\xA6\xCF\x36\xB5\x4C\xBD\x46\xEF\xBD\xE9\x0D\xEE\xC6\xAC\x37\xEB\x89\xED\xA9\xEA\x9C\xED\xB3\xEE\x6D\xEC\x44\xEF\xF3\x53\x52\xEF\xBA\xEC\x57\xE4\xD2\x99\x23\xEE\x40\xEB\x5E\xE6\x50\xE6\x3A\x02\x23\xB1\x14\xD5\x2A\xA3\x5E\xEF\x48\xDF\x22\xD5\x75\x8C\x6A\xEF\x75\xC9\x7E\xD8\xD7\x52\x6E\xEF\x8D\xB8\x55\xC3\xEA\x7E\xA3\xD8\x69\xB7\x45\xEF\xA0\xE5\x59\xE6\xB8\xC3\xF1\xD1\x71\x9B\x72\xEF\x01\x98\x51\xE9\x71\xEF\x79\xEF\x44\xD0\xBB\xB9\x3A\xEF\x82\xEF\x4D\xB1\x56\xE2\x39\x6C\x7E\xEF\x8E\xD5\x2D\xCD\x81\xEF\x20\xE8\x93\xE2\x74\xCE\x83\xBC\x8A\xEF\xC1\xD5\xC6\xE6\x08\xC7\xB3\xE3\x82\xDE\xA2\xE2\xB6\xE3\x65\xDE\x92\xEF\x89\xDE\x53\xEE\x8B\xDE\xF0\xE7\xA1\xB7\x4F\xEE\x91\xDE\x47\xBE\x41\xE7\x6F\xEE\x8F\x96\xE6\xE0\xFF\xE7\x03\xCA\xC7\xED\x6D\xD2\x18\xBE\x9B\xEF\x7A\xEF\x5D\xEE\xE1\xE6\x07\xEF\xCD\xED\xA3\xEF\xAD\xEF\x56\xE5\x6A\xEE\x0C\xEF\xE9\xE3\x4D\xED\xD3\xED\x4E\xBE\x18\xEC\xA5\xEF\xB5\xB7\x71\xEE\xF7\xE2\xB9\xC8\x53\xD9\x69\xED\xC3\xEF\xC4\xEF\xC5\xEF\xC6\xEF\xC7\xEF\xC8\xEF\xC9\xEF\xCA\xEF\xCB\xEF\xCC\xEF\xCD\xEF\xCE\xEF\x11\x52",
};

		void WfGetParserBuffer(vl::stream::MemoryStream& stream)
		{
			vl::stream::MemoryStream compressedStream;
			for (vint i = 0; i < parserBufferRows; i++)
			{
				vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
				compressedStream.Write((void*)parserBuffer[i], size);
			}
			compressedStream.SeekFromBegin(0);
			vl::stream::LzwDecoder decoder;
			vl::stream::DecoderStream decoderStream(compressedStream, decoder);
			vl::collections::Array<vl::vuint8_t> buffer(65536);
			while (true)
			{
				vl::vint size = decoderStream.Read(&buffer[0], 65536);
				if (size == 0) break;
				stream.Write(&buffer[0], size);
			}
			stream.SeekFromBegin(0);
		}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

		extern void UnescapeFormatString(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
		extern void UnescapeString(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

		class WfTreeConverter : public vl::parsing::ParsingTreeConverter
		{
		public:
			using vl::parsing::ParsingTreeConverter::SetMember;

			bool SetMember(WfPredefinedTypeName& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Void") { member=WfPredefinedTypeName::Void; return true; }
					else if(token->GetValue()==L"Object") { member=WfPredefinedTypeName::Object; return true; }
					else if(token->GetValue()==L"Interface") { member=WfPredefinedTypeName::Interface; return true; }
					else if(token->GetValue()==L"Int") { member=WfPredefinedTypeName::Int; return true; }
					else if(token->GetValue()==L"UInt") { member=WfPredefinedTypeName::UInt; return true; }
					else if(token->GetValue()==L"Float") { member=WfPredefinedTypeName::Float; return true; }
					else if(token->GetValue()==L"Double") { member=WfPredefinedTypeName::Double; return true; }
					else if(token->GetValue()==L"String") { member=WfPredefinedTypeName::String; return true; }
					else if(token->GetValue()==L"Char") { member=WfPredefinedTypeName::Char; return true; }
					else if(token->GetValue()==L"Bool") { member=WfPredefinedTypeName::Bool; return true; }
					else { member=WfPredefinedTypeName::Void; return false; }
				}
				member=WfPredefinedTypeName::Void;
				return false;
			}

			bool SetMember(WfMapWritability& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Readonly") { member=WfMapWritability::Readonly; return true; }
					else if(token->GetValue()==L"Writable") { member=WfMapWritability::Writable; return true; }
					else { member=WfMapWritability::Readonly; return false; }
				}
				member=WfMapWritability::Readonly;
				return false;
			}

			bool SetMember(WfLiteralValue& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Null") { member=WfLiteralValue::Null; return true; }
					else if(token->GetValue()==L"True") { member=WfLiteralValue::True; return true; }
					else if(token->GetValue()==L"False") { member=WfLiteralValue::False; return true; }
					else { member=WfLiteralValue::Null; return false; }
				}
				member=WfLiteralValue::Null;
				return false;
			}

			bool SetMember(WfUnaryOperator& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Positive") { member=WfUnaryOperator::Positive; return true; }
					else if(token->GetValue()==L"Negative") { member=WfUnaryOperator::Negative; return true; }
					else if(token->GetValue()==L"Not") { member=WfUnaryOperator::Not; return true; }
					else { member=WfUnaryOperator::Positive; return false; }
				}
				member=WfUnaryOperator::Positive;
				return false;
			}

			bool SetMember(WfBinaryOperator& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Assign") { member=WfBinaryOperator::Assign; return true; }
					else if(token->GetValue()==L"Index") { member=WfBinaryOperator::Index; return true; }
					else if(token->GetValue()==L"Concat") { member=WfBinaryOperator::Concat; return true; }
					else if(token->GetValue()==L"FailedThen") { member=WfBinaryOperator::FailedThen; return true; }
					else if(token->GetValue()==L"Exp") { member=WfBinaryOperator::Exp; return true; }
					else if(token->GetValue()==L"Add") { member=WfBinaryOperator::Add; return true; }
					else if(token->GetValue()==L"Sub") { member=WfBinaryOperator::Sub; return true; }
					else if(token->GetValue()==L"Mul") { member=WfBinaryOperator::Mul; return true; }
					else if(token->GetValue()==L"Div") { member=WfBinaryOperator::Div; return true; }
					else if(token->GetValue()==L"Mod") { member=WfBinaryOperator::Mod; return true; }
					else if(token->GetValue()==L"Shl") { member=WfBinaryOperator::Shl; return true; }
					else if(token->GetValue()==L"Shr") { member=WfBinaryOperator::Shr; return true; }
					else if(token->GetValue()==L"LT") { member=WfBinaryOperator::LT; return true; }
					else if(token->GetValue()==L"GT") { member=WfBinaryOperator::GT; return true; }
					else if(token->GetValue()==L"LE") { member=WfBinaryOperator::LE; return true; }
					else if(token->GetValue()==L"GE") { member=WfBinaryOperator::GE; return true; }
					else if(token->GetValue()==L"EQ") { member=WfBinaryOperator::EQ; return true; }
					else if(token->GetValue()==L"NE") { member=WfBinaryOperator::NE; return true; }
					else if(token->GetValue()==L"Xor") { member=WfBinaryOperator::Xor; return true; }
					else if(token->GetValue()==L"And") { member=WfBinaryOperator::And; return true; }
					else if(token->GetValue()==L"Or") { member=WfBinaryOperator::Or; return true; }
					else { member=WfBinaryOperator::Assign; return false; }
				}
				member=WfBinaryOperator::Assign;
				return false;
			}

			bool SetMember(WfRangeBoundary& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Inclusive") { member=WfRangeBoundary::Inclusive; return true; }
					else if(token->GetValue()==L"Exclusive") { member=WfRangeBoundary::Exclusive; return true; }
					else { member=WfRangeBoundary::Inclusive; return false; }
				}
				member=WfRangeBoundary::Inclusive;
				return false;
			}

			bool SetMember(WfSetTesting& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"In") { member=WfSetTesting::In; return true; }
					else if(token->GetValue()==L"NotIn") { member=WfSetTesting::NotIn; return true; }
					else { member=WfSetTesting::In; return false; }
				}
				member=WfSetTesting::In;
				return false;
			}

			bool SetMember(WfTypeCastingStrategy& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Strong") { member=WfTypeCastingStrategy::Strong; return true; }
					else if(token->GetValue()==L"Weak") { member=WfTypeCastingStrategy::Weak; return true; }
					else { member=WfTypeCastingStrategy::Strong; return false; }
				}
				member=WfTypeCastingStrategy::Strong;
				return false;
			}

			bool SetMember(WfTypeTesting& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"IsType") { member=WfTypeTesting::IsType; return true; }
					else if(token->GetValue()==L"IsNotType") { member=WfTypeTesting::IsNotType; return true; }
					else if(token->GetValue()==L"IsNull") { member=WfTypeTesting::IsNull; return true; }
					else if(token->GetValue()==L"IsNotNull") { member=WfTypeTesting::IsNotNull; return true; }
					else { member=WfTypeTesting::IsType; return false; }
				}
				member=WfTypeTesting::IsType;
				return false;
			}

			bool SetMember(WfObserveType& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"SimpleObserve") { member=WfObserveType::SimpleObserve; return true; }
					else if(token->GetValue()==L"ExtendedObserve") { member=WfObserveType::ExtendedObserve; return true; }
					else { member=WfObserveType::SimpleObserve; return false; }
				}
				member=WfObserveType::SimpleObserve;
				return false;
			}

			bool SetMember(WfForEachDirection& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Normal") { member=WfForEachDirection::Normal; return true; }
					else if(token->GetValue()==L"Reversed") { member=WfForEachDirection::Reversed; return true; }
					else { member=WfForEachDirection::Normal; return false; }
				}
				member=WfForEachDirection::Normal;
				return false;
			}

			bool SetMember(WfFunctionAnonymity& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Named") { member=WfFunctionAnonymity::Named; return true; }
					else if(token->GetValue()==L"Anonymous") { member=WfFunctionAnonymity::Anonymous; return true; }
					else { member=WfFunctionAnonymity::Named; return false; }
				}
				member=WfFunctionAnonymity::Named;
				return false;
			}

			bool SetMember(WfClassMemberKind& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Static") { member=WfClassMemberKind::Static; return true; }
					else if(token->GetValue()==L"Normal") { member=WfClassMemberKind::Normal; return true; }
					else { member=WfClassMemberKind::Static; return false; }
				}
				member=WfClassMemberKind::Static;
				return false;
			}

			bool SetMember(WfClassKind& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Class") { member=WfClassKind::Class; return true; }
					else if(token->GetValue()==L"Interface") { member=WfClassKind::Interface; return true; }
					else { member=WfClassKind::Class; return false; }
				}
				member=WfClassKind::Class;
				return false;
			}

			bool SetMember(WfModuleType& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Module") { member=WfModuleType::Module; return true; }
					else if(token->GetValue()==L"Unit") { member=WfModuleType::Unit; return true; }
					else { member=WfModuleType::Module; return false; }
				}
				member=WfModuleType::Module;
				return false;
			}

			void Fill(vl::Ptr<WfType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfPredefinedType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfTopQualifiedType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfReferenceType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfRawPointerType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
			}

			void Fill(vl::Ptr<WfSharedPointerType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
			}

			void Fill(vl::Ptr<WfNullableType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
			}

			void Fill(vl::Ptr<WfEnumerableType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
			}

			void Fill(vl::Ptr<WfMapType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->writability, obj->GetMember(L"writability"), tokens);
				SetMember(tree->key, obj->GetMember(L"key"), tokens);
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfFunctionType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->result, obj->GetMember(L"result"), tokens);
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
			}

			void Fill(vl::Ptr<WfChildType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfTopQualifiedExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfReferenceExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfOrderedNameExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfOrderedLambdaExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->body, obj->GetMember(L"body"), tokens);
			}

			void Fill(vl::Ptr<WfMemberExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfChildExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfLiteralExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfFloatingExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfIntegerExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfStringExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
				{
					UnescapeString(tree->value, tokens);
				}
			}

			void Fill(vl::Ptr<WfFormatExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
				{
					UnescapeFormatString(tree->value, tokens);
				}
				SetMember(tree->expandedExpression, obj->GetMember(L"expandedExpression"), tokens);
			}

			void Fill(vl::Ptr<WfUnaryExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->op, obj->GetMember(L"op"), tokens);
				SetMember(tree->operand, obj->GetMember(L"operand"), tokens);
			}

			void Fill(vl::Ptr<WfBinaryExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->op, obj->GetMember(L"op"), tokens);
				SetMember(tree->first, obj->GetMember(L"first"), tokens);
				SetMember(tree->second, obj->GetMember(L"second"), tokens);
			}

			void Fill(vl::Ptr<WfLetVariable> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfLetExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->variables, obj->GetMember(L"variables"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfIfExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->condition, obj->GetMember(L"condition"), tokens);
				SetMember(tree->trueBranch, obj->GetMember(L"trueBranch"), tokens);
				SetMember(tree->falseBranch, obj->GetMember(L"falseBranch"), tokens);
			}

			void Fill(vl::Ptr<WfRangeExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->begin, obj->GetMember(L"begin"), tokens);
				SetMember(tree->beginBoundary, obj->GetMember(L"beginBoundary"), tokens);
				SetMember(tree->end, obj->GetMember(L"end"), tokens);
				SetMember(tree->endBoundary, obj->GetMember(L"endBoundary"), tokens);
			}

			void Fill(vl::Ptr<WfSetTestingExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->test, obj->GetMember(L"test"), tokens);
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
				SetMember(tree->collection, obj->GetMember(L"collection"), tokens);
			}

			void Fill(vl::Ptr<WfConstructorArgument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->key, obj->GetMember(L"key"), tokens);
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfConstructorExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
			}

			void Fill(vl::Ptr<WfInferExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfTypeCastingExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->strategy, obj->GetMember(L"strategy"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfTypeTestingExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->test, obj->GetMember(L"test"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfTypeOfTypeExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfTypeOfExpressionExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfAttachEventExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->event, obj->GetMember(L"event"), tokens);
				SetMember(tree->function, obj->GetMember(L"function"), tokens);
			}

			void Fill(vl::Ptr<WfDetachEventExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->handler, obj->GetMember(L"handler"), tokens);
			}

			void Fill(vl::Ptr<WfBindExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->expandedExpression, obj->GetMember(L"expandedExpression"), tokens);
			}

			void Fill(vl::Ptr<WfObserveExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->observeType, obj->GetMember(L"observeType"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->events, obj->GetMember(L"events"), tokens);
			}

			void Fill(vl::Ptr<WfCallExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->function, obj->GetMember(L"function"), tokens);
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
			}

			void Fill(vl::Ptr<WfStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfBreakStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfContinueStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfReturnStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfDeleteStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfRaiseExceptionStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfIfStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->trueBranch, obj->GetMember(L"trueBranch"), tokens);
				SetMember(tree->falseBranch, obj->GetMember(L"falseBranch"), tokens);
			}

			void Fill(vl::Ptr<WfSwitchCase> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->statement, obj->GetMember(L"statement"), tokens);
			}

			void Fill(vl::Ptr<WfSwitchStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->caseBranches, obj->GetMember(L"caseBranches"), tokens);
				SetMember(tree->defaultBranch, obj->GetMember(L"defaultBranch"), tokens);
			}

			void Fill(vl::Ptr<WfWhileStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->condition, obj->GetMember(L"condition"), tokens);
				SetMember(tree->statement, obj->GetMember(L"statement"), tokens);
			}

			void Fill(vl::Ptr<WfForEachStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->direction, obj->GetMember(L"direction"), tokens);
				SetMember(tree->collection, obj->GetMember(L"collection"), tokens);
				SetMember(tree->statement, obj->GetMember(L"statement"), tokens);
			}

			void Fill(vl::Ptr<WfTryStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->protectedStatement, obj->GetMember(L"protectedStatement"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->catchStatement, obj->GetMember(L"catchStatement"), tokens);
				SetMember(tree->finallyStatement, obj->GetMember(L"finallyStatement"), tokens);
			}

			void Fill(vl::Ptr<WfBlockStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->statements, obj->GetMember(L"statements"), tokens);
			}

			void Fill(vl::Ptr<WfExpressionStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfNamespaceDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->declarations, obj->GetMember(L"declarations"), tokens);
			}

			void Fill(vl::Ptr<WfFunctionArgument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfFunctionDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->anonymity, obj->GetMember(L"anonymity"), tokens);
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
				SetMember(tree->returnType, obj->GetMember(L"returnType"), tokens);
				SetMember(tree->statement, obj->GetMember(L"statement"), tokens);
			}

			void Fill(vl::Ptr<WfFunctionExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->function, obj->GetMember(L"function"), tokens);
			}

			void Fill(vl::Ptr<WfVariableDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfVariableStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->variable, obj->GetMember(L"variable"), tokens);
			}

			void Fill(vl::Ptr<WfNewTypeExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
				SetMember(tree->functions, obj->GetMember(L"functions"), tokens);
			}

			void Fill(vl::Ptr<WfClassMember> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->kind, obj->GetMember(L"kind"), tokens);
				SetMember(tree->declaration, obj->GetMember(L"declaration"), tokens);
			}

			void Fill(vl::Ptr<WfEventDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
			}

			void Fill(vl::Ptr<WfPropertyDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
				SetMember(tree->getter, obj->GetMember(L"getter"), tokens);
				SetMember(tree->setter, obj->GetMember(L"setter"), tokens);
				SetMember(tree->valueChangedEvent, obj->GetMember(L"valueChangedEvent"), tokens);
			}

			void Fill(vl::Ptr<WfClassDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->kind, obj->GetMember(L"kind"), tokens);
				SetMember(tree->baseTypes, obj->GetMember(L"baseTypes"), tokens);
				SetMember(tree->members, obj->GetMember(L"members"), tokens);
			}

			void Fill(vl::Ptr<WfModuleUsingFragment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfModuleUsingNameFragment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfModuleUsingWildCardFragment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfModuleUsingItem> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->fragments, obj->GetMember(L"fragments"), tokens);
			}

			void Fill(vl::Ptr<WfModuleUsingPath> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->items, obj->GetMember(L"items"), tokens);
			}

			void Fill(vl::Ptr<WfModule> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->moduleType, obj->GetMember(L"moduleType"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->paths, obj->GetMember(L"paths"), tokens);
				SetMember(tree->declarations, obj->GetMember(L"declarations"), tokens);
			}

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
			{
				if(obj->GetType()==L"PredefinedType")
				{
					vl::Ptr<WfPredefinedType> tree = new WfPredefinedType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TopQualifiedType")
				{
					vl::Ptr<WfTopQualifiedType> tree = new WfTopQualifiedType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ReferenceType")
				{
					vl::Ptr<WfReferenceType> tree = new WfReferenceType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"RawPointerType")
				{
					vl::Ptr<WfRawPointerType> tree = new WfRawPointerType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SharedPointerType")
				{
					vl::Ptr<WfSharedPointerType> tree = new WfSharedPointerType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"NullableType")
				{
					vl::Ptr<WfNullableType> tree = new WfNullableType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"EnumerableType")
				{
					vl::Ptr<WfEnumerableType> tree = new WfEnumerableType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"MapType")
				{
					vl::Ptr<WfMapType> tree = new WfMapType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FunctionType")
				{
					vl::Ptr<WfFunctionType> tree = new WfFunctionType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ChildType")
				{
					vl::Ptr<WfChildType> tree = new WfChildType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TopQualifiedExpression")
				{
					vl::Ptr<WfTopQualifiedExpression> tree = new WfTopQualifiedExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ReferenceExpression")
				{
					vl::Ptr<WfReferenceExpression> tree = new WfReferenceExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"OrderedNameExpression")
				{
					vl::Ptr<WfOrderedNameExpression> tree = new WfOrderedNameExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"OrderedLambdaExpression")
				{
					vl::Ptr<WfOrderedLambdaExpression> tree = new WfOrderedLambdaExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"MemberExpression")
				{
					vl::Ptr<WfMemberExpression> tree = new WfMemberExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ChildExpression")
				{
					vl::Ptr<WfChildExpression> tree = new WfChildExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"LiteralExpression")
				{
					vl::Ptr<WfLiteralExpression> tree = new WfLiteralExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FloatingExpression")
				{
					vl::Ptr<WfFloatingExpression> tree = new WfFloatingExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"IntegerExpression")
				{
					vl::Ptr<WfIntegerExpression> tree = new WfIntegerExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"StringExpression")
				{
					vl::Ptr<WfStringExpression> tree = new WfStringExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FormatExpression")
				{
					vl::Ptr<WfFormatExpression> tree = new WfFormatExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"UnaryExpression")
				{
					vl::Ptr<WfUnaryExpression> tree = new WfUnaryExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"BinaryExpression")
				{
					vl::Ptr<WfBinaryExpression> tree = new WfBinaryExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"LetVariable")
				{
					vl::Ptr<WfLetVariable> tree = new WfLetVariable;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"LetExpression")
				{
					vl::Ptr<WfLetExpression> tree = new WfLetExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"IfExpression")
				{
					vl::Ptr<WfIfExpression> tree = new WfIfExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"RangeExpression")
				{
					vl::Ptr<WfRangeExpression> tree = new WfRangeExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SetTestingExpression")
				{
					vl::Ptr<WfSetTestingExpression> tree = new WfSetTestingExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ConstructorArgument")
				{
					vl::Ptr<WfConstructorArgument> tree = new WfConstructorArgument;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ConstructorExpression")
				{
					vl::Ptr<WfConstructorExpression> tree = new WfConstructorExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"InferExpression")
				{
					vl::Ptr<WfInferExpression> tree = new WfInferExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TypeCastingExpression")
				{
					vl::Ptr<WfTypeCastingExpression> tree = new WfTypeCastingExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TypeTestingExpression")
				{
					vl::Ptr<WfTypeTestingExpression> tree = new WfTypeTestingExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TypeOfTypeExpression")
				{
					vl::Ptr<WfTypeOfTypeExpression> tree = new WfTypeOfTypeExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TypeOfExpressionExpression")
				{
					vl::Ptr<WfTypeOfExpressionExpression> tree = new WfTypeOfExpressionExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"AttachEventExpression")
				{
					vl::Ptr<WfAttachEventExpression> tree = new WfAttachEventExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"DetachEventExpression")
				{
					vl::Ptr<WfDetachEventExpression> tree = new WfDetachEventExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"BindExpression")
				{
					vl::Ptr<WfBindExpression> tree = new WfBindExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ObserveExpression")
				{
					vl::Ptr<WfObserveExpression> tree = new WfObserveExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"CallExpression")
				{
					vl::Ptr<WfCallExpression> tree = new WfCallExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"BreakStatement")
				{
					vl::Ptr<WfBreakStatement> tree = new WfBreakStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ContinueStatement")
				{
					vl::Ptr<WfContinueStatement> tree = new WfContinueStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ReturnStatement")
				{
					vl::Ptr<WfReturnStatement> tree = new WfReturnStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"DeleteStatement")
				{
					vl::Ptr<WfDeleteStatement> tree = new WfDeleteStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"RaiseExceptionStatement")
				{
					vl::Ptr<WfRaiseExceptionStatement> tree = new WfRaiseExceptionStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"IfStatement")
				{
					vl::Ptr<WfIfStatement> tree = new WfIfStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SwitchCase")
				{
					vl::Ptr<WfSwitchCase> tree = new WfSwitchCase;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SwitchStatement")
				{
					vl::Ptr<WfSwitchStatement> tree = new WfSwitchStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"WhileStatement")
				{
					vl::Ptr<WfWhileStatement> tree = new WfWhileStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ForEachStatement")
				{
					vl::Ptr<WfForEachStatement> tree = new WfForEachStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TryStatement")
				{
					vl::Ptr<WfTryStatement> tree = new WfTryStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"BlockStatement")
				{
					vl::Ptr<WfBlockStatement> tree = new WfBlockStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ExpressionStatement")
				{
					vl::Ptr<WfExpressionStatement> tree = new WfExpressionStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"NamespaceDeclaration")
				{
					vl::Ptr<WfNamespaceDeclaration> tree = new WfNamespaceDeclaration;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfDeclaration>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FunctionArgument")
				{
					vl::Ptr<WfFunctionArgument> tree = new WfFunctionArgument;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FunctionDeclaration")
				{
					vl::Ptr<WfFunctionDeclaration> tree = new WfFunctionDeclaration;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfDeclaration>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FunctionExpression")
				{
					vl::Ptr<WfFunctionExpression> tree = new WfFunctionExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"VariableDeclaration")
				{
					vl::Ptr<WfVariableDeclaration> tree = new WfVariableDeclaration;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfDeclaration>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"VariableStatement")
				{
					vl::Ptr<WfVariableStatement> tree = new WfVariableStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"NewTypeExpression")
				{
					vl::Ptr<WfNewTypeExpression> tree = new WfNewTypeExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ClassMember")
				{
					vl::Ptr<WfClassMember> tree = new WfClassMember;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"EventDeclaration")
				{
					vl::Ptr<WfEventDeclaration> tree = new WfEventDeclaration;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfDeclaration>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"PropertyDeclaration")
				{
					vl::Ptr<WfPropertyDeclaration> tree = new WfPropertyDeclaration;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfDeclaration>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ClassDeclaration")
				{
					vl::Ptr<WfClassDeclaration> tree = new WfClassDeclaration;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfDeclaration>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ModuleUsingNameFragment")
				{
					vl::Ptr<WfModuleUsingNameFragment> tree = new WfModuleUsingNameFragment;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfModuleUsingFragment>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ModuleUsingWildCardFragment")
				{
					vl::Ptr<WfModuleUsingWildCardFragment> tree = new WfModuleUsingWildCardFragment;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfModuleUsingFragment>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ModuleUsingItem")
				{
					vl::Ptr<WfModuleUsingItem> tree = new WfModuleUsingItem;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ModuleUsingPath")
				{
					vl::Ptr<WfModuleUsingPath> tree = new WfModuleUsingPath;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"Module")
				{
					vl::Ptr<WfModule> tree = new WfModule;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else 
					return 0;
			}
		};

		vl::Ptr<vl::parsing::ParsingTreeCustomBase> WfConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			WfTreeConverter converter;
			vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
			converter.SetMember(tree, node, tokens);
			return tree;
		}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

		vl::Ptr<WfPredefinedType> WfPredefinedType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfPredefinedType>();
		}

		vl::Ptr<WfTopQualifiedType> WfTopQualifiedType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTopQualifiedType>();
		}

		vl::Ptr<WfReferenceType> WfReferenceType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfReferenceType>();
		}

		vl::Ptr<WfRawPointerType> WfRawPointerType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfRawPointerType>();
		}

		vl::Ptr<WfSharedPointerType> WfSharedPointerType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfSharedPointerType>();
		}

		vl::Ptr<WfNullableType> WfNullableType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfNullableType>();
		}

		vl::Ptr<WfEnumerableType> WfEnumerableType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfEnumerableType>();
		}

		vl::Ptr<WfMapType> WfMapType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfMapType>();
		}

		vl::Ptr<WfFunctionType> WfFunctionType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFunctionType>();
		}

		vl::Ptr<WfChildType> WfChildType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfChildType>();
		}

		vl::Ptr<WfTopQualifiedExpression> WfTopQualifiedExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTopQualifiedExpression>();
		}

		vl::Ptr<WfReferenceExpression> WfReferenceExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfReferenceExpression>();
		}

		vl::Ptr<WfOrderedNameExpression> WfOrderedNameExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfOrderedNameExpression>();
		}

		vl::Ptr<WfOrderedLambdaExpression> WfOrderedLambdaExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfOrderedLambdaExpression>();
		}

		vl::Ptr<WfMemberExpression> WfMemberExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfMemberExpression>();
		}

		vl::Ptr<WfChildExpression> WfChildExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfChildExpression>();
		}

		vl::Ptr<WfLiteralExpression> WfLiteralExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfLiteralExpression>();
		}

		vl::Ptr<WfFloatingExpression> WfFloatingExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFloatingExpression>();
		}

		vl::Ptr<WfIntegerExpression> WfIntegerExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfIntegerExpression>();
		}

		vl::Ptr<WfStringExpression> WfStringExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfStringExpression>();
		}

		vl::Ptr<WfFormatExpression> WfFormatExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFormatExpression>();
		}

		vl::Ptr<WfUnaryExpression> WfUnaryExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfUnaryExpression>();
		}

		vl::Ptr<WfBinaryExpression> WfBinaryExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfBinaryExpression>();
		}

		vl::Ptr<WfLetVariable> WfLetVariable::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfLetVariable>();
		}

		vl::Ptr<WfLetExpression> WfLetExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfLetExpression>();
		}

		vl::Ptr<WfIfExpression> WfIfExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfIfExpression>();
		}

		vl::Ptr<WfRangeExpression> WfRangeExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfRangeExpression>();
		}

		vl::Ptr<WfSetTestingExpression> WfSetTestingExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfSetTestingExpression>();
		}

		vl::Ptr<WfConstructorArgument> WfConstructorArgument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfConstructorArgument>();
		}

		vl::Ptr<WfConstructorExpression> WfConstructorExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfConstructorExpression>();
		}

		vl::Ptr<WfInferExpression> WfInferExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfInferExpression>();
		}

		vl::Ptr<WfTypeCastingExpression> WfTypeCastingExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTypeCastingExpression>();
		}

		vl::Ptr<WfTypeTestingExpression> WfTypeTestingExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTypeTestingExpression>();
		}

		vl::Ptr<WfTypeOfTypeExpression> WfTypeOfTypeExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTypeOfTypeExpression>();
		}

		vl::Ptr<WfTypeOfExpressionExpression> WfTypeOfExpressionExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTypeOfExpressionExpression>();
		}

		vl::Ptr<WfAttachEventExpression> WfAttachEventExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfAttachEventExpression>();
		}

		vl::Ptr<WfDetachEventExpression> WfDetachEventExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfDetachEventExpression>();
		}

		vl::Ptr<WfBindExpression> WfBindExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfBindExpression>();
		}

		vl::Ptr<WfObserveExpression> WfObserveExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfObserveExpression>();
		}

		vl::Ptr<WfCallExpression> WfCallExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfCallExpression>();
		}

		vl::Ptr<WfBreakStatement> WfBreakStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfBreakStatement>();
		}

		vl::Ptr<WfContinueStatement> WfContinueStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfContinueStatement>();
		}

		vl::Ptr<WfReturnStatement> WfReturnStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfReturnStatement>();
		}

		vl::Ptr<WfDeleteStatement> WfDeleteStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfDeleteStatement>();
		}

		vl::Ptr<WfRaiseExceptionStatement> WfRaiseExceptionStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfRaiseExceptionStatement>();
		}

		vl::Ptr<WfIfStatement> WfIfStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfIfStatement>();
		}

		vl::Ptr<WfSwitchCase> WfSwitchCase::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfSwitchCase>();
		}

		vl::Ptr<WfSwitchStatement> WfSwitchStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfSwitchStatement>();
		}

		vl::Ptr<WfWhileStatement> WfWhileStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfWhileStatement>();
		}

		vl::Ptr<WfForEachStatement> WfForEachStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfForEachStatement>();
		}

		vl::Ptr<WfTryStatement> WfTryStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTryStatement>();
		}

		vl::Ptr<WfBlockStatement> WfBlockStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfBlockStatement>();
		}

		vl::Ptr<WfExpressionStatement> WfExpressionStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfExpressionStatement>();
		}

		vl::Ptr<WfNamespaceDeclaration> WfNamespaceDeclaration::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfNamespaceDeclaration>();
		}

		vl::Ptr<WfFunctionArgument> WfFunctionArgument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFunctionArgument>();
		}

		vl::Ptr<WfFunctionDeclaration> WfFunctionDeclaration::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFunctionDeclaration>();
		}

		vl::Ptr<WfFunctionExpression> WfFunctionExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFunctionExpression>();
		}

		vl::Ptr<WfVariableDeclaration> WfVariableDeclaration::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfVariableDeclaration>();
		}

		vl::Ptr<WfVariableStatement> WfVariableStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfVariableStatement>();
		}

		vl::Ptr<WfNewTypeExpression> WfNewTypeExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfNewTypeExpression>();
		}

		vl::Ptr<WfClassMember> WfClassMember::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfClassMember>();
		}

		vl::Ptr<WfEventDeclaration> WfEventDeclaration::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfEventDeclaration>();
		}

		vl::Ptr<WfPropertyDeclaration> WfPropertyDeclaration::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfPropertyDeclaration>();
		}

		vl::Ptr<WfClassDeclaration> WfClassDeclaration::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfClassDeclaration>();
		}

		vl::Ptr<WfModuleUsingNameFragment> WfModuleUsingNameFragment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModuleUsingNameFragment>();
		}

		vl::Ptr<WfModuleUsingWildCardFragment> WfModuleUsingWildCardFragment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModuleUsingWildCardFragment>();
		}

		vl::Ptr<WfModuleUsingItem> WfModuleUsingItem::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModuleUsingItem>();
		}

		vl::Ptr<WfModuleUsingPath> WfModuleUsingPath::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModuleUsingPath>();
		}

		vl::Ptr<WfModule> WfModule::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModule>();
		}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

		void WfPredefinedType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTopQualifiedType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfReferenceType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfRawPointerType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfSharedPointerType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfNullableType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfEnumerableType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfMapType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFunctionType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfChildType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTopQualifiedExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfReferenceExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfOrderedNameExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfOrderedLambdaExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfMemberExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfChildExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfLiteralExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFloatingExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfIntegerExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfStringExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFormatExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfUnaryExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfBinaryExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfLetExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfIfExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfRangeExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfSetTestingExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfConstructorExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfInferExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTypeCastingExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTypeTestingExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTypeOfTypeExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTypeOfExpressionExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfAttachEventExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfDetachEventExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfBindExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfObserveExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfCallExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfBreakStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfContinueStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfReturnStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfDeleteStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfRaiseExceptionStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfIfStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfSwitchStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfWhileStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfForEachStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTryStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfBlockStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfExpressionStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfNamespaceDeclaration::Accept(WfDeclaration::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFunctionDeclaration::Accept(WfDeclaration::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFunctionExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfVariableDeclaration::Accept(WfDeclaration::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfVariableStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfNewTypeExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfEventDeclaration::Accept(WfDeclaration::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfPropertyDeclaration::Accept(WfDeclaration::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfClassDeclaration::Accept(WfDeclaration::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfModuleUsingNameFragment::Accept(WfModuleUsingFragment::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfModuleUsingWildCardFragment::Accept(WfModuleUsingFragment::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

/***********************************************************************
Parser Function
***********************************************************************/

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseDeclarationAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowDeclaration");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseDeclarationAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseDeclarationAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfDeclaration> WfParseDeclaration(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowDeclaration");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfDeclaration>();
			}
			return 0;
		}

		vl::Ptr<WfDeclaration> WfParseDeclaration(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseDeclaration(input, table, errors, codeIndex);
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseExpressionAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowExpression");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseExpressionAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseExpressionAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfExpression> WfParseExpression(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowExpression");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfExpression>();
			}
			return 0;
		}

		vl::Ptr<WfExpression> WfParseExpression(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseExpression(input, table, errors, codeIndex);
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseModuleAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowModule");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseModuleAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseModuleAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfModule> WfParseModule(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowModule");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfModule>();
			}
			return 0;
		}

		vl::Ptr<WfModule> WfParseModule(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseModule(input, table, errors, codeIndex);
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowStatement");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseStatementAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfStatement> WfParseStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowStatement");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfStatement>();
			}
			return 0;
		}

		vl::Ptr<WfStatement> WfParseStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseStatement(input, table, errors, codeIndex);
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseTypeAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowType");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseTypeAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseTypeAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfType> WfParseType(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowType");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfType>();
			}
			return 0;
		}

		vl::Ptr<WfType> WfParseType(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseType(input, table, errors, codeIndex);
		}

/***********************************************************************
Table Generation
***********************************************************************/

		vl::Ptr<vl::parsing::tabling::ParsingTable> WfLoadTable()
		{
			vl::stream::MemoryStream stream;
			WfGetParserBuffer(stream);
			vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
			table->Initialize();
			return table;
		}

	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::workflow;

			IMPL_TYPE_INFO_RENAME(vl::workflow::WfType, workflow::WfType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfPredefinedTypeName, workflow::WfPredefinedTypeName)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfPredefinedType, workflow::WfPredefinedType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfTopQualifiedType, workflow::WfTopQualifiedType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfReferenceType, workflow::WfReferenceType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfRawPointerType, workflow::WfRawPointerType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfSharedPointerType, workflow::WfSharedPointerType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfNullableType, workflow::WfNullableType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfEnumerableType, workflow::WfEnumerableType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfMapWritability, workflow::WfMapWritability)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfMapType, workflow::WfMapType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionType, workflow::WfFunctionType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfChildType, workflow::WfChildType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfExpression, workflow::WfExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfTopQualifiedExpression, workflow::WfTopQualifiedExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfReferenceExpression, workflow::WfReferenceExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfOrderedNameExpression, workflow::WfOrderedNameExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfOrderedLambdaExpression, workflow::WfOrderedLambdaExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfMemberExpression, workflow::WfMemberExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfChildExpression, workflow::WfChildExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfLiteralValue, workflow::WfLiteralValue)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfLiteralExpression, workflow::WfLiteralExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfFloatingExpression, workflow::WfFloatingExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfIntegerExpression, workflow::WfIntegerExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfStringExpression, workflow::WfStringExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfFormatExpression, workflow::WfFormatExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfUnaryOperator, workflow::WfUnaryOperator)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfUnaryExpression, workflow::WfUnaryExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfBinaryOperator, workflow::WfBinaryOperator)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfBinaryExpression, workflow::WfBinaryExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfLetVariable, workflow::WfLetVariable)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfLetExpression, workflow::WfLetExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfIfExpression, workflow::WfIfExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfRangeBoundary, workflow::WfRangeBoundary)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfRangeExpression, workflow::WfRangeExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfSetTesting, workflow::WfSetTesting)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfSetTestingExpression, workflow::WfSetTestingExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfConstructorArgument, workflow::WfConstructorArgument)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfConstructorExpression, workflow::WfConstructorExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfInferExpression, workflow::WfInferExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeCastingStrategy, workflow::WfTypeCastingStrategy)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeCastingExpression, workflow::WfTypeCastingExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeTesting, workflow::WfTypeTesting)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeTestingExpression, workflow::WfTypeTestingExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeOfTypeExpression, workflow::WfTypeOfTypeExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeOfExpressionExpression, workflow::WfTypeOfExpressionExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfAttachEventExpression, workflow::WfAttachEventExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfDetachEventExpression, workflow::WfDetachEventExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfBindExpression, workflow::WfBindExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfObserveType, workflow::WfObserveType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfObserveExpression, workflow::WfObserveExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfCallExpression, workflow::WfCallExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfStatement, workflow::WfStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfBreakStatement, workflow::WfBreakStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfContinueStatement, workflow::WfContinueStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfReturnStatement, workflow::WfReturnStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfDeleteStatement, workflow::WfDeleteStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfRaiseExceptionStatement, workflow::WfRaiseExceptionStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfIfStatement, workflow::WfIfStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfSwitchCase, workflow::WfSwitchCase)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfSwitchStatement, workflow::WfSwitchStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfWhileStatement, workflow::WfWhileStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfForEachDirection, workflow::WfForEachDirection)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfForEachStatement, workflow::WfForEachStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfTryStatement, workflow::WfTryStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfBlockStatement, workflow::WfBlockStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfExpressionStatement, workflow::WfExpressionStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfDeclaration, workflow::WfDeclaration)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfNamespaceDeclaration, workflow::WfNamespaceDeclaration)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionArgument, workflow::WfFunctionArgument)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionAnonymity, workflow::WfFunctionAnonymity)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionDeclaration, workflow::WfFunctionDeclaration)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionExpression, workflow::WfFunctionExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfVariableDeclaration, workflow::WfVariableDeclaration)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfVariableStatement, workflow::WfVariableStatement)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfNewTypeExpression, workflow::WfNewTypeExpression)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfClassMemberKind, workflow::WfClassMemberKind)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfClassKind, workflow::WfClassKind)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfClassMember, workflow::WfClassMember)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfEventDeclaration, workflow::WfEventDeclaration)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfPropertyDeclaration, workflow::WfPropertyDeclaration)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfClassDeclaration, workflow::WfClassDeclaration)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingFragment, workflow::WfModuleUsingFragment)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingNameFragment, workflow::WfModuleUsingNameFragment)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingWildCardFragment, workflow::WfModuleUsingWildCardFragment)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingItem, workflow::WfModuleUsingItem)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingPath, workflow::WfModuleUsingPath)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleType, workflow::WfModuleType)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfModule, workflow::WfModule)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfType::IVisitor, workflow::WfType::IVisitor)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfExpression::IVisitor, workflow::WfExpression::IVisitor)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfStatement::IVisitor, workflow::WfStatement::IVisitor)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfDeclaration::IVisitor, workflow::WfDeclaration::IVisitor)
			IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingFragment::IVisitor, workflow::WfModuleUsingFragment::IVisitor)

			BEGIN_CLASS_MEMBER(WfType)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(WfType)

			BEGIN_ENUM_ITEM(WfPredefinedTypeName)
				ENUM_ITEM_NAMESPACE(WfPredefinedTypeName)
				ENUM_NAMESPACE_ITEM(Void)
				ENUM_NAMESPACE_ITEM(Object)
				ENUM_NAMESPACE_ITEM(Interface)
				ENUM_NAMESPACE_ITEM(Int)
				ENUM_NAMESPACE_ITEM(UInt)
				ENUM_NAMESPACE_ITEM(Float)
				ENUM_NAMESPACE_ITEM(Double)
				ENUM_NAMESPACE_ITEM(String)
				ENUM_NAMESPACE_ITEM(Char)
				ENUM_NAMESPACE_ITEM(Bool)
			END_ENUM_ITEM(WfPredefinedTypeName)

			BEGIN_CLASS_MEMBER(WfPredefinedType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfPredefinedType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(name)
			END_CLASS_MEMBER(WfPredefinedType)

			BEGIN_CLASS_MEMBER(WfTopQualifiedType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTopQualifiedType>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfTopQualifiedType::*)(), [](WfTopQualifiedType* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfTopQualifiedType::*)(const vl::WString&), [](WfTopQualifiedType* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfTopQualifiedType)

			BEGIN_CLASS_MEMBER(WfReferenceType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfReferenceType>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfReferenceType::*)(), [](WfReferenceType* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfReferenceType::*)(const vl::WString&), [](WfReferenceType* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfReferenceType)

			BEGIN_CLASS_MEMBER(WfRawPointerType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfRawPointerType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(element)
			END_CLASS_MEMBER(WfRawPointerType)

			BEGIN_CLASS_MEMBER(WfSharedPointerType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfSharedPointerType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(element)
			END_CLASS_MEMBER(WfSharedPointerType)

			BEGIN_CLASS_MEMBER(WfNullableType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfNullableType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(element)
			END_CLASS_MEMBER(WfNullableType)

			BEGIN_CLASS_MEMBER(WfEnumerableType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfEnumerableType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(element)
			END_CLASS_MEMBER(WfEnumerableType)

			BEGIN_ENUM_ITEM(WfMapWritability)
				ENUM_ITEM_NAMESPACE(WfMapWritability)
				ENUM_NAMESPACE_ITEM(Readonly)
				ENUM_NAMESPACE_ITEM(Writable)
			END_ENUM_ITEM(WfMapWritability)

			BEGIN_CLASS_MEMBER(WfMapType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfMapType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(writability)
				CLASS_MEMBER_FIELD(key)
				CLASS_MEMBER_FIELD(value)
			END_CLASS_MEMBER(WfMapType)

			BEGIN_CLASS_MEMBER(WfFunctionType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFunctionType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(result)
				CLASS_MEMBER_FIELD(arguments)
			END_CLASS_MEMBER(WfFunctionType)

			BEGIN_CLASS_MEMBER(WfChildType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfChildType>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfChildType::*)(), [](WfChildType* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfChildType::*)(const vl::WString&), [](WfChildType* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfChildType)

			BEGIN_CLASS_MEMBER(WfExpression)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(WfExpression)

			BEGIN_CLASS_MEMBER(WfTopQualifiedExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTopQualifiedExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfTopQualifiedExpression::*)(), [](WfTopQualifiedExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfTopQualifiedExpression::*)(const vl::WString&), [](WfTopQualifiedExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfTopQualifiedExpression)

			BEGIN_CLASS_MEMBER(WfReferenceExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfReferenceExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfReferenceExpression::*)(), [](WfReferenceExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfReferenceExpression::*)(const vl::WString&), [](WfReferenceExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfReferenceExpression)

			BEGIN_CLASS_MEMBER(WfOrderedNameExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfOrderedNameExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfOrderedNameExpression::*)(), [](WfOrderedNameExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfOrderedNameExpression::*)(const vl::WString&), [](WfOrderedNameExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfOrderedNameExpression)

			BEGIN_CLASS_MEMBER(WfOrderedLambdaExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfOrderedLambdaExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(body)
			END_CLASS_MEMBER(WfOrderedLambdaExpression)

			BEGIN_CLASS_MEMBER(WfMemberExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfMemberExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfMemberExpression::*)(), [](WfMemberExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfMemberExpression::*)(const vl::WString&), [](WfMemberExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfMemberExpression)

			BEGIN_CLASS_MEMBER(WfChildExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfChildExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfChildExpression::*)(), [](WfChildExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfChildExpression::*)(const vl::WString&), [](WfChildExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfChildExpression)

			BEGIN_ENUM_ITEM(WfLiteralValue)
				ENUM_ITEM_NAMESPACE(WfLiteralValue)
				ENUM_NAMESPACE_ITEM(Null)
				ENUM_NAMESPACE_ITEM(True)
				ENUM_NAMESPACE_ITEM(False)
			END_ENUM_ITEM(WfLiteralValue)

			BEGIN_CLASS_MEMBER(WfLiteralExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfLiteralExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(value)
			END_CLASS_MEMBER(WfLiteralExpression)

			BEGIN_CLASS_MEMBER(WfFloatingExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFloatingExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(WfFloatingExpression::*)(), [](WfFloatingExpression* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(WfFloatingExpression::*)(const vl::WString&), [](WfFloatingExpression* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(WfFloatingExpression)

			BEGIN_CLASS_MEMBER(WfIntegerExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfIntegerExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(WfIntegerExpression::*)(), [](WfIntegerExpression* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(WfIntegerExpression::*)(const vl::WString&), [](WfIntegerExpression* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(WfIntegerExpression)

			BEGIN_CLASS_MEMBER(WfStringExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfStringExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(WfStringExpression::*)(), [](WfStringExpression* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(WfStringExpression::*)(const vl::WString&), [](WfStringExpression* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(WfStringExpression)

			BEGIN_CLASS_MEMBER(WfFormatExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFormatExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(WfFormatExpression::*)(), [](WfFormatExpression* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(WfFormatExpression::*)(const vl::WString&), [](WfFormatExpression* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
				CLASS_MEMBER_FIELD(expandedExpression)
			END_CLASS_MEMBER(WfFormatExpression)

			BEGIN_ENUM_ITEM(WfUnaryOperator)
				ENUM_ITEM_NAMESPACE(WfUnaryOperator)
				ENUM_NAMESPACE_ITEM(Positive)
				ENUM_NAMESPACE_ITEM(Negative)
				ENUM_NAMESPACE_ITEM(Not)
			END_ENUM_ITEM(WfUnaryOperator)

			BEGIN_CLASS_MEMBER(WfUnaryExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfUnaryExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(op)
				CLASS_MEMBER_FIELD(operand)
			END_CLASS_MEMBER(WfUnaryExpression)

			BEGIN_ENUM_ITEM(WfBinaryOperator)
				ENUM_ITEM_NAMESPACE(WfBinaryOperator)
				ENUM_NAMESPACE_ITEM(Assign)
				ENUM_NAMESPACE_ITEM(Index)
				ENUM_NAMESPACE_ITEM(Concat)
				ENUM_NAMESPACE_ITEM(FailedThen)
				ENUM_NAMESPACE_ITEM(Exp)
				ENUM_NAMESPACE_ITEM(Add)
				ENUM_NAMESPACE_ITEM(Sub)
				ENUM_NAMESPACE_ITEM(Mul)
				ENUM_NAMESPACE_ITEM(Div)
				ENUM_NAMESPACE_ITEM(Mod)
				ENUM_NAMESPACE_ITEM(Shl)
				ENUM_NAMESPACE_ITEM(Shr)
				ENUM_NAMESPACE_ITEM(LT)
				ENUM_NAMESPACE_ITEM(GT)
				ENUM_NAMESPACE_ITEM(LE)
				ENUM_NAMESPACE_ITEM(GE)
				ENUM_NAMESPACE_ITEM(EQ)
				ENUM_NAMESPACE_ITEM(NE)
				ENUM_NAMESPACE_ITEM(Xor)
				ENUM_NAMESPACE_ITEM(And)
				ENUM_NAMESPACE_ITEM(Or)
			END_ENUM_ITEM(WfBinaryOperator)

			BEGIN_CLASS_MEMBER(WfBinaryExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfBinaryExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(op)
				CLASS_MEMBER_FIELD(first)
				CLASS_MEMBER_FIELD(second)
			END_CLASS_MEMBER(WfBinaryExpression)

			BEGIN_CLASS_MEMBER(WfLetVariable)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfLetVariable>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfLetVariable::*)(), [](WfLetVariable* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfLetVariable::*)(const vl::WString&), [](WfLetVariable* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(value)
			END_CLASS_MEMBER(WfLetVariable)

			BEGIN_CLASS_MEMBER(WfLetExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfLetExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(variables)
				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfLetExpression)

			BEGIN_CLASS_MEMBER(WfIfExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfIfExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(condition)
				CLASS_MEMBER_FIELD(trueBranch)
				CLASS_MEMBER_FIELD(falseBranch)
			END_CLASS_MEMBER(WfIfExpression)

			BEGIN_ENUM_ITEM(WfRangeBoundary)
				ENUM_ITEM_NAMESPACE(WfRangeBoundary)
				ENUM_NAMESPACE_ITEM(Inclusive)
				ENUM_NAMESPACE_ITEM(Exclusive)
			END_ENUM_ITEM(WfRangeBoundary)

			BEGIN_CLASS_MEMBER(WfRangeExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfRangeExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(begin)
				CLASS_MEMBER_FIELD(beginBoundary)
				CLASS_MEMBER_FIELD(end)
				CLASS_MEMBER_FIELD(endBoundary)
			END_CLASS_MEMBER(WfRangeExpression)

			BEGIN_ENUM_ITEM(WfSetTesting)
				ENUM_ITEM_NAMESPACE(WfSetTesting)
				ENUM_NAMESPACE_ITEM(In)
				ENUM_NAMESPACE_ITEM(NotIn)
			END_ENUM_ITEM(WfSetTesting)

			BEGIN_CLASS_MEMBER(WfSetTestingExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfSetTestingExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(test)
				CLASS_MEMBER_FIELD(element)
				CLASS_MEMBER_FIELD(collection)
			END_CLASS_MEMBER(WfSetTestingExpression)

			BEGIN_CLASS_MEMBER(WfConstructorArgument)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfConstructorArgument>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(key)
				CLASS_MEMBER_FIELD(value)
			END_CLASS_MEMBER(WfConstructorArgument)

			BEGIN_CLASS_MEMBER(WfConstructorExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfConstructorExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(arguments)
			END_CLASS_MEMBER(WfConstructorExpression)

			BEGIN_CLASS_MEMBER(WfInferExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfInferExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfInferExpression)

			BEGIN_ENUM_ITEM(WfTypeCastingStrategy)
				ENUM_ITEM_NAMESPACE(WfTypeCastingStrategy)
				ENUM_NAMESPACE_ITEM(Strong)
				ENUM_NAMESPACE_ITEM(Weak)
			END_ENUM_ITEM(WfTypeCastingStrategy)

			BEGIN_CLASS_MEMBER(WfTypeCastingExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTypeCastingExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(strategy)
				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfTypeCastingExpression)

			BEGIN_ENUM_ITEM(WfTypeTesting)
				ENUM_ITEM_NAMESPACE(WfTypeTesting)
				ENUM_NAMESPACE_ITEM(IsType)
				ENUM_NAMESPACE_ITEM(IsNotType)
				ENUM_NAMESPACE_ITEM(IsNull)
				ENUM_NAMESPACE_ITEM(IsNotNull)
			END_ENUM_ITEM(WfTypeTesting)

			BEGIN_CLASS_MEMBER(WfTypeTestingExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTypeTestingExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(test)
				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfTypeTestingExpression)

			BEGIN_CLASS_MEMBER(WfTypeOfTypeExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTypeOfTypeExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfTypeOfTypeExpression)

			BEGIN_CLASS_MEMBER(WfTypeOfExpressionExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTypeOfExpressionExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfTypeOfExpressionExpression)

			BEGIN_CLASS_MEMBER(WfAttachEventExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfAttachEventExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(event)
				CLASS_MEMBER_FIELD(function)
			END_CLASS_MEMBER(WfAttachEventExpression)

			BEGIN_CLASS_MEMBER(WfDetachEventExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfDetachEventExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(handler)
			END_CLASS_MEMBER(WfDetachEventExpression)

			BEGIN_CLASS_MEMBER(WfBindExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfBindExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(expandedExpression)
			END_CLASS_MEMBER(WfBindExpression)

			BEGIN_ENUM_ITEM(WfObserveType)
				ENUM_ITEM_NAMESPACE(WfObserveType)
				ENUM_NAMESPACE_ITEM(SimpleObserve)
				ENUM_NAMESPACE_ITEM(ExtendedObserve)
			END_ENUM_ITEM(WfObserveType)

			BEGIN_CLASS_MEMBER(WfObserveExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfObserveExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfObserveExpression::*)(), [](WfObserveExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfObserveExpression::*)(const vl::WString&), [](WfObserveExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_FIELD(observeType)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(events)
			END_CLASS_MEMBER(WfObserveExpression)

			BEGIN_CLASS_MEMBER(WfCallExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfCallExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(function)
				CLASS_MEMBER_FIELD(arguments)
			END_CLASS_MEMBER(WfCallExpression)

			BEGIN_CLASS_MEMBER(WfStatement)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(WfStatement)

			BEGIN_CLASS_MEMBER(WfBreakStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfBreakStatement>(), NO_PARAMETER)


			END_CLASS_MEMBER(WfBreakStatement)

			BEGIN_CLASS_MEMBER(WfContinueStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfContinueStatement>(), NO_PARAMETER)


			END_CLASS_MEMBER(WfContinueStatement)

			BEGIN_CLASS_MEMBER(WfReturnStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfReturnStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfReturnStatement)

			BEGIN_CLASS_MEMBER(WfDeleteStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfDeleteStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfDeleteStatement)

			BEGIN_CLASS_MEMBER(WfRaiseExceptionStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfRaiseExceptionStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfRaiseExceptionStatement)

			BEGIN_CLASS_MEMBER(WfIfStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfIfStatement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfIfStatement::*)(), [](WfIfStatement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfIfStatement::*)(const vl::WString&), [](WfIfStatement* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(type)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(trueBranch)
				CLASS_MEMBER_FIELD(falseBranch)
			END_CLASS_MEMBER(WfIfStatement)

			BEGIN_CLASS_MEMBER(WfSwitchCase)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfSwitchCase>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(statement)
			END_CLASS_MEMBER(WfSwitchCase)

			BEGIN_CLASS_MEMBER(WfSwitchStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfSwitchStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(caseBranches)
				CLASS_MEMBER_FIELD(defaultBranch)
			END_CLASS_MEMBER(WfSwitchStatement)

			BEGIN_CLASS_MEMBER(WfWhileStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfWhileStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(condition)
				CLASS_MEMBER_FIELD(statement)
			END_CLASS_MEMBER(WfWhileStatement)

			BEGIN_ENUM_ITEM(WfForEachDirection)
				ENUM_ITEM_NAMESPACE(WfForEachDirection)
				ENUM_NAMESPACE_ITEM(Normal)
				ENUM_NAMESPACE_ITEM(Reversed)
			END_ENUM_ITEM(WfForEachDirection)

			BEGIN_CLASS_MEMBER(WfForEachStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfForEachStatement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfForEachStatement::*)(), [](WfForEachStatement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfForEachStatement::*)(const vl::WString&), [](WfForEachStatement* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(direction)
				CLASS_MEMBER_FIELD(collection)
				CLASS_MEMBER_FIELD(statement)
			END_CLASS_MEMBER(WfForEachStatement)

			BEGIN_CLASS_MEMBER(WfTryStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTryStatement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfTryStatement::*)(), [](WfTryStatement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfTryStatement::*)(const vl::WString&), [](WfTryStatement* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(protectedStatement)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(catchStatement)
				CLASS_MEMBER_FIELD(finallyStatement)
			END_CLASS_MEMBER(WfTryStatement)

			BEGIN_CLASS_MEMBER(WfBlockStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfBlockStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(statements)
			END_CLASS_MEMBER(WfBlockStatement)

			BEGIN_CLASS_MEMBER(WfExpressionStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfExpressionStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfExpressionStatement)

			BEGIN_CLASS_MEMBER(WfDeclaration)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})
				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfDeclaration::*)(), [](WfDeclaration* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfDeclaration::*)(const vl::WString&), [](WfDeclaration* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfDeclaration)

			BEGIN_CLASS_MEMBER(WfNamespaceDeclaration)
				CLASS_MEMBER_BASE(WfDeclaration)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfNamespaceDeclaration>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(declarations)
			END_CLASS_MEMBER(WfNamespaceDeclaration)

			BEGIN_CLASS_MEMBER(WfFunctionArgument)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFunctionArgument>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfFunctionArgument::*)(), [](WfFunctionArgument* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfFunctionArgument::*)(const vl::WString&), [](WfFunctionArgument* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfFunctionArgument)

			BEGIN_ENUM_ITEM(WfFunctionAnonymity)
				ENUM_ITEM_NAMESPACE(WfFunctionAnonymity)
				ENUM_NAMESPACE_ITEM(Named)
				ENUM_NAMESPACE_ITEM(Anonymous)
			END_ENUM_ITEM(WfFunctionAnonymity)

			BEGIN_CLASS_MEMBER(WfFunctionDeclaration)
				CLASS_MEMBER_BASE(WfDeclaration)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFunctionDeclaration>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(anonymity)
				CLASS_MEMBER_FIELD(arguments)
				CLASS_MEMBER_FIELD(returnType)
				CLASS_MEMBER_FIELD(statement)
			END_CLASS_MEMBER(WfFunctionDeclaration)

			BEGIN_CLASS_MEMBER(WfFunctionExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFunctionExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(function)
			END_CLASS_MEMBER(WfFunctionExpression)

			BEGIN_CLASS_MEMBER(WfVariableDeclaration)
				CLASS_MEMBER_BASE(WfDeclaration)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfVariableDeclaration>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(type)
				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfVariableDeclaration)

			BEGIN_CLASS_MEMBER(WfVariableStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfVariableStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(variable)
			END_CLASS_MEMBER(WfVariableStatement)

			BEGIN_CLASS_MEMBER(WfNewTypeExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfNewTypeExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(type)
				CLASS_MEMBER_FIELD(arguments)
				CLASS_MEMBER_FIELD(functions)
			END_CLASS_MEMBER(WfNewTypeExpression)

			BEGIN_ENUM_ITEM(WfClassMemberKind)
				ENUM_ITEM_NAMESPACE(WfClassMemberKind)
				ENUM_NAMESPACE_ITEM(Static)
				ENUM_NAMESPACE_ITEM(Normal)
			END_ENUM_ITEM(WfClassMemberKind)

			BEGIN_ENUM_ITEM(WfClassKind)
				ENUM_ITEM_NAMESPACE(WfClassKind)
				ENUM_NAMESPACE_ITEM(Class)
				ENUM_NAMESPACE_ITEM(Interface)
			END_ENUM_ITEM(WfClassKind)

			BEGIN_CLASS_MEMBER(WfClassMember)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfClassMember>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(kind)
				CLASS_MEMBER_FIELD(declaration)
			END_CLASS_MEMBER(WfClassMember)

			BEGIN_CLASS_MEMBER(WfEventDeclaration)
				CLASS_MEMBER_BASE(WfDeclaration)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfEventDeclaration>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(arguments)
			END_CLASS_MEMBER(WfEventDeclaration)

			BEGIN_CLASS_MEMBER(WfPropertyDeclaration)
				CLASS_MEMBER_BASE(WfDeclaration)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfPropertyDeclaration>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_getter, NO_PARAMETER, vl::WString(WfPropertyDeclaration::*)(), [](WfPropertyDeclaration* node){ return node->getter.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_getter, {L"value"}, void(WfPropertyDeclaration::*)(const vl::WString&), [](WfPropertyDeclaration* node, const vl::WString& value){ node->getter.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_setter, NO_PARAMETER, vl::WString(WfPropertyDeclaration::*)(), [](WfPropertyDeclaration* node){ return node->setter.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_setter, {L"value"}, void(WfPropertyDeclaration::*)(const vl::WString&), [](WfPropertyDeclaration* node, const vl::WString& value){ node->setter.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_valueChangedEvent, NO_PARAMETER, vl::WString(WfPropertyDeclaration::*)(), [](WfPropertyDeclaration* node){ return node->valueChangedEvent.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_valueChangedEvent, {L"value"}, void(WfPropertyDeclaration::*)(const vl::WString&), [](WfPropertyDeclaration* node, const vl::WString& value){ node->valueChangedEvent.value = value; })

				CLASS_MEMBER_FIELD(type)
				CLASS_MEMBER_PROPERTY(getter, get_getter, set_getter)
				CLASS_MEMBER_PROPERTY(setter, get_setter, set_setter)
				CLASS_MEMBER_PROPERTY(valueChangedEvent, get_valueChangedEvent, set_valueChangedEvent)
			END_CLASS_MEMBER(WfPropertyDeclaration)

			BEGIN_CLASS_MEMBER(WfClassDeclaration)
				CLASS_MEMBER_BASE(WfDeclaration)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfClassDeclaration>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(kind)
				CLASS_MEMBER_FIELD(baseTypes)
				CLASS_MEMBER_FIELD(members)
			END_CLASS_MEMBER(WfClassDeclaration)

			BEGIN_CLASS_MEMBER(WfModuleUsingFragment)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(WfModuleUsingFragment)

			BEGIN_CLASS_MEMBER(WfModuleUsingNameFragment)
				CLASS_MEMBER_BASE(WfModuleUsingFragment)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModuleUsingNameFragment>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfModuleUsingNameFragment::*)(), [](WfModuleUsingNameFragment* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfModuleUsingNameFragment::*)(const vl::WString&), [](WfModuleUsingNameFragment* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfModuleUsingNameFragment)

			BEGIN_CLASS_MEMBER(WfModuleUsingWildCardFragment)
				CLASS_MEMBER_BASE(WfModuleUsingFragment)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModuleUsingWildCardFragment>(), NO_PARAMETER)


			END_CLASS_MEMBER(WfModuleUsingWildCardFragment)

			BEGIN_CLASS_MEMBER(WfModuleUsingItem)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModuleUsingItem>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(fragments)
			END_CLASS_MEMBER(WfModuleUsingItem)

			BEGIN_CLASS_MEMBER(WfModuleUsingPath)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModuleUsingPath>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(items)
			END_CLASS_MEMBER(WfModuleUsingPath)

			BEGIN_ENUM_ITEM(WfModuleType)
				ENUM_ITEM_NAMESPACE(WfModuleType)
				ENUM_NAMESPACE_ITEM(Module)
				ENUM_NAMESPACE_ITEM(Unit)
			END_ENUM_ITEM(WfModuleType)

			BEGIN_CLASS_MEMBER(WfModule)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModule>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfModule::*)(), [](WfModule* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfModule::*)(const vl::WString&), [](WfModule* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(moduleType)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(paths)
				CLASS_MEMBER_FIELD(declarations)
			END_CLASS_MEMBER(WfModule)

			BEGIN_CLASS_MEMBER(WfType::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfType::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfType_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfPredefinedType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfTopQualifiedType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfReferenceType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfRawPointerType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfSharedPointerType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfNullableType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfEnumerableType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfMapType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfFunctionType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfChildType* node))
			END_CLASS_MEMBER(WfType)

			BEGIN_CLASS_MEMBER(WfExpression::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfExpression::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfExpression_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTopQualifiedExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfReferenceExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfOrderedNameExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfOrderedLambdaExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfMemberExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfChildExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfLiteralExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfFloatingExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfIntegerExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfStringExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfFormatExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfUnaryExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfBinaryExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfLetExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfIfExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfRangeExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfSetTestingExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfConstructorExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfInferExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTypeCastingExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTypeTestingExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTypeOfTypeExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTypeOfExpressionExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfAttachEventExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfDetachEventExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfBindExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfObserveExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfCallExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfFunctionExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfNewTypeExpression* node))
			END_CLASS_MEMBER(WfExpression)

			BEGIN_CLASS_MEMBER(WfStatement::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfStatement::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfStatement_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfBreakStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfContinueStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfReturnStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfDeleteStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfRaiseExceptionStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfIfStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfSwitchStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfWhileStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfForEachStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfTryStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfBlockStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfExpressionStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfVariableStatement* node))
			END_CLASS_MEMBER(WfStatement)

			BEGIN_CLASS_MEMBER(WfDeclaration::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfDeclaration::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfDeclaration_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfDeclaration::IVisitor::*)(WfNamespaceDeclaration* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfDeclaration::IVisitor::*)(WfFunctionDeclaration* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfDeclaration::IVisitor::*)(WfVariableDeclaration* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfDeclaration::IVisitor::*)(WfEventDeclaration* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfDeclaration::IVisitor::*)(WfPropertyDeclaration* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfDeclaration::IVisitor::*)(WfClassDeclaration* node))
			END_CLASS_MEMBER(WfDeclaration)

			BEGIN_CLASS_MEMBER(WfModuleUsingFragment::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfModuleUsingFragment::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfModuleUsingFragment_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfModuleUsingFragment::IVisitor::*)(WfModuleUsingNameFragment* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfModuleUsingFragment::IVisitor::*)(WfModuleUsingWildCardFragment* node))
			END_CLASS_MEMBER(WfModuleUsingFragment)

			class WfTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::workflow::WfType)
					ADD_TYPE_INFO(vl::workflow::WfPredefinedTypeName)
					ADD_TYPE_INFO(vl::workflow::WfPredefinedType)
					ADD_TYPE_INFO(vl::workflow::WfTopQualifiedType)
					ADD_TYPE_INFO(vl::workflow::WfReferenceType)
					ADD_TYPE_INFO(vl::workflow::WfRawPointerType)
					ADD_TYPE_INFO(vl::workflow::WfSharedPointerType)
					ADD_TYPE_INFO(vl::workflow::WfNullableType)
					ADD_TYPE_INFO(vl::workflow::WfEnumerableType)
					ADD_TYPE_INFO(vl::workflow::WfMapWritability)
					ADD_TYPE_INFO(vl::workflow::WfMapType)
					ADD_TYPE_INFO(vl::workflow::WfFunctionType)
					ADD_TYPE_INFO(vl::workflow::WfChildType)
					ADD_TYPE_INFO(vl::workflow::WfExpression)
					ADD_TYPE_INFO(vl::workflow::WfTopQualifiedExpression)
					ADD_TYPE_INFO(vl::workflow::WfReferenceExpression)
					ADD_TYPE_INFO(vl::workflow::WfOrderedNameExpression)
					ADD_TYPE_INFO(vl::workflow::WfOrderedLambdaExpression)
					ADD_TYPE_INFO(vl::workflow::WfMemberExpression)
					ADD_TYPE_INFO(vl::workflow::WfChildExpression)
					ADD_TYPE_INFO(vl::workflow::WfLiteralValue)
					ADD_TYPE_INFO(vl::workflow::WfLiteralExpression)
					ADD_TYPE_INFO(vl::workflow::WfFloatingExpression)
					ADD_TYPE_INFO(vl::workflow::WfIntegerExpression)
					ADD_TYPE_INFO(vl::workflow::WfStringExpression)
					ADD_TYPE_INFO(vl::workflow::WfFormatExpression)
					ADD_TYPE_INFO(vl::workflow::WfUnaryOperator)
					ADD_TYPE_INFO(vl::workflow::WfUnaryExpression)
					ADD_TYPE_INFO(vl::workflow::WfBinaryOperator)
					ADD_TYPE_INFO(vl::workflow::WfBinaryExpression)
					ADD_TYPE_INFO(vl::workflow::WfLetVariable)
					ADD_TYPE_INFO(vl::workflow::WfLetExpression)
					ADD_TYPE_INFO(vl::workflow::WfIfExpression)
					ADD_TYPE_INFO(vl::workflow::WfRangeBoundary)
					ADD_TYPE_INFO(vl::workflow::WfRangeExpression)
					ADD_TYPE_INFO(vl::workflow::WfSetTesting)
					ADD_TYPE_INFO(vl::workflow::WfSetTestingExpression)
					ADD_TYPE_INFO(vl::workflow::WfConstructorArgument)
					ADD_TYPE_INFO(vl::workflow::WfConstructorExpression)
					ADD_TYPE_INFO(vl::workflow::WfInferExpression)
					ADD_TYPE_INFO(vl::workflow::WfTypeCastingStrategy)
					ADD_TYPE_INFO(vl::workflow::WfTypeCastingExpression)
					ADD_TYPE_INFO(vl::workflow::WfTypeTesting)
					ADD_TYPE_INFO(vl::workflow::WfTypeTestingExpression)
					ADD_TYPE_INFO(vl::workflow::WfTypeOfTypeExpression)
					ADD_TYPE_INFO(vl::workflow::WfTypeOfExpressionExpression)
					ADD_TYPE_INFO(vl::workflow::WfAttachEventExpression)
					ADD_TYPE_INFO(vl::workflow::WfDetachEventExpression)
					ADD_TYPE_INFO(vl::workflow::WfBindExpression)
					ADD_TYPE_INFO(vl::workflow::WfObserveType)
					ADD_TYPE_INFO(vl::workflow::WfObserveExpression)
					ADD_TYPE_INFO(vl::workflow::WfCallExpression)
					ADD_TYPE_INFO(vl::workflow::WfStatement)
					ADD_TYPE_INFO(vl::workflow::WfBreakStatement)
					ADD_TYPE_INFO(vl::workflow::WfContinueStatement)
					ADD_TYPE_INFO(vl::workflow::WfReturnStatement)
					ADD_TYPE_INFO(vl::workflow::WfDeleteStatement)
					ADD_TYPE_INFO(vl::workflow::WfRaiseExceptionStatement)
					ADD_TYPE_INFO(vl::workflow::WfIfStatement)
					ADD_TYPE_INFO(vl::workflow::WfSwitchCase)
					ADD_TYPE_INFO(vl::workflow::WfSwitchStatement)
					ADD_TYPE_INFO(vl::workflow::WfWhileStatement)
					ADD_TYPE_INFO(vl::workflow::WfForEachDirection)
					ADD_TYPE_INFO(vl::workflow::WfForEachStatement)
					ADD_TYPE_INFO(vl::workflow::WfTryStatement)
					ADD_TYPE_INFO(vl::workflow::WfBlockStatement)
					ADD_TYPE_INFO(vl::workflow::WfExpressionStatement)
					ADD_TYPE_INFO(vl::workflow::WfDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfNamespaceDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfFunctionArgument)
					ADD_TYPE_INFO(vl::workflow::WfFunctionAnonymity)
					ADD_TYPE_INFO(vl::workflow::WfFunctionDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfFunctionExpression)
					ADD_TYPE_INFO(vl::workflow::WfVariableDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfVariableStatement)
					ADD_TYPE_INFO(vl::workflow::WfNewTypeExpression)
					ADD_TYPE_INFO(vl::workflow::WfClassMemberKind)
					ADD_TYPE_INFO(vl::workflow::WfClassKind)
					ADD_TYPE_INFO(vl::workflow::WfClassMember)
					ADD_TYPE_INFO(vl::workflow::WfEventDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfPropertyDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfClassDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingFragment)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingNameFragment)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingWildCardFragment)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingItem)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingPath)
					ADD_TYPE_INFO(vl::workflow::WfModuleType)
					ADD_TYPE_INFO(vl::workflow::WfModule)
					ADD_TYPE_INFO(vl::workflow::WfType::IVisitor)
					ADD_TYPE_INFO(vl::workflow::WfExpression::IVisitor)
					ADD_TYPE_INFO(vl::workflow::WfStatement::IVisitor)
					ADD_TYPE_INFO(vl::workflow::WfDeclaration::IVisitor)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingFragment::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool WfLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new WfTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}

/***********************************************************************
RUNTIME\WFRUNTIME.CPP
***********************************************************************/

namespace vl
{
	using namespace reflection;
	using namespace reflection::description;
	using namespace workflow::runtime;
	using namespace collections;

	namespace workflow
	{
		namespace runtime
		{

/***********************************************************************
WfRuntimeGlobalContext
***********************************************************************/

			WfRuntimeGlobalContext::WfRuntimeGlobalContext(Ptr<WfAssembly> _assembly)
				:assembly(_assembly)
			{
				globalVariables = new WfRuntimeVariableContext;
				globalVariables->variables.Resize(assembly->variableNames.Count());
				if (assembly->typeImpl)
				{
					assembly->typeImpl->SetGlobalContext(this);
				}
			}

			WfRuntimeGlobalContext::~WfRuntimeGlobalContext()
			{
				if (assembly->typeImpl)
				{
					assembly->typeImpl->SetGlobalContext(nullptr);
				}
			}

/***********************************************************************
WfRuntimeCallStackInfo
***********************************************************************/

			Ptr<IValueReadonlyDictionary> WfRuntimeCallStackInfo::GetVariables(collections::List<WString>& names, Ptr<WfRuntimeVariableContext> context, Ptr<IValueReadonlyDictionary>& cache)
			{
				if (!cache)
				{
					if (!context)
					{
						Dictionary<WString, Value> map;
						FOREACH_INDEXER(WString, name, index, names)
						{
							map.Add(name, context->variables[index]);
						}
						cache = IValueDictionary::Create(
							From(map)
								.Select([](Pair<WString, Value> pair)
								{
									return Pair<Value, Value>(BoxValue(pair.key), pair.value);
								})
							);
					}
					else
					{
						cache = IValueDictionary::Create();
					}
				}
				return cache;
			}

			WfRuntimeCallStackInfo::WfRuntimeCallStackInfo()
			{
			}

			WfRuntimeCallStackInfo::WfRuntimeCallStackInfo(WfRuntimeThreadContext* context, const WfRuntimeStackFrame& stackFrame)
			{
				assembly = context->globalContext->assembly;
				functionIndex = stackFrame.functionIndex;
				instruction = stackFrame.nextInstructionIndex - 1;

				auto function = assembly->functions[functionIndex];

				if (context->globalContext->globalVariables->variables.Count() > 0)
				{
					global = context->globalContext->globalVariables;
				}

				captured = stackFrame.capturedVariables;

				if (function->argumentNames.Count() > 0)
				{
					arguments = new WfRuntimeVariableContext;
					arguments->variables.Resize(function->argumentNames.Count());
					for (vint i = 0; i < arguments->variables.Count(); i++)
					{
						arguments->variables[i] = context->stack[stackFrame.stackBase + i];
					}
				}

				if (function->localVariableNames.Count()>0)
				{
					localVariables = new WfRuntimeVariableContext;
					localVariables->variables.Resize(function->localVariableNames.Count());
					for (vint i = 0; i < localVariables->variables.Count(); i++)
					{
						localVariables->variables[i] = context->stack[stackFrame.stackBase + function->argumentNames.Count() + i];
					}
				}
			}

			WfRuntimeCallStackInfo::~WfRuntimeCallStackInfo()
			{
			}

			Ptr<IValueReadonlyDictionary> WfRuntimeCallStackInfo::GetLocalVariables()
			{
				return GetVariables(assembly->functions[functionIndex]->localVariableNames, localVariables, cachedLocalVariables);
			}

			Ptr<IValueReadonlyDictionary> WfRuntimeCallStackInfo::GetLocalArguments()
			{
				return GetVariables(assembly->functions[functionIndex]->argumentNames, localVariables, cachedLocalArguments);
			}

			Ptr<IValueReadonlyDictionary> WfRuntimeCallStackInfo::GetCapturedVariables()
			{
				return GetVariables(assembly->functions[functionIndex]->capturedVariableNames, captured, cachedCapturedVariables);
			}

			Ptr<IValueReadonlyDictionary> WfRuntimeCallStackInfo::GetGlobalVariables()
			{
				return GetVariables(assembly->variableNames, global, cachedGlobalVariables);
			}

			WString WfRuntimeCallStackInfo::GetFunctionName()
			{
				if (!assembly)
				{
					return L"<EXTERNAL CODE>";
				}
				return assembly->functions[functionIndex]->name;
			}

			WString WfRuntimeCallStackInfo::GetSourceCodeBeforeCodegen()
			{
				if (!assembly)
				{
					return L"";
				}
				const auto& range = assembly->insBeforeCodegen->instructionCodeMapping[instruction];
				if (range.codeIndex == -1)
				{
					return L"";
				}
				return assembly->insBeforeCodegen->moduleCodes[range.codeIndex];
			}

			WString WfRuntimeCallStackInfo::GetSourceCodeAfterCodegen()
			{
				if (!assembly)
				{
					return L"";
				}
				const auto& range = assembly->insAfterCodegen->instructionCodeMapping[instruction];
				if (range.codeIndex == -1)
				{
					return L"";
				}
				return assembly->insAfterCodegen->moduleCodes[range.codeIndex];
			}

			vint WfRuntimeCallStackInfo::GetRowBeforeCodegen()
			{
				if (!assembly)
				{
					return -1;
				}
				const auto& range = assembly->insBeforeCodegen->instructionCodeMapping[instruction];
				return range.start.row;
			}

			vint WfRuntimeCallStackInfo::GetRowAfterCodegen()
			{
				if (!assembly)
				{
					return -1;
				}
				const auto& range = assembly->insAfterCodegen->instructionCodeMapping[instruction];
				return range.start.row;
			}

/***********************************************************************
WfRuntimeExceptionInfo
***********************************************************************/

			WfRuntimeExceptionInfo::WfRuntimeExceptionInfo(const WString& _message, bool _fatal)
				:message(_message)
				, fatal(_fatal)
			{
			}

			WfRuntimeExceptionInfo::~WfRuntimeExceptionInfo()
			{
			}
				
#pragma push_macro("GetMessage")
#if defined GetMessage
#undef GetMessage
#endif
			WString WfRuntimeExceptionInfo::GetMessage()
			{
				return message;
			}
#pragma pop_macro("GetMessage")

			bool WfRuntimeExceptionInfo::GetFatal()
			{
				return fatal;
			}

			Ptr<IValueReadonlyList> WfRuntimeExceptionInfo::GetCallStack()
			{
				if (!cachedCallStack)
				{
					cachedCallStack = IValueList::Create(
						From(callStack)
							.Cast<IValueCallStack>()
							.Select([](Ptr<IValueCallStack> callStack)
							{
								return BoxValue(callStack);
							})
						);
				}
				return cachedCallStack;
			}

/***********************************************************************
WfRuntimeThreadContext
***********************************************************************/

			WfRuntimeThreadContext::WfRuntimeThreadContext(Ptr<WfRuntimeGlobalContext> _context)
				:globalContext(_context)
			{
				stack.SetLessMemoryMode(false);
				stackFrames.SetLessMemoryMode(false);
			}

			WfRuntimeThreadContext::WfRuntimeThreadContext(Ptr<WfAssembly> _assembly)
				:globalContext(new WfRuntimeGlobalContext(_assembly))
			{
				stack.SetLessMemoryMode(false);
				stackFrames.SetLessMemoryMode(false);
			}

			WfRuntimeStackFrame& WfRuntimeThreadContext::GetCurrentStackFrame()
			{
				return stackFrames[stackFrames.Count() - 1];
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PushStackFrame(vint functionIndex, vint argumentCount, Ptr<WfRuntimeVariableContext> capturedVariables)
			{
				if (stackFrames.Count() == 0)
				{
					if (stack.Count() < argumentCount)
					{
						return WfRuntimeThreadContextError::StackCorrupted;
					}
				}
				else
				{
					auto& frame = GetCurrentStackFrame();
					if (stack.Count() - frame.freeStackBase < argumentCount)
					{
						return WfRuntimeThreadContextError::StackCorrupted;
					}
				}
				if (functionIndex < 0 || functionIndex >= globalContext->assembly->functions.Count())
				{
					return WfRuntimeThreadContextError::WrongFunctionIndex;
				}
				auto meta = globalContext->assembly->functions[functionIndex];
				if (meta->argumentNames.Count() != argumentCount)
				{
					return WfRuntimeThreadContextError::WrongArgumentCount;
				}
				if (meta->capturedVariableNames.Count() == 0)
				{
					if (capturedVariables)
					{
						return WfRuntimeThreadContextError::WrongCapturedVariableCount;
					}
				}
				else
				{
					if (!capturedVariables || capturedVariables->variables.Count() != meta->capturedVariableNames.Count())
					{
						return WfRuntimeThreadContextError::WrongCapturedVariableCount;
					}
				}

				WfRuntimeStackFrame frame;
				frame.capturedVariables = capturedVariables;
				frame.functionIndex = functionIndex;
				frame.nextInstructionIndex = globalContext->assembly->functions[functionIndex]->firstInstruction;
				frame.stackBase = stack.Count() - argumentCount;

				frame.fixedVariableCount = meta->argumentNames.Count() + meta->localVariableNames.Count();
				frame.freeStackBase = frame.stackBase + frame.fixedVariableCount;
				stackFrames.Add(frame);

				for (vint i = 0; i < meta->localVariableNames.Count(); i++)
				{
					stack.Add(Value());
				}
				if (status == WfRuntimeExecutionStatus::Finished || status == WfRuntimeExecutionStatus::FatalError)
				{
					status = WfRuntimeExecutionStatus::Ready;
				}
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PopStackFrame()
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				WfRuntimeStackFrame frame = GetCurrentStackFrame();
				if (trapFrames.Count() > 0)
				{
					WfRuntimeTrapFrame& trapFrame = GetCurrentTrapFrame();
					if (trapFrame.stackFrameIndex == stackFrames.Count() - 1)
					{
						return WfRuntimeThreadContextError::TrapFrameCorrupted;
					}
				}
				stackFrames.RemoveAt(stackFrames.Count() - 1);

				if (stack.Count() > frame.stackBase)
				{
					stack.RemoveRange(frame.stackBase, stack.Count() - frame.stackBase);
				}
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeTrapFrame& WfRuntimeThreadContext::GetCurrentTrapFrame()
			{
				return trapFrames[trapFrames.Count() - 1];
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PushTrapFrame(vint instructionIndex)
			{
				WfRuntimeTrapFrame frame;
				frame.stackFrameIndex = stackFrames.Count() - 1;
				frame.instructionIndex = instructionIndex;
				frame.stackPatternCount = stack.Count();
				trapFrames.Add(frame);
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PopTrapFrame(vint saveStackPatternCount)
			{
				if (trapFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyTrapFrame;
				WfRuntimeTrapFrame& frame = trapFrames[trapFrames.Count() - 1];
				if (frame.stackFrameIndex != stackFrames.Count() - 1) return WfRuntimeThreadContextError::TrapFrameCorrupted;

				vint stackPopCount = stack.Count() - frame.stackPatternCount - saveStackPatternCount;
				if (stackPopCount < 0)
				{
					return WfRuntimeThreadContextError::StackCorrupted;
				}
				else if (stackPopCount>0)
				{
					stack.RemoveRange(stack.Count() - stackPopCount, stackPopCount);
				}

				trapFrames.RemoveAt(trapFrames.Count() - 1);
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PushValue(const reflection::description::Value& value)
			{
				stack.Add(value);
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PopValue(reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0)
				{
					if (stack.Count() == 0) return WfRuntimeThreadContextError::EmptyStack;
				}
				else
				{
					WfRuntimeStackFrame& frame = GetCurrentStackFrame();
					if (stack.Count() <= frame.freeStackBase) return WfRuntimeThreadContextError::StackCorrupted;
				}
				value = stack[stack.Count() - 1];
				stack.RemoveAt(stack.Count() - 1);
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::RaiseException(const WString& exception, bool fatalError, bool skipDebugger)
			{
				auto info = MakePtr<WfRuntimeExceptionInfo>(exception, fatalError);
				return RaiseException(info, skipDebugger);
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::RaiseException(Ptr<WfRuntimeExceptionInfo> info, bool skipDebugger)
			{
				exceptionInfo = info;
				status = info->fatal ? WfRuntimeExecutionStatus::FatalError : WfRuntimeExecutionStatus::RaisedException;

				if (info->callStack.Count() == 0)
				{
					if (auto debugger = GetDebuggerForCurrentThread())
					{
						vint contextCount = debugger->GetThreadContexts().Count();
						for (vint i = contextCount - 1; i >= 0; i--)
						{
							auto context = debugger->GetThreadContexts()[i];
							vint stackCount = context->stackFrames.Count();
							for (vint j = stackCount - 1; j >= 0; j--)
							{
								const auto& stackFrame = context->stackFrames[j];
								info->callStack.Add(new WfRuntimeCallStackInfo(context, stackFrame));
							}

							if (i > 0)
							{
								info->callStack.Add(new WfRuntimeCallStackInfo);
							}
						}

						if (!skipDebugger)
						{
							if (auto callback = GetDebuggerCallback(debugger.Obj()))
							{
								if (callback->BreakException(info))
								{
									if (!callback->WaitForContinue())
									{
										RaiseException(L"Internal error: Debugger stopped the program.", true, true);
									}
								}
							}
						}
					}
				}

				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::LoadStackValue(vint stackItemIndex, reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				auto frame = GetCurrentStackFrame();
				if (stackItemIndex < frame.freeStackBase || stackItemIndex >= stack.Count())
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				value = stack[stackItemIndex];
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::LoadGlobalVariable(vint variableIndex, reflection::description::Value& value)
			{
				if (variableIndex < 0 || variableIndex >= globalContext->globalVariables->variables.Count())
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				value = globalContext->globalVariables->variables[variableIndex];
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::StoreGlobalVariable(vint variableIndex, const reflection::description::Value& value)
			{
				if (variableIndex < 0 || variableIndex >= globalContext->globalVariables->variables.Count())
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				globalContext->globalVariables->variables[variableIndex] = value;
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::LoadCapturedVariable(vint variableIndex, reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				auto frame = GetCurrentStackFrame();
				if (variableIndex < 0 || variableIndex >= frame.capturedVariables->variables.Count())
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				value = frame.capturedVariables->variables[variableIndex];
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::LoadLocalVariable(vint variableIndex, reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				auto frame = GetCurrentStackFrame();
				if (variableIndex < 0 || variableIndex >= frame.fixedVariableCount)
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				value = stack[frame.stackBase + variableIndex];
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::StoreLocalVariable(vint variableIndex, const reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				auto frame = GetCurrentStackFrame();
				if (variableIndex < 0 || variableIndex >= frame.fixedVariableCount)
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				stack[frame.stackBase + variableIndex] = value;
				return WfRuntimeThreadContextError::Success;
			}

			void WfRuntimeThreadContext::ExecuteToEnd()
			{
				auto callback = GetDebuggerCallback();
				if (callback)
				{
					callback->EnterThreadContext(this);
				}
				while (Execute(callback) != WfRuntimeExecutionAction::Nop);
				if (callback)
				{
					callback->LeaveThreadContext(this);
				}
			}
		}
	}
}

/***********************************************************************
RUNTIME\WFRUNTIMEASSEMBLY.CPP
***********************************************************************/

namespace vl
{
	using namespace reflection::description;
	using namespace workflow::runtime;
	using namespace workflow::typeimpl;
	using namespace collections;

	namespace stream
	{
		namespace internal
		{
			BEGIN_SERIALIZATION(WfInstructionDebugInfo)
				SERIALIZE(moduleCodes)
				SERIALIZE(instructionCodeMapping)
			END_SERIALIZATION

			BEGIN_SERIALIZATION(WfAssemblyFunction)
				SERIALIZE(name)
				SERIALIZE(argumentNames)
				SERIALIZE(capturedVariableNames)
				SERIALIZE(localVariableNames)
				SERIALIZE(firstInstruction)
				SERIALIZE(lastInstruction)
			END_SERIALIZATION

			SERIALIZE_ENUM(WfInsCode)
			SERIALIZE_ENUM(WfInsType)
			SERIALIZE_ENUM(Value::ValueType)

/***********************************************************************
Serizliation (Metadata)
***********************************************************************/

			template<>
			struct Serialization<ITypeDescriptor*>
			{
				static void IO(Reader& reader, ITypeDescriptor*& value)
				{
					WString id;
					reader << id;
					value = GetTypeDescriptor(id);
					CHECK_ERROR(value, L"Failed to load type.");
				}
					
				static void IO(Writer& writer, ITypeDescriptor*& value)
				{
					WString id = value->GetTypeName();
					writer << id;
				}
			};

			template<>
			struct Serialization<IMethodInfo*>
			{
				static void IO(Reader& reader, IMethodInfo*& value)
				{
					ITypeDescriptor* type = 0;
					WString name;
					List<WString> parameters;
					reader << type << name << parameters;
					auto group =
						name == L"#ctor" ? type->GetConstructorGroup() :
						type->GetMethodGroupByName(name, false);
					CHECK_ERROR(group, L"Failed to load method.");

					value = 0;
					vint count = group->GetMethodCount();
					for (vint i = 0; i < count; i++)
					{
						auto method = group->GetMethod(i);
						if (method->GetParameterCount() == parameters.Count())
						{
							bool found = true;
							for (vint j = 0; j < parameters.Count(); j++)
							{
								if (method->GetParameter(j)->GetName() != parameters[j])
								{
									found = false;
									break;
								}
							}

							if (found)
							{
								CHECK_ERROR(!value, L"Failed to load method.");
								value = method;
							}
						}
					}
					CHECK_ERROR(value, L"Failed to load method.");
				}
					
				static void IO(Writer& writer, IMethodInfo*& value)
				{
					auto type = value->GetOwnerTypeDescriptor();
					WString name =
						value->GetOwnerMethodGroup() == type->GetConstructorGroup() ? L"#ctor" :
						value->GetName();
					writer << type << name;

					List<WString> parameters;
					vint count = value->GetParameterCount();
					for (vint i = 0; i < count; i++)
					{
						parameters.Add(value->GetParameter(i)->GetName());
					}
					writer << parameters;
				}
			};

			template<>
			struct Serialization<IPropertyInfo*>
			{
				static void IO(Reader& reader, IPropertyInfo*& value)
				{
					ITypeDescriptor* type = 0;
					WString name;
					reader << type << name;
					value = type->GetPropertyByName(name, false);
					CHECK_ERROR(value, L"Failed to load property.");
				}
					
				static void IO(Writer& writer, IPropertyInfo*& value)
				{
					auto type = value->GetOwnerTypeDescriptor();
					WString name = value->GetName();
					writer << type << name;
				}
			};

			template<>
			struct Serialization<IEventInfo*>
			{
				static void IO(Reader& reader, IEventInfo*& value)
				{
					ITypeDescriptor* type = 0;
					WString name;
					reader << type << name;
					value = type->GetEventByName(name, false);
					CHECK_ERROR(value, L"Failed to load event.");
				}
					
				static void IO(Writer& writer, IEventInfo*& value)
				{
					auto type = value->GetOwnerTypeDescriptor();
					WString name = value->GetName();
					writer << type << name;
				}
			};

			template<>
			struct Serialization<Value>
			{
				static void IO(Reader& reader, Value& value)
				{
					WString id, text;
					reader << id << text;
					if (id == L"")
					{
						value = Value();
					}
					else
					{
						auto type = GetTypeDescriptor(id);
						if (type == GetTypeDescriptor<ITypeDescriptor>())
						{
							type = GetTypeDescriptor(text);
							CHECK_ERROR(type, L"Failed to load type.");
							value = Value::From(type);
						}
						else
						{
							type->GetValueSerializer()->Parse(text, value);
						}
					}
				}
					
				static void IO(Writer& writer, Value& value)
				{
					WString id;
					if (value.GetTypeDescriptor())
					{
						id = value.GetTypeDescriptor()->GetTypeName();
					}
					writer << id;

					if (value.GetTypeDescriptor() == GetTypeDescriptor<ITypeDescriptor>())
					{
						WString text = UnboxValue<ITypeDescriptor*>(value)->GetTypeName();
						writer << text;
					}
					else
					{
						WString text = value.GetText();
						writer << text;
					}
				}
			};

/***********************************************************************
Serialization (CollectTypeDescriptors)
***********************************************************************/

			static void CollectTypeDescriptors(ITypeDescriptor* td, SortedList<ITypeDescriptor*>& tds)
			{
				if (!tds.Contains(td))
				{
					tds.Add(td);
				}
			}

			static void CollectTypeDescriptors(ITypeInfo* typeInfo, SortedList<ITypeDescriptor*>& tds)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					CollectTypeDescriptors(typeInfo->GetElementType(), tds);
					break;
				case ITypeInfo::Generic:
					{
						CollectTypeDescriptors(typeInfo->GetElementType(), tds);
						vint count = typeInfo->GetGenericArgumentCount();
						for (vint i = 0; i < count; i++)
						{
							CollectTypeDescriptors(typeInfo->GetGenericArgument(i), tds);
						}
					}
					break;
				case ITypeInfo::TypeDescriptor:
					CollectTypeDescriptors(typeInfo->GetTypeDescriptor(), tds);
					break;
				}
			}

			static void CollectTypeDescriptors(IMethodInfo* info, SortedList<ITypeDescriptor*>& tds)
			{
				CollectTypeDescriptors(info->GetReturn(), tds);
				vint count = info->GetParameterCount();
				for (vint i = 0; i < count; i++)
				{
					CollectTypeDescriptors(info->GetParameter(i)->GetType(), tds);
				}
			}

			static void CollectTypeDescriptors(IEventInfo* info, SortedList<ITypeDescriptor*>& tds)
			{
				CollectTypeDescriptors(info->GetHandlerType(), tds);
			}

			static void CollectTypeDescriptors(IPropertyInfo* info, SortedList<ITypeDescriptor*>& tds)
			{
				CollectTypeDescriptors(info->GetReturn(), tds);
			}

			static void CollectTypeDescriptors(WfCustomType* td, SortedList<ITypeDescriptor*>& tds)
			{
				vint baseCount = td->GetBaseTypeDescriptorCount();
				for (vint i = 0; i < baseCount; i++)
				{
					auto baseType = td->GetBaseTypeDescriptor(i);
					CollectTypeDescriptors(baseType, tds);
				}

				vint methodGroupCount = td->GetMethodGroupCount();
				for (vint i = 0; i < methodGroupCount; i++)
				{
					auto group = td->GetMethodGroup(i);
					vint methodCount = group->GetMethodCount();
					for (vint j = 0; j < methodCount; j++)
					{
						auto method = group->GetMethod(j);
						CollectTypeDescriptors(method, tds);
					}
				}

				vint propertyCount = td->GetPropertyCount();
				for (vint i = 0; i < propertyCount; i++)
				{
					CollectTypeDescriptors(td->GetProperty(i), tds);
				}

				vint eventCount = td->GetEventCount();
				for (vint i = 0; i < eventCount; i++)
				{
					CollectTypeDescriptors(td->GetEvent(i), tds);
				}
			}

			static void CollectTypeDescriptors(WfTypeImpl* typeImpl, SortedList<ITypeDescriptor*>& tds)
			{
				FOREACH(Ptr<WfClass>, td, typeImpl->classes)
				{
					CollectTypeDescriptors(td.Obj(), tds);
				}
				FOREACH(Ptr<WfInterface>, td, typeImpl->interfaces)
				{
					CollectTypeDescriptors(td.Obj(), tds);
				}
			}

/***********************************************************************
Serialization (TypeImpl)
***********************************************************************/

			template<>
			struct Serialization<WfTypeImpl>
			{
				static void IOType(Reader& reader, Ptr<ITypeInfo>& typeInfo, Dictionary<vint, ITypeDescriptor*>& tdIndex)
				{
					vint decorator = 0;
					reader << decorator;
					auto typeInfoImpl = MakePtr<TypeInfoImpl>(static_cast<ITypeInfo::Decorator>(decorator));
					typeInfo = typeInfoImpl;
					
					switch (typeInfoImpl->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
					case ITypeInfo::Nullable:
						{
							Ptr<ITypeInfo> elementType;
							IOType(reader, elementType, tdIndex);
							typeInfoImpl->SetElementType(elementType);
						}
						break;
					case ITypeInfo::Generic:
						{
							Ptr<ITypeInfo> elementType;
							IOType(reader, elementType, tdIndex);
							typeInfoImpl->SetElementType(elementType);

							vint count = 0;
							reader << count;
							for (vint i = 0; i < count; i++)
							{
								Ptr<ITypeInfo> argumentType;
								IOType(reader, argumentType, tdIndex);
								typeInfoImpl->AddGenericArgument(argumentType);
							}
						}
						break;
					case ITypeInfo::TypeDescriptor:
						{
							vint index;
							reader << index;
							typeInfoImpl->SetTypeDescriptor(tdIndex[index]);
						}
						break;
					}
				}
					
				static void IOType(Writer& writer, ITypeInfo* typeInfo, Dictionary<ITypeDescriptor*, vint>& tdIndex)
				{
					vint decorator = static_cast<vint>(typeInfo->GetDecorator());
					writer << decorator;

					switch (typeInfo->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
					case ITypeInfo::Nullable:
						IOType(writer, typeInfo->GetElementType(), tdIndex);
						break;
					case ITypeInfo::Generic:
						{
							IOType(writer, typeInfo->GetElementType(), tdIndex);
							vint count = typeInfo->GetGenericArgumentCount();
							writer << count;
							for (vint i = 0; i < count; i++)
							{
								IOType(writer, typeInfo->GetGenericArgument(i), tdIndex);
							}
						}
						break;
					case ITypeInfo::TypeDescriptor:
						{
							vint index = tdIndex[typeInfo->GetTypeDescriptor()];
							writer << index;
						}
						break;
					}
				}

				//----------------------------------------------------

				static void IOMethodBase(Reader& reader, WfMethodBase* info, Dictionary<vint, ITypeDescriptor*>& tdIndex)
				{
					Ptr<ITypeInfo> type;
					IOType(reader, type, tdIndex);
					info->SetReturn(type);

					vint count = 0;
					reader << count;
					for (vint i = 0; i < count; i++)
					{
						WString name;
						IOType(reader, type, tdIndex);
						reader << name;
						info->AddParameter(new ParameterInfoImpl(info, name, type));
					}
				}
					
				static void IOMethodBase(Writer& writer, WfMethodBase* info, Dictionary<ITypeDescriptor*, vint>& tdIndex)
				{
					IOType(writer, info->GetReturn(), tdIndex);

					vint count = info->GetParameterCount();
					writer << count;
					for (vint i = 0; i < count; i++)
					{
						auto parameter = info->GetParameter(i);
						IOType(writer, parameter->GetType(), tdIndex);

						WString name = parameter->GetName();
						writer << name;
					}
				}

				//----------------------------------------------------

				static void IOStaticMethod(Reader& reader, WfStaticMethod* info, Dictionary<vint, ITypeDescriptor*>& tdIndex)
				{
					reader << info->functionIndex;
					IOMethodBase(reader, info, tdIndex);
				}

				static void IOStaticMethod(Writer& writer, WfStaticMethod* info, Dictionary<ITypeDescriptor*, vint>& tdIndex)
				{
					writer << info->functionIndex;
					IOMethodBase(writer, info, tdIndex);
				}

				//----------------------------------------------------

				static void IOInterfaceMethod(Reader& reader, WfInterfaceMethod* info, Dictionary<vint, ITypeDescriptor*>& tdIndex)
				{
					IOMethodBase(reader, info, tdIndex);
				}

				static void IOInterfaceMethod(Writer& writer, WfInterfaceMethod* info, Dictionary<ITypeDescriptor*, vint>& tdIndex)
				{
					IOMethodBase(writer, info, tdIndex);
				}

				//----------------------------------------------------

				static void IOCustomType(Reader& reader, WfCustomType* td, Dictionary<vint, ITypeDescriptor*>& tdIndex, bool isClass)
				{
					// methods
					vint methodGroupCount = 0;
					reader << methodGroupCount;
					for (vint i = 0; i < methodGroupCount; i++)
					{
						vint methodCount = 0;
						WString methodName;
						reader << methodCount << methodName;
						for (vint j = 0; j < methodCount; j++)
						{
							bool isStaticMethod = false;
							reader << isStaticMethod;

							if (isStaticMethod)
							{
								auto info = MakePtr<WfStaticMethod>();
								td->AddMember(methodName, info);
								IOStaticMethod(reader, info.Obj(), tdIndex);
							}
							else if (isClass)
							{
								throw 0;
							}
							else
							{
								auto info = MakePtr<WfInterfaceMethod>();
								td->AddMember(methodName, info);
								IOInterfaceMethod(reader, info.Obj(), tdIndex);
							}
						}
					}

					// events
					vint eventCount = 0;
					reader << eventCount;
					for (vint i = 0; i < eventCount; i++)
					{
						WString eventName;
						reader << eventName;

						Ptr<ITypeInfo> eventType;
						IOType(reader, eventType, tdIndex);

						auto info = MakePtr<WfEvent>(td, eventName);
						info->SetHandlerType(eventType);
						td->AddMember(info);
					}

					// properties
					vint propertyCount = 0;
					reader << propertyCount;
					for (vint i = 0; i < propertyCount; i++)
					{
						bool isProperty = false;
						WString propName;
						reader << isProperty << propName;

						if (isProperty)
						{
							auto info = MakePtr<WfProperty>(td, propName);

							WString getterName, setterName, eventName;
							reader << getterName << setterName << eventName;

							if (getterName != L"")
							{
								info->SetGetter(dynamic_cast<MethodInfoImpl*>(td->GetMethodGroupByName(getterName, false)->GetMethod(0)));
							}
							if (setterName != L"")
							{
								info->SetSetter(dynamic_cast<MethodInfoImpl*>(td->GetMethodGroupByName(setterName, false)->GetMethod(0)));
							}
							if (eventName != L"")
							{
								info->SetValueChangedEvent(dynamic_cast<EventInfoImpl*>(td->GetEventByName(eventName, false)));
							}

							td->AddMember(info);
						}
						else
						{
							throw 0;
						}
					}
				}
					
				static void IOCustomType(Writer& writer, WfCustomType* td, Dictionary<ITypeDescriptor*, vint>& tdIndex, bool isClass)
				{
					// methods
					vint methodGroupCount = td->GetMethodGroupCount();
					writer << methodGroupCount;
					for (vint i = 0; i < methodGroupCount; i++)
					{
						auto group = td->GetMethodGroup(i);
						vint methodCount = group->GetMethodCount();
						WString methodName = group->GetName();
						writer << methodCount << methodName;
						for (vint j = 0; j < methodCount; j++)
						{
							auto method = group->GetMethod(j);
							bool isStaticMethod = false;

							if (auto staticMethod = dynamic_cast<WfStaticMethod*>(method))
							{
								isStaticMethod = true;
								writer << isStaticMethod;
								IOStaticMethod(writer, staticMethod, tdIndex);
							}
							else if (isClass)
							{
								throw 0;
							}
							else
							{
								auto interfaceMethod = dynamic_cast<WfInterfaceMethod*>(method);
								writer << isStaticMethod;
								IOInterfaceMethod(writer, interfaceMethod, tdIndex);
							}
						}
					}

					// events
					vint eventCount = td->GetEventCount();
					writer << eventCount;
					for (vint i = 0; i < eventCount; i++)
					{
						auto info = td->GetEvent(i);
						WString eventName = info->GetName();
						writer << eventName;
						IOType(writer, info->GetHandlerType(), tdIndex);
					}

					// properties
					vint propertyCount = td->GetPropertyCount();
					writer << propertyCount;
					for (vint i = 0; i < propertyCount; i++)
					{
						auto propInfo = td->GetProperty(i);
						bool isProperty = false;

						if (auto prop = dynamic_cast<WfProperty*>(propInfo))
						{
							isProperty = true;
							WString propName = prop->GetName();
							writer << isProperty << propName;

							auto getterName = prop->GetGetter() ? prop->GetGetter()->GetName() : L"";
							auto setterName = prop->GetSetter() ? prop->GetSetter()->GetName() : L"";
							auto eventName = prop->GetValueChangedEvent() ? prop->GetValueChangedEvent()->GetName() : L"";
							writer << getterName << setterName << eventName;
						}
						else
						{
							throw 0;
						}
					}
				}

				//----------------------------------------------------

				static void IOClass(Reader& reader, WfClass* td, Dictionary<vint, ITypeDescriptor*>& tdIndex)
				{
					IOCustomType(reader, td, tdIndex, true);
				}

				static void IOClass(Writer& writer, WfClass* td, Dictionary<ITypeDescriptor*, vint>& tdIndex)
				{
					IOCustomType(writer, td, tdIndex, true);
				}

				//----------------------------------------------------

				static void IOInterface(Reader& reader, WfInterface* td, Dictionary<vint, ITypeDescriptor*>& tdIndex)
				{
					IOCustomType(reader, td, tdIndex, false);
				}

				static void IOInterface(Writer& writer, WfInterface* td, Dictionary<ITypeDescriptor*, vint>& tdIndex)
				{
					IOCustomType(writer, td, tdIndex, false);
				}

				//----------------------------------------------------

				template<typename TType>
				static void IOCustomTypeList(Reader& reader, List<Ptr<TType>>& types, Dictionary<vint, ITypeDescriptor*>& tdIndex)
				{
					vint typeCount = 0;
					reader << typeCount;
					for (vint i = 0; i < typeCount; i++)
					{
						WString typeName;
						reader << typeName;
						types.Add(MakePtr<TType>(typeName));
					}

					for (vint i = 0; i < typeCount; i++)
					{
						tdIndex.Add(tdIndex.Count(), types[i].Obj());
					}
				}

				template<typename TType>
				static void IOCustomTypeList(Writer& writer, List<Ptr<TType>>& types, Dictionary<ITypeDescriptor*, vint>& tdIndex)
				{
					vint typeCount = types.Count();
					writer << typeCount;
					for (vint i = 0; i < typeCount; i++)
					{
						WString typeName = types[i]->GetTypeName();
						writer << typeName;
					}
					
					for (vint i = 0; i < typeCount; i++)
					{
						tdIndex.Add(types[i].Obj(), tdIndex.Count());
					}
				}

				//----------------------------------------------------

				static void IO(Reader& reader, WfTypeImpl& value)
				{
					bool hasTypeImpl = false;
					reader << hasTypeImpl;
					if (hasTypeImpl)
					{
						// types
						Dictionary<vint, ITypeDescriptor*> tdIndex;
						IOCustomTypeList(reader, value.classes, tdIndex);
						IOCustomTypeList(reader, value.interfaces, tdIndex);
					
						// used type descriptors
						vint tdCount = 0;
						reader << tdCount;
						for (vint i = 0; i < tdCount; i++)
						{
							WString typeName;
							reader << typeName;
							tdIndex.Add((i * -1) - 1, GetTypeDescriptor(typeName));
						}

						// fill types
						FOREACH(Ptr<WfClass>, td, value.classes)
						{
							IOClass(reader, td.Obj(), tdIndex);
						}
						FOREACH(Ptr<WfInterface>, td, value.interfaces)
						{
							IOInterface(reader, td.Obj(), tdIndex);
						}
					}
				}
					
				static void IO(Writer& writer, WfTypeImpl& value)
				{
					bool hasTypeImpl = &value != nullptr;
					writer << hasTypeImpl;
					if (hasTypeImpl)
					{
						// types
						Dictionary<ITypeDescriptor*, vint> tdIndex;
						IOCustomTypeList(writer, value.classes, tdIndex);
						IOCustomTypeList(writer, value.interfaces, tdIndex);

						// used type descriptors
						SortedList<ITypeDescriptor*> tds;
						CollectTypeDescriptors(&value, tds);
						for (vint i = tds.Count() - 1; i >= 0; i--)
						{
							if (tdIndex.Keys().Contains(tds[i]))
							{
								tds.RemoveAt(i);
							}
						}

						vint tdCount = tds.Count();
						writer << tdCount;
						for (vint i = 0; i < tdCount; i++)
						{
							tdIndex.Add(tds[i], (i * -1) - 1);
							WString typeName = tds[i]->GetTypeName();
							writer << typeName;
						}

						// fill types
						FOREACH(Ptr<WfClass>, td, value.classes)
						{
							IOClass(writer, td.Obj(), tdIndex);
						}
						FOREACH(Ptr<WfInterface>, td, value.interfaces)
						{
							IOInterface(writer, td.Obj(), tdIndex);
						}
					}
				}
			};

/***********************************************************************
Serialization (Instruction)
***********************************************************************/

			template<>
			struct Serialization<WfInstruction>
			{
				template<typename TIO>
				static void IO(TIO& io, WfInstruction& value)
				{
					io << value.code;
#define STREAMIO(NAME)						case WfInsCode::NAME: break;
#define STREAMIO_VALUE(NAME)				case WfInsCode::NAME: io << value.valueParameter; break;
#define STREAMIO_FUNCTION(NAME)				case WfInsCode::NAME: io << value.indexParameter; break;
#define STREAMIO_FUNCTION_COUNT(NAME)		case WfInsCode::NAME: io << value.indexParameter << value.countParameter; break;
#define STREAMIO_VARIABLE(NAME)				case WfInsCode::NAME: io << value.indexParameter; break;
#define STREAMIO_COUNT(NAME)				case WfInsCode::NAME: io << value.countParameter; break;
#define STREAMIO_FLAG_TYPEDESCRIPTOR(NAME)	case WfInsCode::NAME: io << value.flagParameter << value.typeDescriptorParameter; break;
#define STREAMIO_PROPERTY(NAME)				case WfInsCode::NAME: io << value.propertyParameter; break;
#define STREAMIO_METHOD_COUNT(NAME)			case WfInsCode::NAME: io << value.methodParameter << value.countParameter; break;
#define STREAMIO_EVENT(NAME)				case WfInsCode::NAME: io << value.eventParameter; break;
#define STREAMIO_LABEL(NAME)				case WfInsCode::NAME: io << value.indexParameter; break;
#define STREAMIO_TYPE(NAME)					case WfInsCode::NAME: io << value.typeParameter; break;

					switch (value.code)
					{
						INSTRUCTION_CASES(
							STREAMIO,
							STREAMIO_VALUE,
							STREAMIO_FUNCTION,
							STREAMIO_FUNCTION_COUNT,
							STREAMIO_VARIABLE,
							STREAMIO_COUNT,
							STREAMIO_FLAG_TYPEDESCRIPTOR,
							STREAMIO_PROPERTY,
							STREAMIO_METHOD_COUNT,
							STREAMIO_EVENT,
							STREAMIO_LABEL,
							STREAMIO_TYPE)
					}

#undef STREAMIO
#undef STREAMIO_VALUE
#undef STREAMIO_FUNCTION
#undef STREAMIO_FUNCTION_COUNT
#undef STREAMIO_VARIABLE
#undef STREAMIO_COUNT
#undef STREAMIO_FLAG_TYPEDESCRIPTOR
#undef STREAMIO_PROPERTY
#undef STREAMIO_METHOD_COUNT
#undef STREAMIO_EVENT
#undef STREAMIO_LABEL
#undef STREAMIO_TYPE
				}
			};
		}
	}

	namespace workflow
	{
		namespace runtime
		{

/***********************************************************************
WfInstructionDebugInfo
***********************************************************************/

			void WfInstructionDebugInfo::Initialize()
			{
				for (vint i = 0; i < instructionCodeMapping.Count(); i++)
				{
					const auto& range = instructionCodeMapping[i];
					if (range.codeIndex != -1)
					{
						codeInstructionMapping.Add(Tuple<vint, vint>(range.codeIndex, range.start.row), i);
					}
				}
			}

/***********************************************************************
WfAssembly
***********************************************************************/

			template<typename TIO>
			void WfAssembly::IO(TIO& io)
			{
				io << typeImpl;
				if (typeImpl)
				{
					GetGlobalTypeManager()->AddTypeLoader(typeImpl);
				}
				io	<< insBeforeCodegen
					<< insAfterCodegen
					<< variableNames
					<< functionByName
					<< functions
					<< instructions
					;
				if (typeImpl)
				{
					GetGlobalTypeManager()->RemoveTypeLoader(typeImpl);
				}
			}

			WfAssembly::WfAssembly()
			{
			}

			WfAssembly::WfAssembly(stream::IStream& input)
			{
				stream::internal::Reader reader(input);
				IO(reader);
				Initialize();
			}

			void WfAssembly::Initialize()
			{
				insBeforeCodegen->Initialize();
				insAfterCodegen->Initialize();
			}

			void WfAssembly::Serialize(stream::IStream& output)
			{
				stream::internal::Writer writer(output);
				IO(writer);
			}
		}
	}
}

/***********************************************************************
RUNTIME\WFRUNTIMECONSTRUCTIONS.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace runtime
		{
			using namespace reflection::description;

/***********************************************************************
WfRuntimeReverseEnumerable
***********************************************************************/

			WfRuntimeReverseEnumerable::Enumerator::Enumerator(Ptr<reflection::description::IValueList> _list)
				:list(_list), index(_list->GetCount())
			{
			}

			reflection::description::Value WfRuntimeReverseEnumerable::Enumerator::GetCurrent()
			{
				return list->Get(index);
			}

			vint WfRuntimeReverseEnumerable::Enumerator::GetIndex()
			{
				return list->GetCount() - 1 - index;
			}

			bool WfRuntimeReverseEnumerable::Enumerator::Next()
			{
				if (index <= 0) return false;
				index--;
				return true;
			}

			WfRuntimeReverseEnumerable::WfRuntimeReverseEnumerable(Ptr<reflection::description::IValueList> _list)
				:list(_list)
			{
			}

			Ptr<reflection::description::IValueEnumerator> WfRuntimeReverseEnumerable::CreateEnumerator()
			{
				return MakePtr<Enumerator>(list);
			}
			
/***********************************************************************
WfRuntimeLambda
***********************************************************************/

			WfRuntimeLambda::WfRuntimeLambda(Ptr<WfRuntimeGlobalContext> _globalContext, Ptr<WfRuntimeVariableContext> _capturedVariables, vint _functionIndex)
				:globalContext(_globalContext)
				, capturedVariables(_capturedVariables)
				, functionIndex(_functionIndex)
			{
			}

			reflection::description::Value WfRuntimeLambda::Invoke(Ptr<reflection::description::IValueList> arguments)
			{
				WfRuntimeThreadContext context(globalContext);
				vint count = arguments->GetCount();
				for (vint i = 0; i < count; i++)
				{
					context.PushValue(arguments->Get(i));
				}
					
				WString message;
				if (context.PushStackFrame(functionIndex, count, capturedVariables) != WfRuntimeThreadContextError::Success)
				{
					throw WfRuntimeException(L"Internal error: failed to invoke a function.", true);
				}

				context.ExecuteToEnd();
				if (context.status != WfRuntimeExecutionStatus::Finished)
				{
					throw WfRuntimeException(context.exceptionInfo);
				}

				Value result;
				if (context.PopValue(result) != WfRuntimeThreadContextError::Success)
				{
					throw WfRuntimeException(L"Internal error: failed to pop the function result.", true);
				}
					
				return result;
			}
			
/***********************************************************************
WfRuntimeInterfaceInstance
***********************************************************************/

			reflection::description::Value WfRuntimeInterfaceInstance::Invoke(const WString& name, Ptr<reflection::description::IValueList> arguments)
			{
				vint index = functions.Keys().IndexOf(name);
				if (index == -1)
				{
					throw WfRuntimeException(L"Internal error: failed to invoke the interface method \"" + name + L"\"", true);
				}
				else
				{
					return functions.Values()[index]->Invoke(arguments);
				}
			}
		}
	}
}

/***********************************************************************
RUNTIME\WFRUNTIMEDEBUGGER.CPP
***********************************************************************/
#include <math.h>

namespace vl
{
	namespace workflow
	{
		namespace runtime
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
IWfDebuggerCallback
***********************************************************************/

			WfBreakPoint WfBreakPoint::Ins(WfAssembly* assembly, vint instruction)
			{
				WfBreakPoint breakPoint;
				breakPoint.type = Instruction;
				breakPoint.assembly = assembly;
				breakPoint.instruction = instruction;
				return breakPoint;
			}

			WfBreakPoint WfBreakPoint::Read(WfAssembly* assembly, vint variable)
			{
				WfBreakPoint breakPoint;
				breakPoint.type = ReadGlobalVar;
				breakPoint.assembly = assembly;
				breakPoint.variable = variable;
				return breakPoint;
			}

			WfBreakPoint WfBreakPoint::Write(WfAssembly* assembly, vint variable)
			{
				WfBreakPoint breakPoint;
				breakPoint.type = WriteGlobalVar;
				breakPoint.assembly = assembly;
				breakPoint.variable = variable;
				return breakPoint;
			}

			WfBreakPoint WfBreakPoint::Get(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo)
			{
				WfBreakPoint breakPoint;
				breakPoint.type = GetProperty;
				breakPoint.thisObject = thisObject;
				breakPoint.propertyInfo = propertyInfo;
				return breakPoint;
			}

			WfBreakPoint WfBreakPoint::Set(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo)
			{
				WfBreakPoint breakPoint;
				breakPoint.type = SetProperty;
				breakPoint.thisObject = thisObject;
				breakPoint.propertyInfo = propertyInfo;
				return breakPoint;
			}

			WfBreakPoint WfBreakPoint::Attach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo)
			{
				WfBreakPoint breakPoint;
				breakPoint.type = AttachEvent;
				breakPoint.thisObject = thisObject;
				breakPoint.eventInfo = eventInfo;
				return breakPoint;
			}

			WfBreakPoint WfBreakPoint::Detach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo)
			{
				WfBreakPoint breakPoint;
				breakPoint.type = DetachEvent;
				breakPoint.thisObject = thisObject;
				breakPoint.eventInfo = eventInfo;
				return breakPoint;
			}

			WfBreakPoint WfBreakPoint::Invoke(reflection::DescriptableObject* thisObject, reflection::description::IMethodInfo* methodInfo)
			{
				WfBreakPoint breakPoint;
				breakPoint.type = InvokeMethod;
				breakPoint.thisObject = thisObject;
				breakPoint.methodInfo = methodInfo;
				return breakPoint;
			}

			WfBreakPoint WfBreakPoint::Create(reflection::description::ITypeDescriptor* typeDescriptor)
			{
				WfBreakPoint breakPoint;
				breakPoint.type = CreateObject;
				breakPoint.typeDescriptor = typeDescriptor;
				return breakPoint;
			}

/***********************************************************************
InstructionLocation
***********************************************************************/

			bool WfDebugger::InstructionLocation::BreakStepOver(const InstructionLocation& il, bool beforeCodegen)
			{
				if (contextIndex != il.contextIndex) return contextIndex > il.contextIndex;
				if (assembly != il.assembly) return true;
				if (stackFrameIndex != il.stackFrameIndex) return stackFrameIndex > il.stackFrameIndex;

				auto debugInfo = (beforeCodegen ? assembly->insBeforeCodegen : assembly->insAfterCodegen);
				auto& range1 = debugInfo->instructionCodeMapping[instruction];
				auto& range2 = debugInfo->instructionCodeMapping[il.instruction];

				if (range1.codeIndex != range2.codeIndex) return true;
				if (range1.start.row != range2.start.row) return true;

				return false;
			}

			bool WfDebugger::InstructionLocation::BreakStepInto(const InstructionLocation& il, bool beforeCodegen)
			{
				if (contextIndex != il.contextIndex) return true;
				if (assembly != il.assembly) return true;
				if (stackFrameIndex != il.stackFrameIndex) return true;

				auto debugInfo = (beforeCodegen ? assembly->insBeforeCodegen : assembly->insAfterCodegen);
				auto& range1 = debugInfo->instructionCodeMapping[instruction];
				auto& range2 = debugInfo->instructionCodeMapping[il.instruction];

				if (range1.codeIndex != range2.codeIndex) return true;
				if (range1.start.row != range2.start.row) return true;

				return false;
			}

/***********************************************************************
WfDebugger
***********************************************************************/

			void WfDebugger::OnBlockExecution()
			{
			}

			void WfDebugger::OnStartExecution()
			{
			}

			void WfDebugger::OnStopExecution()
			{
			}

			WfDebugger::InstructionLocation WfDebugger::MakeCurrentInstructionLocation()
			{
				auto context = threadContexts[threadContexts.Count() - 1];
				InstructionLocation il;
				il.contextIndex = threadContexts.Count() - 1;
				il.assembly = context->globalContext->assembly.Obj();
				il.stackFrameIndex = context->stackFrames.Count() - 1;
				il.instruction = context->stackFrames[context->stackFrames.Count() - 1].nextInstructionIndex;
				return il;
			}
				
			template<typename TKey>
			bool WfDebugger::HandleBreakPoint(const TKey& key, collections::Dictionary<TKey, vint>& breakPointMap)
			{
				if (evaluatingBreakPoint)
				{
					return false;
				}

				evaluatingBreakPoint = true;
				bool activated = false;
				vint index = breakPointMap.Keys().IndexOf(key);
				if (index != -1)
				{
					index = breakPointMap.Values()[index];
					const auto& breakPoint = breakPoints[index];
					if (breakPoint.available && breakPoint.enabled)
					{
						if (breakPoint.action)
						{
							activated = breakPoint.action->EvaluateCondition(this);
							breakPoint.action->PostAction(this);
						}
						else
						{
							activated = true;
						}
					}

					if (activated)
					{
						lastActivatedBreakPoint = index;
					}
				}
				evaluatingBreakPoint = false;
				return activated;
			}

			void WfDebugger::EnterThreadContext(WfRuntimeThreadContext* context)
			{
				if (threadContexts.Count() == 0)
				{
					lastActivatedBreakPoint = InvalidBreakPoint;
					instructionLocation = InstructionLocation();
					OnStartExecution();
					if (state == Stopped)
					{
						state = Running;
					}
				}
				threadContexts.Add(context);
			}

			void WfDebugger::LeaveThreadContext(WfRuntimeThreadContext* context)
			{
				auto oldContext = threadContexts[threadContexts.Count() - 1];
				threadContexts.RemoveAt(threadContexts.Count() - 1);
				CHECK_ERROR(context == oldContext, L"vl::workflow::runtime::WfDebugger::LeaveThreadContext(WfRuntimeThreadContext*)#EnterThreadContext and LeaveThreadContext should be called in pairs.");

				if (threadContexts.Count() == 0)
				{
					state = Stopped;
					OnStopExecution();
				}
			}

			bool WfDebugger::BreakIns(WfAssembly* assembly, vint instruction)
			{
				if (runningType != RunUntilBreakPoint)
				{
					auto il = MakeCurrentInstructionLocation();
					bool needToBreak = false;
					switch (runningType)
					{
					case RunStepOver:
						needToBreak = instructionLocation.BreakStepOver(il, stepBeforeCodegen);
						break;
					case RunStepInto:
						needToBreak = instructionLocation.BreakStepInto(il, stepBeforeCodegen);
						break;
					default:;
					}
					if (needToBreak)
					{
						instructionLocation = il;
						lastActivatedBreakPoint = WfDebugger::PauseBreakPoint;
						return true;
					}
				}

				switch (state)
				{
				case RequiredToPause:
				case RequiredToStop:
					lastActivatedBreakPoint = WfDebugger::PauseBreakPoint;
					return true;
				default:;
				}

				AssemblyKey key(assembly, instruction);
				return HandleBreakPoint(key, insBreakPoints);
			}

			bool WfDebugger::BreakRead(WfAssembly* assembly, vint variable)
			{
				AssemblyKey key(assembly, variable);
				return HandleBreakPoint(key, getGlobalVarBreakPoints);
			}

			bool WfDebugger::BreakWrite(WfAssembly* assembly, vint variable)
			{
				AssemblyKey key(assembly, variable);
				return HandleBreakPoint(key, setGlobalVarBreakPoints);
			}

			bool WfDebugger::BreakGet(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo)
			{
				PropertyKey key1(thisObject, propertyInfo);
				PropertyKey key2(nullptr, propertyInfo);
				return HandleBreakPoint(key1, getPropertyBreakPoints) || HandleBreakPoint(key2, getPropertyBreakPoints);
			}

			bool WfDebugger::BreakSet(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo)
			{
				PropertyKey key1(thisObject, propertyInfo);
				PropertyKey key2(nullptr, propertyInfo);
				return HandleBreakPoint(key1, setPropertyBreakPoints) || HandleBreakPoint(key2, setPropertyBreakPoints);
			}

			bool WfDebugger::BreakAttach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo)
			{
				EventKey key1(thisObject, eventInfo);
				EventKey key2(nullptr, eventInfo);
				return HandleBreakPoint(key1, attachEventBreakPoints) || HandleBreakPoint(key2, attachEventBreakPoints);
			}

			bool WfDebugger::BreakDetach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo)
			{
				EventKey key1(thisObject, eventInfo);
				EventKey key2(nullptr, eventInfo);
				return HandleBreakPoint(key1, detachEventBreakPoints) || HandleBreakPoint(key2, detachEventBreakPoints);
			}

			bool WfDebugger::BreakInvoke(reflection::DescriptableObject* thisObject, reflection::description::IMethodInfo* methodInfo)
			{
				MethodKey key1(thisObject, methodInfo);
				MethodKey key2(nullptr, methodInfo);
				return HandleBreakPoint(key1, invokeMethodBreakPoints) || HandleBreakPoint(key2, invokeMethodBreakPoints);
			}

			bool WfDebugger::BreakCreate(reflection::description::ITypeDescriptor* typeDescriptor)
			{
				return HandleBreakPoint(typeDescriptor, createObjectBreakPoints);
			}

			bool WfDebugger::BreakException(Ptr<WfRuntimeExceptionInfo> info)
			{
				if (breakException)
				{
					lastActivatedBreakPoint = PauseBreakPoint;
					return true;
				}
				else
				{
					return false;
				}
			}

			bool WfDebugger::WaitForContinue()
			{
				if (state == RequiredToStop)
				{
					return false;
				}

				state = lastActivatedBreakPoint >= 0 ? PauseByBreakPoint : PauseByOperation;
				while (state == PauseByBreakPoint || state == PauseByOperation)
				{
					OnBlockExecution();
				}
				
				if (state == Continue)
				{
					state = Running;
				}
				return true;
			}

/***********************************************************************
WfDebugger
***********************************************************************/

#define TEST(AVAILABLE, KEY, MAP) if (AVAILABLE && available == MAP.Keys().Contains(KEY)) return false;
#define SET(KEY, MAP) if (available) MAP.Add(KEY, index); else MAP.Remove(KEY);
#define SETC(AVAILABLE, KEY, MAP) if (AVAILABLE) {if (available) MAP.Add(KEY, index); else MAP.Remove(KEY);}

			bool WfDebugger::SetBreakPoint(const WfBreakPoint& breakPoint, bool available, vint index)
			{
				switch (breakPoint.type)
				{
				case WfBreakPoint::Instruction:
					{
						AssemblyKey key(breakPoint.assembly, breakPoint.instruction);
						TEST(true, key, insBreakPoints);
						SET(key, insBreakPoints);
					}
					break;
				case WfBreakPoint::ReadGlobalVar:
					{
						AssemblyKey key(breakPoint.assembly, breakPoint.variable);
						TEST(true, key, getGlobalVarBreakPoints);
						SET(key, getGlobalVarBreakPoints);
					}
					break;
				case WfBreakPoint::WriteGlobalVar:
					{
						AssemblyKey key(breakPoint.assembly, breakPoint.instruction);
						TEST(true, key, setGlobalVarBreakPoints);
						SET(key, setGlobalVarBreakPoints);
					}
					break;
				case WfBreakPoint::GetProperty:
					{
						PropertyKey key1(breakPoint.thisObject, breakPoint.propertyInfo);
						MethodKey key2(breakPoint.thisObject, breakPoint.propertyInfo->GetGetter());
						TEST(true, key1, getPropertyBreakPoints);
						TEST(key2.f1, key2, invokeMethodBreakPoints);
						SET(key1, getPropertyBreakPoints);
						SETC(key2.f1, key2, invokeMethodBreakPoints);
					}
					break;
				case WfBreakPoint::SetProperty:
					{
						PropertyKey key1(breakPoint.thisObject, breakPoint.propertyInfo);
						MethodKey key2(breakPoint.thisObject, breakPoint.propertyInfo->GetSetter());
						TEST(true, key1, setPropertyBreakPoints);
						TEST(key2.f1, key2, invokeMethodBreakPoints);
						SET(key1, setPropertyBreakPoints);
						SETC(key2.f1, key2, invokeMethodBreakPoints);
					}
					break;
				case WfBreakPoint::AttachEvent:
					{
						EventKey key(breakPoint.thisObject, breakPoint.eventInfo);
						TEST(true, key, attachEventBreakPoints);
						SET(key, attachEventBreakPoints);
					}
					break;
				case WfBreakPoint::DetachEvent:
					{
						EventKey key(breakPoint.thisObject, breakPoint.eventInfo);
						TEST(true, key, detachEventBreakPoints);
						SET(key, detachEventBreakPoints);
					}
					break;
				case WfBreakPoint::InvokeMethod:
					{
						// get property, set property and new object are all compiled to invoke method
						// so here it is not noecessary to generate other keys
						MethodKey key(breakPoint.thisObject, breakPoint.methodInfo);
						TEST(true, key, invokeMethodBreakPoints);
						SET(key, invokeMethodBreakPoints);
					}
					break;
				case WfBreakPoint::CreateObject:
					{
						auto group = breakPoint.typeDescriptor->GetConstructorGroup();
						vint count = group ? group->GetMethodCount() : 0;

						TEST(true, breakPoint.typeDescriptor, createObjectBreakPoints);
						for (vint i = 0; i < count; i++)
						{
							MethodKey key(nullptr, group->GetMethod(i));
							TEST(true, key, invokeMethodBreakPoints);
						}
						SET(breakPoint.typeDescriptor, createObjectBreakPoints);
						for (vint i = 0; i < count; i++)
						{
							MethodKey key(nullptr, group->GetMethod(i));
							SET(key, invokeMethodBreakPoints);
						}
					}
					break;
				default:
					return false;
				}
				return true;
			}

#undef TEST
#undef SET
#undef SETC

			WfDebugger::WfDebugger()
			{
			}

			WfDebugger::~WfDebugger()
			{
			}

			vint WfDebugger::AddBreakPoint(const WfBreakPoint& breakPoint)
			{
				vint index = breakPoints.Count();
				if (freeBreakPointIndices.Count() > 0)
				{
					index = freeBreakPointIndices[freeBreakPointIndices.Count() - 1];
				}

				if (!SetBreakPoint(breakPoint, true, index))
				{
					return -1;
				}
				
				if (index == breakPoints.Count())
				{
					breakPoints.Add(breakPoint);
				}
				else
				{
					freeBreakPointIndices.RemoveAt(freeBreakPointIndices.Count() - 1);
					breakPoints[index] = breakPoint;
				}

				breakPoints[index].id = index;
				breakPoints[index].available = true;
				breakPoints[index].enabled = true;
				return index;
			}

			vint WfDebugger::AddCodeLineBreakPoint(WfAssembly* assembly, vint codeIndex, vint row, bool beforeCodegen)
			{
				auto& codeInsMap = (beforeCodegen ? assembly->insBeforeCodegen : assembly->insAfterCodegen)->codeInstructionMapping;
				Tuple<vint, vint> key(codeIndex, row);
				vint index = codeInsMap.Keys().IndexOf(key);
				if (index == -1)
				{
					return -1;
				}

				vint ins = codeInsMap.GetByIndex(index)[0];
				return AddBreakPoint(WfBreakPoint::Ins(assembly, ins));
			}

			vint WfDebugger::GetBreakPointCount()
			{
				return breakPoints.Count();
			}

			const WfBreakPoint& WfDebugger::GetBreakPoint(vint index)
			{
				return breakPoints[index];
			}

			bool WfDebugger::RemoveBreakPoint(vint index)
			{
				if (index < 0 || index >= breakPoints.Count())
				{
					return false;
				}

				auto& breakPoint = breakPoints[index];
				if (!breakPoint.available || !SetBreakPoint(breakPoint, false, -1))
				{
					return false;
				}

				breakPoint.available = false;
				freeBreakPointIndices.Add(index);
				return true;
			}

			bool WfDebugger::EnableBreakPoint(vint index, bool enabled)
			{
				if (0 <= index && index <= breakPoints.Count())
				{
					auto& breakPoint = breakPoints[index];
					if (breakPoint.available)
					{
						breakPoint.enabled = enabled;
						return true;
					}
				}
				return false;
			}

			bool WfDebugger::GetBreakException()
			{
				return breakException;
			}

			void WfDebugger::SetBreakException(bool value)
			{
				breakException = value;
			}

			bool WfDebugger::Run()
			{
				if (state != PauseByOperation && state != PauseByBreakPoint)
				{
					return false;
				}
				state = Continue;
				runningType = RunUntilBreakPoint;
				return true;
			}

			bool WfDebugger::Pause()
			{
				if (state != Running && state != Stopped)
				{
					return false;
				}
				state = RequiredToPause;
				return true;
			}

			bool WfDebugger::Stop()
			{
				if (state != PauseByOperation && state != PauseByBreakPoint && state != Running)
				{
					return false;
				}
				state = RequiredToStop;
				return true;
			}

			bool WfDebugger::StepOver(bool beforeCodegen)
			{
				if (state != PauseByOperation && state != PauseByBreakPoint && state != Stopped)
				{
					return false;
				}
				if (state != Stopped)
				{
					state = Continue;
					instructionLocation = MakeCurrentInstructionLocation();
				}
				runningType = RunStepOver;
				stepBeforeCodegen = beforeCodegen;
				return true;
			}

			bool WfDebugger::StepInto(bool beforeCodegen)
			{
				if (state != PauseByOperation && state != PauseByBreakPoint && state != Stopped)
				{
					return false;
				}
				if (state != Stopped)
				{
					state = Continue;
					instructionLocation = MakeCurrentInstructionLocation();
				}
				state = Continue;
				runningType = RunStepInto;
				stepBeforeCodegen = beforeCodegen;
				return true;
			}

			WfDebugger::State WfDebugger::GetState()
			{
				return state;
			}

			WfDebugger::RunningType WfDebugger::GetRunningType()
			{
				return runningType;
			}

			vint WfDebugger::GetLastActivatedBreakPoint()
			{
				return lastActivatedBreakPoint;
			}

			const WfDebugger::ThreadContextList& WfDebugger::GetThreadContexts()
			{
				return threadContexts;
			}

			WfRuntimeThreadContext* WfDebugger::GetCurrentThreadContext()
			{
				if (threadContexts.Count() == 0)
				{
					return nullptr;
				}
				return threadContexts[threadContexts.Count() - 1];
			}

			const parsing::ParsingTextRange& WfDebugger::GetCurrentPosition(bool beforeCodegen, WfRuntimeThreadContext* context, vint callStackIndex)
			{
				if (!context)
				{
					context = GetCurrentThreadContext();
				}
				if (callStackIndex == -1)
				{
					callStackIndex = context->stackFrames.Count() - 1;
				}

				auto& stackFrame = context->stackFrames[callStackIndex];
				auto ins = stackFrame.nextInstructionIndex;
				auto debugInfo = (beforeCodegen ? context->globalContext->assembly->insBeforeCodegen : context->globalContext->assembly->insAfterCodegen);
				return debugInfo->instructionCodeMapping[ins];
			}

			reflection::description::Value WfDebugger::GetValueByName(const WString& name, WfRuntimeThreadContext* context, vint callStackIndex)
			{
				if (!context)
				{
					context = GetCurrentThreadContext();
				}
				if (callStackIndex == -1)
				{
					callStackIndex = context->stackFrames.Count() - 1;
				}

				auto& stackFrame = context->stackFrames[callStackIndex];
				auto function = context->globalContext->assembly->functions[stackFrame.functionIndex];

				vint index = function->argumentNames.IndexOf(name);
				if (index != -1)
				{
					return context->stack[stackFrame.stackBase + index];
				}

				index = function->localVariableNames.IndexOf(name);
				if (index != -1)
				{
					return context->stack[stackFrame.stackBase + function->argumentNames.Count() + index];
				}

				index = function->capturedVariableNames.IndexOf(name);
				if (index != -1)
				{
					return stackFrame.capturedVariables->variables[index];
				}

				index = context->globalContext->assembly->variableNames.IndexOf(name);
				if (index != -1)
				{
					return context->globalContext->globalVariables->variables[index];
				}

				return Value();
			}

/***********************************************************************
Helper Functions
***********************************************************************/

			ThreadVariable<Ptr<WfDebugger>> threadDebugger;

			IWfDebuggerCallback* GetDebuggerCallback()
			{
				return GetDebuggerCallback(GetDebuggerForCurrentThread().Obj());
			}

			IWfDebuggerCallback* GetDebuggerCallback(WfDebugger* debugger)
			{
				return debugger;
			}

			Ptr<WfDebugger> GetDebuggerForCurrentThread()
			{
				return threadDebugger.HasData() ? threadDebugger.Get() : nullptr;
			}

			void SetDebuggerForCurrentThread(Ptr<WfDebugger> debugger)
			{
				threadDebugger.Set(debugger);
			}
		}
	}
}

/***********************************************************************
RUNTIME\WFRUNTIMEEXECUTION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace runtime
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
WfRuntimeThreadContext (Operators)
***********************************************************************/

#define INTERNAL_ERROR(MESSAGE)\
				do{\
					context.RaiseException(WString(L"Internal error: " MESSAGE), true);\
					return WfRuntimeExecutionAction::Nop; \
				} while (0)\

#define CONTEXT_ACTION(ACTION, MESSAGE)\
				do{\
					if ((context.ACTION) != WfRuntimeThreadContextError::Success)\
					{\
						INTERNAL_ERROR(MESSAGE);\
					}\
				} while (0)\

			//-------------------------------------------------------------------------------

#define UNARY_OPERATOR(NAME, OPERATOR)\
			template<typename T>\
			WfRuntimeExecutionAction OPERATOR_##NAME(WfRuntimeThreadContext& context)\
			{\
				Value operand;\
				CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");\
				T value = OPERATOR UnboxValue<T>(operand);\
				context.PushValue(BoxValue(value));\
				return WfRuntimeExecutionAction::ExecuteInstruction;\
			}\

#define BINARY_OPERATOR(NAME, OPERATOR)\
			template<typename T>\
			WfRuntimeExecutionAction OPERATOR_##NAME(WfRuntimeThreadContext& context)\
			{\
				Value first, second;\
				CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");\
				CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");\
				T value = UnboxValue<T>(first) OPERATOR UnboxValue<T>(second);\
				context.PushValue(BoxValue(value));\
				return WfRuntimeExecutionAction::ExecuteInstruction;\
			}\

			//-------------------------------------------------------------------------------

			UNARY_OPERATOR(OpNot, ~)
			UNARY_OPERATOR(OpNot_Bool, !)
			UNARY_OPERATOR(OpPositive, +)
			UNARY_OPERATOR(OpNegative, -)

			BINARY_OPERATOR(OpAdd, +)
			BINARY_OPERATOR(OpSub, -)
			BINARY_OPERATOR(OpMul, *)
			BINARY_OPERATOR(OpDiv, /)
			BINARY_OPERATOR(OpMod, %)
			BINARY_OPERATOR(OpShl, <<)
			BINARY_OPERATOR(OpShr, >>)
			BINARY_OPERATOR(OpAnd, &)
			BINARY_OPERATOR(OpAnd_Bool, &&)
			BINARY_OPERATOR(OpOr, |)
			BINARY_OPERATOR(OpOr_Bool, ||)
			BINARY_OPERATOR(OpXor, ^)

			template<typename T>
			WfRuntimeExecutionAction OPERATOR_OpExp(WfRuntimeThreadContext& context)
			{
				Value first, second;
				CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
				CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");
				T firstValue = UnboxValue<T>(first);
				T secondValue = UnboxValue<T>(second);
				T value = exp(secondValue * log(firstValue));
				context.PushValue(BoxValue(value));
				return WfRuntimeExecutionAction::ExecuteInstruction;
			}
			
			template<typename T>
			WfRuntimeExecutionAction OPERATOR_OpCompare(WfRuntimeThreadContext& context)
			{
				Value first, second;
				CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
				CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");

				bool firstNull = first.GetValueType() == Value::Null;
				bool secondNull = second.GetValueType() == Value::Null;
				if (firstNull)
				{
					if (secondNull)
					{
						context.PushValue(BoxValue((vint)0));
					}
					else
					{
						context.PushValue(BoxValue((vint)-1));
					}
				}
				else
				{
					if (secondNull)
					{context.PushValue(BoxValue((vint)1));
					}
					else
					{
						T firstValue = UnboxValue<T>(first);
						T secondValue = UnboxValue<T>(second);
						if (firstValue < secondValue)
						{
							context.PushValue(BoxValue((vint)-1));
						}
						else if (firstValue > secondValue)
						{
							context.PushValue(BoxValue((vint)1));
						}
						else
						{
							context.PushValue(BoxValue((vint)0));
						}
					}
				}
				return WfRuntimeExecutionAction::ExecuteInstruction;
			}
			
/***********************************************************************
WfRuntimeThreadContext (TypeConversion)
***********************************************************************/

			bool OPERATOR_OpConvertToType(const Value& result, Value& converted, const WfInstruction& ins)
			{
				switch (ins.flagParameter)
				{
				case Value::Null:
					return false;
				case Value::RawPtr:
					if (result.GetValueType() == Value::Text)
					{
						return false;
					}
					else if (result.GetRawPtr())
					{
						if (result.GetTypeDescriptor()->CanConvertTo(ins.typeDescriptorParameter))
						{
							converted = Value::From(result.GetRawPtr());
						}
						else
						{
							return false;
						}
					}
					break;
				case Value::SharedPtr:
					if (result.GetValueType() == Value::Text)
					{
						return false;
					}
					else if (result.GetRawPtr())
					{
						if (result.GetTypeDescriptor()->CanConvertTo(ins.typeDescriptorParameter))
						{
							converted = Value::From(Ptr<DescriptableObject>(result.GetRawPtr()));
						}
						else
						{
							return false;
						}
					}
					break;
				case Value::Text:
					if (result.GetValueType() != Value::Text)
					{
						return false;
					}
					else if (ins.typeDescriptorParameter == GetTypeDescriptor<void>())
					{
						if (result.GetText() != L"")
						{
							return false;
						}
					}
					else
					{
						auto serializer = ins.typeDescriptorParameter->GetValueSerializer();
						if (!serializer)
						{
							return false;
						}
						if (!serializer->Parse(result.GetText(), converted))
						{
							return false;
						}
					}
					break;
				}

				return true;
			}
			
/***********************************************************************
WfRuntimeThreadContext (Range)
***********************************************************************/
			
			template<typename T>
			WfRuntimeExecutionAction OPERATOR_OpCreateRange(WfRuntimeThreadContext& context)
			{
				Value first, second;
				CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
				CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");
				T firstValue = UnboxValue<T>(first);
				T secondValue = UnboxValue<T>(second);
				auto enumerable = MakePtr<WfRuntimeRange<T>>(firstValue, secondValue);
				context.PushValue(Value::From(enumerable));
				return WfRuntimeExecutionAction::ExecuteInstruction;
			}
			
/***********************************************************************
WfRuntimeThreadContext (ReverseEnumerable)
***********************************************************************/
			
			Value OPERATOR_OpReverseEnumerable(Value operand)
			{
				auto enumerable = UnboxValue<Ptr<IValueEnumerable>>(operand);
				auto list = enumerable.Cast<IValueList>();
				if (!list)
				{
					list = IValueList::Create(GetLazyList<Value>(enumerable));
				}
				return Value::From(MakePtr<WfRuntimeReverseEnumerable>(list));
			}

#undef INTERNAL_ERROR
#undef CONTEXT_ACTION
#undef UNARY_OPERATOR
#undef BINARY_OPERATOR

/***********************************************************************
Helper Functions
***********************************************************************/

			Ptr<reflection::description::IValueFunctionProxy> LoadFunction(Ptr<WfRuntimeGlobalContext> context, const WString& name)
			{
				const auto& names = context->assembly->functionByName[name];
				CHECK_ERROR(names.Count() == 1, L"vl::workflow::runtime::LoadFunction(Ptr<WfRUntimeGlobalContext>, const WString&)#Multiple functions are found.");
				vint functionIndex = names[0];
				auto lambda = MakePtr<WfRuntimeLambda>(context, nullptr, functionIndex);
				return lambda;
			}

/***********************************************************************
WfRuntimeThreadContext
***********************************************************************/
			
#define INTERNAL_ERROR(MESSAGE)\
				do{\
					RaiseException(WString(L"Internal error: " MESSAGE), true);\
					return WfRuntimeExecutionAction::Nop; \
				} while (0)\

#define CONTEXT_ACTION(ACTION, MESSAGE)\
				do{\
					if ((ACTION) != WfRuntimeThreadContextError::Success)\
					{\
						INTERNAL_ERROR(MESSAGE);\
					}\
				} while (0)\

#define CALL_DEBUGGER(ACTION)\
				do {\
					if (callback)\
					{\
						if (ACTION)\
						{\
							if (!callback->WaitForContinue())\
							{\
								INTERNAL_ERROR(L"Debugger stopped the program.");\
							}\
						}\
					}\
				} while (0)\

#define TYPE_OF_Bool							bool
#define TYPE_OF_I1								vint8_t
#define TYPE_OF_I2								vint16_t
#define TYPE_OF_I4								vint32_t
#define TYPE_OF_I8								vint64_t
#define TYPE_OF_U1								vuint8_t
#define TYPE_OF_U2								vuint16_t
#define TYPE_OF_U4								vuint32_t
#define TYPE_OF_U8								vuint64_t
#define TYPE_OF_F4								float
#define TYPE_OF_F8								double
#define TYPE_OF_String							WString
#define EXECUTE(OPERATION, TYPE)				case WfInsType::TYPE: return OPERATOR_##OPERATION<TYPE_OF_##TYPE>(*this);
#define BEGIN_TYPE								switch(ins.typeParameter) {
#define END_TYPE								default: INTERNAL_ERROR(L"unexpected type argument."); }

			WfRuntimeExecutionAction WfRuntimeThreadContext::ExecuteInternal(WfInstruction& ins, WfRuntimeStackFrame& stackFrame, IWfDebuggerCallback* callback)
			{
				switch (ins.code)
				{
				case WfInsCode::LoadValue:
					PushValue(ins.valueParameter);
					return WfRuntimeExecutionAction::ExecuteInstruction;
				case WfInsCode::LoadClosure:
					{
						Ptr<WfRuntimeVariableContext> capturedVariables;
						if (ins.countParameter > 0)
						{
							capturedVariables = new WfRuntimeVariableContext;
							capturedVariables->variables.Resize(ins.countParameter);
							Value operand;
							for (vint i = 0; i < ins.countParameter; i++)
							{
								CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
								capturedVariables->variables[ins.countParameter - 1 - i] = operand;
							}
						}

						auto lambda = MakePtr<WfRuntimeLambda>(globalContext, capturedVariables, ins.indexParameter);
						PushValue(Value::From(lambda));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::LoadException:
					{
						PushValue(BoxValue(exceptionInfo));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::LoadLocalVar:
					{
						Value operand;
						CONTEXT_ACTION(LoadLocalVariable(ins.indexParameter, operand), L"illegal local variable index.");
						PushValue(operand);
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::LoadCapturedVar:
					{
						Value operand;
						CONTEXT_ACTION(LoadCapturedVariable(ins.indexParameter, operand), L"illegal captured variable index.");
						PushValue(operand);
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::LoadGlobalVar:
					{
						CALL_DEBUGGER(callback->BreakRead(globalContext->assembly.Obj(), ins.indexParameter));
						Value operand;
						CONTEXT_ACTION(LoadGlobalVariable(ins.indexParameter, operand), L"illegal global variable index.");
						PushValue(operand);
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::StoreLocalVar:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						CONTEXT_ACTION(StoreLocalVariable(ins.indexParameter, operand), L"illegal local variable index.");
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::StoreGlobalVar:
					{
						CALL_DEBUGGER(callback->BreakWrite(globalContext->assembly.Obj(), ins.indexParameter));
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						CONTEXT_ACTION(StoreGlobalVariable(ins.indexParameter, operand), L"illegal global variable index.");
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::Duplicate:
					{
						vint index = stack.Count() - 1 - ins.countParameter;
						Value operand;
						CONTEXT_ACTION(LoadStackValue(index, operand), L"failed to duplicate a value from the stack.");
						PushValue(operand);
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::Pop:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::Return:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop the function result.");
						CONTEXT_ACTION(PopStackFrame(), L"failed to pop the stack frame.");
						PushValue(operand);
						if (stackFrames.Count() == 0)
						{
							status = WfRuntimeExecutionStatus::Finished;
						}
						return WfRuntimeExecutionAction::ExitStackFrame;
					}
				case WfInsCode::CreateArray:
					{
						auto list = IValueList::Create();
						Value operand;
						for (vint i = 0; i < ins.countParameter; i++)
						{
							CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
							list->Add(operand);
						}
						PushValue(Value::From(list));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::CreateMap:
					{
						auto map = IValueDictionary::Create();
						Value key, value;
						for (vint i = 0; i < ins.countParameter; i+=2)
						{
							CONTEXT_ACTION(PopValue(value), L"failed to pop a value from the stack.");
							CONTEXT_ACTION(PopValue(key), L"failed to pop a value from the stack.");
							map->Set(key, value);
						}
						PushValue(Value::From(map));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::CreateInterface:
					{
						auto proxy = MakePtr<WfRuntimeInterfaceInstance>();
						Value key, value;
						for (vint i = 0; i < ins.countParameter; i+=2)
						{
							CONTEXT_ACTION(PopValue(value), L"failed to pop a value from the stack.");
							CONTEXT_ACTION(PopValue(key), L"failed to pop a value from the stack.");
							auto name = UnboxValue<WString>(key);
							auto func = UnboxValue<Ptr<IValueFunctionProxy>>(value);
							proxy->functions.Add(name, func);
						}
						PushValue(Value::From(proxy));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::CreateRange:
					BEGIN_TYPE
						EXECUTE(OpCreateRange, I1)
						EXECUTE(OpCreateRange, I2)
						EXECUTE(OpCreateRange, I4)
						EXECUTE(OpCreateRange, I8)
						EXECUTE(OpCreateRange, U1)
						EXECUTE(OpCreateRange, U2)
						EXECUTE(OpCreateRange, U4)
						EXECUTE(OpCreateRange, U8)
					END_TYPE
				case WfInsCode::ReverseEnumerable:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						Value reversedEnumerable = OPERATOR_OpReverseEnumerable(operand);
						PushValue(reversedEnumerable);
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::DeleteRawPtr:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						operand.DeleteRawPtr();
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::ConvertToType:
					{
						Value result, converted;
						CONTEXT_ACTION(PopValue(result), L"failed to pop a value from the stack.");
						if (OPERATOR_OpConvertToType(result, converted, ins))
						{
							PushValue(converted);
							return WfRuntimeExecutionAction::ExecuteInstruction;
						}
						else
						{
							WString from = result.IsNull() ? L"<null>" : L"<" + result.GetText() + L"> of " + result.GetTypeDescriptor()->GetTypeName();
							WString to = ins.typeDescriptorParameter->GetTypeName();
							RaiseException(L"Failed to convert from \"" + from + L"\" to \"" + to + L"\".", false);
							return WfRuntimeExecutionAction::Nop;
						}
					}
				case WfInsCode::TryConvertToType:
					{
						Value result, converted;
						CONTEXT_ACTION(PopValue(result), L"failed to pop a value from the stack.");
						if (OPERATOR_OpConvertToType(result, converted, ins))
						{
							PushValue(converted);
						}
						else
						{
							PushValue(Value());
						}
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::TestType:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						if (operand.GetTypeDescriptor() && operand.GetValueType() == ins.flagParameter && operand.GetTypeDescriptor()->CanConvertTo(ins.typeDescriptorParameter))
						{
							PushValue(BoxValue(true));
						}
						else
						{
							PushValue(BoxValue(false));
						}
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::GetType:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						PushValue(Value::From(operand.GetTypeDescriptor()));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::Jump:
					{
						stackFrame.nextInstructionIndex = ins.indexParameter;
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::JumpIf:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						if (UnboxValue<bool>(operand))
						{
							stackFrame.nextInstructionIndex = ins.indexParameter;
						}
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::Invoke:
					{
						CONTEXT_ACTION(PushStackFrame(ins.indexParameter, ins.countParameter), L"failed to invoke a function.");
						return WfRuntimeExecutionAction::EnterStackFrame;
					}
				case WfInsCode::GetProperty:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						CALL_DEBUGGER(callback->BreakGet(operand.GetRawPtr(), ins.propertyParameter));
						Value result = ins.propertyParameter->GetValue(operand);
						PushValue(result);
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::SetProperty:
					{
						Value operand, value;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						CONTEXT_ACTION(PopValue(value), L"failed to pop a value from the stack.");
						CALL_DEBUGGER(callback->BreakSet(operand.GetRawPtr(), ins.propertyParameter));
						ins.propertyParameter->SetValue(operand, value);
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::InvokeProxy:
					{
						Value thisValue;
						CONTEXT_ACTION(PopValue(thisValue), L"failed to pop a value from the stack.");
						auto proxy = UnboxValue<Ptr<IValueFunctionProxy>>(thisValue);
						if (!proxy)
						{
							INTERNAL_ERROR(L"failed to invoke a null function proxy.");
							return WfRuntimeExecutionAction::Nop;
						}

						if (auto lambda = proxy.Cast<WfRuntimeLambda>())
						{
							if (lambda->globalContext == globalContext)
							{
								CONTEXT_ACTION(PushStackFrame(lambda->functionIndex, ins.countParameter, lambda->capturedVariables), L"failed to invoke a function.");
								return WfRuntimeExecutionAction::EnterStackFrame;
							}
						}

						List<Value> arguments;
						for (vint i = 0; i < ins.countParameter; i++)
						{
							Value argument;
							CONTEXT_ACTION(PopValue(argument), L"failed to pop a value from the stack.");
							arguments.Insert(0, argument);
						}

						Ptr<IValueList> list = new ValueListWrapper<List<Value>*>(&arguments);
						Value result = proxy->Invoke(list);
						PushValue(result);
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::InvokeMethod:
					{
						Value thisValue;
						CONTEXT_ACTION(PopValue(thisValue), L"failed to pop a value from the stack.");
						CALL_DEBUGGER(callback->BreakInvoke(thisValue.GetRawPtr(), ins.methodParameter));

						if (auto staticMethod = dynamic_cast<WfStaticMethod*>(ins.methodParameter))
						{
							if (staticMethod->GetGlobalContext() == globalContext.Obj())
							{
								CONTEXT_ACTION(PushStackFrame(staticMethod->functionIndex, ins.countParameter, nullptr), L"failed to invoke a function.");
								return WfRuntimeExecutionAction::EnterStackFrame;
							}
						}

						Array<Value> arguments(ins.countParameter);
						for (vint i = 0; i < ins.countParameter; i++)
						{
							Value argument;
							CONTEXT_ACTION(PopValue(argument), L"failed to pop a value from the stack.");
							arguments[ins.countParameter - i - 1] = argument;
						}

						Value result = ins.methodParameter->Invoke(thisValue, arguments);
						PushValue(result);
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::AttachEvent:
					{
						Value thisValue, function;
						CONTEXT_ACTION(PopValue(function), L"failed to pop a value from the stack.");
						CONTEXT_ACTION(PopValue(thisValue), L"failed to pop a value from the stack.");
						CALL_DEBUGGER(callback->BreakAttach(thisValue.GetRawPtr(), ins.eventParameter));
						auto proxy = UnboxValue<Ptr<IValueFunctionProxy>>(function);
						auto handler = ins.eventParameter->Attach(thisValue, proxy);
						PushValue(Value::From(handler));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::DetachEvent:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						auto handler = UnboxValue<Ptr<IEventHandler>>(operand);
						CALL_DEBUGGER(callback->BreakDetach(handler->GetOwnerObject().GetRawPtr(), handler->GetOwnerEvent()));
						auto result = handler->Detach();
						PushValue(BoxValue(result));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::InstallTry:
					CONTEXT_ACTION(PushTrapFrame(ins.indexParameter), L"failed to push a trap frame");
					return WfRuntimeExecutionAction::ExecuteInstruction;
				case WfInsCode::UninstallTry:
					{
						if (trapFrames.Count() == 0)
						{
							INTERNAL_ERROR(L"failed to pop the trap frame.");
						}
						auto frame = GetCurrentTrapFrame();
						CONTEXT_ACTION(PopTrapFrame(ins.countParameter), L"failed to pop the trap frame.");
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::RaiseException:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						if (operand.GetValueType() == Value::Text)
						{
							RaiseException(operand.GetText(), false);
						}
						else if (auto info = operand.GetSharedPtr().Cast<WfRuntimeExceptionInfo>())
						{
							RaiseException(info);
						}
						else
						{
							INTERNAL_ERROR(L"failed to raise an exception which is neither a string nor a WfRuntimeExceptionInfo.");
						}
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::TestElementInSet:
					{
						Value element, set;
						CONTEXT_ACTION(PopValue(set), L"failed to pop a value from the stack.");
						CONTEXT_ACTION(PopValue(element), L"failed to pop a value from the stack.");

						auto enumerable = UnboxValue<Ptr<IValueEnumerable>>(set);
						auto enumerator = enumerable->CreateEnumerator();
						while (enumerator->Next())
						{
							if (enumerator->GetCurrent() == element)
							{
								PushValue(BoxValue(true));
								return WfRuntimeExecutionAction::ExecuteInstruction;
							}
						}
						PushValue(BoxValue(false));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::CompareLiteral:
					BEGIN_TYPE
						EXECUTE(OpCompare, Bool)
						EXECUTE(OpCompare, I1)
						EXECUTE(OpCompare, I2)
						EXECUTE(OpCompare, I4)
						EXECUTE(OpCompare, I8)
						EXECUTE(OpCompare, U1)
						EXECUTE(OpCompare, U2)
						EXECUTE(OpCompare, U4)
						EXECUTE(OpCompare, U8)
						EXECUTE(OpCompare, F4)
						EXECUTE(OpCompare, F8)
						EXECUTE(OpCompare, String)
					END_TYPE
				case WfInsCode::CompareStruct:
					{
						Value first, second;
						CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
						CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");
						if (!first.IsNull() && !first.GetTypeDescriptor()->GetValueSerializer())
						{
							INTERNAL_ERROR(L"type" + first.GetTypeDescriptor()->GetTypeName() + L" is not a struct.");
						}
						if (!second.IsNull() && !second.GetTypeDescriptor()->GetValueSerializer())
						{
							INTERNAL_ERROR(L"type" + second.GetTypeDescriptor()->GetTypeName() + L" is not a struct.");
						}

						if (first.GetValueType() != second.GetValueType())
						{
							PushValue(BoxValue(false));
						}
						else if (first.IsNull())
						{
							PushValue(BoxValue(true));
						}
						else
						{
							PushValue(BoxValue(first.GetText() == second.GetText()));
						}
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::CompareReference:
					{
						Value first, second;
						CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
						CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");
						bool result = first.GetValueType() != Value::Text && second.GetValueType() != Value::Text && first.GetRawPtr() == second.GetRawPtr();
						PushValue(BoxValue(result));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::CompareValue:
					{
						Value first, second;
						CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
						CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");
						switch (first.GetValueType())
						{
						case Value::RawPtr:
						case Value::SharedPtr:
							switch (first.GetValueType())
							{
							case Value::RawPtr:
							case Value::SharedPtr:
								PushValue(BoxValue(first.GetRawPtr() == second.GetRawPtr()));
								break;
							default:
								PushValue(BoxValue(false));
							}
							break;
						case Value::Text:
							switch (first.GetValueType())
							{
							case Value::Text:
								PushValue(BoxValue(first.GetText() == second.GetText()));
							default:
								PushValue(BoxValue(false));
							}
							break;
						default:
							PushValue(BoxValue(second.IsNull()));
						}
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::OpNot:
					BEGIN_TYPE
						EXECUTE(OpNot_Bool, Bool)
						EXECUTE(OpNot, I1)
						EXECUTE(OpNot, I2)
						EXECUTE(OpNot, I4)
						EXECUTE(OpNot, I8)
						EXECUTE(OpNot, U1)
						EXECUTE(OpNot, U2)
						EXECUTE(OpNot, U4)
						EXECUTE(OpNot, U8)
					END_TYPE
				case WfInsCode::OpPositive:
					BEGIN_TYPE
						EXECUTE(OpPositive, I1)
						EXECUTE(OpPositive, I2)
						EXECUTE(OpPositive, I4)
						EXECUTE(OpPositive, I8)
						EXECUTE(OpPositive, U1)
						EXECUTE(OpPositive, U2)
						EXECUTE(OpPositive, U4)
						EXECUTE(OpPositive, U8)
						EXECUTE(OpPositive, F4)
						EXECUTE(OpPositive, F8)
					END_TYPE
				case WfInsCode::OpNegative:
					BEGIN_TYPE
						EXECUTE(OpNegative, I1)
						EXECUTE(OpNegative, I2)
						EXECUTE(OpNegative, I4)
						EXECUTE(OpNegative, I8)
						EXECUTE(OpNegative, F4)
						EXECUTE(OpNegative, F8)
					END_TYPE
				case WfInsCode::OpConcat:
					{
						Value first, second;
						CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
						CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");
						PushValue(BoxValue(first.GetText() + second.GetText()));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
				case WfInsCode::OpExp:
					BEGIN_TYPE
						EXECUTE(OpExp, F4)
						EXECUTE(OpExp, F8)
					END_TYPE
				case WfInsCode::OpAdd:
					BEGIN_TYPE
						EXECUTE(OpAdd, I1)
						EXECUTE(OpAdd, I2)
						EXECUTE(OpAdd, I4)
						EXECUTE(OpAdd, I8)
						EXECUTE(OpAdd, U1)
						EXECUTE(OpAdd, U2)
						EXECUTE(OpAdd, U4)
						EXECUTE(OpAdd, U8)
						EXECUTE(OpAdd, F4)
						EXECUTE(OpAdd, F8)
					END_TYPE
				case WfInsCode::OpSub:
					BEGIN_TYPE
						EXECUTE(OpSub, I1)
						EXECUTE(OpSub, I2)
						EXECUTE(OpSub, I4)
						EXECUTE(OpSub, I8)
						EXECUTE(OpSub, U1)
						EXECUTE(OpSub, U2)
						EXECUTE(OpSub, U4)
						EXECUTE(OpSub, U8)
						EXECUTE(OpSub, F4)
						EXECUTE(OpSub, F8)
					END_TYPE
				case WfInsCode::OpMul:
					BEGIN_TYPE
						EXECUTE(OpMul, I1)
						EXECUTE(OpMul, I2)
						EXECUTE(OpMul, I4)
						EXECUTE(OpMul, I8)
						EXECUTE(OpMul, U1)
						EXECUTE(OpMul, U2)
						EXECUTE(OpMul, U4)
						EXECUTE(OpMul, U8)
						EXECUTE(OpMul, F4)
						EXECUTE(OpMul, F8)
					END_TYPE
				case WfInsCode::OpDiv:
					BEGIN_TYPE
						EXECUTE(OpDiv, I1)
						EXECUTE(OpDiv, I2)
						EXECUTE(OpDiv, I4)
						EXECUTE(OpDiv, I8)
						EXECUTE(OpDiv, U1)
						EXECUTE(OpDiv, U2)
						EXECUTE(OpDiv, U4)
						EXECUTE(OpDiv, U8)
						EXECUTE(OpDiv, F4)
						EXECUTE(OpDiv, F8)
					END_TYPE
				case WfInsCode::OpMod:
					BEGIN_TYPE
						EXECUTE(OpMod, I1)
						EXECUTE(OpMod, I2)
						EXECUTE(OpMod, I4)
						EXECUTE(OpMod, I8)
						EXECUTE(OpMod, U1)
						EXECUTE(OpMod, U2)
						EXECUTE(OpMod, U4)
						EXECUTE(OpMod, U8)
					END_TYPE
				case WfInsCode::OpShl:
					BEGIN_TYPE
						EXECUTE(OpShl, I1)
						EXECUTE(OpShl, I2)
						EXECUTE(OpShl, I4)
						EXECUTE(OpShl, I8)
						EXECUTE(OpShl, U1)
						EXECUTE(OpShl, U2)
						EXECUTE(OpShl, U4)
						EXECUTE(OpShl, U8)
					END_TYPE
				case WfInsCode::OpShr:
					BEGIN_TYPE
						EXECUTE(OpShr, I1)
						EXECUTE(OpShr, I2)
						EXECUTE(OpShr, I4)
						EXECUTE(OpShr, I8)
						EXECUTE(OpShr, U1)
						EXECUTE(OpShr, U2)
						EXECUTE(OpShr, U4)
						EXECUTE(OpShr, U8)
					END_TYPE
				case WfInsCode::OpXor:
					BEGIN_TYPE
						EXECUTE(OpXor, Bool)
						EXECUTE(OpXor, I1)
						EXECUTE(OpXor, I2)
						EXECUTE(OpXor, I4)
						EXECUTE(OpXor, I8)
						EXECUTE(OpXor, U1)
						EXECUTE(OpXor, U2)
						EXECUTE(OpXor, U4)
						EXECUTE(OpXor, U8)
					END_TYPE
				case WfInsCode::OpAnd:
					BEGIN_TYPE
						EXECUTE(OpAnd_Bool, Bool)
						EXECUTE(OpAnd, I1)
						EXECUTE(OpAnd, I2)
						EXECUTE(OpAnd, I4)
						EXECUTE(OpAnd, I8)
						EXECUTE(OpAnd, U1)
						EXECUTE(OpAnd, U2)
						EXECUTE(OpAnd, U4)
						EXECUTE(OpAnd, U8)
					END_TYPE
				case WfInsCode::OpOr:
					BEGIN_TYPE
						EXECUTE(OpOr_Bool, Bool)
						EXECUTE(OpOr, I1)
						EXECUTE(OpOr, I2)
						EXECUTE(OpOr, I4)
						EXECUTE(OpOr, I8)
						EXECUTE(OpOr, U1)
						EXECUTE(OpOr, U2)
						EXECUTE(OpOr, U4)
						EXECUTE(OpOr, U8)
					END_TYPE
				case WfInsCode::OpLT:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						vint value = UnboxValue<vint>(operand);
						PushValue(BoxValue(value < 0));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
					break;
				case WfInsCode::OpGT:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						vint value = UnboxValue<vint>(operand);
						PushValue(BoxValue(value > 0));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
					break;
				case WfInsCode::OpLE:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						vint value = UnboxValue<vint>(operand);
						PushValue(BoxValue(value <= 0));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
					break;
				case WfInsCode::OpGE:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						vint value = UnboxValue<vint>(operand);
						PushValue(BoxValue(value >= 0));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
					break;
				case WfInsCode::OpEQ:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						vint value = UnboxValue<vint>(operand);
						PushValue(BoxValue(value == 0));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
					break;
				case WfInsCode::OpNE:
					{
						Value operand;
						CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
						vint value = UnboxValue<vint>(operand);
						PushValue(BoxValue(value != 0));
						return WfRuntimeExecutionAction::ExecuteInstruction;
					}
					break;
				default:
					return WfRuntimeExecutionAction::Nop;
				}
			}

			WfRuntimeExecutionAction WfRuntimeThreadContext::Execute(IWfDebuggerCallback* callback)
			{
				try
				{
					switch (status)
					{
					case WfRuntimeExecutionStatus::Ready:
					case WfRuntimeExecutionStatus::Executing:
						{
							if (stackFrames.Count() == 0)
							{
								INTERNAL_ERROR(L"empty stack frame.");
							}
							auto& stackFrame = GetCurrentStackFrame();
							if (stackFrame.nextInstructionIndex < 0 || stackFrame.nextInstructionIndex >= globalContext->assembly->instructions.Count())
							{
								INTERNAL_ERROR(L"illegal instruction index.");
							}

							auto insIndex = stackFrame.nextInstructionIndex;
							CALL_DEBUGGER(callback->BreakIns(globalContext->assembly.Obj(), insIndex));

							stackFrame.nextInstructionIndex++;
							auto& ins = globalContext->assembly->instructions[insIndex];
							return ExecuteInternal(ins, stackFrame, callback);
						}
						break;
					case WfRuntimeExecutionStatus::RaisedException:
						if (trapFrames.Count() > 0)
						{
							auto trapFrame = GetCurrentTrapFrame();
							if (trapFrame.stackFrameIndex == stackFrames.Count() - 1)
							{
								CONTEXT_ACTION(PopTrapFrame(0), L"failed to pop the trap frame");
								GetCurrentStackFrame().nextInstructionIndex = trapFrame.instructionIndex;
								status = WfRuntimeExecutionStatus::Executing;
								return WfRuntimeExecutionAction::UnwrapStack;
							}
							else if (stackFrames.Count() > 0)
							{
								CONTEXT_ACTION(PopStackFrame(), L"failed to pop the stack frame.");
								return WfRuntimeExecutionAction::UnwrapStack;
							}
						}
						break;
					default:;
					}
					return WfRuntimeExecutionAction::Nop;
				}
				catch (const WfRuntimeException& ex)
				{
					if (ex.GetInfo())
					{
						RaiseException(ex.GetInfo());
					}
					else
					{
						RaiseException(ex.Message(), ex.IsFatal());
					}
					return WfRuntimeExecutionAction::ExecuteInstruction;
				}
				catch (const Exception& ex)
				{
					RaiseException(ex.Message(), false);
					return WfRuntimeExecutionAction::ExecuteInstruction;
				}
				catch (const Error& ex)
				{
					RaiseException(ex.Description(), false);
					return WfRuntimeExecutionAction::ExecuteInstruction;
				}
			}

#undef INTERNAL_ERROR
#undef CONTEXT_ACTION
#undef CALL_DEBUGGER
#undef TYPE_OF_Bool
#undef TYPE_OF_I1
#undef TYPE_OF_I2
#undef TYPE_OF_I4
#undef TYPE_OF_I8
#undef TYPE_OF_U1
#undef TYPE_OF_U2
#undef TYPE_OF_U4
#undef TYPE_OF_U8
#undef TYPE_OF_F4
#undef TYPE_OF_F8
#undef TYPE_OF_String
#undef EXECUTE
#undef BEGIN_TYPE
#undef END_TYPE
		}
	}
}

/***********************************************************************
RUNTIME\WFRUNTIMEINSTRUCTION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace runtime
		{
			using namespace reflection::description;

/***********************************************************************
WfInstruction
***********************************************************************/

			WfInstruction::WfInstruction()
				:flagParameter(Value::Null)
				, typeDescriptorParameter(0)
			{

			}

#define CTOR(NAME)\
	WfInstruction WfInstruction::NAME()\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			return ins; \
			}\

#define CTOR_VALUE(NAME)\
	WfInstruction WfInstruction::NAME(const reflection::description::Value& value)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.valueParameter = value; \
			return ins; \
			}\

#define CTOR_FUNCTION(NAME)\
	WfInstruction WfInstruction::NAME(vint function)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.indexParameter = function; \
			return ins; \
			}\

#define CTOR_FUNCTION_COUNT(NAME)\
	WfInstruction WfInstruction::NAME(vint function, vint count)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.indexParameter = function; \
			ins.countParameter = count; \
			return ins; \
			}\

#define CTOR_VARIABLE(NAME)\
	WfInstruction WfInstruction::NAME(vint variable)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.indexParameter = variable; \
			return ins; \
			}\

#define CTOR_COUNT(NAME)\
	WfInstruction WfInstruction::NAME(vint count)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.countParameter = count; \
			return ins; \
			}\

#define CTOR_FLAG_TYPEDESCRIPTOR(NAME)\
	WfInstruction WfInstruction::NAME(reflection::description::Value::ValueType flag, reflection::description::ITypeDescriptor* typeDescriptor)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.flagParameter = flag; \
			ins.typeDescriptorParameter = typeDescriptor; \
			return ins; \
			}\

#define CTOR_PROPERTY(NAME)\
	WfInstruction WfInstruction::NAME(reflection::description::IPropertyInfo* propertyInfo)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.propertyParameter = propertyInfo; \
			return ins; \
			}\

#define CTOR_METHOD_COUNT(NAME)\
	WfInstruction WfInstruction::NAME(reflection::description::IMethodInfo* methodInfo, vint count)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.methodParameter = methodInfo; \
			ins.countParameter = count; \
			return ins; \
			}\

#define CTOR_EVENT(NAME)\
	WfInstruction WfInstruction::NAME(reflection::description::IEventInfo* eventInfo)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.eventParameter = eventInfo; \
			return ins; \
			}\

#define CTOR_LABEL(NAME)\
	WfInstruction WfInstruction::NAME(vint label)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.indexParameter = label; \
			return ins; \
			}\

#define CTOR_TYPE(NAME)\
	WfInstruction WfInstruction::NAME(WfInsType type)\
			{\
			WfInstruction ins; \
			ins.code = WfInsCode::NAME; \
			ins.typeParameter = type; \
			return ins; \
			}\

			INSTRUCTION_CASES(
				CTOR,
				CTOR_VALUE,
				CTOR_FUNCTION,
				CTOR_FUNCTION_COUNT,
				CTOR_VARIABLE,
				CTOR_COUNT,
				CTOR_FLAG_TYPEDESCRIPTOR,
				CTOR_PROPERTY,
				CTOR_METHOD_COUNT,
				CTOR_EVENT,
				CTOR_LABEL,
				CTOR_TYPE)

#undef CTOR
#undef CTOR_VALUE
#undef CTOR_FUNCTION
#undef CTOR_FUNCTION_COUNT
#undef CTOR_VARIABLE
#undef CTOR_COUNT
#undef CTOR_FLAG_TYPEDESCRIPTOR
#undef CTOR_PROPERTY
#undef CTOR_METHOD_COUNT
#undef CTOR_EVENT
#undef CTOR_LABEL
#undef CTOR_TYPE
		}
	}
}

/***********************************************************************
RUNTIME\WFRUNTIMETYPEDESCRIPTOR.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace typeimpl
		{
			using namespace collections;
			using namespace reflection::description;
			using namespace runtime;

/***********************************************************************
WfMethodBase
***********************************************************************/

			void WfMethodBase::SetGlobalContext(runtime::WfRuntimeGlobalContext* _globalContext)
			{
				globalContext = _globalContext;
			}


			WfMethodBase::WfMethodBase()
				:MethodInfoImpl(nullptr, nullptr, true)
			{
			}

			WfMethodBase::~WfMethodBase()
			{
			}
			
			runtime::WfRuntimeGlobalContext* WfMethodBase::GetGlobalContext()
			{
				return globalContext;
			}

			void WfMethodBase::SetReturn(Ptr<ITypeInfo> type)
			{
				returnInfo = type;
			}

/***********************************************************************
WfStaticMethod
***********************************************************************/

			Value WfStaticMethod::InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)
			{
				auto lambda = MakePtr<WfRuntimeLambda>(globalContext, nullptr, functionIndex);
				auto argumentArray = IValueList::Create(arguments);
				return lambda->Invoke(argumentArray);
			}

			Value WfStaticMethod::CreateFunctionProxyInternal(const Value& thisObject)
			{
				auto lambda = MakePtr<WfRuntimeLambda>(globalContext, nullptr, functionIndex);
				return Value::From(lambda);
			}

/***********************************************************************
WfInterfaceMethod
***********************************************************************/

			Value WfInterfaceMethod::InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)
			{
				throw 0;
			}

			Value WfInterfaceMethod::CreateFunctionProxyInternal(const Value& thisObject)
			{
				throw 0;
			}

/***********************************************************************
WfEvent
***********************************************************************/

			void WfEvent::AttachInternal(DescriptableObject* thisObject, IEventHandler* eventHandler)
			{
				throw 0;
			}

			void WfEvent::DetachInternal(DescriptableObject* thisObject, IEventHandler* eventHandler)
			{
				throw 0;
			}

			void WfEvent::InvokeInternal(DescriptableObject* thisObject, collections::Array<Value>& arguments)
			{
				throw 0;
			}

			Ptr<ITypeInfo> WfEvent::GetHandlerTypeInternal()
			{
				return handlerType;
			}

			WfEvent::WfEvent(ITypeDescriptor* ownerTypeDescriptor, const WString& name)
				:EventInfoImpl(ownerTypeDescriptor, name)
			{
			}

			WfEvent::~WfEvent()
			{
			}

			void WfEvent::SetHandlerType(Ptr<ITypeInfo> typeInfo)
			{
				handlerType = typeInfo;
			}

/***********************************************************************
WfProperty
***********************************************************************/

			WfProperty::WfProperty(ITypeDescriptor* ownerTypeDescriptor, const WString& name)
				:PropertyInfoImpl(ownerTypeDescriptor, name, nullptr, nullptr, nullptr)
			{
			}

			WfProperty::~WfProperty()
			{
			}

			void WfProperty::SetGetter(MethodInfoImpl* value)
			{
				getter = value;
			}

			void WfProperty::SetSetter(MethodInfoImpl* value)
			{
				setter = value;
			}

			void WfProperty::SetValueChangedEvent(EventInfoImpl* value)
			{
				valueChangedEvent = value;
			}

/***********************************************************************
WfCustomType
***********************************************************************/

			void WfCustomType::SetGlobalContext(runtime::WfRuntimeGlobalContext* _globalContext)
			{
				globalContext = _globalContext;

				vint methodGroupCount = GetMethodGroupCount();
				for (vint i = 0; i < methodGroupCount; i++)
				{
					auto group = GetMethodGroup(i);
					vint methodCount = group->GetMethodCount();
					for (vint j = 0; j < methodCount; j++)
					{
						auto method = group->GetMethod(j);
						if (auto methodInfo = dynamic_cast<WfMethodBase*>(method))
						{
							methodInfo->SetGlobalContext(globalContext);
						}
					}
				}
			}

			void WfCustomType::LoadInternal()
			{
			}

			WfCustomType::WfCustomType(const WString& typeName)
				:TypeDescriptorImpl(typeName, L"")
			{
			}

			WfCustomType::~WfCustomType()
			{
			}
			
			runtime::WfRuntimeGlobalContext* WfCustomType::GetGlobalContext()
			{
				return globalContext;
			}

			void WfCustomType::AddBaseType(ITypeDescriptor* type)
			{
				TypeDescriptorImpl::AddBaseType(type);
			}

			void WfCustomType::AddMember(const WString& name, Ptr<WfMethodBase> value)
			{
				AddMethod(name, value);
			}

			void WfCustomType::AddMember(Ptr<WfProperty> value)
			{
				AddProperty(value);
			}

			void WfCustomType::AddMember(Ptr<WfEvent> value)
			{
				AddEvent(value);
			}

/***********************************************************************
WfClass
***********************************************************************/

			WfClass::WfClass(const WString& typeName)
				:WfCustomType(typeName)
			{
			}

			WfClass::~WfClass()
			{
			}

/***********************************************************************
WfInterface
***********************************************************************/

			WfInterface::WfInterface(const WString& typeName)
				:WfCustomType(typeName)
			{
			}

			WfInterface::~WfInterface()
			{
			}

/***********************************************************************
WfTypeImpl
***********************************************************************/
			
			runtime::WfRuntimeGlobalContext* WfTypeImpl::GetGlobalContext()
			{
				return globalContext;
			}

			void WfTypeImpl::SetGlobalContext(runtime::WfRuntimeGlobalContext* _globalContext)
			{
				if (globalContext)
				{
					CHECK_ERROR(!_globalContext, L"vl::workflow::typeimpl::WfTypeImpl::SetGlobalContext(WfRuntimeGlobalContext*)#Only one global context is allowed to create from an assembly at the same time.");
				}
				else
				{
					CHECK_ERROR(_globalContext, L"vl::workflow::typeimpl::WfTypeImpl::SetGlobalContext(WfRuntimeGlobalContext*)#Only one global context is allowed to create from an assembly at the same time.");
				}

				globalContext = _globalContext;
				FOREACH(Ptr<WfClass>, td, classes)
				{
					td->SetGlobalContext(globalContext);
				}
				FOREACH(Ptr<WfInterface>, td, interfaces)
				{
					td->SetGlobalContext(globalContext);
				}

				if (globalContext)
				{
					GetGlobalTypeManager()->AddTypeLoader(Ptr<WfTypeImpl>(this));
				}
				else
				{
					GetGlobalTypeManager()->RemoveTypeLoader(Ptr<WfTypeImpl>(this));
				}
			}

			void WfTypeImpl::Load(reflection::description::ITypeManager* manager)
			{
				FOREACH(Ptr<WfClass>, td, classes)
				{
					manager->SetTypeDescriptor(td->GetTypeName(), td);
				}
				FOREACH(Ptr<WfInterface>, td, interfaces)
				{
					manager->SetTypeDescriptor(td->GetTypeName(), td);
				}
			}

			void WfTypeImpl::Unload(reflection::description::ITypeManager* manager)
			{
				FOREACH(Ptr<WfClass>, td, classes)
				{
					manager->SetTypeDescriptor(td->GetTypeName(), nullptr);
				}
				FOREACH(Ptr<WfInterface>, td, interfaces)
				{
					manager->SetTypeDescriptor(td->GetTypeName(), nullptr);
				}
			}
		}
	}
}
